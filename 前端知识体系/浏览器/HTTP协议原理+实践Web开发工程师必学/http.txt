  2.URL
    Uniform Resource Locator/统一资源定位器
    用来找到这个资源它所在的位置，并且去访问它得到它。
    URL所有的部分就包含这些：
    http://user:pass@host.com:80/path?query=string#hash
      1.http:// 协议名词://
        协议定义我们以怎么样的一个方式怎么样的一个协议去访问这个资源，有很多不同的协议，比如说我们通过ftp也可以去访问互联网上的
        某一些资源，还有想mail2就是我们怎么给一个邮件地址去发送一个邮件，因为这些协议它的服务的实现方式会不一样，我们通过不同的
        协议去访问这个服务，那么它的一个解析的方式就会不一样，所以这就是协议的一个重要性，因为它定义了我们服务以及我们的发送方如
        何去传输数据，然后服务如何去解析数据。
      2.user:pass@
        这个代表我们去访问了这个资源之后，如果这个资源需要有特定的身份才能访问，那么你可以在前面加入user:pass来指定说我就是这个
        用户，并且你的服务可以通过我的用户名跟密码来进行一个认证，来表示我这个用户我是真的是这个用户而不是一个虚假的用户，那么这
        种方式在我们现在的web开发里面基本是不太用到的，因为有更好的方式去做用户的认证，如果你每一次需要用户认证的一个内容都需要
        在url里面去输入这个用户名密码，那么它是一个非常不安全的，而且也是非常麻烦的一个操作。
      3.hostname
        host.com或者ip
        这个是用来定位我们这个资源它所在的服务器在互联网中的一个位置，因为我们知道互联网中我们定位一台机器最基础的那就是它的ip，
        那么hostname它可以是ip，那么它就可以直接通过ip去找到这台机器，或者它可以是域名，那么域名我们要通过dns的一个服务去解析
        成ip，然后才能定位到那台服务，所以host相关的它就是用来找这一台服务器所在的互联网的位置
      4.:80
        这个是一个端口，为什么要有端口呢，因为每一台服务器都有非常非常多的端口，在这台服务器上你可以跑很多的我们软件的就是web服
        务，这个web服务呢它可以监听各种不同的端口，那么如果我们要找的是这台物理服务器上面某一个web服务上面它里面存放的这些资源
        的话呢我们就要指定我们是要找的哪一个web服务，也就是说端口就是用来定位我们host找到的那台服务器就是物理服务器上面它存放的
        许多个web服务当中的某一个web服务，因为整个http协议它其实就是一个用来定位的，所以我们先要找到这台物理服务器，然后再找到
        它的一个web服务器，然后我们才能再根据后面的一些内容去定位到这个web服务器下面存放的内容，其实相当于就是我们的搜索范围从
        大的再往小的一点一点精确精确最终精确到我们真正想要找的这个内容。那么在我们常用的已经正式上线的这些web服务上面呢，我们基
        本上后面是不带端口的，这是为什么呢，因为不带端口的情况下默认它其实是传了一个80端口，就是默认我们不带端口的情况下访问的就
        是80端口，而因为端口这个东西是不方便于我们用户去记忆的，所以呢一般情况下我们正式发布到互联网上的这个服务呢都是不带端口的
        而是直接通过域名进行一个访问，这样的话就方便于记忆，方便于传播。
      5./path
        这个path呢我们一般叫它路由，这个路由是什么意思呢，因为这个web服务里面它可能存放了非常多的内容，我们具体要如何找到这个内
        容，那么我们可以通过路由这个东西来进行一个定位，那么路由其实如果了解一些linux的基础的话，你应该可以很明显的看到它这个写
        法跟我们linux里面文件目录的一个路径其实是很像的，比如说它的/代表的是根目录。我们一般认为/就是根目录，如果你是直接在命令
        行里面输入cd /，那么它会跳到我们整台服务器它的操作系统的根目录，那么很多时候我们会认为/是我们这个web服务所在的这个目录的
        根目录。那后面跟上了一个路径代表什么呢，从http的定义上来讲，我们这个路径应该是直接对应的我们这个web服务它的一个目录结构
        下面的路径，那么很多时候因为现在我们的web应用变得越来越复杂，我们的很多数据都是存在数据库里面的，而不是对应我们某一个磁盘
        上的一个文件它所在的位置，所以呢我们更多时候是直接把它用来辨别我们现在这个url所要请求的数据在程序里面去判断而不是直接对应
        一个目录结构的一个映射关系，这就是路由它的一个定义以及它的一个使用方式。
      6.?query=string
        这是一个搜索参数，就是说我们要请求的这个资源我们如何去进行一个搜索进行一些查找或者一些操作的一个方式，那么我们可以通过这种
        方式，基本上我们现在web服务就是用它来传参。
      7.#hash
        后面跟上一个hash，那么这个hash是干嘛用的呢，哈希其实是在http的定义里面它是代表我们请求的前面整个url它找到了一个文档，但
        如果这个文档它非常的大，比如说有好几兆的内容，然后都是文字的，那这个时候呢我如果一下子返回这么多，我并不需要，我其实只是作
        为用户来讲我只是想看一下它某一个段落，那么用这个hash我们其实从http的定义上来讲应该叫fragment,它就是代表我们这个文档里面
        的某一个片段，就是我要看文档里面的某一个片段，那现在呢我们的web服务我们作为前端页面开发时候，我们经常是用hash来作为一个锚
        点的一个定位的一个工具。
14.HTTP报文格式(首行信息)
  http协议它的一个报文的形式
  我们http是请求和响应的这种形式，也就是说发起请求这一方永远是主动的，我们发起了一个请求之后，服务端才会给我们一个响应
  1.它的一个请求报文的格式是这样的：
    1.首先http请求都有一个首行，这个首行呢它并不属于http的headers,headers它是另外区分的，那么首行里面会包含什么呢：
      1.在请求报文里面首行首先它会包含一个method就是我们请求的方法，http的method有很多种，get,post,put,delete，它们有各自的
      语义，一个完成度非常高的web服务会对于不同的请求方法对于同一个url会有不同的操作，这就是请求方法它的一个语义，比如说get它是获
      取这个数据，那么post是我要创建一个数据，put是我要更新这个数据，delete是我要删除这个数据，所以每一个http的method它是有各自
      的语义的，当然这边我要提醒一点，那就是说它这个定义只是一张纸上面写的，就是告诉它应该这么做，但是实际上你完全可以不按照它这个方
      法去实现你的web服务，比如说你如果想通过这个method你去实现一下把这个数据更新掉，完全没有问题，你完全可以这么做，只不过你没有
      遵照http协议它的一个语义化的一个定义去做，那么这有一个什么坏处呢，就是一个不知情的人来访问你的服务的时候，可能一不小心做了一
      个他认为安全的操作，但是你这边呢直接把数据给更新掉了，这就是语义它存在的一个意义，它是希望你规范这个操作，但是你不一点要按照它
      这个操作执行，因为http的协议是没有一个强约束你最终去怎么实现你的这个请求的一个内容的，它只是从定义上面告诉你应该这么去做，但至
      于你真的是不是这么做那么取决于个人的选择。
      2.在请求报文的首行里面呢，第二部分是一个url，就是我要请求的这个资源的地址，一般来说我们这边它只是存放一个路由相关的一些东西，
      而不会包含说像是我们的http协议，因为我们这个报文肯定是http协议的，所以你不需要把协议包含进去，而我们请求的地址是我们在服务
      端发起请求的时候它需要去解析以及创建连接的过程，最终我在发送这个请求的时候，我的连接已经创建完成了，所以我的这个请求报文里面
      没必要把这部分放进去了，我只需要告诉这个服务器，我具体请求的资源是哪个地方就可以
      3.然后首行的第三部分是这个协议的版本，这里就要告诉它这个协议的实现到底是哪一个版本，因为不同的版本可能会有一些不同的操作，比
      如说有一些http的header是没有办法返回的，因为它是没有效果的
    这就是http报文的一个首行
    2.那么首行包含了这些信息，那么header就包含了我传输的这些数据它所包含的一些内容，那么具体http header这一块我们在后面会有很多的
    课为大家讲解每一个header具体有什么用，如何去实现一些功能之类的，我们这一节课主要讲的是首行的一个内容。
  2.然后对应的是我们的响应报文
    1.响应报文也就是response它的一个首行
      1.首先第一部分是http/1.0，也就是一个http的version就是它的版本。
      2.然后第二部分呢是一个code，这个code代表什么意思呢，http协议里面定义了非常多的code，每一个code都有它的一个含义代表我这个请
      求目前是处于一个怎么样的状态，那么200就代表这个状态是OK的，是正常请求而且我可以正常返回你的内容，然后还有像300部分的，就是300
      -399，那么里面有很多的各种定义，然后400-499还有500-599都有它们各自的含义，那么每一个区间它的整体含义是有一个定义，然后每一个
      小的code它又有自己的一个定义，然后对应的是200后面还有一个OK，那么这个OK是什么意思呢，你可以理解为200是code，那么这个OK是这个
      code所代表的含义，用明文的方式来告诉你具体说这个请求是怎么样的，比如说401我们后面跟的这个status那么它就是non authentication
      就是我们没有认证，每一个code会有对应的这么一个字符串来告诉你它具体是什么含义。
  这就是我们一个http请求和响应它的报文的起始行代表的意义，我们可以看到这边有一个格式的问题，就是首行的每一部分之间使用空格进行区分的。
  然后呢在我们解析这个报文的时候呢，我们把首行认为是一个最基础的就是我们首行信息，首行换行之后都是http的header,然后http的header要
  跟http的body进行一个区分的时候是怎么办的呢，这边中间是一个完整的空行，而不仅仅是直接换行就可以了，而是要有一个空行来区分，那么在前
  面的这一部分也就是首行和header读取完成之后读到一个空行，空行之后的内容就全部是http body的内容。所以这就是整的一个http请求报文的
  它的一个格式，大家要注意它的一些定义上面的东西，这节课我们主要是讲的首行的内容和它里面的一些定义。
  3.HTTP的方法
    它是用来定义对资源的操作的，就是我们上节讲到的get对应的是什么，post对应的是什么，put对应的是什么，最常用的就是get,post,put,
    delete，然后还有一些像patch像header这种请求方式也都有，一般我们做web服务的时候是不太会用到这些方法的，而get,post,put,delete
    分别对应就是获取数据，创建数据，修改数据以及删除数据，最简单的我们crud的操作，因为现在web服务更多的就是这些操作，向我们使用restful
    的接口，我们也会使用这些http的方法来定义我们对一个资源的操作，这样的话我们同一个url通过不同的method来进行区分具体的一个操作内容
    ，这样的话我们的整个的api接口的设计就会变得更加的规范，从定义上来讲它们是有各自的语义的，再次声明一下，语义这个东西它是定义上的，
    具体如何实现取决于你自己的一个操作
  4.HTTP code
    1.它定义的是服务器对请求的一个处理结果，这个结果它是处理成功的还是说它需要重定向的还是你发送的请求有问题，比如说你没有做认证，还有
    就是说我处理的时候发现服务器出现了错误，那么这个code它是有各自的含义来代表的。
    2.各个区间的code有各自的语义，比如说：
      1.100-199之间代表你这个操作要持续进行，接下去要再做一些其它的事情，那么我这个请求才能继续返回给你。
      2.200-299那么它代表这个操作是成功的
      3.300-399它代表这个操作你需要去重定向，有别的方式去获取这个数据
      4.400-499是代表你发送的请求有问题，最具有代表性的就是401就代表你发送这个请求的时候你没有做认证，那么你是没有权限去获取你请求的
      资源的内容。
      5.500-599这代表是服务器出现了错误
      6.常见http状态码
        200: 请求成功，所请求的资源发送回客户端
        400: 客户端请求有语法错误，不能被服务器所理解
        403: 禁止访问，服务器收到请求，但是拒绝提供服务
        404: 可以连接服务器，但服务器无法取得所请求的网页，请求资源不存在
        500: 服务器遇到错误，无法完成请求
        502: 网关错误
        503: 由于超载或停机维护，服务器目前无法使用，请求超时，一段时间后可恢复正常
        1**(信息类) 2**(响应成功) 3**(重定向类) 4**(客户端错误类) 5**(服务端错误类)
    3.一个好的http服务是可以通过code来判断这个结果的，就是说你实现了一个非常好的一个http的服务呢，我可以很直观的从你返回给我的http
    code就得知我现在这个请求我处理的结果是怎么样的，我接下去该怎么操作，但是呢现在我们国内很多的做web开发的同学在做服务器的时候呢，在
    他们眼里http code是只有两种，一种是200，一种是500，不管是说我数据请求是正确的还是错误的还是你没有认证，我都会返回你200，然后我
    再返回你一个数据，在这个数据里面再去说明你这个请求到底是正确的还是错误的，那么这种操作方式很明显它不是一个合格的去实现了http语义的
    一个http服务的实现，如果大家接下去以后要去做这些http服务器相关的实现的时候，建议大家是尽量的遵照http它的一个定义，它的一个语义化
    去实现你的一个服务，这样的话你的http服务是更具有通用性的，并且是更符合我们正常的http服务它的一个实现过程
  这就是我们http它的一个首行的信息，以及它每个信息基本上有什么用，在这里进行的一个简单的讲解，那么这些都是语义上面的东西，所以我只是通
  过一个讲解的过程让大家理解这些东西到底是干嘛用的，而且大家也只需要知道就可以了，因为它并没有在我们实现某一个功能的一个规范性上有一定
  的约束力。它只是说定义了这些东西。
17.CORS跨域请求的限制与解决
  今天我们来讲一下浏览器的一个同域的限制，也就是我们做web开发常说到的跨域如何请求资源的一个问题。
  1.cors
    其实不管我们有没有返回'Access-Control-Allow-Origin'这个头，浏览器它都会向我们的服务去发送这个请求，浏览器在发送一个请求的时候
    它并不知道我们这个服务是不是跨域的，所以说它还是会发送请求，并且接收你的返回内容，只不过呢在浏览器接收到它的数据返回的时候，它看到
    里面没有一个'Access-Control-Allow-Origin'这么一个头并且设置为允许的话，那么它会把这个请求返回的内容给它忽略掉并且在你的命令行
    里面给你报这个错，所以这个原理就是请求已经发送了，内容也已经返回了，只不过浏览器在解析了这个返回的内容之后，它发现这是不允许的，所
    以它帮你拦截掉了，这其实是浏览器它提供的一个功能，如果我们在自己的curl里面你随便去发送哪个域名下面的东西，它都没有一个所谓的跨域的
    概念，你任何http请求都是可以发送到的并且都是可以返回内容并且输出的，所以这就是浏览器的跨域的一个限制，就是说你在这一个网页的请求里
    面你发送的任何ajax请求它都是必须在同域里面的，如果跨域那么需要服务器那边同意你跨域你才能够接收到它的一个返回内容。
  2.jsonp 
    因为我们的浏览器它是允许像link标签img标签script标签这些在标签上写路径加载一些内容的时候，它是允许跨域的，它并不在乎你这个服务器它
    是否设置了这个跨域的头，所以jsonp它实现的原理其实就是在script标签里面去加载了一个链接，然后这个链接去访问了服务器的某一个请求并且
    返回了内容，因为服务器返回的内容是可控的，所以我们可以在服务器的返回内容里面写的script标签里面的代码是一段可执行的js代码，然后去调
    用jsonp在发起请求之前它给我们设置的一些内容(这个内容是一个函数定义)，这样的话我们就可以去达到一些我们想要达到的目的，这就是jsonp去
    实现跨域的一个原理。
    它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源。
    客户端
      1.写好<script src='url'></script>标签，可以动态添加并且在url后面写上传给服务端的函数的名字。
      2.定义上面名字的函数用来接收服务端传过来的数据。
    服务端
      1.返回一段可执行的js代码，这段可执行代码就是一个调用客户端请求上面传过来的的函数并且已经将处理好的数据当作函数的参数返回给客户端。
  3.proxy代理
18.CORS跨域限制以及预请求验证
  上一节课中我们讲了使用'Access-Control-Allow-Origin'来允许我们服务之间跨服务的去请求一个数据，那么是否所有情况我们都可以通过设置
  这个头来完成跨域的一个操作呢，并不是如此，所以呢我们这节课就来讲一讲浏览器跨域请求的其他的一些限制。
  1.在cors里面存在的一些其他的限制
    1.首先在跨域的时候我们默认允许的方法只有GET,HEAD,POST，那么其他的方法比如说PUT,DELETE这些方法都是默认不允许的，浏览器要有一个预
      请求的方式去验证的，那么至于预请求做了什么，后面我们会讲，所以首先大家要清楚就是允许的方法在这三个我们使用的时候它是不需要去使用预
      请求去验证过的，但是如果使用其他的方法，都是需要的。
    2.然后还要允许的Content-Type也有限制，一个是text/plain,一个是multipart/form-data,还有一个是application/x-www-from-urlencoded,
      这三个就是我们在html里面使用form表单这个element的时候我们可以设置的三种数据类型，那么除了这三种Content-Type之外的其他的Content-Type
      那么你也需要使用预请求去验证过之后才能进行一个发送。
    3.还有其他的限制，比如说请求头的限制
      1.我们自定义的请求头它就是默认不允许的，它需要去验证过
      2.那么其他还有哪些请求头是不允许的呢，这边有一个网页是官方的一个文档，这上面有说明我们在进行cors的时候哪些默认的头是可以允许使用的，
        除了这些头之外的头它都是需要服务端那边进行过一个预请求的验证的。
        https://fetch.spec.whatwg.org/#cors-safelisted-request-header
      3.XMLHttpRequestUpload对象均没有注册任何监听事件
      4.请求中没有使用ReadableStream对象
  2.cors的预请求
    我们可以在network里看到，我们这边发送了这个请求，而且返回是200 OK，这代表呢就是跟我们上节课讲到过的一样，虽然是它不允许跨域，但呢它
    请求仍然会发送，而且数据呢其实是有返回的，只不过浏览器因为一些安全策略的问题，它把这个请求的返回给忽略掉了并且给你报了这么一个错，那么
    浏览器具体是根据什么来判断这个请求的返回是允不允许的呢，答案就是我们的header跟我们上节课里面一样。如果我们要允许我们自定义的头在请求
    里面发送，那么我们需要返回一个新的头来告诉浏览器我们这个操作是允许的，那么这个头是什么呢，就是
    'Access-Control-Allow-Headers':'我们自定义的头'
    那么这个头允许了之后，是否代表我们刚才那个请求就会成功呢，答案是这个请求就成功了。
    发送成功之后呢，我们会发现这时候多了一个请求，多的这个请求就是我们真正的请求，之前的是预请求，就是它首先发送一个请求，它的request method
    是options，然后其他的东西是跟我们发送的是一摸一样的，只不过它的method是options，我们服务端可以根据不同的method去进行不同的一个操作，
    所以在这边呢，浏览器希望我们做的是什么呢，根据这个options这个method，我们提供的是返回告诉浏览器我们允许你接下去要发的就是我们实际发
    的这个post请求里面的操作的内容是允许的，它是通过这个option请求来获得一个服务端允许的认可，然后再实际发送post请求，所以这就是浏览器的对于
    跨域请求的一个预请求的一个操作，那么既然我们可以通过headers去允许自定义的头，同样的如果我们要我们刚才提到过的那三个方法之外的方法，我们可以
    通过设置'Access-Control-Allow-Methods':'POST,PUT,Delete'来使用，如果这些都是允许的，那么我们发送请求的这边就可以使用这些方法。
    这就是突破跨域限制的几种方法。那么浏览器为什么要提供这些限制呢，因为它希望的是我们在网页里面去进行一些跨域的操作的时候，这个操作是保证
    服务端的一个安全的，它不允许任何随随便便的人都可以进行一个跨域，而且不允许随随便便的一个方法进行跨域，它不希望我们因为一些跨域的请求导致
    我们某一个服务的数据被恶意的串改，所以它提供这些限制之后我们就可以进行一些非常有利的判断来判读我们这个请求到底是否要进行一个响应。
    最后还有一条就是'Access-Control-Max-Age':'1000'代表我们这个请求下面我们允许以这种方式进行跨域的一个请求的最长时间1000秒之内你不需要
    再发送预请求来验证了，直接发起正式的请求就可以了，因为我们的服务在这段时间内已经告诉浏览器说你这个操作是允许的是合规的，你不需要再去验证
    过了。那么这就是我们在浏览器当中要进行跨域的几个限制，根据上一节课的再进行的一些补充，那么这些就是如果你要去做一个跨域的服务，那么就要去
    考虑这些问题，如何进行验证，如何让服务变得更合理，能够保证安全。
19.缓存头Cache-Control的含义和使用
  这节课我们来讲一下关于http协议当中的缓存，也就是Cache-Control，首先Cache-Control有哪些特性呢
    1.可缓存性
      第一个是它的可缓存性，它的可缓存性包括public,private以及no-cache,那么这些都是什么意思呢
      public是指在这个http请求返回的过程当中我在Cache-Control里面设置了public这个值，那么代表这个http请求它返回的内容所经过的任何
      路径当中，包括一些中间的http代理服务器，以及我们发出这个请求的客户端浏览器它都可以进行对我这个返回内容的一个缓存的操作，那么所谓缓存
      大家应该都清楚，就是说我把这份数据存在我本地，然后下一次我可以直接读这个缓存，然后去使用这个数据，而不需要到真正返回这个内容的服务器
      上面去重新进行操作然后返回内容了，那么因为在网络中会有非常多的代理服务器以及我们发起的这个客户端，它们都可以进行一个缓存的操作，而它的
      可缓存性就是用来指定哪些地方可以去执行这个缓存，那么public就是说任何地方这个http经过的任何地方它都可以进行一个缓存，而private就代
      表只有发起请求的这个浏览器，它才可以进行一个缓存，而no-cache那就是任何一个节点，它都不可以进行缓存，这就是Cache-Control的一个可缓
      存性的概念。
    2.到期
      那么到期，就是说这个缓存什么时候到期
      1.那么最常用的max-age=<seconds>,我们可以根据自己的需求去设置我们这一部分的缓存内容它缓存到多少秒之后，它才会过期，过期了
      之后我们的浏览器它才会再次发送请求到我们的服务器端，然后再去请求一个新的内容
      2.s-maxage=<seconds>它会代替max-age，但是呢只有在代理服务器里面它才会生效，也就是说在浏览器端，我们的浏览器它还是会读取
      max-age作为一个缓存的到期时间，但是在代理服务器如果我们设置了max-age和s-maxage这两个，那么它会读取s-maxage，因为这个配
      置项是专门为代理服务器去设置的
      3.max-stale=<seconds>,在我们的max-age过期之后如果我们返回的这部分资源里面有这个max-stale这个设置，max-stale是我们的
      发起请求的这一方它主动去带的一个头，那这个头设置呢是代表即便是我们的缓存已经过期了，但是只要是在max-stale这个时间内，它还可
      以使用过期的缓存，而不需要去原服务器那边去请求一个新的内容，这就是max-stale的一个设置，那么max-stale在浏览器里面是用不到的
      ，因为浏览器我们在发起请求以及我们静态资源请求的过程当中，它并不会主动给我们这只这个头，而这个头呢只有在发起端去设置是有用的，
      在我们服务端返回的内容当中去设置它是没有任何作用的，这就是Cache-Control里面关于到期的一些配置。
    3.重新验证
      1.must-revalidate
        在我们设置了max-age的这个缓存当中，如果它已经过期了，那么我们必须去原服务端去发送这个请求，然后重新获取这部分数据，再来验
        证这个数据到底是否真的过期了，而不能直接使用本地的缓存。
      2.proxy-revalidate
        跟must-revalidate是差不多的意思，只不过呢proxy-revalidate是用在缓存服务器当中的，就是指定缓存服务器在过期的时候，它必
        须要去原服务器上重新请求一遍，而不能直接使用本地的缓存。
    4.其他
      1.no-store
        这边要跟之前的no-cache进行一个区分，no-cache是你可以在本地进行一个缓存，你可以在proxy服务器进行一个缓存，那么每一次你发起
        这个请求的时候都要去服务器那边去验证一下，如果服务器它返回这个请求告诉你，你可以使用本地的缓存，然后你才可以真正的去使用你本地
        这部分缓存，就是说它是要经过服务器端的一个验证的，那么关于如何进行验证我们会在下一节课中讲到，我们只需要知道我们使用no-cache
        它就是代表我们本地可以存缓存，但是呢这个缓存要等服务器验证过之后你才可以去使用。而no-store则是彻底的你本地和代理服务器都是不
        可以去存储这个缓存，就是永远都要去服务器端拿新的body的内容过来才能去使用它，而不能说即便服务器返回告诉你你可以使用缓存，但是
        你本地根本就没有这个缓存，你不能进行一个缓存。
      2.no-transform
        这个也主要是用在proxy服务器那边，因为有一些proxy服务器它比较的有一些想法，它就是说觉得我们返回的这个资源太大了，它帮我们进行
        一些压缩去进行一些格式转换，那么这个是不允许的，就是通过no-transform去配置它告诉我们的代理服务器，你不要去随便改动我返回的一
        个内容。
        那么这些，我又要再提之前我说过的一句非常重要的话，就是这些头它只是一个限制性的声明性的作用，它没有任何强制的约束力，也就是说我
        们这边设置的一些对于代理服务器的它的一些头，我们希望它去按照这个规范去做，但是它完全可以不按照这个规范去做，我们的很多用到代理
        服务器，就比如说我们会用到nginx,我们在正式的环境中很多的线上服务都会用nginx做一层代理，那么用nginx做代理做这个cache是非常
        常见的一种操作，我们之后的有一节课是专门讲nginx如何去做代理服务器的，在那里面我们会更详细的讲到代理服务器它如何去操作一些东西
        ，那么在这里面我们就可以去配置关于我们代理服务器如何去做一些静态资源缓存的一些操作，那么在那里面我们会详细的演示我们这里提到的
        几个关于对代理服务器它的静态资源缓存去操作的一些配置，它如何生效，以及它生效之后会有怎么样的一个效果。
    5.这就是浏览器缓存相关的一些内容，主要就是通过设置Cache-Control以及它的max-age 'Cache-Control': 'max-age=200' 来达到我们
      浏览器长缓存的一个效果，因为Cache-Control可以接受非常多的值所以我们可以在后面使用逗号进行一个区分
      'Cache-Control': 'max-age=200, public',这就是我们设置Cache-Control头的一个效果，那么这些主要就是浏览器缓存相关的，那么
      关于Cache-Control还有很多可以讲的，在后面我们将nginx的服务器代理的时候，我们会深入的再去讲解其他的一些关于一些代理的Cache-Control
      的头，它的属性的一些设置。
20.缓存验证Last-Modified和Etag的使用
  这节课我们来讲我们上节课说到过的，如果我们给我们的Cache-Control设置了no-cache之后，那么每一次浏览器发起对一个已经设置了Cache-Control
  的资源的一个请求的时候，它都会要到服务器端去进行一个资源的验证，验证完了之后如果确定这个资源可以使用缓存，那么它才会读取本地的缓存，
  那么在进入正式的资源验证的课程之前，我们先看一张图：缓存.jpg，能够更好的理解缓存是如何进行一个操作的。
    1.缓存的过程
    首先呢，我们浏览器创建了一个请求，创建了请求之后呢，首先这个请求到达的地方是在本地缓存，当然这是建立在我们有Cache-Control这个头的
    情况下，然后会去本地缓存里面找，如果已经命中了，就是说已经找到了，那么它直接返回给浏览器，浏览器直接显示了，它就不需要经过任何网络的
    一个传输，这也就是在我们network里面看到的from-memory-cache这个展示的一个效果，如果它没有命中呢，它就会往互联网上进行一个发送，
    那么互联网上进行发送的过程当中，有可能就会经过某一层的代理缓存的一个代理服务，那么代理服务里面也会查找相关的一些缓存的设置，以及查看
    这个资源是否有缓存，那么如果命中的话，它就会返回过来，然后经过本地缓存再到浏览器，如果它没有命中，那么它才会真正的最后到我们的原服务
    器，也就是我们自己写的这个webserver里面，然后去获取新的内容，然后再一步步的一个返回，这就是说我们从浏览器发出一个请求到查找缓存的
    一个过程，它是这么样的一个原理，希望大家能够进行更好的理解。
    2.那么我们的数据如何进行一个验证呢，在http协议里面主要的有两个验证的http头
      1.Last-Modified
        Last-Modified它的名字顾名思义就是上次修改时间，也就是说我们给这个资源设置了它上一次是什么时候被修改的，那么它主要配合
        If-Modified-Since或者If-Unmodified-since这两个头进行一个使用，什么意思呢，如果我们请求了一个资源，然后请求这个资
        源上面它返回的header里面有Last-Modified这个头，然后指定了一个时间，那么这个时间在下一次我们浏览器要发起请求的时候它
        就会带上Last-Modified传过来的值，通过If-Modified-Since或者If-Unmodified-Since，那么通常来说浏览器实现的时候都
        是使用If-Modified-Since,那么If-Unmodified-Since有这一个头，但是很少会被用到，然后在这个请求里面就会把它带到我们的
        服务器上，那么我们的服务器就可以通过读取这个header里面的If-Modified-Since带来的这个值，然后呢，对比我们这个资源存在
        的一个地方，然后对比它上次修改的时间，如果发现这两个时间是一样的，那么代表这个资源还没有被重新修改过，那它没有被重新修改
        过，那么服务器就可以告诉浏览器你可以直接使用你缓存的这个，这就是我们去验证我们这个资源能否使用缓存的一个过程。
      2.Etag
        Etag它是一个更加严格的一个验证，Etag的验证呢主要就是通过数据签名，所谓的数据签名是什么呢，就是说我们的一个资源，对它的
        内容会产生唯一的一个签名，也就是说它的这个数据进行了一个修改，它的签名就会变成一个新的，只要有任何修改，它的两个签名就会
        不一样，那么最典型的一个做法就是我们对资源的内容进行一个哈希计算，那么这是最常见的一个，就跟我们在上一节课中讲到的在我们
        的静态资源文件名后面加上一个哈希值是一样的，这个哈希是一样的一个东西，比如说对它内容进行一次计算之后，它会得到一个唯一值
        ，我们用这个签名来标记这个资源，那么下一次我们浏览器发起请求的时候，就会带上If-Match或者If-None-Match这个头，这个头里
        面的值呢就是我们在服务端返回过来的这个Etag的值，然后呢我们对比这两个，服务器拿到了浏览器传过来的这个头之后，我们就可以对
        比我们现在在服务器那边存在的这个资源的签名以及浏览器传过来的签名，如果这两个是相同的，那么它就不需要返回一个新的内容，
    这就是我们关于Etag跟If-Modified-Since的一个讲解。
    http code 304就是Not Modified没有修改的意思，配合缓存验证使用，服务端收到浏览器端的验证信息后，验证服务端资源没有修改告诉
    浏览器可以使用缓存的同时的http code即为304
    Cache-Control里不设置no-cache也不设置no-store,那么浏览器就会在max-age的时间内一直使用缓存；设置no-cache，那么需要去服
    务端进行验证是否能够使用缓存，发送的请求中会带上缓存验证的头；no-store是永远都不使用缓存，发送的请求中也没有需要缓存验证的头。
21.cookie和session
  1.cookie
    1.什么是cookie
      cookie是在服务端返回数据的时候通过Set-Cookie这个header设置到浏览器里面，它保存在浏览器里面的一个内容，那么这个内容我们
      就叫它cookie，浏览器保存了这个cookie之后，它在下一次同域的请求当中，它就会带上这个cookie，通过这个我们就可以实现在这一次
      我们访问用户访问的这个网站的会话当中，我们就可以通过cookie它一直在传输的这个内容来保证我们返回的数据是这个用户的，这就是类
      似于我们后面讲的session这个功能，那么我们设置了cookie之后，浏览器下次请求就会自动带上，cookie是键值对的一个形式来保存的，
      可以设置很多个。
    2.cookie有哪些属性呢
      1.max-age和expires来控制cookie的一个过期时间
      2.Secure这个属性代表这个cookie只有在https的请求的时候它才会带上，在http请求的时候它是不会带上这个的
      3.设置HttpOnly之后就无法通过javascript的document.cookie这个属性通过js去访问cookie的内容，这么做呢有一个原因就是安全性，
        因为互联网上存在着很多各种各样的攻击，比如说有一种非常常用的就是csrf攻击，这种攻击会通过在你的网页里面注入一些脚本，或者是
        通过一个url来引导用户去给攻击者的服务器发送用户自己的，就是我们这个网站设置在用户的浏览器里面的cookie,这样的话攻击者就能拿
        到这个用户的登录状态，然后利用这个cookie来访问我们网站中保存的这个用户的数据，所以禁止重要的一些数据通过js进行访问，是保证
        我们用户数据安全的非常重要的一步
      4.domain
        cookie的一个域名的一个限制的内容
    3.这就是cookie的返回的方式，我们在服务端response内容里面有Set-Cookie这个头，它就会把cookie写到我们的浏览器里面，然后浏览器
      下次请求就会带上。
  2.session
    cookie它不等于session，session也有很多种实现方法，它不一定要使用cookie来做，只不过在我们网站的开发当中，最多的最经常用到的就
    是使用cookie来保存session，那么什么意思呢，我们经常会做的一个方式就是把用户登录之后的一个id或者是它的session的一个key给它设
    置到cookie里面，然后下一次用户请求过来的时候呢，我们就可以读取这个cookie下面的值，那么下次用户再次请求不同的内容的时候，我们可
    以通过读取cookie里面的值拿到这个用户对应的唯一的一个key，然后通过这个key去定位这个用户的信息，然后把这个用户的信息给它拿出来，
    然后去做一些针对这个用户的一些操作，那么这就是一个session的概念，我们只要能够保证定位到这个用户，那么它就是一种session的实现
    方案，我们可以直接把用户的id给它写到cookie里面去，然后下次请求过来的时候，我们根据这个id去搜索用户的信息，但是呢因为用户id也算
    是用户信息的一部分，那么直接保存在客户端，那么相对是不太安全的，那么也有其他的方案就是说我们把这个id相关的一些信息给它转化一下，
    转化成一个对应的唯一key，然后这个用户信息跟这个sessionkey的对应关系就存在服务端的数据库或者缓存里面，然后请求过来的时候我们读
    取这个sessionkey然后再去搜索一下，把这个对应的关系拿出来就可以，这就是session的一个概念，它跟cookie不是一一对应的，它不一定
    要用cookie来实现，我们可以通过js的方式写在header里面那也是可以实现的，所以方式有很多种，那么cookie跟session的关系我们在学习
    http的时候就只要弄清楚cookie不等于session这个概念就可以了。
22.http长连接
  1.这节课中我们将的是http中的connection，在之前的课程当中我们提到过http的请求是在tcp的连接上面进行一个发送的，那么tcp的连接在这边
  就有分为长连接短连接这样的概念，那么什么叫长连接呢，http请求发送的时候要先去创建一个tcp的连接，然后在tcp的连接上面把http请求的内
  容发送，并且接收完返回，在这个时候呢，因为一次http请求已经结束了，浏览器跟服务端就会商量说我们要不要把这个tcp连接给它关闭掉，如果
  不关闭的话呢，这个tcp连接它一直开着，然后会有一定的消耗，但是如果你接下去你还有请求，你可以直接在这个tcp连接上进行一个发送，那么就
  不需要经过三次握手这样的一个连接的创建的一个消耗，而如果直接关闭了之后呢，就代表下次你有请求的时候，又要重新去创建一个连接，那这个时候
  就会有一个网络延迟上面的开销，但是呢它能够提供你的一个好处就是你连接马上就关闭这样的话服务端跟客户端就能减少一个并发的连接数，但是呢
  ，在实际的情况中，因为网站的并发量可能比较大，如果你每次都要重新创建一个连接呢，就会导致创建的这个过程发生的次数太多，而实际导致一个
  开销可能比你保持长连接还要高一点，而且长连接的话是可以设置它的连接的timeout就是过多少时间没有在这个tcp连接上面有新的请求，那么它就
  自动关闭掉，所以呢，一般现在的一个情况，基本上都是保持长连接的。
  2.我们可以来看一下baidu.com，在百度里面我们呢首先打开我们的调试工具，然后点network，记住要把这个disable cache给它钩上，这样的话，
  它就是所有的内容都要去重新加载，然后这个时候我们刷新一下页面，然后在timeline下面这一栏这个地方，你可以右键点一下，选中这个
  Connection ID，这个Connection ID呢就代表是tcp连接的这个id，这样的话我们就可以区分它是否用的是同一个连接，选中之后就会看到这边
  有一栏叫做Connection ID，那么Connection ID点一下之后它会自动排序，然后这个时候我们可以看到百度首页它有非常多的一个请求，在这个
  请求上面我们可以看到，这边有一排上面都是10074，上面的img之类的都在这一个连接上进行发送，而下面有一个新的，因为域名不一样，它要重新
  去创建新的连接，这是没有问题的，但我们可以看到它这边它尽量的去复用了这些连接，但是呢它还是会有很多不同的连接在上面，这是为什么呢，因为
  http/1.1的连接，在tcp连接上面去发送请求它是有先后顺序的，就是说你不可以并发的，你有10个请求，你不能并发的在一个tcp连接上面去发送，
  在这一个tcp连接上面去发送，你只能是一个按着一个，那么我们希望在加载一个首页的时候，我们当然是希望它能够并发，这样的话它的效率会更高
  一点，那这个时候浏览器呢可以允许你产生一个并发的创建tcp连接，像chrome允许的是6个就是一次性的并发，所以呢，一般正常情况我们加载一个
  首页的时候，它肯定会基本上达到6个并发先全部创建完成，但是因为到达了这个6个并发的一个限制之后，那么接下去如果你开始有10个并发，那么
  剩下的4个还是要等前面6个至少有一个完成，然后新的请求再进去，所以呢基本上你可以看到的是再百度首页这边，它会一下子创建很多的连接，但是
  呢之后它就会在这上面进行一个复用，这就是我们去创建一个连接的过程，那么如何让我们的服务去保证它是创建的是长连接而不是短连接呢，我们可
  以看一下它这边的http头里面，Response Headers里面我们可以看到有一条叫做Connection: Keep-Alive，这就代表这个连接是被保持的，那
  么它就不会一下子请求完毕之后就被关闭，而在我们Request Headers里面也有一个Connection: Keep-Alive，因为这是有一个协商的过程，在
  发送请求的时候，浏览器就希望服务端是保持长连接的，但是服务端返回的时候呢，它可以选择是保持还是不保持，如果它选择不保持，那么浏览器端
  还是会关掉。
  3.实验
  所以这就是浏览器的一个tcp连接的并发限制。我们可以看到开始的几张图片它是并发的出来，但是后面要等前面的加载完，它才会再去加载，这就是
  长连接的一个用处，它会复用这里面的tcpip的连接，我们可以看到，默认的情况下我们的Connection都是Keep-Alive。那这个时候如果我把它
  改成close会怎么样，connection在我们的http协议的使用当中基本上只有两个值，一个是keep-alive，还有一个就是close，close代表什么呢，
  一个请求完成之后，这个tcp连接就会关闭掉。那么正常情况下，我们现在开发的http服务都是合理的利用这个'Connection': 'Keep-Alive'的，
  我们可以给这个keep-alive设置自动关闭的一个时间，但是这个呢只是在服务端那边设置操作的，所以跟http协议本身没有什么关系，它并不会在
  http的头上面有什么展示。
  4.然后在http2里面呢，因为它有了一个新的概念，叫信道复用，信道复用是什么意思呢，在tcp连接上面，我们可以并发的去发送http请求，那这
  个时候就代表着什么意思呢，就是我们连接一个网站的时候，我们只需要一个tcp连接，那么相信大家应该知道，这个是什么样的一个好处，我们整一
  个网站，一个用户的一个请求，只需要一个连接，那么对于之前要创建那么多连接的一个开销就降的非常多，我们可以来看一下google的页面，它已经
  都是http2了，我们可以看到这个Connection ID它都是11831，记住是只有同域的情况下才会是同一个，那如果出现不同域的，那么它会创建新的
  连接，但是如果都是在一个域名下面的，那么它都是同一个tcp连接，所以这个时候它的开销就降到最低了，而且它整体的速度会有一个质的提升，那么
  http2服务相关的内容在后期会有单独一节课为大家详细的讲解，如何去实现一个http2的服务，然后它给我们带来的好处以及它还有其他一些功能，
  比如说服务端主动推送的一个功能。
  5.那么这节课我就是告诉大家什么是长连接的一个概念，在理解这一点之前，需要大家去做的呢就是要理解我们之前课里面讲过的http请求是在tcp连
  接上面进行发送的，一个tcp连接可以发送多个http请求，但是在http1.1里面我们的http请求如果要在tcp连接上面进行发送，它是有先后顺序的，
  所以如果为了提高性能，我们还是不得不使用并发tcp连接的一个方式，但是在http2里面呢因为可以在一个tcp连接上面并发的发http请求，所以它
  可以只开一个tcp连接就够了。
23.数据协商
  这节课我们来讲http协议中的数据协商，那么什么叫数据协商呢，所谓的数据协商就是说，在我们客户端发送给服务端一个请求的时候，客户端会声明
  我希望这一个请求我拿到的数据格式以及数据相关的一些限制它都是怎么样的，那么服务端会根据它的一个请求里面表示的它想要拿到怎么样的数据之
  后，然后做出一个判断，服务端可能会有很多不同类型的一个数据的返回，那么服务端可以根据请求端发送过来的这些头信息来进行一个区分，说我到
  底要返回怎么样的一个数据。
  1.分类
    分类中分为请求跟返回这两部分
    1.请求
      1.Accept
        那么请求里面我们通过Accept来进行一个声明我想要怎么样的一个数据，其中最主要的呢是Accept，Accept指定的是我想要的数据类型，那么
        这个数据类型会根据mime type的声明来进行一个限制来告诉服务端我想要怎么样的一个数据类型
      2.Accept-Encoding
        第二个是Accept-Encoding，那么Accept-Encoding呢代表我这个数据是怎么样的一个编码方式来进行一个传输，主要的就是用来限制服务端
        如何进行一个数据的压缩，因为现在数据压缩的算法有很多，gzip,deflate还有br现在新起的一个压缩方式，但是还没有很多服务端支持，
        但是呢以后可能会支持越来越多
      3.Accept-Language
        然后第三个是Accept-Language，在全世界范围来讲，有非常多的不同的语言，那么不同的地方访问一个服务，那么它希望展示的这个语言肯定
        也希望是不同的，比如说国内我们希望是展示的是中文，美国可能它希望展示的是英文，所以呢我们可以根据这个头来判断我们要返回的信息是中
        文还是英文
      4.User-Agent
        然后第四个User-Agent,那么User-Agent是用来表示浏览器的一些相关的信息，就是我们移动端的浏览器跟客户端的跟pc端的浏览器它的
        User-Agent肯定是不一样的，我们可以根据User-Agent来进行一些判断，说我们要返回的是pc端的页面还是移动端的页面，所以它也是一个
        非常重要的头
    2.返回
      1.Content
        Content-Type
        那么与之对应的就是服务端返回的时候，服务端返回的Content,它里面会有Content-Type来对应Accept，Accept里面可以接收好几种不同
        的数据格式，那么Content-Type可以从里面选择一种然后做为它真正返回的数据格式进行一个返回，那么在返回的时候就要声明这个Content-Type
        说我实际返回的是怎样的一个数据格式，因为客户端可能要根据这个来判断然后进行一个怎么样的显示的一个情况
      2.Content-Encoding
        第二个是Content-Encoding，Content-Encoding对应的就是Accept-Encoding，我服务端具体到底是用了gzip还是deflate这种数据
        压缩的方式，那么就会通过Content-Encoding来进行一个声明
      3.Content-Language
        还有就是Content-Language，那么Content-Language对应我是根据你的请求返回了你想要的语言呢还是我没有根据你的请求返回你想要的
        语言，所以都可以通过这个来声明，服务端返回肯定就没有User-Agent了，因为User-Agent是客户端指明我目前是处于哪种浏览器，哪种系
        统环境的一个声明，那么服务端没必要去声明说我服务端是怎么样一个环境，我只要把你想要的数据给你就ok了
  2.我们使用demo分析一下，浏览器请求一个html的时候，它会申请怎么样一个头信息
    1.我们先来看一下我们的请求头里面会有Accept,那么Accept呢它返回的信息我们可以看到，它里面声明的信息我们可以看到有非常多text/html,
    application/xhtml+xml，就这些格式做为浏览器来请求一个页面的时候，它都可以接受，你甚至直接返回一个图片它也是可以接受的，因为浏览
    器认为这些数据格式它都是可以进行一个展示的，它有它自己的一个展示方式，所以它愿意接收这些数据格式，那如果你自己做了一个客户端，你只
    希望接收到html，那么你需要在Accept里面去声明text/html就可以了，又要牵扯到我之前说的那句话，就是你在发送请求的时候，虽然你声明了
    你想要的哪个数据格式，强限制你只希望接收这个格式，但是服务端它不一定会按照你的要求来返回这个数据格式，所以呢很多时候我们做一个http
    的服务的时候，我们就需要考虑我们到底是面向怎么样的一个客户群体，它们用的客户端都是怎么样的，然后你要去选择你可以支持的这些数据格式
    来进行一个使用，ok，这是accept。
    2.然后第二个就是Accept-Encoding,我们可以看到，它这边它声明了三种可以接受的encoding方法，就是现在比较流行的几种，一种是gzip,
    这是用的最多的，然后第二个是deflate，那么第三个br是现在用的相对比较少的，但是它的压缩比会比较高，未来可能会变为一个新的主流
    3.然后第三个是Accept-Language，那么因为我是在中国，然后我的浏览器也是按照中国本地的一个方式进行下载的，所以我安装的过程当中呢，
    其实浏览器它会判断你本系统的一个语言，然后来给你发送，因为这个头是浏览器加的，所以它会给你来发送说我希望接受的语言默认是zh-CN就是
    中文
    4.所以这就是Accept，是浏览器端它自动会给你加的，当然我们在发送ajax请求的时候，我们可以自定义的去设置accept相关的一些东西，那么这些
    你就根据你自己的需求去设置就可以了
    5.User-Agent里面有非常多的一个信息：Mozilla/5.0，本机操作系统版本，浏览器内核，渲染引擎的版本，浏览器版本号，这就是User-Agent
    它里面包含了很多跟系统相关，还有就是浏览器相关的一些信息，那么这些信息你就可以用来判断你想要返回给用户看到的页面是要不要去适应它这个
    浏览器
    6.然后对应的我们可以看到我们返回的只写明了一个Content-Type,因为我们没有进行一个数据压缩。
    7.这就是我们在浏览器里面给我们发送的一些数据协商的一些信息，那么这个时候我们拿到这些信息之后呢，我们就可以在服务端进行一个判断，然后
    返回我们想要的一个信息，返回一个对应的，浏览器想要拿到的一个消息，所以像Content-Type和Accept对应的关系呢，它其实两个就是一个对应
    的一个关系，然后Content-Type它里面声明的值呢有一个定义，叫做mime types，然后在mime types里面有非常多的一个格式来帮助我们去声明
    它,那么它的一个类型就是主类型/sub类型就是分类型，就比如说第一个前面是image，后面可以是png,jpg这些图片的格式，text也可以是plane，
    也可以是html，那么这个mime types大家只需要了解，然后你以后看到能够大致知道它是怎么样一个类型，如果你要做服务端，你要遵照你返回的这
    这么一个类型，那你就要去写这么一个头这种规则就ok啦。
    8.那么关于Content-Type我们有一条必须要讲的是在我们服务端返回的时候，可以返回一个头，叫做'X-Content-Type-Options',基本上我们只
    会用到一个值，叫做'nosniff'，那么这个值是什么意思呢，因为在以前很早的时候，IE浏览器它会主动的，就是你返回的这个Content-Type声明了
    一个数据类型，但是它呢不接受或者是它认为你没有声明对，或者呢还有一种情况就是你根本没有声明这个Content-Type的时候，它会自己去预测你
    返回的这个内容是怎么样的一个类型，然后这样呢会导致一些安全性的问题，比如说别人插入的一些应该是以文本显示的代码，最后它以脚本的方式去
    运行了，导致呢你的安全信息被泄漏了，所以呢，它那个时候设计了一个头就是这个头'X-Content-Type-Options'然后声明它是'nosniff'之后呢
    ，它就不会主动的去预测它了，虽然说这个头呢它基本上用不太到，因为现在的浏览器都不会这么激进的去随便的预测你返回的这个内容，但是如果呢你
    遇到了这种情况，你可以声明这个头来告诉浏览器你不要随意去猜测我返回的一个内容，那么这个大家知道就可以了。
    9.那么接下去我们来讲一下关于Content-Encoding也就是我们Accept-Encoding里面的数据压缩这个问题，那么数据压缩有什么好处呢，我们先来
    看一下我们现在的请求情况，我们可以看到这边有一个size,上面是409B,下面是264B，这个是什么意思呢，409B是我们数据在整个传输的过程中的实
    际大小，那么这个大小呢会包含http的headers和body还有首行的信息，那么这些信息都会包含在这里面，264B是body里面的实际内容的一个大小，
    就是传输信息要比body信息要大，这边显示的这个body信息呢是我们数据拿到之后并且根据我们的这个Content-Encoding解压之后的一个数据，而
    不是说我们传输的里面的body是多少就是多少，如果我们这边显示的是传输的是多少就是多少的话呢，就是上面这个就永远大于下面这个，那么实际情
    况并不是如此，所以我们这边接下去要演示的就是我们使用gzip之后，我们Content-Encoding把它变小之后，我们实际的传输大小是会有变化，但是
    下面的body的大小其实是没有变化的。ok,这就是压缩的一个好处，它能够加快我们网络传输的一个开销。
    10.最后我们再来讲一下关于发送请求的时候的Content-Type,因为我们有时候也会发送一些主动的请求，要发送一些数据，那么这些数据肯定要有
    Content-Type，并且有对应的格式，要声明这个Content-Type,因为如果不声明我们不知道在服务端如何去获取这部分的数据。所以这就是在发送
    请求的不同的Content-Type的一个情况，那么对应的也是需要你在我们的body里面去放上不同的数据格式的，因为我们的服务会根据它的这个请求的
    头信息然后不同的方式去解析它传过去的这个body的数据，所以这就是Content-Type它的一个作用，用来在客户端和服务端之间进行一个数据格式的
    一个协商和声明来告诉你我们要怎么样的方式去接收你传过来的这些数据。
  那么这就是数据协商相关的一些内容。其实在服务端跟客户端之间关于数据的东西还有其他的一些东西不是特别的重要，但是可能也会有用处，但是呢
  在课里面我们就不那么详细的把每一个点都讲到了，因为http headers其实有非常非常多，不是标准的http头，但是在业界也用的比较多，那么我们不
  会每一个都讲，我们只讲最重要的那一部分，然后大家知道了这些东西大概的意思之后，你之后你去学你去看到一个新的东西之后，你会学得非常的快，所
  以这就是我这门课想要达到的一个目的。
24.Redirect
  这节课我们来讲一下关于http的redirect，那么什么是redirect呢，就是我们通过url去访问一个路径的时候，我们去请求这个资源的时候，我们
  发现这个资源呢可能已经不在这个url所指定的位置了，那这个时候呢，服务器要告诉我们的浏览器客户端说你要请求的这个资源它在哪个地方，然后
  浏览器再去重新请求那个地方的，这样的话它就可以拿到这个资源，所以呢如果我们以前在开发服务器的时候，已经指定了某一个资源在某个地方，那
  如果你以后把这个资源搬到别的地方呢，你不应该说立刻就把这个url给它废弃掉，因为你废弃掉之后你可能就直接返回404了，说这个资源不存在，
  那么正常来讲，你要告诉客户端，它应该去哪个地方找到它想要的这个资源，那么这个东西我们怎么做呢，非常的简单，我们只需要在response的
  writeHead()里面我们再写一个它的head是302，然后呢我们要告诉浏览器新的资源在哪里就可以了，那么新的资源在哪里呢，我们这边就把这个代
  码逻辑给它改一下，如果我们访问跟路径，就是request.url === '/'的时候，那么我们直接redirect，redirect的时候呢，我们的内容就不需
  要写啦，然后呢，如果request.url === '/new',我们再把实际的内容给它写进去，实际的内容返回我们把它放到这里，那么这里的时候呢，我们
  的code肯定还是200，那么我们把它redirect到新的路径的时候我们怎么做呢，我们在302的时候就不需要返回内容了，然后呢在header里面去写一
  个叫做'Location'这个头，然后它的地址就等于我们新的这个url,因为是在同域之内跳转，所以呢我们只需要到后面的路由阶段就可以了，不需要、
  指定我们的host跟端口，因为默认情况下，我们不写host跟端口，那就是在同域的一个情况下。ok,那么我们来启动一下服务，访问localhost:8888
  ，我们可以看到这边的路径呢它就直接变成/new了，而且它显示出来了内容。我们用devtool来看一下实际的一个情况是怎么样的，我们可以看到，
  先访问的是302，302 Found，那么302 Found了之后呢，它就会去跳转到我们指定的这个response里面的Location: /new，然后它就跳到了
  /new，就变成了这个了，这就是最基本的redirect的一个操作。那么即便是你在header里面写了这个Location,那如果我返回的是200，那这个
  时候会变成什么样呢，我们来看一下，我们可以看到，就是什么东西都没有，因为只有302的头才代表说它要去进行一个跳转。那么我们返回302的
  情况，我们仍然要服务端这边来指定我们要跳转到哪里，因为302的语义代表呢是临时跳转，就是说你现在访问的这个路径，我临时的跳转到了/new，
  而不是我永久的，所以有可能你下一次访问我跟路径的时候，我跳转的就不是/new了，而是一个/other这么一个路径，所以呢如果你能够确定的说
  你接下去这个/它都是跳转到/new的话，那么我们就可以通过301这个头来指定说我这个/路径已经永久跳转到/new了，那么指定301跟302有什么
  区别呢，我们先来看一下302的一个情况，我们可以看到打印的/跟/new都会出现，就是说每一次我从老的那个路径来访问的时候都要经过服务端的
  一次跳转，然后才能跳转到新的，那么我们使用301的情况，我们来看一下，第一次访问是/跟/new都会出现，第二次之后就只会访问/new，这是为
  什么呢，因为301它指定的呢是你这个/这个路径这个资源它是永久变成了/new，那么这个头就会告诉浏览器说下一次你在浏览器里面去出现了这一
  个路径的访问的时候，你直接在浏览器这边把它变成新的路径就可以了，你不需要经过服务器再去指定一个新的location,因为它是一个永久的变更
  ，这就是301和302它们进行一个redirect的一个不同的区别，大家要清楚你什么时候才能去用对应的http code。那么在这里大家还要注意一点
  就是，301的请求它的Size是from disk cache,就是从缓存里面去读取了，也就是说我们/这个路由的请求已经被放到浏览器的缓存里面了，那么
  因为我们301它的定义就是这个链接已经永久变成一个新的路由了，所以呢浏览器它本身在http协议里面定义并没有说301这个返回是有一个过期时
  间这种限制，所以呢浏览器缓存这个301返回的时候它是尽可能长的时间缓存，也就是说除非是像我们主动去清缓存这些操作之前，那么浏览器都是
  默认都会把这个路由给它跳转，所以说就算我们这边这个301给它取消掉了，我们变成200，然后把Location这个头也给它取消掉，然后我们重启了
  服务器，浏览器这边是根本没有感知的，它还是会主动的跳转到这个新的路由，因为它是从缓存里面去读取的，所以301的返回是要非常的慎重去做的，
  因为301缓存，如果你做了之后，接下去你如果要反悔，那就不是你自己能决定的事情了，而是你的用户使用浏览器的一个情况而定了，如果像我主动
  的清了一下浏览器的缓存，那么ok，新的请求就不会跳转了，但是如果用户一直不清这个缓存，它就一直会进行这个跳转，所以如果你决定给某一个
  链接变成一个永久的跳转到另外一个新的链接的时候，你使用301的时候要非常非常的谨慎，因为你使用了之后就不是你可以控制的一个情况了。
  
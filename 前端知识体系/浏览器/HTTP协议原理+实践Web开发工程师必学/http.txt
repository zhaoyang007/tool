HTTP code
  304：就是协商缓存之后服务端返回的告诉浏览器使用缓存的状态码。
  401：就代表你发送这个请求的时候你没有做认证，那么你是没有权限去获取你请求的
  403: 禁止访问，服务器收到请求，但是拒绝提供服务
  502: 网关错误
  503: 由于超载或停机维护，服务器目前无法使用，请求超时，一段时间后可恢复正常
CORS跨域请求的限制与解决
  1.cors
    其实不管我们有没有返回'Access-Control-Allow-Origin'这个头，浏览器它都会向我们的服务去发送这个请求，浏览器在发送一个请求的时候
    它并不知道我们这个服务是不是跨域的，所以说它还是会发送请求，并且接收你的返回内容，只不过呢在浏览器接收到它的数据返回的时候，它看到
    里面没有一个'Access-Control-Allow-Origin'这么一个头并且设置为允许的话，那么它会把这个请求返回的内容给它忽略掉并且在你的命令行
    里面给你报这个错，就是说你在这一个网页的请求里
    面你发送的任何ajax请求必须在同域里面的，如果跨域那么需要服务器那边同意你跨域你才能够接收到它的一个返回内容。
  2.jsonp 
    因为我们的浏览器它是允许像link标签img标签script标签这些在标签上写路径加载一些内容的时候，它是允许跨域的，它并不在乎你这个服务器它
    是否设置了这个跨域的头，所以jsonp它实现的原理其实就是在script标签里面去加载了一个链接，然后这个链接去访问了服务器的某一个请求并且
    返回了内容，因为服务器返回的内容是可控的，所以我们可以在服务器的返回内容里面写的script标签里面的代码是一段可执行的js代码，然后去调
    用jsonp在发起请求之前它给我们设置的一些内容(这个内容是一个函数定义)，这样的话我们就可以去达到一些我们想要达到的目的，这就是jsonp去
    实现跨域的一个原理。
    它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源。
    客户端
      1.写好<script src='url'></script>标签，可以动态添加并且在url后面写上传给服务端的函数的名字。
      2.定义上面名字的函数用来接收服务端传过来的数据。
    服务端
      1.返回一段可执行的js代码，这段可执行代码就是一个调用客户端请求上面传过来的的函数并且已经将处理好的数据当作函数的参数返回给客户端。
  3.proxy代理
CORS跨域限制以及预请求验证
  1.在cors里面存在的一些其他的限制
    1.首先在跨域的时候我们默认允许的方法只有GET,HEAD,POST，那么其他的方法比如说PUT,DELETE这些方法都是默认不允许的，浏览器要有一个预
      请求的方式去验证的，那么至于预请求做了什么，后面我们会讲，所以首先大家要清楚就是允许的方法在这三个我们使用的时候它是不需要去使用预
      请求去验证过的，但是如果使用其他的方法，都是需要的。
    2.然后还要允许的Content-Type也有限制，一个是text/plain,一个是multipart/form-data,还有一个是application/x-www-from-urlencoded,
      这三个就是我们在html里面使用form表单这个element的时候我们可以设置的三种数据类型，那么除了这三种Content-Type之外的其他的Content-Type
      那么你也需要使用预请求去验证过之后才能进行一个发送。
    3.还有其他的限制，比如说请求头的限制
      1.我们自定义的请求头它就是默认不允许的，它需要去验证过
      2.那么其他还有哪些请求头是不允许的呢，这边有一个网页是官方的一个文档，这上面有说明我们在进行cors的时候哪些默认的头是可以允许使用的，
        除了这些头之外的头它都是需要服务端那边进行过一个预请求的验证的。
        https://fetch.spec.whatwg.org/#cors-safelisted-request-header
      3.XMLHttpRequestUpload对象均没有注册任何监听事件
      4.请求中没有使用ReadableStream对象
  2.cors的预请求
    我们可以在network里看到，我们这边发送了这个请求，而且返回是200 OK，这代表呢就是跟我们上节课讲到过的一样，虽然是它不允许跨域，但呢它
    请求仍然会发送，而且数据呢其实是有返回的，只不过浏览器因为一些安全策略的问题，它把这个请求的返回给忽略掉了并且给你报了这么一个错，那么
    浏览器具体是根据什么来判断这个请求的返回是允不允许的呢，答案就是header。如果我们要允许我们自定义的头在请求
    里面发送，那么我们需要返回一个新的头来告诉浏览器我们这个操作是允许的，那么这个头是什么呢，就是
    'Access-Control-Allow-Headers':'我们自定义的头'
    那么这个头允许了之后，我们刚才那个请求就会成功
    发送成功之后呢，我们会发现这时候多了一个请求，多的这个请求就是我们真正的请求，之前的是预请求，就是它首先发送一个请求，它的request method
    是options，然后其他的东西是跟我们发送的是一摸一样的，只不过它的method是options，我们服务端可以根据不同的method去进行不同的一个操作，
    所以在这边呢，浏览器希望我们做的是什么呢，根据这个options这个method，我们提供的是返回告诉浏览器我们允许你接下去要发的就是我们实际发
    的这个post请求里面的操作的内容是允许的，它是通过这个option请求来获得一个服务端允许的认可，然后再实际发送post请求，所以这就是浏览器的对于
    跨域请求的一个预请求的一个操作，那么既然我们可以通过headers去允许自定义的头，同样的如果我们要我们刚才提到过的那三个方法之外的方法，我们可以
    通过设置'Access-Control-Allow-Methods':'POST,PUT,Delete'来使用，如果这些都是允许的，那么我们发送请求的这边就可以使用这些方法。
    这就是突破跨域限制的几种方法。
缓存头Cache-Control的含义和使用
    1.可缓存性
      可缓存性包括public,private以及no-cache
      public是指在这个http请求返回的过程当中我在Cache-Control里面设置了public这个值，那么代表这个http请求它返回的内容所经过的任何
      路径当中，包括一些中间的http代理服务器，以及我们发出这个请求的客户端浏览器它都可以进行对我这个返回内容的一个缓存的操作，
      可缓存性就是用来指定哪些地方可以去执行这个缓存，那么public就是说任何地方这个http经过的任何地方它都可以进行一个缓存，而private就代
      表只有发起请求的这个浏览器，它才可以进行一个缓存，而no-cache那就是任何一个节点，它都不可以进行缓存。
    2.到期
      1.那么最常用的max-age=<seconds>,我们可以根据自己的需求去设置我们这一部分的缓存内容它缓存到多少秒之后，它才会过期，过期了
      之后我们的浏览器它才会再次发送请求到我们的服务器端，然后再去请求一个新的内容
      2.s-maxage=<seconds>它会代替max-age，但是呢只有在代理服务器里面它才会生效，浏览器它还是会读取
      max-age作为一个缓存的到期时间，但是在代理服务器如果我们设置了max-age和s-maxage这两个，那么它会读取s-maxage，这个配
      置项是专门为代理服务器去设置的
      3.max-stale=<seconds>,在我们的max-age过期之后如果我们返回的这部分资源里面有这个max-stale这个设置，max-stale是我们的
      发起请求的这一方它主动去带的一个头，那这个头设置呢是代表即便是我们的缓存已经过期了，但是只要是在max-stale这个时间内，它还可
      以使用过期的缓存，而不需要去原服务器那边去请求一个新的内容，这就是max-stale的一个设置，那么max-stale在浏览器里面是用不到的
      ，因为浏览器我们在发起请求以及我们静态资源请求的过程当中，它并不会主动给我们这只这个头，而这个头呢只有在发起端去设置是有用的，
      在我们服务端返回的内容当中去设置它是没有任何作用的，这就是Cache-Control里面关于到期的一些配置。
    3.重新验证
      1.must-revalidate
        在我们设置了max-age的这个缓存当中，如果它已经过期了，那么我们必须去原服务端去发送这个请求，然后重新获取这部分数据，再来验
        证这个数据到底是否真的过期了，而不能直接使用本地的缓存。
      2.proxy-revalidate
        跟must-revalidate是差不多的意思，只不过呢proxy-revalidate是用在缓存服务器当中的，就是指定缓存服务器在过期的时候，它必
        须要去原服务器上重新请求一遍，而不能直接使用本地的缓存。
    4.其他
      1.no-store
        这边要跟之前的no-cache进行一个区分，no-cache是你可以在本地进行一个缓存，你可以在proxy服务器进行一个缓存，那么每一次你发起
        这个请求的时候都要去服务器那边去验证一下，如果服务器它返回这个请求告诉你，你可以使用本地的缓存，然后你才可以真正的去使用你本地
        这部分缓存，就是说它是要经过服务器端的一个验证的，那么关于如何进行验证我们会在下一节课中讲到，我们只需要知道我们使用no-cache
        它就是代表我们本地可以存缓存，但是呢这个缓存要等服务器验证过之后你才可以去使用。而no-store则是彻底的你本地和代理服务器都是不
        可以去存储这个缓存，就是永远都要去服务器端拿新的body的内容过来才能去使用它，而不能说即便服务器返回告诉你你可以使用缓存，但是
        你本地根本就没有这个缓存，你不能进行一个缓存。
      2.no-transform
        有一些proxy服务器觉得我们返回的这个资源太大了，帮我们进行一些压缩和格式转换，通过no-transform告诉代理服务器，不要随便改动我返回的内容。
    5.这就是浏览器缓存相关的一些内容，主要就是通过设置Cache-Control以及它的max-age 'Cache-Control': 'max-age=200' 来达到我们
      浏览器长缓存的一个效果，因为Cache-Control可以接受非常多的值所以我们可以在后面使用逗号进行一个区分
      'Cache-Control': 'max-age=200, public'
缓存验证Last-Modified和Etag的使用
  如果Cache-Control设置了no-cache之后，那么浏览器发起对一个已经设置了Cache-Control
  的资源的请求的时候，它都会要到服务器端去进行资源的验证，验证完了之后如果确定这个资源可以使用缓存，那么它才会读取本地的缓存，
    1.缓存的过程
    首先呢，我们浏览器创建了一个请求，创建了请求之后呢，首先这个请求到达的地方是在本地缓存，当然这是建立在我们有Cache-Control这个头的
    情况下，然后会去本地缓存里面找，如果已经命中了，就是说已经找到了，那么它直接返回给浏览器，浏览器直接显示了，它就不需要经过任何网络的
    一个传输，这也就是在我们network里面看到的from-memory-cache这个展示的一个效果，如果它没有命中呢，它就会往互联网上进行一个发送，
    那么互联网上进行发送的过程当中，有可能就会经过某一层的代理缓存的一个代理服务，那么代理服务里面也会查找相关的一些缓存的设置，以及查看
    这个资源是否有缓存，那么如果命中的话，它就会返回过来，然后经过本地缓存再到浏览器，如果它没有命中，那么它才会真正的最后到我们的原服务
    器，去获取新的内容，然后再一步步的返回
    2.那么我们的数据如何进行一个验证呢，在http协议里面主要的有两个验证的http头
      1.Last-Modified
        Last-Modified它的名字顾名思义就是上次修改时间，也就是说我们给这个资源设置了它上一次是什么时候被修改的，那么它主要配合
        If-Modified-Since，如果我们请求了一个资源，然后请求这个资
        源上面它返回的header里面有Last-Modified这个头，然后指定了一个时间，那么这个时间在下一次我们浏览器要发起请求的时候它
        就会带上Last-Modified传过来的值，通过If-Modified-Since，服务器就可以通过读取header，对比它上次修改的时间，如果发
        现这两个时间是一样的，代表这个资源还没有被重新修改过，服务器就可以告诉浏览器你可以直接使用你缓存的这个。
      2.Etag
        Etag它是一个更加严格的一个验证，Etag的验证呢主要就是通过数据签名，只要有修改，签名就会更新
        那么下一次我们浏览器发起请求的时候，就会带上If-None-Match这个头，这个头里
        面的值呢就是我们在服务端返回过来的这个Etag的值，然后对比这两个值，如果这两个是相同的，它就不需要返回一个新的内容而使用缓存。
    Cache-Control里不设置no-cache也不设置no-store,那么浏览器就会在max-age的时间内一直使用缓存；设置no-cache，那么需要去服
    务端进行验证是否能够使用缓存，发送的请求中会带上缓存验证的头；no-store是永远都不使用缓存，发送的请求中也没有需要缓存验证的头。
cookie和session
  1.cookie
    1.什么是cookie
      cookie是在服务端返回数据的时候通过Set-Cookie这个header设置到浏览器里面，cookie是键值对的形式，可以设置多个。
    2.cookie属性
      1.max-age和expires来控制cookie的过期时间
      2.设置HttpOnly之后就无法通过js的document.cookie这个属性去访问cookie的内容
      3.domain
        cookie的一个域名的一个限制的内容
  2.session
    在网站的开发当中，经常用到的就
    是使用cookie来保存session，我们经常会做的一个方式就是把用户登录之后的一个id或者是session的一个key给它设
    置到cookie里面，然后下一次用户请求过来的时候呢，我们就可以读取这个cookie下面的值，然后通过这个key去定位这个用户的信息，这就是
    session的概念，只要能够保证定位到这个用户，那么它就是一种session的实现
    方案，我们可以直接把用户的id给它写到cookie里面去，然后下次请求过来的时候，我们根据这个id去搜索用户的信息，但是呢因为用户id也算
    是用户信息的一部分，那么直接保存在客户端，那么相对是不太安全的，那么也有其他的方案就是说我们把这个id相关的一些信息给它转化一下，
    转化成一个对应的唯一key，然后这个用户信息跟这个sessionkey的对应关系就存在服务端的数据库或者缓存里面，然后请求过来的时候我们读
    取这个sessionkey然后再去搜索一下，把这个对应的关系拿出来就可以，这就是session的一个概念，它跟cookie不是一一对应的，它不一定
    要用cookie来实现，我们可以通过js的方式写在header里面那也是可以实现的，所以方式有很多种。
数据协商
  1.分类
    分类中分为请求跟返回这两部分
    1.请求
      1.Accept
        那么请求里面我们通过Accept来进行一个声明我想要怎么样的一个数据，其中最主要的呢是Accept，Accept指定的是我想要的数据类型，那么
        这个数据类型会根据mime type的声明来进行一个限制来告诉服务端我想要怎么样的一个数据类型
      2.Accept-Encoding
        第二个是Accept-Encoding，那么Accept-Encoding呢代表我这个数据是怎么样的一个编码方式来进行一个传输，主要的就是用来限制服务端
        如何进行一个数据的压缩，因为现在数据压缩的算法有很多，gzip,deflate还有br现在新起的一个压缩方式，但是还没有很多服务端支持，
        但是呢以后可能会支持越来越多
      3.Accept-Language
      4.User-Agent
        用来表示浏览器的一些相关的信息
    2.返回
      1.Content
        Content-Type
        那么与之对应的就是服务端返回的时候，服务端返回的Content,它里面会有Content-Type来对应Accept，Accept里面可以接收好几种不同
        的数据格式，那么Content-Type可以从里面选择一种然后做为它真正返回的数据格式进行一个返回a，客户端根据这个来进行一个怎么样的显示
      2.Content-Encoding
        Content-Encoding对应的就是Accept-Encoding，我服务端具体到底是用了gzip还是deflate这种数据
        压缩的方式，通过Content-Encoding来声明
      3.Content-Language
  
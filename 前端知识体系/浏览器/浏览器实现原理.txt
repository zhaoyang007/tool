浏览器的实现原理和API
  实现原理
    解析
    构建DOM树
    计算CSS
    排版
    渲染、合成和绘制
  API
    DOM
    CSSOM
    事件
    API总集合

实现原理
  解析
    浏览器：一个浏览器是如何工作的？（阶段一）
    1.对于前端开发来说，我们平时与浏览器打交道的时间是最多的。可浏览器对前端同学来说更多像一个神秘黑盒子的存在。我们仅仅知道它
      能做什么，而不知道它是如何做到的。
    2.在我面试和接触过的前端开发者中，70% 的前端同学对这部分的知识内容只能达到“一知半解”的程度。甚至还有一部分同学会质疑这部分
      知识是否重要：这与我们的工作相关吗，学多了会不会偏移前端工作的方向？
    3.事实上，我们这里所需要了解的浏览器工作原理只是它的大致过程，这部分浏览器工作原理不但是前端面试的常考知识点，它还会辅助你的
      实际工作，学习浏览器的内部工作原理和个中缘由，对于我们做性能优化、排查错误都有很大的好处。
    4.在我们的课程中，我也会控制浏览器相关知识的粒度，把它保持在“给前端工程师了解浏览器”的水准，而不是详细到“给浏览器开发工程师
      实现浏览器”的水准。
    5.那么，我们今天开始，来共同思考一下。一个浏览器到底是如何工作的。
    6.实际上，对浏览器的实现者来说，他们做的事情，就是把一个 URL 变成一个屏幕上显示的网页。
    7.这个过程是这样的：
      1.浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；
      2.把请求回来的 HTML 代码经过解析，构建成 DOM 树；
      3.计算 DOM 树上的 CSS 属性；
      4.最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；
      5.一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；
      6.合成之后，再绘制到界面上。
        浏览器工作原理.jpg
      7.我们在开始详细介绍之前，要建立一个感性认识。我们从 HTTP 请求回来开始，这个过程并非一般想象中的一步做完再做下一步，而是
        一条流水线。
      8.从 HTTP 请求回来，就产生了流式的数据，后续的 DOM 树构建、CSS 计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出：
        即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。
      9.首先我们来介绍下网络通讯的部分。
    8.HTTP 协议
      1.浏览器首先要做的事就是根据 URL 把数据取回来，取回数据使用的是 HTTP 协议，实际上这个过程之前还有 DNS 查询，不过这里就
        不详细展开了。
      2.我先来了解下 HTTP 的标准。
      3.HTTP 标准由 IETF 组织制定，跟它相关的标准主要有两份：
        HTTP1.1 https://tools.ietf.org/html/rfc2616
        HTTP1.1 https://tools.ietf.org/html/rfc7234
      4.HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 
        Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。
      5.大部分情况下，浏览器的实现者只需要用一个 TCP 库，甚至一个现成的 HTTP 库就可以搞定浏览器的网络通讯部分。HTTP 是纯粹的
        文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。
      6.下面，我们试着用一个纯粹的 TCP 客户端来手工实现 HTTP 一下：
    9.实验
      1.我们的实验需要使用 telnet 客户端，这个客户端是一个纯粹的 TCP 连接工具（安装方法）。
      2.首先我们运行 telnet，连接到极客时间主机，在命令行里输入以下内容：
        telnet time.geekbang.org 80
      3.这个时候，TCP 连接已经建立，我们输入以下字符作为请求：
        GET / HTTP/1.1
        Host: time.geekbang.org
      4.按下两次回车，我们收到了服务端的回复：
        HTTP/1.1 301 Moved Permanently
        Date: Fri, 25 Jan 2019 13:28:12 GMT
        Content-Type: text/html
        Content-Length: 182
        Connection: keep-alive
        Location: https://time.geekbang.org/
        Strict-Transport-Security: max-age=15768000

        <html>
        <head><title>301 Moved Permanently</title></head>
        <body bgcolor="white">
        <center><h1>301 Moved Permanently</h1></center>
        <hr><center>openresty</center>
        </body>
        </html>
      5.这就是一次完整的 HTTP 请求的过程了，我们可以看到，在 TCP 通道中传输的，完全是文本。
      6.在请求部分，第一行被称作 request line，它分为三个部分，HTTP Method，也就是请求的“方法”，请求的路径和请求的协议和
        版本。
      7.在响应部分，第一行被称作 response line，它也分为三个部分，协议和版本、状态码和状态文本。
      8.紧随在 request line 或者 response line 之后，是请求头 / 响应头，这些头由若干行组成，每行是用冒号分隔的名称和值。
      9.在头之后，以一个空行（两个换行符）为分隔，是请求体 / 响应体，请求体可能包含文件或者表单数据，响应体则是 HTML 代码。
    10.HTTP 协议格式
      1.根据上面的分析，我们可以知道 HTTP 协议，大概可以划分成如下部分。
        http协议格式.jpg
      2.我们简单看一下，在这些部分中，path 是请求的路径完全由服务端来定义，没有很多的特别内容；而 version 几乎都是固定字符串；
        response body 是我们最熟悉的 HTML，我在后面会有专门的课程介绍，这里也就不多讲了。
      3.下面我们就来逐个给你介绍其它部分。
    11.HTTP Method（方法）
      1.我们首先来介绍一下 request line 里面的方法部分。这里的方法跟我们编程中的方法意义类似，表示我们此次 HTTP 请求希望执行的
        操作类型。方法有以下几种定义：
        GET
        POST
        HEAD
        PUT
        DELETE
        CONNECT
        OPTIONS
        TRACE
      2.浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法。
      3.HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起
      4.PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。
      5.CONNECT 现在多用于 HTTPS 和 WebSocket。
      6.OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。
    12.HTTP Status code（状态码）和 Status text（状态文本）
      1.接下来我们看看 response line 的状态码和状态文本。常见的状态码有以下几种。
        1xx：临时回应，表示客户端请继续。
        2xx：请求成功。
          200：请求成功。
        3xx: 表示请求的目标有变化，希望客户端进一步处理。
          301&302：永久性与临时性跳转。
          304：跟客户端缓存没有更新。
        4xx：客户端请求错误。
          403：无权限。
          404：表示请求的页面不存在。
          418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议）
        5xx：服务端请求错误。
          500：服务端错误。
          503：服务端暂时性错误，可以一会再试。
      2.对我们前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 HTTP 库直接处理掉了，不会让上层应用知晓。
      3.2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。
      4.3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 
        更接近于一种报错，提示客户端下次别来了。
      5.304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，
        当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。
    13.HTTP Head (HTTP 头)
      1.HTTP 头可以看作一个键值对。原则上，HTTP 头也是一种数据，我们可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一
        些特殊的 HTTP 头，我们现在就来了解一下它们。
      2.在 HTTP 标准中，有完整的请求 / 响应头规定，这里我们挑几个重点的说一下：
      3.我们先来看看 Request Header。
        httpRequestHeader.png
      4.接下来看一下 Response Header。
        httpResponseHeader.png
      5.这里仅仅列出了我认为比较常见的 HTTP 头，这些头是我认为前端工程师应该做到不需要查阅，看到就可以知道意思的 HTTP 头。完
        整的列表还是请你参考我给出的 rfc2616 标准。
    14.HTTP Request Body
      1.HTTP 请求的 body 主要用于提交表单场景。实际上，HTTP 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就
        可以了。一些常见的 body 格式是：
        application/json
        application/x-www-form-urlencoded
        multipart/form-data
        text/xml
      2.我们使用 HTML 的 form 标签提交产生的 HTML 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有
        文件上传时，则会使用 multipart/form-data。
    15.HTTPS
      1.在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 
        Request-Response 模式。
      2.我们首先来了解下 HTTPS。HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者
        篡改。
      3.HTTPS 的标准也是由 RFC 规定的，你可以查看它的详情链接：
        https://tools.ietf.org/html/rfc2818
      4.HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它
        实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。
    16.HTTP 2
      1.HTTP 2 是 HTTP 1.1 的升级版本，你可以查看它的详情链接。
        https://tools.ietf.org/html/rfc7540
      2.HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用。
      3.服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来  
        的并行度不高，从而导致的性能问题。
      4.TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输
        窗口小的问题。
      5.Note: 其实很多优化涉及更下层的协议。IP 层的分包情况，和物理层的建连时间是需要被考虑的。
    17.结语
      1.在这一节内容中，我们一起学习了浏览器的第一步工作，也就是“浏览器首先使用 HTTP 协议或 HTTPS 协议，向服务端请求页面”的
        这一过程。
      2.在这个过程中，掌握 HTTP 协议是重中之重。我从一个小实验开始，带你体验了一次完整的 HTTP 请求过程。我们一起先分析了 HTTP 
        协议的结构。接下来，我分别介绍了 HTTP 方法、HTTP 状态码和状态文本、HTTP Head 和 HTTP Request Body 几个重点需要注
        意的部分。
      3.最后，我还介绍了 HTTPS 和 HTTP 2 这两个补充版本，以便你可以更好地熟悉并理解新的特性。
      4.你在工作中，是否已经开始使用 HTTPS 和 HTTP 2 协议了呢？用到了它们的哪些特性，请留言告诉我吧。
  构建DOM树  
    浏览器：一个浏览器是如何工作的？（阶段二）
    1.你好，我是 winter，今天我们继续来看浏览器的相关内容。
    2.我在上一篇文章中，简要介绍了浏览器的工作大致可以分为 6 个阶段，我们昨天讲完了第一个阶段，也就是通讯的部分：浏览器使用 HTTP 
      协议或者 HTTPS 协议，向服务端请求页面的过程。
    3.今天我们主要来看两个过程：如何解析请求回来的 HTML 代码，DOM 树又是如何构建的。
      解析HTML代码DOM树构建.png
    4.解析代码
      1.我们在前面讲到了 HTTP 的构成，但是我们有一部分没有详细讲解，那就是 Response 的 body 部分，这正是因为 HTTP 的 
        Response 的 body，就要交给我们今天学习的内容去处理了。
      2.HTML 的结构不算太复杂，我们日常开发需要的 90% 的“词”（指编译原理的术语 token，表示最小的有意义的单元），种类大约只有
        标签开始、属性、标签结束、注释、CDATA 节点几种。
      3.实际上有点麻烦的是，由于 HTML 跟 SGML 的千丝万缕的联系，我们需要做不少容错处理。“<?”和“<%”什么的也是必须要支持好的，
        报了错也不能吭声。
    5. 1. 词（token）是如何被拆分的
      1.首先我们来看看一个非常标准的标签，会被如何拆分：
        <p class="a">text text text</p>
      2.如果我们从最小有意义单元的定义来拆分，第一个词（token）是什么呢？显然，作为一个词（token），整个 p 标签肯定是过大了
        （它甚至可以嵌套）。
      3.那么，只用 p 标签的开头是不是合适吗？我们考虑到起始标签也是会包含属性的，最小的意义单元其实是“<p“，所以“<p”就是我们的
        第一个词（token）。
      4.我们继续拆分，可以把这段代码依次拆成词（token）：
        <p “标签开始”的开始；
        class=“a” 属性；
        > “标签开始”的结束；
        text text text 文本；
        </p> 标签结束。
      5.这是一段最简单的例子，类似的还有什么呢？现在我们可以来来看看这些词（token）长成啥样子：
        解析代码词token.png
      6.根据这样的分析，现在我们讲讲浏览器是如何用代码实现，我们设想，代码开始从 HTTP 协议收到的字符流读取字符。
      7.在接受第一个字符之前，我们完全无法判断这是哪一个词（token），不过，随着我们接受的字符越来越多，拼出其他的内容可能性就
        越来越少。
      8.比如，假设我们接受了一个字符“ < ” 我们一下子就知道这不是一个文本节点啦。
      9.之后我们再读一个字符，比如就是 x，那么我们一下子就知道这不是注释和 CDATA 了，接下来我们就一直读，直到遇到“>”或者空格，
        这样就得到了一个完整的词（token）了。
      10.实际上，我们每读入一个字符，其实都要做一次决策，而且这些决定是跟“当前状态”有关的。在这样的条件下，浏览器工程师要想实现
        把字符流解析成词（token），最常见的方案就是使用状态机。
    6. 2. 状态机
      1.绝大多数语言的词法部分都是用状态机实现的。那么我们来把部分词（token）的解析画成一个状态机看看： 
        词的解析状态机.png
      2.当然了，我们这里的分析比较粗略，真正完整的 HTML 词法状态机，比我们描述的要复杂的多。更详细的内容，你可以参考HTML 官方
        文档https://html.spec.whatwg.org/multipage/parsing.html#tokenization，HTML 官方文档规定了 80 个状态
        （顺便一说，HTML 是我见过唯一一个标准中规定了状态机实现的语言，对大部分语言来说，状态机是一种实现而非定义）。
      3.这里我们为了理解原理，用这个简单的状态机就足够说明问题了。
      4.状态机的初始状态，我们仅仅区分 “< ”和 “非 <”：
        如果获得的是一个非 < 字符，那么可以认为进入了一个文本节点；
        如果获得的是一个 < 字符，那么进入一个标签状态。
      5.不过当我们在标签状态时，则会面临着一些可能性。
        比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。
        如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。
        如果下一个字符是字母，那么可以确定进入了一个开始标签。
        如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。
      6.我们可以看到，用状态机做词法分析，其实正是把每个词的“特征字符”逐个拆开成独立状态，然后再把所有词的特征字符链合并起来，
        形成一个联通图结构。
      7.由于状态机设计属于编译原理的基本知识，这里我们仅作一个简要的介绍。
      8.接下来就是代码实现的事情了，在 C/C++ 和 JavaScript 中，实现状态机的方式大同小异：我们把每个函数当做一个状态，参数是
        接受的字符，返回值是下一个状态函数。（这里我希望再次强调下，状态机真的是一种没有办法封装的东西，所以我们永远不要试图封
        装状态机。）
      9.为了方便理解和试验，我们这里用 JavaScript 来讲解，图上的 data 状态大概就像下面这样的：
        var data = function(c){
            if(c=="&") {
                return characterReferenceInData;
            }
            if(c=="<") {
                return tagOpen;
            }
            else if(c=="\0") {
                error();
                emitToken(c);
                return data;
            }
            else if(c==EOF) {
                emitToken(EOF);
                return data;
            }
            else {
                emitToken(c);
                return data;
            }
        };
        var tagOpenState = function tagOpenState(c){
            if(c=="/") {
                return endTagOpenState;
            }
            if(c.match(/[A-Z]/)) {
                token = new StartTagToken();
                token.name = c.toLowerCase();
                return tagNameState;
            }
            if(c.match(/[a-z]/)) {
                token = new StartTagToken();
                token.name = c;
                return tagNameState;
            }
            if(c=="?") {
                return bogusCommentState;
            }
            else {
                error();
                return dataState;
            }
        };
        //……
      10.这段代码给出了状态机的两个状态示例：data 即为初始状态，tagOpenState 是接受了一个“ < ” 字符，来判断标签类型的状态。
      11.这里的状态机，每一个状态是一个函数，通过“if else”来区分下一个字符做状态迁移。这里所谓的状态迁移，就是当前状态函数返
        回下一个状态函数。
      12.这样，我们的状态迁移代码非常的简单：
        var state = data;
        var char
        while(char = getInput())
            state = state(char);
      13.这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的
        字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。
      13.状态函数通过代码中的 emitToken 函数来输出解析好的 token（词），我们只需要覆盖 emitToken，即可指定对解析结果的处理
        方式。
      14.词法分析器接受字符的方式很简单，就像下面这样：
        function HTMLLexicalParser(){
            //状态函数们……
            function data() {
                // ……
            }
            function tagOpen() {
                // ……
            }
            // ……
            var state = data;
            this.receiveInput = function(char) {
                state = state(char);
            }
        }
      15.至此，我们就把字符流拆成了词（token）了。
    7.构建 DOM 树
      1.接下来我们要把这些简单的词变成 DOM 树，这个过程我们是使用栈来实现的，任何语言几乎都有栈，为了给你跑着玩，我们还是用 
        JavaScript 来实现吧，毕竟 JavaScript 中的栈只要用数组就好了。
        function HTMLSyntaticalParser(){
            var stack = [new HTMLDocument];
            this.receiveInput = function(token) {
                //……
            }
            this.getOutput = function(){
                return stack[0];
            }
        }
      2.我们这样来设计 HTML 的语法分析器，receiveInput 负责接收词法部分产生的词（token），通常可以由 emitToken 来调用。
      3.在接收的同时，即开始构建 DOM 树，所以我们的主要构建 DOM 树的算法，就写在 receiveInput 当中。当接收完所有输入，栈顶
        就是最后的根节点，我们 DOM 树的产出，就是这个 stack 的第一项。
      4.为了构建 DOM 树，我们需要一个 Node 类，接下来我们所有的节点都会是这个 Node 类的实例。
      5.在完全符合标准的浏览器中，不一样的 HTML 节点对应了不同的 Node 的子类，我们为了简化，就不完整实现这个继承体系了。我们
        仅仅把 Node 分为 Element 和 Text（如果是基于类的 OOP 的话，我们还需要抽象工厂来创建对象），
        function Element(){
            this.childNodes = [];
        }
        function Text(value){
            this.value = value || "";
        }
      6.前面我们的词（token）中，以下两个是需要成对匹配的：
        tag start
        tag end
      7.根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。
      8.对于 Text 节点，我们则需要把相邻的 Text 节点合并起来，我们的做法是当词（token）入栈时，检查栈顶是否是 Text 节点，如
        果是的话就合并 Text 节点。
      9.同样我们来看看直观的解析过程：
        <html maaa=a >
            <head>
                <title>cool</title>
            </head>
            <body>
                <img src="a" />
            </body>
        </html>
      10.通过这个栈，我们可以构建 DOM 树：
        栈顶元素就是当前节点；
        遇到属性，就添加到当前节点；
        遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；
        遇到注释节点，作为当前节点的子节点；
        遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；
        遇到 tag end 就出栈一个节点（还可以检查是否匹配）。
      11.我在文章里面放了一个视频，你可以点击查看用栈构造 DOM 树的全过程。
      12.当我们的源代码完全遵循 XHTML（这是一种比较严谨的 HTML 语法）时，这非常简单问题，然而 HTML 具有很强的容错能力，奥妙
        在于当 tag end 跟栈顶的 start tag 不匹配的时候如何处理。
      13.于是，这又有一个极其复杂的规则，幸好 W3C 又一次很贴心地把全部规则都整理地很好，我们只要翻译成对应的代码就好了，以下这
        个网站呈现了全部规则。你可以点击查看。
        http://www.w3.org/html/wg/drafts/html/master/syntax.html#tree-construction
    8.结语
      1.好了，总结一下。在今天的文章中，我带你继续探索了浏览器的工作原理，我们主要研究了解析代码和构建 DOM 树两个步骤。在解析代
        码的环节里，我们一起详细地分析了一个词（token）被拆分的过程，并且给出了实现它所需要的一个简单的状态机。
      2.在构建 DOM 树的环节中，基本思路是使用栈来构建 DOM 树为了方便你动手实践，我用 JavaScript 实现了这一过程。
      3.今天给你留的题目是：在语法和词法的代码，我已经给出了大体的结构，请你试着把内容补充完整吧。
  计算CSS  
    浏览器：一个浏览器是如何工作的？（阶段三）
    1.在上一节课中，我已经讲了浏览器的 DOM 构建过程，但是这个构建的 DOM，实际上信息是不全的，它只有节点和属性，不包含任何的样
      式信息。
    2.我们这一节课就来讲讲：浏览器是如何把 CSS 规则应用到节点上，并给这棵朴素的 DOM 树添加上 CSS 属性的。
    3.整体过程
      1.首先我们还是要感性地理解一下这个过程。
      2.首先 CSS 选择器这个名称，可能会给你带来一定的误解，觉得好像 CSS 规则是 DOM 树构建好了以后，再进行选择并给它添加样式
        的。实际上，这个过程并不是这样的。
      3.我们回忆一下我们在浏览器第一节课讲的内容，浏览器会尽量流式处理整个过程。我们上一节课构建 DOM 的过程是：从父到子，从先
        到后，一个一个节点构造，并且挂载到 DOM 树上的，那么这个过程中，我们是否能同步把 CSS 属性计算出来呢？
      4.答案是肯定的。
      5.在这个过程中，我们依次拿到上一步构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。所以，从这个
        角度看，所谓的选择器，应该被理解成“匹配器”才更合适。
      6.我在 CSS 语法部分，已经总结了选择器的各种符号，这里再把它列出来，我们回顾一下。
        空格: 后代，选中它的子节点和所有子节点的后代节点。
        >: 子代，选中它的子节点。
        +：直接后继选择器，选中它的下一个相邻节点。
        ~：后继，选中它之后所有的相邻节点。
        ||：列，选中表格中的一列。
      7.关于选择器的知识，我会在 CSS 的部分继续讲解。这里我们主要介绍浏览器是如何实现这些规则的。
      8.不知道你有没有发现，这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原
        则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。
      9.也就是说，未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，
        而父节点会先于子节点构建。
      10.理解了 CSS 构建的大概过程，我们下面来看看具体的操作。
      11.首先，我们必须把 CSS 规则做一下处理。作为一门语言，CSS 需要先经过词法分析和语法分析，变成计算机能够理解的结构。
      12.这部分具体的做法属于编译原理的内容，这里就不做赘述了。我们这里假设 CSS 已经被解析成了一棵可用的抽象语法树。
      13.我们在之前的 CSS 课程中已经介绍过 compound-selector 的概念，一个 compound-selector 是检查一个元素的规则，而一
        个复合型选择器，则是由数个 compound-selector 通过前面讲的符号连接起来的。
    4.后代选择器 “空格”
      1.我们先来分析一下后代选择器，我们来一起看一个例子：
        a#b .cls {
            width: 100px;
        }
      2.可以把一个 CSS 选择器按照 compound-selector 来拆成数段，每当满足一段条件的时候，就前进一段。
      3.比如，在上面的例子中，当我们找到了匹配 a#b 的元素时，我们才会开始检查它所有的子代是否匹配 .cls。
      4.除了前进一段的情况，我们还需要处理后退的情况，比如，我们这样一段代码：
        <a id=b>
            <span>1<span>
            <span class=cls>2<span>
        </a>
        <span class=cls>3<span>
      5.当遇到 时，必须使得规则 a#b .cls 回退一步，这样第三个 span 才不会被选中。后代选择器的作用范围是父节点的所有子节点，
        因此规则是在匹配到本标签的结束标签时回退。
    5.后继选择器“ ~ ”
      1.接下来我们看下后继选择器，跟后代选择器不同的地方是，后继选择器只作用于一层，我们来看一个例子：
        .cls~* {
            border:solid 1px green;
        }
        <div>
        <span>1<span>
        <span class=cls>2<span>
        <span>
            3
            <span>4</span>
        <span>
        <span>5</span>
        </div>
      2.这里 .cls 选中了 span 2 然后 span 3 是它的后继，但是 span 3 的子节点 span 4 并不应该被选中，而 span 5 也是它
        的后继，因此应该被选中。
      3.按照 DOM 树的构造顺序，4 在 3 和 5 中间，我们就没有办法像前面讲的后代选择器一样通过激活或者关闭规则来实现匹配。
      4.但是这里有个非常方便的思路，就是给选择器的激活，带上一个条件：父元素。
      5.注意，这里后继选择器，当前半段的 .cls 匹配成功时，后续 * 所匹配的所有元素的父元素都已经确定了（后继节点和当前节点父元
        素相同是充分必要条件）。在我们的例子中，那个 div 就是后继节点的父元素。
    6.子代选择器“ >”
      1.我们继续看，子代选择器是如何实现的。
      2.实际上，有了前面讲的父元素这个约束思路，我们很容易实现子代选择器。区别仅仅是拿当前节点作为父元素，还是拿当前节点的父元
        素作为父元素。
        div>.cls {
            border:solid 1px green;
        }
        <div>
        <span>1<span>
        <span class=cls>2<span>
        <span>
            3
            <span>4</span>
        <span>
        <span>5</span>
        </div>
      3.我们看这段代码，当 DOM 树构造到 div 时，匹配了 CSS 规则的第一段，因为是子代选择器，我们激活后面的 .cls 选择条件，并
        且指定父元素必须是当前 div。于是后续的构建 DOM 树构建过程中，span 2 就被选中了。
    7.直接后继选择器“ +”
      1.直接后继选择器的实现是上述中最为简单的了，因为它只对唯一一个元素生效，所以不需要像前面几种一样反复激活和关闭规则。
      2.一个最简单的思路是，我们可以把它当作检查元素自身的选择器来处理。即我们把 #id+.cls 都当做检查某一个元素的选择器。
      3.另外的一种思路是：给后继选择器加上一个 flag，使它匹配一次后失效。你可以尝试一下，告诉我结果。
    8.列选择器“ || ”
      1.列选择器比较特别，它是专门针对表格的选择器，跟表格的模型建立相关，我们这里不详细讲了。
    9.其它
      1.我们不要忘记，CSS 选择器还支持逗号分隔，表示“或”的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。
      2.比如：
        a#b, .cls {

        }
      3.我们当作两条规则来处理：
        a#b {

        }
        .cls {

        }  
      4.还有一个情况，就是选择器可能有重合，这样，我们可以使用树形结构来进行一些合并，来提高效率：
        #a .cls {

        }

        #a span {

        }
        #a>span {

        }
      5.这里实际上可以把选择器构造成一棵树：
        #a
          < 空格 >.cls
          < 空格 >span
          >span
      6.需要注意的是，这里的树，必须要带上连接符。
    10.结语
      1.这一节我们讲解了 CSS 计算的过程。CSS 计算是把 CSS 规则应用到 DOM 树上，为 DOM 结构添加显示相关属性的过程。在这一
        节中，我们主要介绍了选择器的几种复合结构应该如何实现。
      2.在这一步骤之后，我们得到了一棵带有 CSS 属性的树，为我们后续打下了基础。
      3.最后留一个问题，你认为 CSS 语法解析成什么结构，最适合我们进行 CSS 计算。
  排版  
    浏览器：一个浏览器是如何工作的？（阶段四）
    1.我们书接上文。浏览器进行到这一步，我们已经给 DOM 元素添加了用于展现的 CSS 属性，接下来，浏览器的工作就是确定每一个元素
      的位置了。我们的基本原则仍然不变，就是尽可能流式地处理上一步骤的输出。
    2.在构建 DOM 树和计算 CSS 属性这两个步骤，我们的产出都是一个一个的元素，但是在排版这个步骤中，有些情况下，我们就没法做到
      这样了。
    3.尤其是表格相关排版、Flex 排版和 Grid 排版，它们有一个显著的特点，那就是子元素之间具有关联性。
    4.基本概念
      1.首先我们先来介绍一些基本概念，使你可以感性地认识一下我们平常说的各种术语。
      2.“排版”这个概念最初来自活字印刷，是指我们把一个一个的铅字根据文章顺序，放入板框当中的步骤，排版的意思是确定每一个字的
        位置。
      3.在现代浏览器中，仍然借用了这个概念，但是排版的内容更加复杂，包括文字、图片、图形、表格等等，我们把浏览器确定它们位置的
        过程，叫作排版。
      4.浏览器最基本的排版方案是正常流排版，它包含了顺次排布和折行等规则，这是一个跟我们提到的印刷排版类似的排版方案，也跟我们
        平时书写文字的方式一致，所以我们把它叫做正常流。
      5.浏览器的文字排版遵循公认的文字排版规范，文字排版是一个复杂的系统，它规定了行模型和文字在行模型中的排布。行模型规定了行
        顶、行底、文字区域、基线等对齐方式。（你还记得小时候写英语的英语本吗？英语本上的四条线就是一个简单的行模型。）
      6.此外，浏览器支持不同语言，因为不同语言的书写顺序不一致，所以浏览器的文本排版还支持双向文字系统。
      7.浏览器又可以支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是所谓的盒模型。
      8.在正常流的基础上，浏览器还支持两类元素：绝对定位元素和浮动元素。
        1.绝对定位元素把自身从正常流抽出，直接由 top 和 left 等属性确定自身的位置，不参加排版计算，也不影响其它元素。绝对定
          位元素由 position 属性控制。
        2.浮动元素则是使得自己在正常流的位置向左或者向右移动到边界，并且占据一块排版空间。浮动元素由 float 属性控制。
      9.除了正常流，浏览器还支持其它排版方式，比如现在非常常用的 Flex 排版，这些排版方式由外部元素的 display 属性来控制（注
        意，display 同时还控制元素在正常流中属于 inline 等级还是 block 等级）。
    5.正常流文字排版
      1.我们会在 CSS 部分详细介绍正常流排版的行为，我们这里主要介绍浏览器中的正常流。正常流是唯一一个文字和盒混排的排版方式，
        我们先从文字来讲起。
      2.要想理解正常流，我们首先要回忆一下自己如何在纸上写文章。
      3.首先，纸是有固定宽度的，虽然纸有固定高度，但是我们可以通过下一页纸的方式来接续，因此我们不存在写不下的场景。
      4.我们书写文字的时候，是从左到右依次书写，每一个字跟上一个字都不重叠，文字之间有一定间距，当写满一行时，我们换到下一行去
        继续写。
      5.书写中文时，文字的上、下、中轴线都对齐，书写英文时，不同字母的高度不同，但是有一条基线对齐。
      6.实际上浏览器环境也很类似。但是因为浏览器支持改变排版方向，不一定是从左到右从上到下，所以我们把文字依次书写的延伸方向称
        为主轴或者主方向，换行延伸的方向，跟主轴垂直交叉，称为交叉轴或者交叉方向。
      7.我们一般会从某个字体文件中获取某个特定文字的相关信息。我们获取到的信息大概类似下面：
        文字相关信息横行版本.png
      8.纵向版本：
        文字相关信息纵向版本.png
      9.这两张图片来自著名开源字体解析库 freetype，实际上，各个库对字体的理解大同小异，我们注意一下，advance 代表每一个文字
        排布后在主轴上的前进距离，它跟文字的宽 / 高不相等，是字体中最重要的属性。
      10.除了字体提供的字形本身包含的信息，文字排版还受到一些 CSS 属性影响，如 line-height、letter-spacing、
        word-spacing 等。
      11.在正常流的文字排版中，多数元素被当作长方形盒来排版，而只有 display 为 inline 的元素，是被拆成文本来排版的（还有一
        种 run-in 元素，它有时作为盒，有时作为文字，不太常用，这里不详细讲了）。
      12.display 值为 inline 的元素中的文字排版时会被直接排入文字流中，inline 元素主轴方向的 margin 属性和 border 属性
        （例如主轴为横向时的 margin-left 和 margin-right）也会被计算进排版前进距离当中。
      13.注意，当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。
      14.这样，即使没有元素包裹，混合书写方向的文字也可以形成一个盒结构，我们在排版时，遇到这样的双向文字盒，会先排完盒内再排
        盒外。
    6.正常流中的盒
      1.在正常流中，display 不为 inline 的元素或者伪元素，会以盒的形式跟文字一起排版。多数 display 属性都可以分成两部分：
        内部的排版和是否 inline，带有 inline- 前缀的盒，被称作行内级盒。
      2.根据盒模型，一个盒具有 margin、border、padding、width/height 等属性，它在主轴方向占据的空间是由对应方向的这几个
        属性之和决定的，而 vertical-align 属性决定了盒在交叉轴方向的位置，同时也会影响实际行高。
      3.所以，浏览器对行的排版，一般是先行内布局，再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。
      4.块级盒比较简单，它总是单独占据一整行，计算出交叉轴方向的高度即可。
    7.绝对定位元素  
      1.position 属性为 absolute 的元素，我们需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到
        其父级的 position 非 static 元素即可。
    8.浮动元素排版
      1.loat 元素非常特别，浏览器对 float 的处理是先排入正常流，再移动到排版宽度的最左 / 最右（这里实际上是主轴的最前和最后）。
      2.移动之后，float 元素占据了一块排版的空间，因此，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮
        动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。float 元素排布完成后，float 元素所在的行需要重新确定位置。
    9.其它的排版
      1.CSS 的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如 Flex 排版，支持了 flex 属性，flex 属性将每一行
        排版后的剩余空间平均分配给主轴方向的 width/height 属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的。
    10.结束
      1.这一部分，我们以正常流为主，介绍了浏览器的排版基本概念及一些算法。这里，我主要介绍了正常流中的文字排版、正常流中的盒、绝
        对定位元素、浮动元素排版这几种情况。最后，我还简单介绍了一下 Flex 排版。这属于进阶版的排版方式了，你可以了解一下。
      2.你平时喜欢使用方式排版呢，欢迎留言告诉我。
  渲染、合成和绘制
    浏览器：一个浏览器是如何工作的？（阶段五）
    1.你好，我是 winter。我们的浏览器系列已经进行到最后一篇。
    2.在之前的几篇文章中，我们已经经历了把 URL 变成字符流，把字符流变成词（token）流，把词（token）流构造成 DOM 树，把不含样
      式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM 树，并且根据样式信息，计算了每个元素的位置和大小。
    3.那么，我们最后的步骤，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。
    4.渲染
      1.首先我们来谈谈渲染这个词，渲染也是个外来词，它是英文词 render 的翻译，render 这个词在英文里面，有“导致”“变成”的意思，
        也有“粉刷墙壁”的意思。
      2.在计算机图形学领域里，英文 render 这个词是一个简写，它是特指把模型变成位图的过程。我们把 render 翻译成“渲染”，是个非
        常有意思的翻译，中文里“渲染”这个词是一种绘画技法，是指沾清水把墨涂开的意思。
      3.所以，render 翻译成“渲染”，我认为是非常高明的，对 render 这个过程，用国画的渲染手法来概括，是颇有神似的。
      4.我们现在的一些框架，也会把“从数据变成 HTML 代码的过程”称为 render，其实我觉得这是非常具有误导性的，我个人是非常不喜欢
        这种命名方式，当然了，所谓“文无第一”，在自然语言的范围里，我们很难彻底否定这种用法的合理性。
      5.不过，在本篇文章中，我们可以约定一下，本文中出现的“渲染”一词，统一指的是它在图形学的意义，也就是把模型变成位图的过程。
      6.这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是 DOM 树中占据浏览器内存最多
        的信息，我们在做内存占用优化时，主要就是考虑这一部分）。
      7.浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 
        inline 元素，可能会分成多行）。每一个盒对应着一张位图。
      8.这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：图形和文字。
      9.盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类。这就像我们实现 HTTP 协议必须要基于 TCP 库一样，这一部分，
        我们需要一个底层库来支持。
      10.一般的操作系统会提供一个底层库，比如在 Android 中，有大名鼎鼎的 Skia，而 Windows 平台则有 GDI，一般的浏览器会做一
        个兼容层来处理掉平台差异。
      11.这些盒的特性如何绘制，每一个都有对应的标准规定，而每一个的实现都可以作为一个独立的课题来研究，当年圆角 + 虚线边框，可
        是难倒了各个浏览器的工程师。考虑到这些知识互相都比较独立，对前端工程师来说也不是特别重要的细节，我们这里就不详细探究了。
      12.盒中的文字，也需要用底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形。
      13.字形分为像素字形和矢量字形两种。通常的字体，会在 6px 8px 等小尺寸提供像素字形，比较大的尺寸则提供矢量字形。矢量字形
        本身就需要经过渲染才能继续渲染到元素的位图上去。目前最常用的字体库是 Freetype，这是一个 C++ 编写的开源的字体库。
      14.在最普遍的情况下，渲染过程生成的位图尺寸跟它在上一步排版时占据的尺寸相同。
      15.但是理想和现实是有差距的，很多属性会影响渲染位图的大小，比如阴影，它可能非常巨大，或者渲染到非常遥远的位置，所以为了优
        化，浏览器实际的实现中会把阴影作为一个独立的盒来处理。
      16.注意，我们这里讲的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结
        果能够最大程度被缓存，减少重新渲染。
    5.合成
      1.合成是英文术语 compositing 的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。
      2.我们上一小节中讲到，渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为
        合成层），把一部分子元素渲染到合成的位图上面。
      3.看到这句话，我想你一定会问问题，到底是为哪些元素创建合成后的位图，把哪些子元素渲染到合成的位图上面呢？
      4.这就是我们要讲的合成的策略。我们前面讲了，合成是一个性能考量，那么合成的目标就是提高性能，根据这个目标，我们建立的原则
        就是最大限度减少绘制次数原则。
      5.我们举一个极端的例子。如果我们把所有元素都进行合成，比如我们为根元素 HTML 创建一个合成后的位图，把所有子元素都进行合成，
        那么会发生什么呢？
      6.那就是，一旦我们用 JavaScript 或者别的什么方式，改变了任何一个 CSS 属性，这份合成后的位图就失效了，我们需要重新绘制
        所有的元素。
      7.那么如果我们所有的元素都不合成，会怎样呢？结果就是，相当于每次我们都必须要重新绘制所有的元素，这也不是对性能友好的选择。
      8.那么好的合成策略是什么呢，好的合成策略是“猜测”可能变化的元素，把它排除到合成之外。
      9.我们来举个例子：  
        <div id="a">
            <div id="b">...</div>
            <div id="c" style="transform:translate(0,0)"></div>
        </div>
      10.假设我们的合成策略能够把 a、b 两个 div 合成，而不把 c 合成，那么，当我执行以下代码时：
        document.getElementById("c").style.transform = "translate(100px, 0)";
      11.我们绘制的时候，就可以只需要绘制 a 和 b 合成好的位图和 c，从而减少了绘制次数。这里需要注意的是，在实际场景中，我们的 
        b 可能有很多复杂的子元素，所以当合成命中时，性能提升收益非常之高。
      12.目前，主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。
      13.但是，这样的猜测准确性有限，所以新的 CSS 标准中，规定了 will-change 属性，可以由业务代码来提示浏览器的合成策略，灵
        活运用这样的特性，可以大大提升合成策略的效果。
    6.绘制
      1.绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只
        需要把最终要显示的位图交给操作系统即可。
      2.一般最终位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或者驱动就可以了，这取决于浏览器运
        行的环境。不过无论如何，我们把任何位图合成到这个“最终位图”的操作称为绘制。
      3.这个过程听上去非常简单，这是因为在前面两个小节中，我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，
        实际上就是按照 z-index 把它们依次绘制到屏幕上。
      4.然而如果在实际中这样做，会带来极其糟糕的性能。
      5.有一个一度非常流行于前端群体的说法，讲做 CSS 性能优化，应该尽量避免“重排”和“重绘”，前者讲的是我们上一课的排版行为，后
        者模糊地指向了我们本课程三小节讲的三个步骤，而实际上，这个说法大体不能算错，却不够准确。
      6.因为，实际上，“绘制”发生的频率比我们想象中要高得多。我们考虑一个情况：鼠标划过浏览器显示区域。这个过程中，鼠标的每次移
        动，都造成了重新绘制，如果我们不重新绘制，就会产生大量的鼠标残影。
      7.这个时候，限制绘制的面积就很重要了。如果鼠标某次位置恰巧遮盖了某个较小的元素，我们完全可以重新绘制这个元素来完成我们的
        目标，当然，简单想想就知道，这种事情不可能总是发生的。
      8.计算机图形学中，我们使用的方案就是“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域。
      9.当鼠标移动、元素移动或者其它导致需要重绘的场景发生时，我们只重新绘制它所影响到的几个矩形区域就够了。比矩形区域更小的影
        响最多只会涉及 4 个矩形，大型元素则覆盖多个矩形。
      10.设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂。
      11.我们重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交集部分绘制即可。
    7.结语
      1.在这一节课程中，我们讲解了浏览器中的位图操作部分，这包括了渲染、合成和绘制三个部分。渲染过程把元素变成位图，合成把一部
        分位图变成合成层，最终的绘制过程把合成层显示到屏幕上。
      2.当绘制完成时，就完成了浏览器的最终任务，把一个 URL 最后变成了一个可以看的网页图像。当然了，我们对每一个部分的讲解，都
        省略了大量的细节，比如我们今天讲到的绘制，就有意地无视了滚动区域。
      3.尽管如此，对浏览器工作原理的感性认识，仍然可以帮助我们理解很多前端技术的设计和应用技巧，浏览器的工作原理和性能部分非常
        强相关，我们在实践部分的性能优化部分，会再次跟你做一些探讨。
      4.实际上，如果你认真阅读浏览器系列的课程，是可以用 JavaScript 实现一个玩具浏览器的，我非常希望学习课程的同学中能有人这
        样做，一旦你做到了，收益会非常大。这就是我今天留给你的课外作业，你可以尝试一下。
API
  DOM
    浏览器DOM：你知道HTML的节点有哪几种吗？
    1.今天我们进入浏览器 API 的学习, 这一节课，我们来学习一下 DOM API。
    2.DOM API 是最早被设计出来的一批 API，也是用途最广的 API，所以早年的技术社区，常常用 DOM 来泛指浏览器中所有的 API。不
      过今天这里我们要介绍的 DOM，指的就是狭义的文档对象模型。
    3.DOM API 介绍
      1.首先我们先来讲一讲什么叫做文档对象模型。
      2.顾名思义，文档对象模型是用来描述文档，这里的文档，是特指 HTML 文档（也用于 XML 文档，但是本课不讨论 XML）。同时它又
        是一个“对象模型”，这意味着它使用的是对象这样的概念来描述 HTML 文档。
      3.说起 HTML 文档，这是大家最熟悉的东西了，我们都知道，HTML 文档是一个由标签嵌套而成的树形结构，因此，DOM 也是使用树形
        的对象模型来描述一个 HTML 文档。
      4.DOM API 大致会包含 4 个部分。
        节点：DOM 树形结构中的节点相关 API。
        事件：触发和监听事件相关 API。
        Range：操作文字范围相关 API。
        遍历：遍历 DOM 需要的 API。
      5.事件相关 API 和事件模型，我们会用单独的课程讲解，所以我们本篇文章重点会为你介绍节点和遍历相关 API。
      6.DOM API 数量很多，我希望给你提供一个理解 DOM API 设计的思路，避免单靠机械的方式去死记硬背。
    4.节点
      1.DOM 的树形结构所有的节点有统一的接口 Node，我们按照继承关系，给你介绍一下节点的类型。
        DOM节点类型.png
      2.在这些节点中，除了 Document 和 DocumentFrangment，都有与之对应的 HTML 写法，我们可以看一下。
        Element: <tagname>...</tagname>
        Text: text
        Comment: <!-- comments -->
        DocumentType: <!Doctype html>
        ProcessingInstruction: <?a 1?>
      3.我们在编写 HTML 代码并且运行后，就会在内存中得到这样一棵 DOM 树，HTML 的写法会被转化成对应的文档模型，而我们则可以
        通过 JavaScript 等语言去访问这个文档模型。
      4.这里我们每天都需要用到，要重点掌握的是：Document、Element、Text 节点。
      5.DocumentFragment 也非常有用，它常常被用来高性能地批量添加节点。因为 Comment、DocumentType 和 
        ProcessingInstruction 很少需要运行时去修改和操作，所以有所了解即可。
    5.Node
      1.Node 是 DOM 树继承关系的根节点，它定义了 DOM 节点在 DOM 树上的操作，首先，Node 提供了一组属性，来表示它在 DOM 树
        中的关系，它们是：
        parentNode
        childNodes
        firstChild
        lastChild
        nextSibling
        previousSibling
      2.从命名上，我们可以很清晰地看出，这一组属性提供了前、后、父、子关系，有了这几个属性，我们可以很方便地根据相对位置获取元
        素。当然，Node 中也提供了操作 DOM 树的 API，主要有下面几种。
        appendChild
        insertBefore
        removeChild
        replaceChild
      3.这个命名跟上面一样，我们基本可以知道 API 的作用。这几个 API 的设计可以说是饱受诟病。其中最主要的批评是它不对称——只有
        before，没有 after，而 jQuery 等框架都对其做了补充。
      4.实际上，appendChild 和 insertBefore 的这个设计，是一个“最小原则”的设计，这两个 API 是满足插入任意位置的必要 API，
        而 insertAfter，则可以由这两个 API 实现出来。
      5.我个人其实不太喜欢这个设计，对我而言，insertAt(pos) 更符合审美一些。当然，不论喜不喜欢，这个标准已经确定，我们还是必
        须要掌握它。
      6.这里从设计的角度还想要谈一点，那就是，所有这几个修改型的 API，全都是在父元素上操作的，比如我们要想实现“删除一个元素的
        上一个元素”，必须要先用 parentNode 获取其父元素。
      7.这样的设计是符合面向对象的基本原则的。还记得我们在 JavaScript 对象部分讲的对象基本特征吗？“拥有哪些子元素”是父元素的
        一种状态，所以修改状态，应该是父元素的行为。这个设计我认为是 DOM API 中好的部分。
      8.到此为止，Node 提供的 API 已经可以很方便（大概吧）地对树进行增、删、遍历等操作了。
      9.除此之外，Node 还提供了一些高级 API，我们来认识一下它们。
        compareDocumentPosition 是一个用于比较两个节点中关系的函数。
        contains 检查一个节点是否包含另一个节点的函数。
        isEqualNode 检查两个节点是否完全相同。
        isSameNode 检查两个节点是否是同一个节点，实际上在 JavaScript 中可以用“===”。
        cloneNode 复制一个节点，如果传入参数 true，则会连同子元素做深拷贝。
      10.DOM 标准规定了节点必须从文档的 create 方法创建出来，不能够使用原生的 JavaScript 的 new 运算。于是 document 对
        象有这些方法。
        createElement
        createTextNode
        createCDATASection
        createComment
        createProcessingInstruction
        createDocumentFragment
        createDocumentType
      11.上面的这些方法都是用于创建对应的节点类型。你可以自己尝试一下。
    6.Element 与 Attribute
      1.Node 提供了树形结构上节点相关的操作。而大部分时候，我们比较关注的是元素。Element 表示元素，它是 Node 的子类。
      2.元素对应了 HTML 中的标签，它既有子节点，又有属性。所以 Element 子类中，有一系列操作属性的方法。
      3.我们需要注意，对 DOM 而言，Attribute 和 Property 是完全不同的含义，只有特性场景下，两者才会互相关联（这里在后面我
        会详细讲解，今天的文章里我就不展开了）。
      4.首先，我们可以把元素的 Attribute 当作字符串来看待，这样就有以下的 API：
        getAttribute
        setAttribute
        removeAttribute
        hasAttribute
      5.如果你追求极致的性能，还可以把 Attribute 当作节点：
        getAttributeNode
        setAttributeNode
      6.此外，如果你喜欢 property 一样的访问 attribute，还可以使用 attributes 对象，比如 
        document.body.attributes.class = “a” 等效于 document.body.setAttribute(“class”, “a”)。
    7.查找元素
      1.document 节点提供了查找元素的能力。比如有下面的几种。
        querySelector
        querySelectorAll
        getElementById
        getElementsByName
        getElementsByTagName
        getElementsByClassName
      2.我们需要注意，getElementById、getElementsByName、getElementsByTagName、getElementsByClassName，这几个 
        API 的性能高于 querySelector。
      3.而 getElementsByName、getElementsByTagName、getElementsByClassName 获取的集合并非数组，而是一个能够动态更
        新的集合。
      4.我们看一个例子：
        var collection = document.getElementsByClassName('winter');
        console.log(collection.length);
        var winter = document.createElement('div');
        winter.setAttribute('class', 'winter')
        document.documentElement.appendChild(winter)
        console.log(collection.length);
      5.在这段代码中，我们先获取了页面的 className 为 winter 的元素集合，不出意外的话，应该是空。
      6.我们通过 console.log 可以看到集合的大小为 0。之后我们添加了一个 class 为 winter 的 div，这时候我们再看集合，可
        以发现，集合中出现了新添加的元素。
      7.这说明浏览器内部是有高速的索引机制，来动态更新这样的集合的。所以，尽管 querySelector 系列的 API 非常强大，我们还是
        应该尽量使用 getElement 系列的 API。
    8.遍历
      1.前面已经提到过，通过 Node 的相关属性，我们可以用 JavaScript 遍历整个树。实际上，DOM API 中还提供了 NodeIterator 
        和 TreeWalker 来遍历树。
      2.比起直接用属性来遍历，NodeIterator 和 TreeWalker 提供了过滤功能，还可以把属性节点也包含在遍历之内。
      3.NodeIterator 的基本用法示例如下：
        var iterator = document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT, null, false);
        var node;
        while(node = iterator.nextNode())
        {
            console.log(node);
        }
      4.这个 API 的设计非常老派，这么讲的原因主要有两点，一是循环并没有类似“hasNext”这样的方法，而是直接以 nextNode 返回
        null 来标志结束，二是第二个参数是掩码，这两个设计都是传统 C 语言里比较常见的用法。
      5.放到今天看，这个迭代器无法匹配 JavaScript 的迭代器语法，而且 JavaScript 位运算并不高效，掩码的设计就徒增复杂性了。
      6.这里请你注意一下这个例子中的处理方法，通常掩码型参数，我们都是用按位或运算来叠加。而针对这种返回 null 表示结束的迭代
        器，我使用了在 while 循环条件中赋值，来保证循环次数和调用 next 次数严格一致（但这样写可能违反了某些编码规范）。
      7.我们再来看一下 TreeWalker 的用法。
        var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null, false)
        var node;
        while(node = walker.nextNode())
        {
            if(node.tagName === "p")
                node.nextSibling();
            console.log(node);
        }
      8.比起 NodeIterator，TreeWalker 多了在 DOM 树上自由移动当前节点的能力，一般来说，这种 API 用于“跳过”某些节点，或
        者重复遍历某些节点。
      9.总的来说，我个人不太喜欢 TreeWalker 和 NodeIterator 这两个 API，建议需要遍历 DOM 的时候，直接使用递归和 Node 
        的属性。
    9.Range
      1.Range API 是一个比较专业的领域，如果不做富文本编辑类的业务，不需要太深入。这里我们就仅介绍概念和给出基本用法的示例，
        你只要掌握即可。
      2.Range API 表示一个 HTML 上的范围，这个范围是以文字为最小单位的，所以 Range 不一定包含完整的节点，它可能是 Text 
        节点中的一段，也可以是头尾两个 Text 的一部分加上中间的元素。
      3.我们通过 Range API 可以比节点 API 更精确地操作 DOM 树，凡是 节点 API 能做到的，Range API 都可以做到，而且可以做
        到更高性能，但是 Range API 使用起来比较麻烦，所以在实际项目中，并不常用，只有做底层框架和富文本编辑对它有强需求。
      4.创建 Range 一般是通过设置它的起止来实现，我们可以看一个例子：
        var range = new Range(),
            firstText = p.childNodes[1],
            secondText = em.firstChild
        range.setStart(firstText, 9) // do not forget the leading space
        range.setEnd(secondText, 4)
      5.此外，通过 Range 也可以从用户选中区域创建，这样的 Range 用于处理用户选中区域:
        var range = document.getSelection().getRangeAt(0);
      6.更改 Range 选中区段内容的方式主要是取出和插入，分别由 extractContents 和 insertNode 来实现。
        var fragment = range.extractContents()
        range.insertNode(document.createTextNode("aaaa"))
      7.最后我们看一个完整的例子。
        var range = new Range(),
            firstText = p.childNodes[1],
            secondText = em.firstChild
        range.setStart(firstText, 9) // do not forget the leading space
        range.setEnd(secondText, 4)

        var fragment = range.extractContents()
        range.insertNode(document.createTextNode("aaaa"))
      8.这个例子展示了如何使用 range 来取出元素和在特定位置添加新元素。
    10.总结
      1.在今天的文章中，我们一起了解了 DOM API 的内容。DOM API 大致会包含 4 个部分。
        节点：DOM 树形结构中的节点相关 API。
        事件：触发和监听事件相关 API。
        Range：操作文字范围相关 API。
        遍历：遍历 DOM 需要的 API。
      2.DOM API 中还提供了 NodeIterator 和 TreeWalker 来遍历树。比起直接用属性来遍历，NodeIterator 和 TreeWalker 提
        供了过滤功能，还可以把属性节点也包含在遍历之内。
      3.除此之外，我们还谈到了 Range 的一些基础知识点，这里你掌握即可。
      4.最后，我给你留了一个题目，请你用 DOM API 来实现遍历整个 DOM 树，把所有的元素的 tagName 打印出来。
    11.补充阅读：命名空间
      1.我们本课介绍的所有 API，特意忽略了命名空间。
      2.在 HTML 场景中，需要考虑命名空间的场景不多。最主要的场景是 SVG。创建元素和属性相关的 API 都有带命名空间的版本：
        document
          createElementNS
          createAttributeNS
        Element
          getAttributeNS
          setAttributeNS
          getAttributeNodeNS
          setAttributeNodeNS
          removeAttributeNS
          hasAttributeNS
          attributes.setNamedItemNS
          attributes.getNamedItemNS
          attributes.removeNamedItemNS
      3.若要创建 Document 或者 Doctype，也必须要考虑命名空间问题。DOM 要求从 document.implementation 来创建。
        document.implementation.createDocument
        document.implementation.createDocumentType
      4.除此之外，还提供了一个快捷方式，你也可以动手尝试一下。
        document.implementation.createHTMLDocument
  CSSOM
    浏览器CSSOM：如何获取一个元素的准确位置
    1.在前面的课程中，我们已经学习了 DOM 相关的 API，狭义的 DOM API 仅仅包含 DOM 树形结构相关的内容。今天，我们再来学习一
      类新的 API：CSSOM。
    2.我想，你在最初接触浏览器 API 的时候，应该都有跟我类似的想法：“好想要 element.width、element.height 这样的 API 啊”。
    3.这样的 API 可以直接获取元素的显示相关信息，它们是非常符合人的第一印象直觉的设计，但是，偏偏 DOM API 中没有这样的内容。
    4.随着学习的深入，我才知道，这样的设计是有背后的逻辑的，正如 HTML 和 CSS 分别承担了语义和表现的分工，DOM 和 CSSOM 也有
      语义和表现的分工。
    5.DOM 中的所有的属性都是用来表现语义的属性，CSSOM 的则都是表现的属性，width 和 height 这类显示相关的属性，都属于我们今
      天要讲的 CSSOM。
    6.顾名思义，CSSOM 是 CSS 的对象模型，在 W3C 标准中，它包含两个部分：描述样式表和规则等 CSS 的模型部分（CSSOM），和跟元
      素视图相关的 View 部分（CSSOM View）。
    7.在实际使用中，CSSOM View 比 CSSOM 更常用一些，因为我们很少需要用代码去动态地管理样式表。
    8.在今天的文章中，我来分别为你介绍这两部分的 API。
    9.CSSOM
      1.首先我们来介绍下 CSS 中样式表的模型，也就是 CSSOM 的本体。
      2.我们通常创建样式表也都是使用 HTML 标签来做到的，我们用 style 标签和 link 标签创建样式表，例如：
        <style title="Hello">
        a {
          color:red;
        }
        </style>
        <link rel="stylesheet" title="x" href="data:text/css,p%7Bcolor:blue%7D">
      3.我们创建好样式表后，还有可能要对它进行一些操作。如果我们以 DOM 的角度去理解的话，这些标签在 DOM 中是一个节点，它们有
        节点的内容、属性，这两个标签中，CSS 代码有的在属性、有的在子节点。这两个标签也遵循 DOM 节点的操作规则，所以可以使用 
        DOM API 去访问。
      4.但是，这样做的后果是我们需要去写很多分支逻辑，并且，要想解析 CSS 代码结构也不是一件简单的事情，所以，这种情况下，我们
        直接使用 CSSOM API 去操作它们生成的样式表，这是一个更好的选择。
      5.我们首先了解一下 CSSOM API 的基本用法，一般来说，我们需要先获取文档中所有的样式表：
        document.styleSheets
      6.document 的 styleSheets 属性表示文档中的所有样式表，这是一个只读的列表，我们可以用方括号运算符下标访问样式表，也可
        以使用 item 方法来访问，它有 length 属性表示文档中的样式表数量。
      7.样式表只能使用 style 标签或者 link 标签创建（对 XML 来说，还可以使用，咱们暂且不表）。
      8.我们虽然无法用 CSSOM API 来创建样式表，但是我们可以修改样式表中的内容。
        document.styleSheets[0].insertRule("p { color:pink; }", 0)
        document.styleSheets[0].removeRule(0)
      9.更进一步，我们可以获取样式表中特定的规则（Rule），并且对它进行一定的操作，具体来说，就是使用它的 cssRules 属性来实现：
        document.styleSheets[0].cssRules
      10.这里取到的规则列表，同样是支持 item、length 和下标运算。
      11.不过，这里的 Rules 可就没那么简单了，它可能是 CSS 的 at-rule，也可能是普通的样式规则。不同的 rule 类型，具有不同
        的属性。
      12.我们在 CSS 语法部分，已经为你整理过 at-rule 的完整列表，多数 at-rule 都对应着一个 rule 类型：
        CSSStyleRule
        CSSCharsetRule
        CSSImportRule
        CSSMediaRule
        CSSFontFaceRule
        CSSPageRule
        CSSNamespaceRule
        CSSKeyframesRule
        CSSKeyframeRule
        CSSSupportsRule
      13.具体的规则支持的属性，建议你可以用到的时候，再去查阅 MDN 或者 W3C 的文档，在我们的文章中，仅为你详细介绍最常用的 
        CSSStyleRule。
      14.CSSStyleRule 有两个属性：selectorText 和 style，分别表示一个规则的选择器部分和样式部分。
      15.selector 部分是一个字符串，这里显然偷懒了没有设计进一步的选择器模型，我们按照选择器语法设置即可。
      16.style 部分是一个样式表，它跟我们元素的 style 属性是一样的类型，所以我们可以像修改内联样式一样，直接改变属性修改规
        则中的具体 CSS 属性定义，也可以使用 cssText 这样的工具属性。
      17.此外，CSSOM 还提供了一个非常重要的方法，来获取一个元素最终经过 CSS 计算得到的属性：
        window.getComputedStyle(elt, pseudoElt);
      18.其中第一个参数就是我们要获取属性的元素，第二个参数是可选的，用于选择伪元素。
      19.好了，到此为止，我们可以使用 CSSOM API 自由地修改页面已经生效的样式表了。接下来，我们来一起关注一下视图的问题。
    10.CSSOM View
      1.CSSOM View 这一部分的 API，可以视为 DOM API 的扩展，它在原本的 Element 接口上，添加了显示相关的功能，这些功能，
        又可以分成三个部分：窗口部分，滚动部分和布局部分，下面我来分别带你了解一下。
    11.窗口 API
      1.窗口 API 用于操作浏览器窗口的位置、尺寸等。
        moveTo(x, y) 窗口移动到屏幕的特定坐标；
        moveBy(x, y) 窗口移动特定距离；
        resizeTo(x, y) 改变窗口大小到特定尺寸；
        resizeBy(x, y) 改变窗口大小特定尺寸。
      2.此外，窗口 API 还规定了 window.open() 的第三个参数：
        window.open("about:blank", "_blank" ,"width=100,height=100,left=100,right=100" )  
      3.一些浏览器出于安全考虑没有实现，也不适用于移动端浏览器，这部分你仅需简单了解即可。下面我们来了解一下滚动 API。
    12.滚动 API
      1.要想理解滚动，首先我们必须要建立一个概念，在 PC 时代，浏览器可视区域的滚动和内部元素的滚动关系是比较模糊的，但是在移
        动端越来越重要的今天，两者必须分开看待，两者的性能和行为都有区别。
    13.视口滚动 API
      1.可视区域（视口）滚动行为由 window 对象上的一组 API 控制，我们先来了解一下：
        scrollX 是视口的属性，表示 X 方向上的当前滚动距离，有别名 pageXOffset；
        scrollY 是视口的属性，表示 Y 方向上的当前滚动距离，有别名 pageYOffset；
        scroll(x, y) 使得页面滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 {top, left}；
        scrollBy(x, y) 使得页面滚动特定的距离，支持传入配置型参数 {top, left}。
      2.通过这些属性和方法，我们可以读取视口的滚动位置和操纵视口滚动。不过，要想监听视口滚动事件，我们需要在 document 对象上
        绑定事件监听函数：
        document.addEventListener("scroll", function(event){
          //......
        })
      3.视口滚动 API 是页面的顶层容器的滚动，大部分移动端浏览器都会采用一些性能优化，它和元素滚动不完全一样，请大家一定建立这
        个区分的意识。
    14.元素滚动 API
      1.接下来我们来认识一下元素滚动 API，在 Element 类（参见 DOM 部分），为了支持滚动，加入了以下 API。
        scrollTop 元素的属性，表示 Y 方向上的当前滚动距离。
        scrollLeft 元素的属性，表示 X 方向上的当前滚动距离。
        scrollWidth 元素的属性，表示元素内部的滚动内容的宽度，一般来说会大于等于元素宽度。
        scrollHeight 元素的属性，表示元素内部的滚动内容的高度，一般来说会大于等于元素高度。
        scroll(x, y) 使得元素滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 {top, left}。
        scrollBy(x, y) 使得元素滚动到特定的位置，支持传入配置型参数 {top, left}。
        scrollIntoView(arg) 滚动元素所在的父元素，使得元素滚动到可见区域，可以通过 arg 来指定滚到中间、开始或者就近。
      2.除此之外，可滚动的元素也支持 scroll 事件，我们在元素上监听它的事件即可：
        element.addEventListener("scroll", function(event){
          //......
        })
      3.这里你需要注意一点，元素部分的 API 设计与视口滚动命名风格上略有差异，你在使用的时候不要记混。
    15.布局 API
      1.最后我们来介绍一下布局 API，这是整个 CSSOM 中最常用到的部分，我们同样要分成全局 API 和元素上的 API。
    16.全局尺寸信息
      1.window 对象上提供了一些全局的尺寸信息，它是通过属性来提供的，我们一起来了解一下来这些属性。
        window对象上全局的尺寸信息.png
        window.innerHeight, window.innerWidth 这两个属性表示视口的大小。
        window.outerWidth, window.outerHeight 这两个属性表示浏览器窗口占据的大小，很多浏览器没有实现，一般来说这两个属性无关紧要。
        window.devicePixelRatio 这个属性非常重要，表示物理像素和 CSS 像素单位的倍率关系，Retina 屏这个值是 2，后来也出现了一些 3 倍的 Android 屏。
        window.screen （屏幕尺寸相关的信息）
          window.screen.width, window.screen.height 设备的屏幕尺寸。
          window.screen.availWidth, window.screen.availHeight 设备屏幕的可渲染区域尺寸，一些 Android 机器会把屏幕的一部分预留做固定按钮，所以有这两个属性，实际上一般浏览器不会实现的这么细致。
          window.screen.colorDepth, window.screen.pixelDepth 这两个属性是固定值 24，应该是为了以后预留。
      2.虽然 window 有这么多相关信息，在我看来，我们主要使用的是 innerHeight、innerWidth 和 devicePixelRatio 三个属性，
        因为我们前端开发工作只需要跟视口打交道，其它信息大概了解即可。
    17.元素的布局信息
      1.最后我们来到了本节课一开始提到的问题，我们是否能够取到一个元素的宽（width）和高（height）呢？
      2.实际上，我们首先应该从脑中消除“元素有宽高”这样的概念，我们课程中已经多次提到了，有些元素可能产生多个盒，事实上，只有盒
        有宽和高，元素是没有的。
      3.所以我们获取宽高的对象应该是“盒”，于是 CSSOM View 为 Element 类添加了两个方法：
        getClientRects();
        getBoundingClientRect()。
      4.getClientRects 会返回一个列表，里面包含元素对应的每一个盒所占据的客户端矩形区域，这里每一个矩形区域可以用 x, y, 
        width, height 来获取它的位置和尺寸。
      5.getBoundingClientRect ，这个 API 的设计更接近我们脑海中的元素盒的概念，它返回元素对应的所有盒的包裹的矩形区域，需
        要注意，这个 API 获取的区域会包括当 overflow 为 visible 时的子元素区域。
      6.根据实际的精确度需要，我们可以选择何时使用这两个 API。
      7.这两个 API 获取的矩形区域都是相对于视口的坐标，这意味着，这些区域都是受滚动影响的。
      8.如果我们要获取相对坐标，或者包含滚动区域的坐标，需要一点小技巧：
        var offsetX = document.documentElement.getBoundingClientRect().x - element.getBoundingClientRect().x;
      9.如这段代码所示，我们只需要获取文档跟节点的位置，再相减即可得到它们的坐标。
      10.这两个 API 的兼容性非常好，定义又非常清晰，建议你如果是用 JavaScript 实现视觉效果时，尽量使用这两个 API。
    18.结语
      1.今天我们一起学习了 CSSOM 这一类型的 API。我们首先就说到了，就像 HTML 和 CSS 分别承担了语义和表现的分工，DOM 和 
        CSSOM 也有语义和表现的分工。
      2.CSSOM 是 CSS 的对象模型，在 W3C 标准中，它包含两个部分：描述样式表和规则等 CSS 的模型部分（CSSOM），和跟元素视图相
        关的 View 部分（CSSOM View）。
      3.最后留给你一个问题，写好欢迎留言来讨论，请找一个网页，用我们今天讲的 API，把页面上的所有盒的轮廓画到一个 canvas 元素上。
  事件
    浏览器事件：为什么会有捕获过程和冒泡过程？
    1.你好，我是 winter。这一节课，我们进入了浏览器的部分，一起来学习一下事件。
    2.事件概述
      1.在开始接触具体的 API 之前，我们要先了解一下事件。一般来说，事件来自输入设备，我们平时的个人设备上，输入设备有三种：
        键盘；
        鼠标；
        触摸屏。
      2.这其中，触摸屏和鼠标又有一定的共性，它们被称作 pointer 设备，所谓 pointer 设备，是指它的输入最终会被抽象成屏幕上面的
        一个点。但是触摸屏和鼠标又有一定区别，它们的精度、反应时间和支持的点的数量都不一样。
      3.我们现代的 UI 系统，都源自 WIMP 系统。WIMP 即 Window Icon Menu Pointer 四个要素，它最初由施乐公司研发，后来被微
        软和苹果两家公司应用在了自己的操作系统上（关于这个还有一段有趣的故事，我附在文末了）。
      4.WIMP 是如此成功，以至于今天很多的前端工程师会有一个观点，认为我们能够“点击一个按钮”，实际上并非如此，我们只能够点击鼠标
        上的按钮或者触摸屏，是操作系统和浏览器把这个信息对应到了一个逻辑上的按钮，再使得它的视图对点击事件有反应。这就引出了我们
        第一个要讲解的机制：捕获与冒泡。
    3.捕获与冒泡
      1.很多文章会讲到捕获过程是从外向内，冒泡过程是从内向外，但是这里我希望讲清楚，为什么会有捕获过程和冒泡过程。
      2.我们刚提到，实际上点击事件来自触摸屏或者鼠标，鼠标点击并没有位置信息，但是一般操作系统会根据位移的累积计算出来，跟触摸屏
        一样，提供一个坐标给浏览器。
      3.那么，把这个坐标转换为具体的元素上事件的过程，就是捕获过程了。而冒泡过程，则是符合人类理解逻辑的：当你按电视机开关时，你
        也按到了电视机。
      4.所以我们可以认为，捕获是计算机处理事件的逻辑，而冒泡是人类处理事件的逻辑。
      5.以下代码展示了事件传播顺序：
        <body>
          <input id="i"/>
        </body>

        document.body.addEventListener("mousedown", () => {
          console.log("key1")
        }, true)

        document.getElementById("i").addEventListener("mousedown", () => {
          console.log("key2")
        }, true)

        document.body.addEventListener("mousedown", () => {
          console.log("key11")
        }, false)

        document.getElementById("i").addEventListener("mousedown", () => {
          console.log("key22")
        }, false)
      6.我们监听了 body 和一个 body 的子元素上的鼠标按下事件，捕获和冒泡分别监听，可以看到，最终产生的顺序是：
        “key1”
        “key2”
        “key22”
        “key11”
      7.这是捕获和冒泡发生的完整顺序。
      8.在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。
      9.在我们实际监听事件时，我建议这样使用冒泡和捕获机制：默认使用冒泡模式，当开发组件时，遇到需要父元素控制子元素的行为，可以
        使用捕获机制。
      10.理解了冒泡和捕获的过程，我们再看监听事件的 API，就非常容易理解了。
      11.addEventListener 有三个参数：
        事件名称；
        事件处理函数；
        捕获还是冒泡。
      12.事件处理函数不一定是函数，也可以是个 JavaScript 具有 handleEvent 方法的对象，看下例子：
        var o = {
          handleEvent: event => console.log(event)
        }
        document.body.addEventListener("keydown", o, false);
      13.第三个参数不一定是 bool 值，也可以是个对象，它提供了更多选项。
        once：只执行一次。
        passive：承诺此事件监听不会调用 preventDefault，这有助于性能。
        useCapture：是否捕获（否则冒泡）。
      14.实际使用，在现代浏览器中，还可以不传第三个参数，我建议默认不传第三个参数，因为我认为冒泡是符合正常的人类心智模型的，大
        部分业务开发者不需要关心捕获过程。除非你是组件或者库的使用者，那就总是需要关心冒泡和捕获了。
    4.焦点
      1.我们讲完了 pointer 事件是由坐标控制，而我们还没有讲到键盘事件。
      2.键盘事件是由焦点系统控制的，一般来说，操作系统也会提供一套焦点系统，但是现代浏览器一般都选择在自己的系统内覆盖原本的焦点
        系统。
      3.焦点系统也是视障用户访问的重要入口，所以设计合理的焦点系统是非常重要的产品需求，尤其是不少国家对可访问性有明确的法律要求。
      4.在旧时代，有一个经典的问题是如何去掉输入框上的虚线框，这个虚线框就是 Windows 焦点系统附带的 UI 表现。
      5.现在 Windows 的焦点已经不是用虚线框表示了，但是焦点系统的设计几十年间没有太大变化。
      6.焦点系统认为整个 UI 系统中，有且仅有一个“聚焦”的元素，所有的键盘事件的目标元素都是这个聚焦元素。
      7.Tab 键被用来切换到下一个可聚焦的元素，焦点系统占用了 Tab 键，但是可以用 JavaScript 来阻止这个行为。
      8.浏览器 API 还提供了 API 来操作焦点，如：
        document.body.focus();
        document.body.blur();
      9.其实原本键盘事件不需要捕获过程，但是为了跟 pointer 设备保持一致，也规定了从外向内传播的捕获过程。
    5.自定义事件
      1.除了来自输入设备的事件，还可以自定义事件，实际上事件也是一种非常好的代码架构，但是 DOM API 中的事件并不能用于普通对象，
        所以很遗憾，我们只能在 DOM 元素上使用自定义事件。
      2.自定义事件的代码示例如下（来自 MDN）：
        var evt = new Event("look", {"bubbles":true, "cancelable":false});
        document.dispatchEvent(evt);
      3.这里使用 Event 构造器来创造了一个新的事件，然后调用 dispatchEvent 来在特定元素上触发。
      4.我们可以给这个 Event 添加自定义属性、方法。
      5.注意，这里旧的自定义事件方法（使用 document.createEvent 和 initEvent）已经被废弃。
    6.总结
      1.今天这一节课，我们讲了浏览器中的事件。
      2.我们分别介绍了事件的捕获与冒泡机制、焦点机制和自定义事件。
      3.捕获与冒泡机制来自 pointer 设备输入的处理，捕获是计算机处理输入的逻辑，冒泡是人类理解事件的思维，捕获总是在冒泡之前发生。
      4.焦点机制则来自操作系统的思路，用于处理键盘事件。除了我们讲到的这些，随着输入设备的不断丰富，还有很多新的事件加入，如 
        Geolocation 和陀螺仪等。
      5.最后给你留个小问题。请你找出你所知道的所有事件类型，和它们的目标元素类型。
    7.WIMP 的小故事
      1.WIMP 是由 Alan Kay 主导设计的，这位巨匠，同时也是面向对象之父和 Smalltalk 语言之父。
      2.乔布斯曾经受邀参观施乐，他见到当时的 WIMP 界面，认为非常惊艳，不久后就领导苹果研究了新一代麦金塔系统。
      3.后来，在某次当面对话中，乔布斯指责比尔盖茨抄袭了 WIMP 的设计，盖茨淡定地回答：“史蒂夫，我觉得应该用另一种方式看待这个
        问题。这就像我们有个叫施乐的有钱邻居，当我闯进去想偷走电视时，却发现你已经这么干了。”
      4.但是不论如何，苹果和微软的数十代操作系统，极大地发展了这个体系，才有了我们今天的 UI 界面。
  API总集合  
    浏览器API（小实验）：动手整理全部API
    1.你好，我是 winter。今天我们来讲讲浏览器 API。
    2.浏览器的 API 数目繁多，我们在之前的课程中，已经一起学习了其中几个比较有体系的部分：比如之前讲到过的 DOM 和 CSSOM 等等。
      但是，如果你留意过，会发现我们讲到的 API 仍然是标准中非常小的一部分。
    3.这里，我们不可能把课程变成一本厚厚的 API 参考手册，所以这一节课，我设计了一个实验，我们一起来给 API 分分类。
    4.我们按照每个 API 所在的标准来分类。所以，我们用代码来反射浏览器环境中全局对象的属性，然后我们用 JavaScript 的 filter 
      方法来逐步过滤掉已知的属性。
    5.接下来，我们整理 API 的方法如下：
      从 Window 的属性中，找到 API 名称；
      查阅 MDN 或者 Google，找到 API 所在的标准；
      阅读标准，手工或者用代码整理出标准中包含的 API；
      用代码在 Window 的属性中过滤掉标准中涉及的 API。
    6.重复这个过程，我们可以找到所有的 API 对应的标准。首先我们先把前面已经讲过的 API 过滤掉。
    7.##JavaScript 中规定的 API
    8.大部分的 API 属于 Window 对象（或者说全局对象），我们可以用反射来看一看现行浏览器中已经实现的 API，我这里使用 Mac 下
      的 Chrome 72.0.3626.121 版本。
    9.我们首先调用 Object.getOwnPropertyNames(window)。在我的环境中，可以看到，共有 821 个属性。
    10.这里包含了 JavaScript 标准规定的属性，我们做一下过滤：
      {
          let js = new Set();
          let objects = ["BigInt", "BigInt64Array", "BigUint64Array", "Infinity", "NaN", "undefined", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Array", "Date", "RegExp", "Promise", "Proxy", "Map", "WeakMap", "Set", "WeakSet", "Function", "Boolean", "String", "Number", "Symbol", "Object", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray", "Atomics", "JSON", "Math", "Reflect", "escape", "unescape"];
          objects.forEach(o => js.add(o));
          let names = Object.getOwnPropertyNames(window)
          names = names.filter(e => !js.has(e));
      }
    11.这一部分我们已经在 JavaScript 部分讲解过了（JavaScript 对象：你知道全部的对象分类吗），所以这里我就采用手工的方式过滤
      出来。
    12.DOM 中的元素构造器
      1.接下来我们看看已经讲过的 DOM 部分，DOM 部分包含了 document 属性和一系列的构造器，我们可以用 JavaScript 的 
        prototype 来过滤构造器。
        names = names.filter( e => {
            try { 
                return !(window[e].prototype instanceof Node)
            } catch(err) {
                return true;
            }
        }).filter( e => e != "Node")
      2.这里我们把所有 Node 的子类都过滤掉，再把 Node 本身也过滤掉，这是非常大的一批了。
    13.Window 对象上的属性
      1.接下来我们要找到 Window 对象的定义，我们在下面链接中可以找到。
        https://html.spec.whatwg.org/#window
      2.这里有一个 Window 接口，是使用 WebIDL 定义的，我们手工把其中的函数和属性整理出来，如下：
        window,self,document,name,location,history,customElements,locationbar,menubar, personalbar,
        scrollbars,statusbar,toolbar,status,close,closed,stop,focus, blur,frames,length,top,opener,parent,
        frameElement,open,navigator,applicationCache,alert,confirm,prompt,print,postMessage
      3.接下来，我们编写代码，把这些函数和属性，从浏览器 Window 对象的属性中去掉，JavaScript 代码如下：
        {
            let names = Object.getOwnPropertyNames(window)
            let js = new Set();
            let objects = ["BigInt", "BigInt64Array", "BigUint64Array", "Infinity", "NaN", "undefined", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Array", "Date", "RegExp", "Promise", "Proxy", "Map", "WeakMap", "Set", "WeakSet", "Function", "Boolean", "String", "Number", "Symbol", "Object", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray", "Atomics", "JSON", "Math", "Reflect", "escape", "unescape"];
            objects.forEach(o => js.add(o));
            names = names.filter(e => !js.has(e));

            names = names.filter( e => {
                try { 
                    return !(window[e].prototype instanceof Node)
                } catch(err) {
                    return true;
                }
            }).filter( e => e != "Node")

            let windowprops = new Set();
            objects = ["window", "self", "document", "name", "location", "history", "customElements", "locationbar", "menubar", " personalbar", "scrollbars", "statusbar", "toolbar", "status", "close", "closed", "stop", "focus", " blur", "frames", "length", "top", "opener", "parent", "frameElement", "open", "navigator", "applicationCache", "alert", "confirm", "prompt", "print", "postMessage", "console"];
            objects.forEach(o => windowprops.add(o));
            names = names.filter(e => !windowprops.has(e));
        }
      4.我们还要过滤掉所有的事件，也就是 on 开头的属性。
        names = names.filter( e => !e.match(/^on/))
      5.webkit 前缀的私有属性我们也过滤掉：
        names = names.filter( e => !e.match(/^webkit/))
      6.除此之外，我们在 HTML 标准中还能找到所有的接口，这些我们也过滤掉：
        let interfaces = new Set();
        objects = ["ApplicationCache", "AudioTrack", "AudioTrackList", "BarProp", "BeforeUnloadEvent", "BroadcastChannel", "CanvasGradient", "CanvasPattern", "CanvasRenderingContext2D", "CloseEvent", "CustomElementRegistry", "DOMStringList", "DOMStringMap", "DataTransfer", "DataTransferItem", "DataTransferItemList", "DedicatedWorkerGlobalScope", "Document", "DragEvent", "ErrorEvent", "EventSource", "External", "FormDataEvent", "HTMLAllCollection", "HashChangeEvent", "History", "ImageBitmap", "ImageBitmapRenderingContext", "ImageData", "Location", "MediaError", "MessageChannel", "MessageEvent", "MessagePort", "MimeType", "MimeTypeArray", "Navigator", "OffscreenCanvas", "OffscreenCanvasRenderingContext2D", "PageTransitionEvent", "Path2D", "Plugin", "PluginArray", "PopStateEvent", "PromiseRejectionEvent", "RadioNodeList", "SharedWorker", "SharedWorkerGlobalScope", "Storage", "StorageEvent", "TextMetrics", "TextTrack", "TextTrackCue", "TextTrackCueList", "TextTrackList", "TimeRanges", "TrackEvent", "ValidityState", "VideoTrack", "VideoTrackList", "WebSocket", "Window", "Worker", "WorkerGlobalScope", "WorkerLocation", "WorkerNavigator"];
        objects.forEach(o => interfaces.add(o));
        names = names.filter(e => !interfaces.has(e));
      7.这样过滤之后，我们已经过滤掉了所有的事件、Window 对象、JavaScript 全局对象和 DOM 相关的属性，但是，竟然还剩余了很多
        属性！你是不是很惊讶呢？好了，接下来我们才进入今天的正题。
    14.其它属性
      1.这些既不属于 Window 对象，又不属于 JavaScript 语言的 Global 对象的属性，它们究竟是什么呢？
      2.我们可以一个一个来查看这些属性，来发现一些我们以前没有关注过的标准。
      3.首先，我们要把过滤的代码做一下抽象，写成一个函数：
        function filterOut(names, props) {
            let set = new Set();
            props.forEach(o => set.add(o));
            return names.filter(e => !set.has(e));
        }
      4.每次执行完 filter 函数，都会剩下一些属性，接下来，我们找到剩下的属性来看一看。
    15.ECMAScript 2018 Internationalization API
      1.在我的浏览器环境中，第一个属性是：Intl。
      2.查找这些属性来历的最佳文档是 MDN，当然，你也可以使用 Google。
      3.总之，经过查阅，我发现，它属于 ECMA402 标准，这份标准是 JavaScript 的一个扩展，它包含了国际化相关的内容：
        http://www.ecma-international.org/ecma-402/5.0/index.html#Title
      4.ECMA402 中，只有一个全局属性 Intl，我们也把它过滤掉：
        names = names.filter(e => e != "Intl")
      5.再来看看还有什么属性。
    16.Streams 标准
      1.接下来我看到的属性是： ByteLengthQueuingStrategy。
      2.同样经过查阅，它来自 WHATWG 的 Streams 标准：
        https://streams.spec.whatwg.org/#blqs-class
      3.不过，跟 ECMA402 不同，Streams 标准中还有一些其它属性，这里我手工查阅了这份标准，并做了整理。
      4.接下来，我们用代码把它们跟 ByteLengthQueuingStrategy 一起过滤掉：
        names = filterOut(names, ["ReadableStream", "ReadableStreamDefaultReader", "ReadableStreamBYOBReader", 
        "ReadableStreamDefaultController", "ReadableByteStreamController", "ReadableStreamBYOBRequest", 
        "WritableStream", "WritableStreamDefaultWriter", "WritableStreamDefaultController", "TransformStream", 
        "TransformStreamDefaultController", "ByteLengthQueuingStrategy", "CountQueuingStrategy"]);
      5.好了，过滤之后，又少了一些属性，我们继续往下看。
    17.WebGL
      1.接下来我看到的属性是：WebGLContext​Event。
      2.显然，这个属性来自 WebGL 标准：
        https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15
      3.我们在这份标准中找到了一些别的属性，我们把它一起过滤掉：
        names = filterOut(names, ["WebGLContextEvent","WebGLObject", "WebGLBuffer", "WebGLFramebuffer", 
        "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLTexture", "WebGLUniformLocation", 
        "WebGLActiveInfo", "WebGLShaderPrecisionFormat", "WebGLRenderingContext"]);
      4.过滤掉 WebGL，我们继续往下看。
    18.Web Audio API
      1.下一个属性是 WaveShaperNode。这个属性名听起来就跟声音有关，这个属性来自 W3C 的 Web Audio API 标准。
      2.我们来看一下标准：
        https://www.w3.org/TR/webaudio/
      3.Web Audio API 中有大量的属性，这里我用代码做了过滤。得到了以下列表：
        ["AudioContext", "AudioNode", "AnalyserNode", "AudioBuffer", "AudioBufferSourceNode", 
        "AudioDestinationNode", "AudioParam", "AudioListener", "AudioWorklet", "AudioWorkletGlobalScope", 
        "AudioWorkletNode", "AudioWorkletProcessor", "BiquadFilterNode", "ChannelMergerNode", 
        "ChannelSplitterNode", "ConstantSourceNode", "ConvolverNode", "DelayNode", "DynamicsCompressorNode", 
        "GainNode", "IIRFilterNode", "MediaElementAudioSourceNode", "MediaStreamAudioSourceNode", 
        "MediaStreamTrackAudioSourceNode", "MediaStreamAudioDestinationNode", "PannerNode", "PeriodicWave", 
        "OscillatorNode", "StereoPannerNode", "WaveShaperNode", "ScriptProcessorNode", "AudioProcessingEvent"]
      4.于是我们把它们也过滤掉：
        names = filterOut(names, ["AudioContext", "AudioNode", "AnalyserNode", "AudioBuffer", 
        "AudioBufferSourceNode", "AudioDestinationNode", "AudioParam", "AudioListener", "AudioWorklet", 
        "AudioWorkletGlobalScope", "AudioWorkletNode", "AudioWorkletProcessor", "BiquadFilterNode", 
        "ChannelMergerNode", "ChannelSplitterNode", "ConstantSourceNode", "ConvolverNode", "DelayNode", 
        "DynamicsCompressorNode", "GainNode", "IIRFilterNode", "MediaElementAudioSourceNode", 
        "MediaStreamAudioSourceNode", "MediaStreamTrackAudioSourceNode", "MediaStreamAudioDestinationNode", 
        "PannerNode", "PeriodicWave", "OscillatorNode", "StereoPannerNode", "WaveShaperNode", 
        "ScriptProcessorNode", "AudioProcessingEvent"]);
      5.我们继续看下一个属性。
    19.Encoding 标准
      1.在我的环境中，下一个属性是 TextDecoder，经过查阅得知，这个属性也来自一份 WHATWG 的标准，Encoding：
        https://encoding.spec.whatwg.org/#dom-textencoder
      2.这份标准仅仅包含四个接口，我们把它们过滤掉：
        names = filterOut(names, ["TextDecoder", "TextEncoder", "TextDecoderStream", "TextEncoderStream"]);
      3.我们继续来看下一个属性。
    20.Web Background Synchronization
      1.下一个属性是 SyncManager，这个属性比较特殊，它并没有被标准化，但是我们仍然可以找到它的来源文档：
        https://wicg.github.io/BackgroundSync/spec/#sync-manager-interface
      2.这个属性我们就不多说了，过滤掉就好了。
    21.Web Cryptography API
      1.我们继续看下去，下一个属性是 SubtleCrypto，这个属性来自 Web Cryptography API，也是 W3C 的标准。
        https://www.w3.org/TR/WebCryptoAPI/
      2.这份标准中规定了三个 Class 和一个 Window 对象的扩展，给 Window 对象添加了一个属性 crypto。
        names = filterOut(names, ["CryptoKey", "SubtleCrypto", "Crypto", "crypto"]);
      3.我们继续来看。
    22.The Screen Orientation API
      1.下一个属性是 ScreenOrientation，它来自 W3C 的 The Screen Orientation API 标准：
        https://www.w3.org/TR/screen-orientation/
      2.它里面只有 ScreenOrientation 一个接口，也是可以过滤掉的。
    23.结语
      1.到 Screen Orientation API，我这里看到还剩 300 余个属性没有处理，剩余部分，我想把它留给大家自己来完成。
      2.我们可以看到，在整理 API 的过程中，我们可以找到各种不同组织的标准，比如：
        ECMA402 标准来自 ECMA；
        Encoding 标准来自 WHATWG；
        WebGL 标准来自 Khronos；
        Web Cryptography 标准来自 W3C；
        还有些 API，根本没有被标准化。
      3.浏览器环境的 API，正是这样复杂的环境。我们平时编程面对的环境也是这样的一个环境。
      4.所以，面对如此繁复的 API，我建议在系统掌握 DOM、CSSOM 的基础上，你可以仅仅做大概的浏览和记忆，根据实际工作需要，选择
        其中几个来深入学习。
      5.做完这个实验，你对 Web API 的理解应该会有很大提升。
      6.这一节课的问题就是完成所有的 API 到标准的归类，不同的浏览器环境应该略有不同，欢迎你把自己的结果留言一起讨论。    
其他总结
  1.js-web-api
    1.dom（document object model 文档对象模型）
      1.dom本质
        它到底是个什么东西
        dom的本质就是一颗树。首先html它本身是一个树形的结构。浏览器的开发者工具中的elements里面的我们就可以把它理解为dom结构。
        它不是完全百分之百的dom，它的结构就是dom的结构，但它里面还有一些css的信息。我们的html代码下载到浏览器之后，浏览器一解
        析，就会生成一个dom结构。html和dom它是不一样的。html它是一个文件或者说一段代码，dom它是一个浏览器内存里面已经初始化好
        的树的一个结构。dom的本质是从html文件解析出来的一棵树。
      2.dom节点操作
        这个节点操作就是针对单个节点。
        1.获取dom节点
          document.getElementById('div1') // 元素
          document.getElementsByTagName('div') // 集合
          document.getElementsByClassName('container') // 集合
          document.querySelectorAll('p') // css选择器来获取，集合
        2.attribute
          获取节点之后，我们可以操作它的attribute
          const pList = document.querySelectorAll('p')
          const p = pList[0]
          p.getAttribute('data-name')
          p.setAttribute('data-name', 'imooc')
          p.getAttribute('style')
          p.setAttribute('style', 'font-size: 30px;')
          我们可以通过一个getAttribute和setAttribute这样的api去直接修改这个html的结构。它是能真正作用到dom结构里面去的。它
          是修改的标签的一个属性。
        3.property
          property的意思就是我们能获取dom元素，然后去通过js的属性的方式来操作
          const pList = document.querySelectorAll('p')
          const p = pList[0]
          p.style.width // 获取样式
          p.style.width = '100px' // 修改样式
          p.className // 获取class
          p.className = 'p1' // 修改class
          p.nodeName // 获取nodename
          p.nodeType // 获取nodeType
          这个property是通过以js对象属性的形式来去操作它里面的一些东西。所以property它本身不是一个api的名字。它是用js的属性
          操作的一种形式。我们可以对这个属性进行设置和获取，就是读和写。设置完了之后它真正的渲染到了页面上。
        property修改的是js变量的属性，不会对标签产生影响。attribute它修改的是标签的属性，设置上之后，标签上就会有这个属性。两者
        都有可能引起dom的重新渲染。平常该怎么用它们呢，建议尽量用property去操作。因为property它可能会在js的一些机制中去重复避免
        一些dom的不必要的渲染。attribute你一旦改了这个html结构，它肯定引起这个重新渲染。dom的重新渲染是比较耗费性能的。如果必须
        要修改标签结构的话当然也要用attribute。
      3.dom结构操作
        因为dom是一棵树，对于树的结构操作一般会分为这么几个
        1.新增/插入节点
        2.获取子节点列表，获取父节点
        3.删除子节点
        const div1 = document.getElementsById('div1')
        const p1 = document.createElement('p') // 新增一个节点
        p1.innerHTML = 'this is p1'
        div1.appendChild(p1)                   // 插入节点
        const p2 = document.getElementById('p2')
        div1.appendChild(p2)                   // 移动一个节点
        const child = div1.childNodes          // 获取子节点列表
        const parent = div1.parentNode         // 获取父节点
        div1.removeChild(child[0])             // 删除子节点
      4.dom性能
        dom操作是比较耗时，也是比较耗cpu的，我们怎么通过自己的一些比较常用的手段去解决这种问题。
        dom操作是非常昂贵的，所谓昂贵其实就是它占用cpu会比较多，因为它有可能会导致浏览器的重绘或重排就是重新渲染，这些工作会比较
        耗时一些或耗费cpu计算比较多一些。如果是频繁操作呢，可能会导致卡顿的一些问题，所以说我们就需要注意这些地方，避免频繁的dom
        操作。
        1.对dom查询做一些缓存
          我们现在电脑的内存都还好，所以我们做一些dom查询的缓存应该会减少我们dom的操作。查出来之后就先存起来，存起来之后就不要再
          查了。为什么会比较频繁的查询呢，为什么浏览器自己不缓存呢，因为我们的js有可能会操作dom，比如每次循环里面我们都对这个p进
          行一些修改，这样的话，浏览器是不是就没办法做到它保存完之后的正确性了。所以说我们的js可以去修改dom，所以说浏览器这个时候
          它就不能缓存dom的查询。是不是缓存得由我们自己来决定，既然浏览器不能缓存，我们就自己缓存。
          // 不缓存dom查询结果
          for (let i = 0; i < document.getElementsByTagName('p').length; i++) {
            // 每次循环，都会计算length，频繁进行dom查询
          }
          // 缓存dom查询结果
          const pList = document.getElementsByTagName('p')
          const length = pList.length
          for (let i = 0; i < length; i++) {
            // 缓存length，只进行一次dom查询
          }
          上面这样的结果对比很明显，如果是p的数量多了之后，这个性能的差异还是很大的。
        2.将频繁操作改为一次性操作，就是合并的处理
          有时候我们可能会频繁插入一些东西，这时能不能打个包一块插入进去。这样的话也是避免频繁的dom操作。
          const listNode = document.getElementById('list')
          // 创建一个文档片段，此时还没有插入到dom树中
          const frag = document.createDocumentFragment()
          // 执行插入
          for (let i = 0; i < 10; i++) {
            const li = document.createElement('li')
            li.innerHTML = 'list item ' + i
            frag.appendChild(li)
          }
          // 都完成之后，再插入到dom树中
          listNode.appendChild(frag)
    2.bom（bom browser object model 浏览器对象模型） 
      1.navigator
        浏览器的信息
        navigator.userAgent
      2.screen
        屏幕的信息，比如说宽度高度等待这些
        screen.width
        screen.height
      3.location
        地址的一些信息，就是分析url的一些信息
        https://coding.imooc.com/lesson/400.html?a=100&b=200#mid=30309
        location.href        // https://coding.imooc.com/lesson/400.html#mid=30309
        location.protocol    // 'https:'  
        location.host        // 'coding.imooc.com'  
        location.pathname    // '/lesson/400.html'
        location.search      // '?a=100&b=200'
        location.hash        // '#mid=30309'
        我们整个的网址都是通过这些信息拼接出来的。
      4.history
        前进后退这些信息
        history.back()    // 网页后退
        history.forward() // 网页前进
    3.事件
      1.事件绑定
        事件绑定就是addEventListener
        const btn = document.getElementById('btn1')
        btn.addEventListener('click', event => {
          console.log('clicked')
        })
      2.事件冒泡
        事件冒泡是基于dom的树形结构，事件顺着这个dom结构往它的上级一层一层的冒，在它本身和它的上级都可以把这个事件监听到。应用
        场景就是事件代理。
      3.事件代理
        事件代理是基于事件冒泡来做的。有了事件冒泡这个机制，我们才能在这个机制的基础上去实现这个代理。所谓代理就是因为数量太多或结
        果比较复杂，不好去挨个都去绑定事件的情况。我们把事件绑到某一个父元素上。事件里通过event.target获取触发元素做一些判断，是
        不是我们想要的那个元素。然后再去做一些其他的动作。
        1.代码简洁
          事件代理的代码比较简洁，你如果是每一个元素都给它绑一个事件的话，这样代码反而就会麻烦了，至少你还得做个dom查询，还得做个
          循环。
        2.减少浏览器内存使用
          如果需要绑定事件的元素非常多的话，每一个元素都去挂一个事件监听，如果数量过多的话，它是非常耗费内存的。但是利用事件代理只
          在父元素上去挂一个事件，只挂一次事件就没有那么耗费内存。
        3.不要滥用
          只有在一些情况下可以用。就是因为数量太多结果复杂的不好去每一个都去绑定事件的情况下才应该去用。你不要到处都去用这个代理。
          这个代理还是有一定复杂度的。它的代码简洁程度虽然也比较简洁，但是它的简洁是相比于每个元素都做事件监听的情况。比如一个按
          钮的绑定就不至于用代理了。直接把事件绑定到这个按钮上不就完了吗。这样的话才是更简洁的。所以不要滥用，不要为了用代理而用
          代理。要在合适的场景下去使用。
          1.重新写通用事件绑定函数，使其能够适用普通的绑定和事件代理的绑定。
          function bindEvent (elem, type, selector, fn) {
            if (fn == null) {
              fn = selector
              selector = null
            }
            elem.addEventListener(type, event => {
              const target = event.target
              if (selector) {
                // 代理绑定
                if (target.matched(selector)) {
                  fn.call(target, event)
                }
              } else {
                // 普通绑定
                fn.call(target, event)
              }
            })
          }
          const btn1 = document.getElementById('btn1')
          const div3 = document.getElementById('div3')
          bindEvent(btn1, 'click', function (event) {
            event.preventDefault()
            alert(this.innerHTML)
          })
          bindEvent(div3, 'click', 'a', function (event) {
            event.preventDefault()
            alert(this.innerHTML)
          })
    4.ajax
      1.XMLHttpRequest
        我们网页实现ajax最核心的一个api就是这个XMLHttpRequest。
      2.状态码
        // xhr.send()之后，这个xhr.readyState才开始从0-4变化
        xhr.readyState
          1.0 - （未初始化）还没有调用send()方法
          2.1 - （载入）已调用send()方法，正在发送请求
          3.2 - （载入完成）send()方法调用完成，已接收到全部响应内容
          4.3 - （交互）正在解析响应内容
          5.4 - （完成）响应内容解析完成，可在客户端调用
        xhr.status  
          status是我们常见的http协议的状态码
          1.2xx - 表示成功处理请求，如200
          2.3xx - 需要重定向，重定向不用我们自己处理，服务器返回之后浏览器会自己去跳转，如301 302 304
          3.4xx - 客户端请求错误，如404 403
          4.5xx - 服务端错误
      3.跨域，跨域解决方案
        1.什么是跨域（同源策略）
          1.同源策略
            ajax请求的时候，浏览器要求当前网页和server必须同源（安全）。在服务端或非浏览器的环境下是可以请求的。这个同源策略是
            浏览器要求的。
          2.同源
            对于一个url来说，前端页面和server端做对比。协议、域名、端口，三者必须一致。
            前端：http://a.com:8080/； server：https://b.com/api/xxx
            这两个是不同源的，而且是协议，域名，端口都不相同的。有一个不一样就是不同源的。  
            为什么同源策略仅限制浏览器呢。我们的搜索引擎，爬虫它不是浏览器上发送的，它是服务端发送的。搜索引擎的爬虫它是服务端去
            做请求去访问各个网站的一些网页。它照样可以把数据拿到。所以说想要去攻击某一个不同源的网站的一些接口是可以发起攻击的。
            server端可以发起攻击，因为server端它并没有像浏览器一样的同源策略，所以可以发起攻击的。怎么预防就是服务端相互较量的
            事情了。但是浏览器必须要做这个同源的要求，因为每个网站都要有每个网站的一个范围，都要有个墙，都要有域的一个限制。你不
            能乱套。如果说这个浏览器同源策略做的不好，那这个浏览器就是不安全的。我们就没法用，没法信任这个浏览器。
          3.加载图片，css，js可无视同源策略
            同源策略第一个条件就是ajax请求。但如果不是ajax请求，比如说图片，css，js可无视同源策略。它们的地址都可以跨域。浏览
            器不会限制。
            <img src="跨域的图片地址" />
            <link href="跨域的css地址" />
            <script src="跨域的js地址"></script>
            应用：
              1.<img/>
                图片可用于统计打点。可能是使用第三方统计服务，比如站长之家，百度统计等，这些也都是外域的嘛，统计打点无非就是发
                一个请求嘛，这个时候如果我们用ajax发的话那就出现跨域，那就不好解决了。所以说我们用图片，我们去初始化一个图片，
                然后把图片的地址写成第三方统计服务的地址，然后在地址里面写上我们各种各样需要的参数，然后这个时候我们通过图片去
                发这个请求，这样的话就不会出现跨域的问题。 
              2.<link /> <script>
                <link /> <script>可以使用cdn，cdn一般都是外域。 
              3.<script>可以实现jsonp
                jsonp是我们一般情况下前端实现跨域一个比较常用的方案。
            所以说图片，css，js可以无视同源策略可以实现跨域，它们都是有一定的功能的。浏览器也是为了它们有一定功能做了一些考虑
            的。所以说并不是说这三个平白无故的就实现了跨域的。
          4.跨域
            1.所有的跨域，都必须经过server端允许和配合
            2.如果未经server端允许就实现的跨域，说明浏览器有漏洞，是一个危险信号。浏览器有漏洞那就非常危险了。因为你现在所有的
            请求都是通过浏览器发出的。浏览器有漏洞那说明这个浏览器不可信，你的一些什么账号啊，密码啊，什么乱七八糟的请求啊，什么
            一些数据啊都有可能被攻击。
        2.Jsonp
          我们先看一个问题。浏览器随便访问一个网址，服务端返回的一定是一个html文件吗。服务端拿到这个网址url之后分析，然后获取这
          个文件的内容，然后把文件内容返回。其实服务端不一定返回一个html文件的内容，服务端可以动态拼接任何的数据内容返回，只要符
          合相应文件的格式要求。
          同理我们script去访问一个js地址的话，就一定是返回一个js静态文件吗。这个也是不一定的。
          jsonp
            1.<script>可以绕过跨域限制
            2.服务端可以拼接任意动态数据返回
            3.所以，我们就可以通过<script>获得跨域的数据，只要服务端愿意返回
            4.jsonp简易demo
              <script>
                window.callback = function (data) {
                  // 这是我们跨域接收的信息
                  console.log(data)
                }
              </script>
              <script src="https://imooc.com/getData.js"></script>
              <!-- 上面的script将返回 callback({x: 100, y: 200}) -->
        3.cors(服务端支持的一种解决跨域的方式)
          cors其实是一个统称，就是服务器端可以设置http header，就是在服务端response返回的时候可以设置header，如下面这些东西。
          response.setHeader('Access-Control-Allow-Origin', 'http://localhost:8081')        // 允许的域名是什么 
          response.setHeader('Access-Control-Allow-Headers', 'X-Requested-With')            // 允许的headers是什么 
          response.setHeader('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS') // 允许的methods是什么 
          response.setHeader('Access-Control-Allow-Credentials', 'true')                    // 接收跨域的cookie，是否允许传cookie
          这种方式就是纯服务器端的操作
      4.手写一个简易的ajax
        1.ajax工作基本过程
          // xhr.readyState等于4的时候才说明ajax的请求成功了，其他需要判断的东西只有xhr.status也就是http状态码了。比如
          // 网络断开的情况下xhr不可能等于4，所以前端的ajax请求的业务逻辑中根本就不用判断类似断网的这种情况
          1.get请求
            const xhr = new XMLHttpRequest()
            xhr.open('GET', '/api', true)
            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  alert(xhr.responseText) // 返回的信息是字符串
                } else {
                  console.log('其他情况')
                }
              }
            }
            xhr.send()
          2.post请求
            const xhr = new XMLHttpRequest()
            xhr.open('POST', '/api', true)
            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  alert(xhr.responseText) // 返回的信息是字符串
                } else {
                  console.log('其他情况')
                }
              }
            }
            const postData = {
              username: 'zhangsan',
              password: 'xxx'
            }
            // 发送的数据也是字符串
            xhr.send(JSON.stringifypost(Data))
        2.简易的ajax，回调函数版
          function ajax (url, method, successFn, errorFn) {
            const xhr = new XMLHttpRequest()
            xhr.open(method, url, true)
            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  successFn(
                    JSON.parse(xhr.responseText)
                  )
                } else if (xhr.status === 404) {
                  errorFn(new Error('404 not found'))
                }
              }
            }
            xhr.send()
          }
        3.简易的ajax，promise版
          function ajax (url, method) {
            const p = new Promise((resolve, reject) => {
              const xhr = new XMLHttpRequest()
              xhr.open(method, url, true)
              xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                  if (xhr.status === 200) {
                    resolve(
                      JSON.parse(xhr.responseText)
                    )
                  } else if (xhr.status === 404) {
                    reject(new Error('404 not found'))
                  }
                }
              }
              xhr.send()
            })
            return p
          }
          const url = '/data/test.json'
          const method = 'GET'
          ajax(url, method)
            .then(res => {
              console.log(res)
            })
            .catch(err => {
              console.log(err)
            })
    5.存储
      1.cookie
        1.cookie它本身是用于浏览器端和server端通讯，也就是http请求的一部分。
        2.它最早是被借用来做本地存储，因为localStorage和sessionStorage这两个它是html5之后才提出来的。html5是大约在09年
          左右提出来的。那个时候其实我们的互联网已经发展的特别好了。虽说移动互联网还没有那么好，比如美团滴滴啊各种软件那时候还
          没有。只能手机还没有普及。但是那时候的个人电脑已经非常普及了，各种网站，比如百度啊163啊搜狐汽车之家啊，各种网站已经
          很普及了。那时候刚刚发布html5，没有localStorage和sessionStorage，所以说我们只能是用cookie来做本地存储。
        3.我们可以用document.cookie = ''这个方式来去修改。当然这是前端的修改方式。就是h5页前端的用js修改的方式。后端也可以
          去修改cookie，因为cookie它本身是一个通讯的一个标准。
        4.比如我们在浏览器中访问一个h5的页面，Network中可以看到这个Request Headers里面就有cookie。也就是说它是用来浏览器
          和server端通讯的。所以现在即便是html5已经普及，localStorage和sessionStorage已经被我们使用。但是cookie还是有
          自己的价值。因为它的价值不在于本地存储，而在于本地和服务器端进行通讯。cookie的信息中一般是有个人的一些信息标识的。
          这个cookie是个字符串的形式，中间通过分号分割的形式，每一部分都是key=value的形式。我们也可以通过Application里面
          看到cookie一些它拆分出来的一种形式，当前域名下的所有cookie。
          怎么加一个cookie：
            document.cookie = 'a=100'
            console.log(document.cookie) // 'a=100'
            document.cookie = 'b=200'
            console.log(document.cookie) // 'a=100; b=200'
            我们每赋值一个就追加一遍。它是一个追加的过程，它不是一个覆盖的过程。所以说这个api看着还比较怪异。
            document.cookie = 'a=300'
            console.log(document.cookie) // 'b=200; a=300'
            同一个key它会覆盖，不同key它会追加
            所以说这种api的计算形式就和我们之前做的js的那种普通的计算形式它就不一样。这就很难让人理解，你不知道的话可能就会掉
            到坑里面去。所以从api这个易用程度来说，这个cookie做本地存储就不合适。
            我们加上了上面的cookie之后，我们访问这个页面的时候，Request Headers里面就带了这个cookie，这个时候我们访问页面，
            后端是能接收到这个cookie的。比如我们这个cookie里面有一个userId=xxx，服务端接收到这个cookie之后就知道这个登录
            用户是谁了。也就是说登录的过程通常用cookie来实现。
        5.它为什么能做本地存储呢，假使我们现在没有localStorage和sessionStorage，其实cookie是可以做本地存储的。我们上面存
          储了一些cookie信息。我们刷新后，还能够查到这些信息，也就是说只要我们的cookie不清除，页面不管怎么刷新，这个cookie
          出来的都是这些信息。也就是我们在前端对cookie进行赋值，然后页面不管怎么刷新，这个赋的值都会在的，就是浏览器会帮我们
          存下来。所以说它能做本地存储。这也是我们在html5规范出来或普及之前唯一的能在页面中做本地存储的一种能力。但是cookie
          当时的设计并不是为了做本地存储，它是为了浏览器和服务端进行通讯。它只是被借用来做本地存储。它本来就不是干这个活的，但
          是干这个活了。所以它肯定会有一些问题。
          cookie的缺点
            1.存储大小，cookie有个限制，最大存4kb，也就是说我们这写了很长很长的cookie，超过了4kb，那就存不下了，为什么存不
              下呢，因为我们在去发送请求的时候，我们是要把cookie带上的。如果你这个cookie内容很多，当时的网速又不快，网速有限。
              你如果每次请求都带上cookie，然后cookie每次都挂上好几kb的数据，那样的话会严重影响每次的请求。要知道，我们刷新一
              个网页，它是要发很多请求的，每个请求都要把这个cookie给带上的。这个事是很烦人的。所以要有大小限制。
            2.http请求的时候需要发送到服务端，增加请求的数据量，就是你用cookie作为本地的存储，你存什么东西，每次请求都会带到
              服务器上去。这样的话就会让这个请求变得数据量比较大，就会慢一些。
            3.只能用document.cookie = ''这种方式来修改，这种api太过简陋也太不好理解，你每次修改都是追加，这种东西其实和我
              们的js语法本身不是那么的贴近，而且比较费解。
          所以说cookie，大家要理解这个背景。它本身是用来干嘛的。是用来联系这个服务端通讯的。但是由于之前我们没有合理的本地缓
          存或本地存储的这个能力，所以我们不得不用cookie来做这个事情。但是它有一些限制让我们不是很好用。
      2.localStorage sessionStorage
        1.这两个是html5专门为存储设计的，最大可存储5M。5M这个空间对于我们前端来说就算是已经很知足了。因为前端存储的信息基本上
          也就存储个字符串啊，存储个数字啊，就是简单的缓存一下，简单的暂存一下。不会存一些很大的数据量，所以说5M绝对是绰绰有余。
          而且这5M是针对每个域名来说的。每个host，每个域我们可以存储5M，所以说它是专门为存春来设计的，空间更大。
        2.api简单易用，是用setItem getItem来做的。这个方式就完全符合于我们自己写一个存储的功能或者缓存的功能。get set这种
          api，很多这种key value的库都是用这种get set api，所以说非常符合我们的使用。
          localStorage.setItem('a', 100)
          localStorage.getItem('a')
          sessionStorage.setItem('b', 200)
          sessionStorage.getItem('b')
        3.不会随着http请求被发送出去，如果是5M都随便发的话那就麻烦了。你如果是自己实现一个类似于存储缓存的一个功能的话。其实
          也是有一个get有一个set就可以了。别的基本上用处不是很大。
        4.localStorage和sessionStorage的区别
          1.localStorage的数据会永久存储，除非代码或手动删除。
          2.sessionStorage的数据只存在于当前会话，当前会话就是当前你和服务端的一个连接，比如说浏览器关闭的时候它会清空。也就
            是sessionStorage类似于我们服务端的一个session。session是和登录和用户验证有关系的。sessionStorage它会存在于
            用户活跃的这段事件，如果用户关闭浏览器走了，不再访问这个网站了，它就会自动清空了。
          3.用的话一般用localStorage会更多一些。
  2.运行环境
    运行环境我们通常指浏览器，当然server端有nodejs运行环境。浏览器要下载代码，渲染出页面，期间可能会执行若干的js。这是它的主要
    的功能。也就是说前端页面h5页面和服务端或者是客户端有个不一样的地方就在于它需要随时的去下载网页代码，下载完之后还要渲染，渲染
    的过程中还要执行js的一些运算，所以说它的性能就需要一个比较高的要求。首先你要下载快，还要渲染快，里面的js执行逻辑还要比较合理。
    所以我们就针对它的这一个过程来做一些优化。怎么让我们的网页能更快一些。这是我们运行环境这一大节我们需要做的一些工作。就是保证代
    码在浏览器中稳定且高效。首先是稳定，你不能乱了，你做了高效之后有什么安全问题，这个肯定不行。高效就是让它更快，下载的更快，渲染
    的更快以及执行的更快，这就是我们需要做的工作。这个也是比较重要的一部分。
    1.页面加载过程
      1.加载资源的形式
        首先我们要知道它加载什么东西
        1.html代码
          最基本的访问页面需要html代码对吧
        2.媒体文件，如图片，视频等
          再一个页面中如果有图片有视频这样的媒体文件。我们需要加载一些文件，加载一些图片视频的媒体文件。所以我们
        3.javascript css
          然后呢就是js和css的这个代码
        一般情况下的页面就基本上三部分。
      2.加载资源的过程
        1.DNS解析：域名 -> IP地址
          我们输入url，第一步的时候它要进行dns解析，dns就是domin name server就是域名服务，域名服务解析，把域名变成ip地址。
          其实域名直接是ip地址也没问题，但由于ip地址很难记，还有就是ip地址在不同区域内，特别是大型网站，像百度，淘宝这种大型
          的网站，ip地址是不一样的，因为它们做了分区域的ip地址的一个均衡或者代理。所以说我们在访问域名的时候，这个域名解析这个
          服务它会根据地域去解析不同的域名，让你的网站会访问的更快一些。比如说你人在北京，你去访问广州的一个机器，ip地址肯定会
          慢对吧。你人在北京，你去访问一个昌平的一个机器，那肯定会快很多。所以基于这两点，我们肯定是要用域名而不是用ip地址。那
          用域名，你就必须用一个域名解析服务。为什么要用域名解析服务呢，我们的手机或电脑去访问一个域名的时候，它真正对应到的还
          是一个ip地址，还是一个ip地址的机器。所以说域名只是一个中间的，方便大家记住，方便统一使用的一个符号，它真正到网络中，
          它还是用ip地址做这个网络访问的。所以说第一步我们要把域名解析成ip地址。
        2.浏览器根据ip地址向服务器发起http请求
          浏览器向ip地址发送请求，其实浏览器只是一个发起方，它真正的核心模块还是操作系统的，操作系统里面有一些能发送网络服务的
          一些系统服务。浏览器调用这个操作系统的系统服务。然后操作系统去把这个事情发送。这里面我们说是http请求，其他它里面还涉
          及到一些http的一些连接，比如说我们常说的三次握手这些。这些有点概念化了。三次握手这个东西在我们实际的应用中，其实我们
          体会不到。我们能体会到的就是ip地址，http请求。我们前端常用的协议就是http协议。这是发起请求。
        3.发起请求后服务器接收请求并处理http请求，并返回给浏览器。返回的东西就是前面讲的加载的资源。看你请求的是什么东西，它就
          给你返回什么东西。
        大体过程就是这样的。
      3.渲染页面的过程
        1.如果我们请求的是一个页面的话，那肯定是返回html代码。然后网页根据html代码生成DOM Tree。
        2.根据css代码生成CSSOM，这个OM跟DOM的OM是一样的，就是object model对象模型。就是css对象模型。这个意思和html生成dom
          树是一样的，html是一个文本代码，浏览器解析完之后呢，它要生成一个结构化的树结构。那css它也是一个文本代码，然后它要生成
          一个css object model的一个可结构化的一个对象。从概念上理解它和dom树是一样的。遇到css的代码出现就会生成一个CSSOM。
        3.DOM Tree和CSSOM整合成一个Render Tree渲染树。为什么要这么做呢，因为只有dom树是没法渲染的。因为有些标签的css属性是
          在CSSOM里面的。DOM树是整个网页的结构框架。然后再在框架上放上一些样式。最终整合成一个框架和样式合并出来的一个结构。我
          们叫做Render Tree。这样的话就可以去渲染了。所谓Render Tree就是我们dom树里面挂了很多css的属性。它也是一个树结构。只
          不过每个节点它挂了一些css的属性。这样的话就可以渲染了。
        4.然后浏览器根据Render Tree渲染页面
          因为有了结构了也有了css属性了，就可以渲染页面了。
        5.如果入到<script>则暂停渲染，优先加载并执行js代码，完成之后再继续。
          我们之前讲js异步的时候说过，js的进程和渲染进程是共用一个线程的。为什么要共用一个线程呢，因为js有可能会改变dom的结构，
          还有可能会改变Render Tree这个结构。这也是为何建议把js放到body最后的原因所在。
        6.直至把Render Tree渲染完成。这个页面就渲染完成了。
        这就是整个的一个渲染过程。
      4.页面加载和渲染示例
        可以通过示例来分析一下加载和渲染过程
        1.示例1
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8">
              <title>Document</title>
            </head>
            <body>
              <p>test</p>
            </body>
          </html>
          我们根据加载过程把页面加载下来，然后根据html生成一个dom树，根据cssOM，然后最后生成render Tree去渲染。
        2.示例2
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8">
              <title>Document</title>
              <link rel="stylesheet" type="text/css" href="test.css">
            </head>
            <body>
              <p>test</p>
            </body>
          </html>
          我们页面加载完之后，我们要先把css代码加载完，因为它是在head里面，加载完之后我们css代码的这个cssOM就已经给它做出来了。
          出来之后我们再根据html这个结构渲染出dom树，然后两个整合成render tree，然后去把这个页面渲染出来。这个是有css的情况。
          思考题：
            1.为何建议把css放在head中
              根据浏览器的渲染过程。如果css放到dom结构下面，那么就会先生成dom树，因为它没有css的信息，所以它就照着默认标签的样式渲染
              到浏览器上，继续向下渲染发现有一个css，把这个css文件加载完成之后，生成一个CSSOM，然后又和当前的这个dom树做一个合并生成
              RenderTree，然后可能会再重新渲染。可能就会是一个重复的过程。有时候这个动作比较慢的话就可能会出现肉眼可见的样式变化的过
              程，感官上不好。所以即使网速很好，电脑也很好的时候，也不建议把css放到下面来写。因为这是一个不好的书写方式。我们之所以把
              css放到上面来写是建议想把css的规则把css的代码在dom树生成完成之前就给它加载完，就把这个css的规则放到这，然后当dom树生
              成完之后直接和所有的css整合生成一个渲染树，生成一个Render Tree，然后一步渲染完成。这样的话就不要再出现重复了。这样的话
              是我们期望的一个过程。所以说我们要把css放到head中。
        3.示例3
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8">
              <title>Document</title>
            </head>
            <body>
              <div id="container">default</div>
              <script src="index.js"></script>
              <p>test</p>
            </body>
          </html>
          根据我们的渲染过程，我们可以这样分析。拿到html之后，我们去分析html，然后生成一个dom树。然后根据dom树进行渲染。
          思考题：
            1.为何建议把js放到body最后
              如果没有放在最后，可能会出现本来渲染了一部分，然后突然卡住了去加载执行js了，然后有进行渲染后面的dom内容。所以说它就会导致
              一个页面渲染的过程比较长。本来我们期望的是这个页面一共的渲染时间是1s钟。我们期望在0.3s或0.5s钟之内让用户看到页面的所有内
              容。然后剩下的0.5s之内我们执行js代码，然后把这个页面渲染完成。这是我们期望的。我们不期望说这个页面渲染一共是1s钟。然后直
              到1s钟的最后一刻我们才让用户看到所有的内容。所以说我们要把js放到最后。就是说我们要把先能出来的东西全部都渲染出来，把html
              渲染完之后，然后在把script继续执行，到时候你该干什么干什么，反正我dom已经渲染完了，你愿意改的话你就改吧。这样是我们比较
              期望的一个结果。
        4.示例4
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8">
              <title>Document</title>
            </head>
            <body>
              <p>test</p>
              <img src="test.png" />
              <p>test</p>
            </body>
          </html>
          生成dom树之后，依次渲染，发现img，我们就要去加载test.png这个文件。但这个过程不会停止渲染，它不像是一个js文件，它不
          像js代码，因为图片这个东西加载完之后直接插进去就行了，它不会改变其他的结果。只不过这个时候这个图片还没过来，所以说我们
          这个位置先空着，然后继续向下渲染，这个时候不会去阻塞这个渲染过程。等什么时候图片加载完，然后我们就把图片塞到这来。有可
          能图片会比较大，或者比较高，可能会把内容向下撑一下，这个就需要重排一下就可以了。
          这就是带img这个情况的一个用处。
            window.addEventListener('load', function () {
              // 网页全部资源加载完才会执行，包括图片，视频等
            })
            window.addEventListener('DOMContentLoaded', function () {
              // dom渲染完即可执行，此时图片，视频可能还没有加载完
            })
            所以说，如果是有图片的话，用DOMContentLoaded这个事件去监听网页加载完成，这样的话就会更快一些。它就不用等到图片加
            载完，因为我们基本上所有的操作都是对dom的操作，图片是不是加载完对我们的一些js的代码中操作的时候可能不是那么的重要。
            所以我们在一般的情况下，像jquery这种代码它都是要监听DOMContentLoaded这个事件来去做一些处理的。只要是监听到这个
            事件，它就认为这个网页它已经加载完了。它不会等到图片加载完再执行，所以说用这个比用load这个事件更加靠谱。
    2.性能优化
      1.性能优化介绍
        1.性能优化是一个综合性的问题，没有标准答案，但要求尽量全面。面试的是想听到尽量全面的方案或比较全面的一个思考。所以我们本着这
          个思路去分析一下应该怎么去回答这个问题。
        2.某些细节问题可能会单独提问：比如手写防抖、手写节流
          防抖和节流它算是一个体验性的优化方案，也算这个性能优化方案之内。
      2.性能优化原则
        1.多使用内存、缓存或其他方法
        2. 减少cpu计算量，减少网络加载耗时
        所以大家要明白，我们到底是多用什么少用什么，所谓性能优化就是让这个网页加载的更快，渲染的更快，运行的更流畅一些。你想要更快
        更流畅，你就需要多使用内存，缓存这种方法。这种方法适用于所有编程的性能优化。都是用空间换时间。算法中的一个时间复杂度的减小
        也是通过空间换时间。这个没有什么神奇的东西，就是通过空间换时间。
      3.从何入手
        性能优化就是让它更快，怎么让它更快呢。
        1.让加载更快
          就是下载的东西更快，别人下载一个页面或所有的文件需要2s钟，那我的代码让人下载完只需要1s钟，这样不就更快了吗。
        2.让渲染更快
          就是我的这个代码逻辑结构更加合理，没有什么重复的多余的渲染操作，没有无用功，没有等待。让渲染更快，至少是在同一时间内，我
          让用户看得更快。
        所以说我们从让加载更快，让渲染更快这个角度来考虑，我们就能直到这个性能优化从何入手。
      4.让加载更快
        1.减少资源体积：压缩代码
          js代码，css代码，包括图片我们也可以压缩。包括服务器端也会进行一些其他的压缩方式，比如说服务器端会进行gzip压缩，这个和
          我们前端没有太多的关系，这是服务器端做的压缩，然后浏览器进行解压。gzip压缩一般能把代码压缩到体积三分之一左右。
        2.减少访问次数：合并代码，ssr服务端渲染，缓存
          1.合并代码
            我们的http请求每次访问都是很耗时的，同样的代码，比如说一共三个代码，每个代码3kb，一共是9kb。如果是你分三次访问，每次
            访问3kb和你这一次访问9kb这个时间是不一样的。我们就选后者，访问次数比较少的那个。js代码，css代码，图片都是可以合并的。
          2.ssr服务端渲染
            服务端渲染为什么能减少访问次数呢，服务端渲染就是说我们服务端把页面以及页面要显示的内容一块给前端显示出来，这样前端拿到
            内容之后就立马去把这个内容展示出来。如果不是服务端渲染的话，是我们把页面拿到之后，我们再通过ajax再去加载资源，加载资源
            之后再去渲染到页面上去。
          3.缓存
            比如说我们这个页面要访问10个资源，如果没有缓存的话，那就是访问10个资源，也就是10次。如果是其中六个都命中的缓存，那我们
            就可以只访问4个资源，那次数就变少了。
        3.使用更快的网络：cdn
          cdn是根据区域来去做服务器的一个处理。也就是说你如果用cdn的一个网络的话，你从北京访问的ip和你从上海访问的ip是不一样的。
          因为它会根据区域来去联系运营商的服务器然后让下载更快一些。
      5.让渲染更快
        1.css放在head里面，js放到body最下面
        2.今早开始执行js，用DOMContentLoaded里面去触发
        3.懒加载（图片懒加载，上滑加载更多）
          上滑的时候加载更多，这个图片呢它是懒加载的。我们看这种新闻的app，图片都是懒加载的。图片没必要说直接加载，我们可以什么时
          候用什么时候加载。这样渲染就会更快一些。
        4.对dom查询进行缓存
        5.频繁dom操作，合并到一起插入dom结构
        6.节流throttle防抖debounce
          你要知道节流防抖它是怎么回事，节流防抖不能说是让渲染更快，而是让渲染更加流畅，它是一个体验性的优化。当然归到让渲染更快，
          渲染优化里面也没问题。
      6.总之，我们分析了一个性能优化的一个原则，以及我们思考的一些思路，通过这个思路得出来的那么几个方法。
      7.示例
        1.资源合并
          <script src="a.js"></script>
          <script src="b.js"></script>
          <script src="c.js"></script>
          合并后
          <script src="abc.js"></script>
        2.缓存
          bundle.[contenthash].js
          bundle.58jffjq0482nf.js
          1.静态资源加hash后缀，根据文件内容计算hash
          2.文件内容不变，则hash不变，则url不变
          3.url和文件不变，则会自动触发http缓存机制，返回304
            如果我们每次访问一个js的资源，它的url如果不变，并且服务器判断它的文件也不变的话，如果是第一次访问成功之后，第二次再
            去访问，浏览器已经访问过一次了，服务器就会告诉浏览器说这个是304了，304就是说我们的资源根本没有变，所以说你就回去把，
            我就不用给你了。这样直接返回一个304的状态码，那这个内容就非常少了，可能用几个字节就能把这个事情搞定了。就告诉浏览器
            说这个没变，你就用之前的就行了。立马就可以启动这个缓存机制，然后就不用下载了，就可以用之前的缓存的这个文件了。所以这
            个机制不是我们前端去写js实现的，而它是http的缓存机制，浏览器和服务器都会遵从这个机制去做缓存。所以说我们只需要符合
            这个机制去让它尽可能的去命中这个缓存就可以了。
        3.cdn
        4.ssr
          服务端渲染：将网页和数据一起加载，一起渲染
          非ssr：先加载网页，网页的ajax再加载数据，返回后再渲染数据
          所以ssr确实是为了性能考虑来做的。如果是有ssr的话这个性能会提高很多。特别是再网络速度比较慢的情况下会提高很多。所以说
          ssr也是一种减少网络请求的一种思路。
          早先的jsp asp php都属于ssr。ssr是一个比较宽泛的概念。server side render就是服务端渲染。现在的vue react做ssr也
          是借助node的一些能力来做。从服务端渲染这个思路上和jsp asp php也没有什么本质上的区别。只不过它用的更加高级的前端框架
          而已。
        5.懒加载
          比如说一个图片，有时候我们需要图片加载，有时候不需要，比如一个很长的新闻列表，每一个列表项中都有一个图片，这个时候其实
          我们不希望图片一下子全部加载完，我们希望第一屏看到的图片就是在手机屏幕上的图片，我们加载完，比如前五个或前八个让它加载
          完，然后随着用户往上去滑动页面的时候，这个图片慢慢的一个一个加载出来，并不是说我页面下载完之后所有图片立马加载出来。所
          以我们利用懒加载，可以把这个图片默认赋值成一个src="preview.png"就是一个预览的一个图片，这个图片的体积非常小，很容易
          加载，然后我们把真正的图片地址放到data-realsrc="abc.png"里面，放在这里面的话这个图片不会去加载这个地址。当浏览器判
          断到用户往上滑，当这个图片露出这个屏幕的时候我们再去把这个图片地址的data-realsrc赋值给这个图片的src，去加载真正的图
          片地址。这就是懒加载。这个是很常见的，也是性能优化的一个很好的一钟方式。
          <img id="img1" src="preview.png" data-realsrc="abc.png" />
          <script type="text/javascript">
            var img1 = document.getElementById('img1')
            img1.src = img1.getAttribute('data-realsrc')
          </script>
        6.缓存dom查询
        7.多个dom操作合并到一起插入到dom结构
        8.尽早开始js执行
        9.防抖debounce
          1.监听一个输入框，文字变化后触发change事件
          2.直接监听keyup事件，则会频繁触发change事件
          3.防抖：用户在输入结束或暂停的时候，才会触发change事件
          // 防抖简易demo
          const input1 = document.getElementById('input1')
          let timer = null
          input1.addEventListener('keyup', function () {
            if (timer) {
              clearTimeout(timer)
            }
            timer = setTimeout(() => {
              // 模拟触发change事件
              console.log(input1.value)
              // 清空定时器
              timer = null
            }, 500)
          })
          // debounce是对函数的封装，所以它最终返回应该是一个函数
          // 函数的封装就是将大部分逻辑封装起来，使使用的时候更加简单，只写业务逻辑就行了。jq zepto等库和插件都是这个原理。
          function debounce (fn, delay = 500) {
            // 这个timer是在闭包中的，timer这个数据就被隐藏了，不会被外面轻易拿到
            let timer = null

            return function () {
              if (timer) {
                clearTimeout(timer)
              }
              timer = setTimeout(() => {
                // this是为了获取添加事件的dom对象，arguments是为了将事件函数接收到的参数透传给fn
                fn.apply(this, arguments)
                timer = null
              }, delay)
            }
          }
          // 使用
          input1.addEventListener('keyup', debounce(function () {
            console.log(input1.value)
          }, 300))
        10.节流throttle  
          防抖的场景是频繁输入和频繁操作的时候最后的时候才去触发。节流是你在频繁输入频繁操作的时候它会保持一个频率连续触发。
          1.比如拖拽一个元素时，要随时拿到这个元素被拖拽的位置
          2.如果直接用drag事件，则会频繁触发，很容易导致卡顿
          3.这个时候我们需要节流：无论拖拽的速度多快，都会每隔100ms触发一次
          // 防抖简易demo
          const div1 = document.getElementById('div1')
          let timer = null
          div1.addEventListener('drag', function (e) {
            if (timer) {
              return 
            }
            timer = setTimeout(() => {
              console.log(e.offsetX, e.offsetY)
              timer = null
            }, 100)
          })
          // 节流函数封装
          function throttle (fn, delay = 100) {
            let timer = null
            return function () {
              if (timer) {
                return
              }
              timer = setTimeout(() => {
                fn.apply(this, arguments)
                timer = null
              }, delay)
            }
          }
          // 使用
          input1.addEventListener('drag', throttle(function (e) {
            console.log(e.offsetX, e.offsetY)
          }, 200))
    3.安全
      1.常见的web前端攻击方式有哪些，怎么预防
        1.XSS跨站请求攻击
          1.一个博客网站，我发表一篇博客，其中嵌入<script>脚本
          2.脚本内容：获取cookie，发送到我的服务器（服务器配合跨域）
          3.发布这篇博客，有人查看它，我轻松收割访问者的cookie
          预防：
          1.替换特殊字符，如把<变为&lt;，把>变为&gt;
          2.这样的话<script>就变为&lt;script&gt;，直接显示，而不会作为脚本被执行。只有html里面有script才会作为脚本被执行
          3.前端要替换，后端也要替换，都做总不会有错
          4.有xss npm工具
        2.XSRF跨站请求伪造
          1.你正在购物，看中了某个商品，商品id是100
          2.付费接口是xxx.com/pay?id=100，但没有任何验证
          3.我是一个攻击者，我看中了一个商品，id是200
          4.我向你发送一个电子邮件，邮件标题很吸引人
          5.但邮件正文隐藏着<img src="xxx.com/pay?id=200" />
          6.你一查看邮件，就购买了id是200的商品
          因为你现在正在购物，肯定登录了这个网站了，你就会有用户信息了，图片的地址去访问的时候，你的用户信息已经带过去了。
          预防：
          1.使用post接口
            使用post接口，你用img攻击是攻击不通的，因为img的src只支持get请求
          2.增加验证，例如密码，短信验证码，指纹等

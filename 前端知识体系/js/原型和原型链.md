### 原型

* 每个 class 都有显示原型 prototype

* 每个实例都有隐式原型 \_\_proto\_\_

* 实例的隐式原型 \_\_proto\_\_ 指向对应 class 的显示原型 prototype

* prototype 中有一个 constructor 属性，用来引用它的构造函数。这是一种循环引用 

  ```
  Person.prototype.constructor === Person
  ```

### 原型链

我们把这个由 \_\_proto\_\_ 串起来的直到 Object.prototype.\_\_proto\_\_ 为null的链叫做原型链。

对象在获取属性或方法的时候，先在自身的属性和方法中寻找，如果找不到则顺着隐式原型 \_\_proto\_\_ 指向的原型链中一直向上去查找。

原型链关系：

```js
var zjh = new Person()
zjh.__proto__ === Person.prototype 
Person.prototype.__proto__ === Object.prototype 
Object.prototype.__proto__ === null 
        
Object.__proto__ === Function.prototype 
Function.__proto__ === Function.prototype 
Function.prototype.__proto__ === Object.prototype 
Object.prototype.__proto__ === null // 原型链顶端
```

### instanceof

instanceof 是判断这个对象属于哪个class，或者哪个构造函数。也就是说只要这个对象是这个 class 构建出来的，那instanceof 就是 true。因为父类也是参与了构建实例的一部分，所以 instanceof 父类得到的也是 true。Object 是所有类的父类，因为所有对象都是继承自 Object，原型链的末端就是 Object。instanceof 也是顺着原型链往上找的。

```js
[] instanceof Array // true
[] instanceof Object // true
{} instanceof Object // true
```

instanceof 前面这个实例顺着隐式原型往上往上找，然后能不能找到第二个操作数，就是 Student 的这个显示原型，以及People 的显示原型，以及 Object 的显示原型。也就是说 xialuo 顺着隐式原型一层一层往上爬能不能对应到class的显示原型，如果能对应到，那 instanceof 成立，如果对应不到，那 instanceof 就返回 false。要深入理解 instanceof 的原理我们还是要借助原型和原型链。

```js
xialuo instanceof Student // true
xialuo instanceof People // true
xialuo instanceof Object // true
```

### 继承

继承就是从抽象到具象的一个关系，从高级到低级的一个关系

#### 对象冒充继承

修改函数中的 this 值，就达到了用继承函数中的属性和方法。

this 值是通过函数调用的时候确定的，所以就用继承的对象来调用函数。这个对象就变成了要继承的函数的 this。也就继承了函数的属性和方法。

##### 对象冒充内部实现原理

因为构造函数也是一个函数，所以可以使函数 ClassA 成为函数 ClassB 的方法，然后调用它。ClassB 就会收到 ClassA 
构造函数中定义的属性和方法。

```js
function ClassA(sColor) {
  this.color = sColor
  this.sayColor = function () {
    alert(this.color)
  }
}
function ClassB(sColor) {
  this.newMethod = ClassA
  this.newMethod(sColor)
  delete this.newMethod 
  // 以上三步就是call和apply内部实现的核心步骤
}
```

##### call, apply, bind

call 和 apply 关注的就是 this 和传参两件事。

call 和 apply 可以用来重新定义函数的this指向。

call 和 apply 可以实现多重继承，就是一个子类能够继承多个父类。F1 可以同时从 F2, F3 ...等继承。

###### call apply bind 方法的内部实现

https://www.cnblogs.com/echolun/p/12144344.html
https://www.cnblogs.com/guaidianqiao/p/7762205.html
https://www.cnblogs.com/echolun/p/12178655.html

call 和 apply 改变了函数的this,并且执行了该函数，而 bind 是改变了函数的 this，但 bind 并不会立即执行函数，而是返回一个绑定了 this 的新函数。

call

```js
// es5
Function.prototype.call_ = function (obj) {
  //判断是否为null或者undefined,同时考虑传递参数不是对象情况
  obj = obj ? Object(obj) : window
  var args = []
  // 注意i从1开始
  for (var i = 1, len = arguments.length; i < len; i++) {
  	args.push("arguments[" + i + "]")
  };
  obj.fn = this // 此时this就是函数fn
  var result = eval("obj.fn(" + args + ")") // 执行fn
  delete obj.fn // 删除fn
  return result
}

// es6
Function.prototype.call_ = function (obj) {
  obj = obj ? Object(obj) : window
  obj.fn = this
  // 利用拓展运算符直接将arguments转为数组
  let args = [...arguments].slice(1)
  let result = obj.fn(...args)
  delete obj.fn
  return result
}
```

apply   

```js
// es5
Function.prototype.apply_ = function (obj, arr) {
  obj = obj ? Object(obj) : window
  obj.fn = this
  var result
  if (!arr) {
    result = obj.fn()
  } else {
    var args = []
    // 注意这里的i从0开始
    for (var i = 0, len = arr.length; i < len; i++) {
      args.push("arr[" + i + "]")
    }
    result = eval("obj.fn(" + args + ")") // 执行fn
  }
  delete obj.fn //删除fn
  return result
}

// es6
Function.prototype.apply_ = function (obj, arr) {
  obj = obj ? Object(obj) : window
  obj.fn = this
  let result
  if (!arr) {
    result = obj.fn()
  } else {
    result = obj.fn(...arr)
  }
  delete obj.fn
  return result
}
```

bind

```js
// es5 方法1
Function.prototype.bind1 = function () {
  // 将函数参数解析为数组
  const args = Array.prototype.slice.call(arguments)
  // 获取 this (取出数组第一项，数组剩余的就是传递的参数)
  const t = args.shift()
  const self = this // 当前函数
  // 返回一个函数
  return function () {
    // 执行原函数，并返回结果
    return self.apply(t, args)
  }
}
// 使用
function fn1 (a, b, c) {
  console.log('this', this)
  console.log(a, b, c)
  return 'this is fn1'
}
const fn2 = fn1.bind({x: 100}, 10, 20, 30)
const res = fn2()
console.log(res)

// es5 方法2
Function.prototype.bind_ = function (obj) {
  if (typeof this !== "function") {
    throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
  };
  var args = Array.prototype.slice.call(arguments, 1);
  var fn = this;
  // 创建中介函数
  var fn_ = function () {};
  var bound = function () {
    var params = Array.prototype.slice.call(arguments);
    // 通过constructor判断调用方式，为true this指向实例，否则为obj
    fn.apply(this.constructor === fn ? this : obj, args.concat(params));
    console.log(this);
  };
  fn_.prototype = fn.prototype;
  bound.prototype = new fn_();
  return bound;
}

// es6
Function.prototype.bind = function(thisArg) {
  if(typeof this !== 'function'){
    throw new TypeError(this + 'must be a function')
  }
  // 存储函数本身
  const _this  = this
  // 去除thisArg的其他参数 转成数组
  const args = [...arguments].slice(1)
  // 返回一个函数
  const bound = function() {
    // 可能返回了一个构造函数，我们可以 new F()，所以需要判断
    if (this instanceof bound) {
      return new _this(...args, ...arguments)
    }
    // apply修改this指向，把两个函数的参数合并传给thisArg函数，并执行thisArg函数，返回执行结果
    return _this.apply(thisArg, args.concat(...arguments))
  }
  return bound
}
```

call apply应用场景

1.检验数据类型：

```js
function type(obj) {
  var regexp = /\s(\w+)\]/
  var result =  regexp.exec(Object.prototype.toString.call(obj))[1]
  return result
}
console.log(type([123]))      // Array
console.log(type('123'))      // String
console.log(type(123))        // Number
console.log(type(null))       // Null
console.log(type(undefined))  // Undefined
```

2.数组取最大/小值：

```js
var arr = [11, 1, 0, 2, 3, 5];
// 取最大
var max1 = Math.max.call(null, ...arr)
var max2 = Math.max.apply(null, arr)
// 取最小
var min1 = Math.min.call(null, ...arr)
var min2 = Math.min.apply(null, arr)
```

3.伪数组转数组：

```js
var fn = function () {
  var arr = Array.prototype.slice.call(arguments)
  console.log(arr) // [1, 2, 3, 4]
};
fn(1, 2, 3, 4);
```

#### 原型链继承

对象继承类

```js
o.__proto__ = F.prototype  
```

类继承类

```js
F1.prototype.__proto__ = F2.prototype
```

class和继承

class 它是面向对象的一个语法实现。它能更加具象的让我们思考编程的问题。class 它本质上类似于一个模版，然后我们可以通过这个模版去构建一些东西。构建的时候，我们可以去复制上一些属性和方法。

当我们有很多个 class，这个 class 中有一些比较通用的属性的时候，我们就可以把它抽离出来。继承我们通过 extends 这个关键字来去做的。然后里面是通过 super 来执行父类的构造函数，也就是父类的构建过程，然后扩展和重写它的一些方法。

```js
// es6 类继承
class People {}
class Student extends People {}
// 它俩是一个继承关系，Student是继承于People的，所以Student的原型的隐式原型正好指向People的显示原型。
console.log(Student.prototype.__proto__ === People.prototype) // true
console.log(People.prototype.__proto__ === Object.prototype) // true
console.log(Object.prototype.__proto__ === null) // true 原型链顶端
```

#### 混合方式继承

对象冒充可以传参数和继承构造函数内部属性，但是不能继承到原型，原型链可以继承原型，但是不能传参数也不能继承构造函数内部，所以要使用混合模式。

```js
// ClassA
function ClassA(sColor) {
  this.color = sColor
}
ClassA.prototype.sayColor = function () {
  alert(this.color)
}
// ClassB继承ClassA
function ClassB(sColor, sName) {
  ClassA.call(this, sColor)
  this.name = sName
}
ClassB.prototype.__proto__ = ClassA.prototype

//new和es6的extends实现的继承就是上面的这两个方式的结合。
```

#### new继承

构造函数创建实例的过程本身就是一种继承，new的内部其实是做了继承里面的合体工作

```js
ClassB.prototype = new ClassA()
```

#### new操作符的作用

new F(arguments)的时候js内部就会调用下面这个 New 函数

```js
function New (F,arguments) {
  var o = {}
  // 以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象；
  o.__proto__ = F.prototype	 
  F.apply(o, arguments)		   // 将 this 和调用参数传给构造器，执行；      
  return o                   // 如果构造器返回的是对象，则返回，否则返回第一步创建的对象。
}   
```

### 原型应用

#### 手写一个简易的 jquery，考虑插件和扩展性

```js
// jquery是做dom查询的，所以首先constructor里面要传入一个selector
class jQuery {
  constructor (selector) {
    const result = document.querySelectorAll(selector)
    const length = result.length
    for (let i = 0; i < length; i++) {
  		this[i] = result[i]
    }
    this.length = length
    this.selector = selector
  }
  get (index) {
    return this[index]
  }
  each (fn) {
    for (let i = 0; i < this.length; i++) {
    const elem = this[i]
    fn(elem)
  	}
	}
  on (type, fn) {
    return this.each(elem => {
      elem.addEventListener(type, fn, false)
    })
  }
// 可以扩展很多dom 操作 api
}
// 使用
const $p = new jQuery('p')
$p.get(1)
$p.each(elem => console.log(elem.nodeName))
$p.on('click', elem => console.log('clicked'))
```

#### 考虑插件和扩展性

jquery 结构上面使用 class 和原型，扩展性就是要用到继承了。有了class之后我们可以考虑扩展性。考虑扩展性或插件机制，我们有两种方式。

1.插件的形式

```js
// 我们可以直接往 jquery 的原型里面添加函数，这就是所谓的jquery插件
jQuery.prototype.dialog = function (info) {
  alert(info)
}
$p.dialog('abc')就有了
```

2.复写机制(造轮子)

也就是说 jquery 摆在这了，可以做为一个基础。可以基于 jquery 再做一个更加完美的东西，然后给大家使用。插件机制呢，是我做一个插件，大家用的还是jquery。造轮子就是基于 jquery 去造，但是造出来就是我的，大家都用我的，不要用jquery 了。这个时候我们就可以用继承了。

```js
class myJQuery extends jQuery {
  constructor (selector) {
    super(selector) // super执行父类的构造函数，直接用super就可以把jQuery这个父类
    // 的复杂性全部包含，不用再自己把jQuery构造函数里面复杂的逻辑写一遍。
  }
  // 扩展自己的方法，把它造成一个新轮子
  addClass (classname) {
    
  }
  style (data) {

  }
}
// 写完之后，这个东西就可以给别人用了，别人用的话呢，既可以用jquery的东西，还可以用你自己的东西。这样的话这个东西就变得强大了。但是这种情况在现实中是不存在的，因为jquery已经非常非常强大了。没必要自己再重新去写。
```

#### jquery 和 zepto

jquery和zepto的简单使用

```js
var $p = $('p')
$p.css('font-size', '40px')
alert($p.html())
var $div1 = $('#div1')
$div1.css('color', 'blue')
alert($div1.html())
//$p和$div1都有css和html等方法。当多个实例都可以共用一套方法的时候，就说明这些方法都是来自于一个构造函数的原型中的。
```

zepto 是如何使用原型的

```js
// 定义一个自执行的函数，避免全局变量的污染。
(function (window) {
  // 空对象
  var zepto = {}
  zepto.init = function (selector) {
    var slice = Array.prototype.slice
    var dom = slice.call(document.querySelectorAll(selector))
    return zepto.Z(dom, selector)
  }
  // 即使用zepto时候的$
  var $ = function (selector) {
    return zepto.init(selector)
  }
  window.$ = $ // 把这个$函数给它开放到window这个全局的变量中，就可以$('p')这样用了
  // 这就是构造函数
  function Z (dom, selector) {
    // 这些初始化操作就是给自己本身复制一些属性
    var i, len = dom ? dom.length : 0
    for (i = 0; i < len; i++) this[i] = dom[i] // 把dom的每个元素复制成它本身自己的属性
    this.length = len                          // 把dom的length复制成自己的length
    this.selector = selector || ''             // 把selector给它传到自己的selector上
  }
  zepto.Z = function (dom, selector) {
    // 注意，出现了new关键字
    return new Z(dom, selector)
  }
  // 如果选择这么用的话$p = $('p')，它返回的就是Z这个构造函数new出来的一个实例。
  // css html这些方法在什么地方呢，Z是构造函数，构造函数得有原型啊，原型是$.fn，$.fn赋值成了一个对象，这个对象中
  // 就有css和html这些方法。
  $.fn = {
    constructor: zepto.Z,
    css: function (key, value) {

    },
    html: function (value) {

    }
  }
	zepto.Z.prototype = Z.prototype = $.fn
})(window)
```

jquery 是如何使用原型的

```js
(function (window) {
  // jquery里面这个$，和jquery源码中的这个jQuery函数是一回事是一个。
  var jQuery = function (selector) {
    // 注意new关键字，第一步就找到了构造函数
    return new jQuery.fn.init(selector)
  }
  window.$ = jQuery
  jQuery.fn = {}
  // 定义构造函数
  var init = jQuery.fn.init = function (selector) {
    // 构造函数体的内容跟zepto的逻辑基本一样
    var slice = Array.prototype.slice
    var dom = slice.call(document.querySelectorAll(selector))
    var i, len = dom ? dom.length : 0
    for (i = 0; i < len; i++) this[i] = dom[i] 
    this.length = len                         
    this.selector = selector || ''             
  }
  // 初始化jQuery.fn
  jQuery.fn = jQuery.prototype = {
    constructor: jQuery,
    css: function (key, value) {

    },
    html (value) {

    }
  }
  // 定义原型
  init.prototype = jQuery.fn
})(window)
```

#### 原型如何体现它的扩展性

插件机制

1.为什么要把原型方法对象放到$.fn上再赋值给原型，而不是直接把这个对象赋值给原型。因为要扩展插件，做一个简单的插件的例子。

```js
$.fn.getNodeName = function () {
  return this[0].nodeName
}
```

2.为什么不直接给构造函数的原型赋值，而是通过$.fn给原型赋值，进行转化一步呢。这样的好处是什么呢。

* 只有$会暴露在window全局变量

  因为我们不能变量污染啊，你jquery和zepto内部封装定义的构造函数叫init也好叫Z也好，这些都是你jquery和zepto执行的这个自定义函数里面的。不会暴露给外边的全局变量。我们只有$会暴露在外面的全局变量。所以说我们必须通过$.fn去扩展我们不能通过构造函数的原型直接去扩展。因为构造函数我们外面拿不到。我们一个工具一个库基本上要暴露给全局一个变量就好了，不要暴露好多变量，因为很容易造成全局变量的污染。只暴露一个变量就好了，其他东西全部在这一个变量下进行实现。            

* 将插件扩展统一到$.fn.xxx这个接口中，是方便使用的。

  这样的话我们扩展插件特别容易。就是直接$.fn.xxx = xxx就完啦，文档中也没有必要写我的构造函数是什么样子的，我要在什么样的构造函数下扩展，zepto的构造函数和jquery的构造函数还不一样，你要用的话，两者还得分开，这样的话会增加学习成本，然后使用上也不方便，我们用一个统一的接口，特别简单的接口把这个事情做完。这是封装sdk封装软件封装工具的一个符合设计模式的一个方法。
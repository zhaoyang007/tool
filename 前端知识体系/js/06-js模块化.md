### 模块化

模块就是独立的，实现某种特定功能的文件。想要什么功能，就加载什么模块。

### 前端发展模块化背景

在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀。这时候JavaScript作为嵌入式的脚本语言的定位动摇了，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，JavaScript极其简单的代码组织规范不足以驾驭如此庞大规模的代码。既然JavaScript不能handle如此大规模的代码，我们可以借鉴一下其它语言是怎么处理大规模程序设计的，在Java中有一个重要的概念——package，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部如果使用呢？直接import对应的package即可，import java.util.ArrayList。遗憾的是JavaScript在设计时定位原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，各行其是就都乱套了，规范形成的过程是痛苦的，前端的先驱在刀耕火种、茹毛饮血的阶段开始，发展到现在初具规模，简单了解一下这段不凡的历程。

### 前端发展模块化历程及js模块化原理

以下做法就是我们模块化的基础

#### 函数封装

我们在讲函数的时候提到，函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里面编写几个相关函数就是最开始的模块了。

```js
function fn1 () {
  statement
}
function fn2 () {
  statement
}
```

这样在需要的时候加载函数所在文件，调用函数就可以了。

这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。

#### 对象

为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中。

```js
var myModule = {
  var1: 1,
  var2: 2,
  fn1: function () {

  },
  fn2: function () {

  }
}
```

这样我们在希望调用模块的时候引用对应文件，然后

myModule.fn2()

这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系

看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员

myModel.var1 = 100;

这样就会产生意外的安全问题

#### 立即执行函数

可以通过立即执行函数，来达到隐藏细节的目的

```js
var myModule = (function () {
  var var1 = 1;
  var var2 = 2;
  function fn1 () {

  }
  function fn2 () {

  }
  return {
    fn1: fn1,
    fn2: fn2
  }
})()
```

这样在模块外部无法修改我们没有暴露出来的变量、函数

#### 放大模式(扩展模块本身)

如果一个模块很大，必须分成几个部分

```js
var module1 = (function (mod){
  mod.m3 = function () {
    //...
  };
  return mod;
})(module1 || {});
```

上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。

#### 输入全局变量(依赖其他模块)

独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。

为了在模块内部调用全局变量，必须显式地将其他变量输入模块。

```js
var module1 = (function ($, YAHOO) {
  //...
})(jQuery, YAHOO);
```

上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。

这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。

### Javascript模块规范：CommonJS，AMD，CMD

require.js实现AMD规范

sea.js实现CMD规范

定义模块(利用的就是模块化的原理，使用自执行函数)，导出模块；引入模块，使用模块

### 模块化博客

Javascript模块化编程（一）：模块的写法    

http://www.ruanyifeng.com/blog/2012/10/javascript_module.html  

Javascript模块化编程（二）：AMD规范

http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html

Javascript模块化编程（三）：require.js的用法

http://www.ruanyifeng.com/blog/2012/11/require_js.htmls

### 关于js众多模块化标准

* 没有模块化的时代
* AMD成为标准，require.js
* 前端打包工具，使得nodejs的commonjs模块化可以被使用了
* es6出现，想统一现在所有模块化的标准

### 模块打包工具

rollup功能单一，webpack功能强大

rollup输出之后的内容小。对于源代码很多，很复杂，多人维护的代码库非常重要。因为它能优化冗余内容，对于小的程序来说可能无所谓，但对于一些庞大的开发环境中，如果能优化一点点，哪怕是百分之四百分之五概率的冗余的代码，最后输出的内容就会有很大的影响。rollup的功能比较单一，它就是能打包模块化，没有模块化，rollup就没用了。但是js不可能没有模块化。现在的开发环境，模块化是一个非常重要的存在。所以rollup功能单一，但是做到了极致。webpack功能比较强大，但是它的学习成本非常的高。这一点可以参考《设计原则》和《Linux/Unix设计思想》这两本书。它们都提到一个单一值的原则，就是所有的东西呢你都给我做成一个单一功能就行了，没必要说更好更快更强。在软件设计中这是一个不好的事情。软件设计中比较喜欢一个东西只做一件事情，做好了就行了。越简单越单一越好，不能说一个东西把所有东西都干完。让其他的工具没有事干。这样是不好的。

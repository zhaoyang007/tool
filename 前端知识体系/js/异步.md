### 单线程和异步

#### 单线程

只有一个线程，同一时间只能做一件事情，下面的循环过程中，后面的 js 执行和 dom 渲染暂时卡顿，浏览器是处于卡顿状态。

```js
var i, sum = 0
for (i = 0; i < 1000000000; i++) {
  sum += i
}
console.log(sum)
// alert如果不处理完，js执行和dom渲染暂时卡顿
consolee.log(1)
alert('hello')
console.log(2)
```

#### 原因 - 避免dom渲染的冲突

* 浏览器需要渲染 dom
* js 可以修改 dom 结构
* 所以 js 执行的时候，浏览器 dom 渲染就要暂停，因为它们都可以修改 dom 结构，如果它们同时修改了一个 dom 节点那不就冲突了么。
* html5 中的 webworker，能实现多线程，能做到两行 js 代码一块执行。但是 webworker 不能访问 dom。

#### 解决方案 - 异步

由于 js 单线程的机制，我们把需要等待一段时间才能做的事情变成异步，先执行其他的 js 代码，这样就不会阻塞后面代码的执行从而造成页面卡死的状态了。

异步解决方案的问题：异步是 js 单线程的一个唯一解决方案，现在来看也是一个非常合适非常高效的解决方案，但是它还是有一些问题的。

* 没有按照书写的顺序来执行，可读性差
* callback 中不容易模块化

异步是基于 callback 函数形式来调用的，每个异步里面都需要加个回调函数，在合适的时间去执行这个回调函数。



### event-loop 事件循环机制

event loop 是浏览器对异步的实现方式。

事件循环的顺序，决定了 JavaScript 代码的执行顺序。整体的 js 代码这个 macrotask 先执行，同步代码执行完后有 microtask 执行 microtask，没有 microtask 执行下一个 macrotask，如此往复循环至结束。

每一次 call stack 结束后，就是每次宏任务结束后，会触发页面渲染，然后再进行下一次循环就是下一个宏任务。

```js
// 修改DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
  .append($p1)
  .append($p2)
  .append($p3)
// 下面代码会先执行，然后页面渲染才会变化。
console.log('length',  $('#container').children().length )
alert('本次 call stack 结束，尚未触发 DOM 渲染')
```

宏任务：页面渲染后再触发，微任务：页面渲染前会触发。

```js
// 修改DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
  .append($p1)
  .append($p2)
  .append($p3)
// 微任务：DOM 渲染之前执行
Promise.resolve().then(() => {
  const length = $('#container').children().length     
  alert(`micro task ${length}`)
})
// 宏任务：DOM 渲染之后执行
setTimeout(() => {    
  const length = $('#container').children().length
  alert(`macro task ${length}`)
})
```



### JavaScript 异步写法

* 回调函数
* jquery deferred
* Promise
* async/await
* generator
  * 原理比较复杂
  * 不是异步的直接解决方案
  * 主要的原因是我们有更好更简洁的解决方案 async/await
  * koa 也是放弃了 generator 而使用 async/await 来解决异步

### 什么是单线程，和异步有什么关系

#### 单线程 - 只有一个线程，同一时间只能做一件事情

循环过程中，js执行和dom渲染暂时卡顿。比如这个循环执行了1s，这1s钟之内，浏览器是处于卡顿状态，后面的js肯定不会去执行，如果是有dom渲染，页面的渲染，也会暂停，不会执行。

```js
var i, sum = 0
for (i = 0; i < 1000000000; i++) {
  sum += i
}
console.log(sum)
// alert如果不处理完，js执行和dom渲染暂时卡顿
consolee.log(1)
alert('hello')
console.log(2)
```

#### 原因 - 避免dom渲染的冲突

* 浏览器需要渲染dom
* js可以修改dom结构
* 所以js执行的时候，浏览器dom渲染就要暂停，因为它们都可以修改dom结构，如果它们同时修改了一个dom节点那不就冲突了么。
* html5中的webworker，能实现多线程，能做到两行js代码一块执行。但是webworker不能访问dom。

#### 解决方案 - 异步

针对js单线程的机制。我们的解决方案是异步。因为遇到一些需要等待的事情我们不可能等地它做完我们再往下走，这个等待的时间那页面就是卡死的状态，这显然是不合理的。所以我们将这些需要等待的事情让它们成为异步，就是遇到这样的事我们先不管它，先让其他的js代码运行。不要让这个等待影响我们后面的事情。然后等这个异步等待结束后我们再处理这个异步。就是我们先把该执行的执行完了，异步最后再说。这是异步的一个核心逻辑。

#### 异步解决方案的问题

异步是js单线程的一个唯一解决方案，现在来看也是一个非常合适非常高效的解决方案，但是它还是有一些问题的。

* 没有按照书写的顺序来执行，可读性差
* callback 中不容易模块化

#### 5.问题解答

* 单线程就是同一时间只能做一件事情，两段js不能同时执行
* 原因就是为了避免dom渲染的冲突
* 异步是一个无奈的解决方案，因为js只能是单线程。
* 异步是基于callback函数形式来调用的。也就是说每个异步里面都需要加个回调函数。回调函数的意思就是说我们先去执行同步任务，先去执行不是异步的任务。执行完之后，我们再到一个时间再去执行这个回调函数。异步的特点是它不会阻塞后面代码的执行。同步呢，它就会阻塞后面代码的执行，它会在等待的时候卡住。浏览器也不会渲染。js代码也不会执行。这就是同步。

### 什么是event-loop

#### 知识串联

* 单线程 - 同一时间只能做一件事，体现在程序中就是我们的js代码要一行一行执行。不能同一时间执行两行代码。
* 原因 - 避免dom冲突渲染
* 解决方案 - 异步
* 异步的实现方式 - event loop

#### 宏任务 微任务

https://blog.csdn.net/sjn0503/article/details/76087631

每一次 call stack 结束，都会触发 DOM 渲染，然后再进行 event loop

```js
const $p1 = $('<p>一段文字</p>')const $p2 = $('<p>一段文字</p>')const $p3 = $('<p>一段文字</p>')
$('#container')
  .append($p1)
  .append($p2)
  .append($p3)console.log('length',  $('#container').children().length )
alert('本次 call stack 结束，尚未触发 DOM 渲染')
```

宏任务 DOM 渲染后再触发，微任务：DOM 渲染前会触发

```js
// 修改 DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
  .append($p1)
  .append($p2)
  .append($p3)
// 微任务：DOM 渲染之前执行
Promise.resolve().then(() => {
  const length = $('#container').children().length     
  alert(`micro task ${length}`)
})
// 宏任务：DOM 渲染之后执行
setTimeout(() => {    
  const length = $('#container').children().length
  alert(`macro task ${length}`)
})
```

### Promise

Promise是现在js异步的一个比较正统的解决方案。Promise这个东西就是jquery deferred演化过来的。

#### 异常捕获

会被catch捕获到的情况：

* 第一种是在程序执行中的逻辑之外的一些东西的报错，比如语法的报错或一些其他的bug。并不是我们逻辑之内的，并不是我们自己要生成的错误。

* 第二种是我们逻辑之内的，是在我们逻辑之内的自己通过rejec()生成的错误。

catch里面一般做的事情：

* 做异常处理，例如显示一个 message。异常业务逻辑处理。

* 做错误日志统计和上报

#### 多个串联

then参数的函数如果返回了promise实例，那then函数返回就是这个promise实例；如果返回的不是promise实例，那then函数会返回一个全新的promise实例并resolve这个返回的数据；如果什么都没返回，那then函数也是会返回一个全新的promise实例并resolve undefined。

#### Promise.all和Promise.race

#### 状态变化

* 三种状态：pending fulfilled rejected
* 初始状态就是pending
* 状态变化不可逆 pending可以变为fulfilled，或者pending变为rejected

#### then

* then()可以接收两个函数作为参数，成功之后的回调和失败之后的回调
* then()返回的必须是一个Promise实例

### async/await

async/await这种写法跟Promise其实完全不冲突，它是用了Promise的一些特性，然后又做了一些改进，所以也可以作为Promise 的一个扩展。

#### then只是将callback拆分了

它的写法还是一个异步的写法，它的本质上还是callback，因为then里面传的是一个函数，只不过比callback写法更加模块化，更加可以链式的串行，不用嵌套很多层。

#### async/await可以直接用同步的写法来写，最直接的同步写法

其实我们解决了这么长时间的异步，我们之前也说过，我们无法改变js单线程，异步这种本质，但是单线程，异步的本质导致的问题是我们编写代码的顺序和执行的顺序不一致。所以我们一直在解决那种callback所带来的这个问题，现在有了终极解决方案，就是async/await，它看上去就是一个直接的同步代码写法。

```js
const load = async function () {
  const result1 = await loadImg(src1)
  console.log(result1)
  const result2 = await loadImg(src2)
  console.log(result2)
}
load()
```

这完全是同步的写法，使用上没有一个回调函数，可能回调函数的事情封装起来了，使用上是完全的同步的写法。

#### 语法

* 使用await，函数必须用async标识你想要在函数体里面用await，你函数体这个function前面必须加一个async，这个函数也可以作为一个普通的函数来执行。 
* await后面必须跟一个promise实例await的返回值就是这个promise实例resolve或reject传出来的结果。
* 需要用babel-polyfill做编译

#### 总结当前js解决异步的方案

* jquery deferred
* Promise
* async/await
* generator
  * 原理比较复杂
  * 不是异步的直接解决方案
  * 主要的原因是我们有更好更简洁的解决方案async/await
  * koa也是放弃了generator而使用async/await来解决异步








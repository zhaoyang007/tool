### 值类型，引用类型，栈堆的内存存储形式

在计算机变量存储的时候，栈和堆同时存在。栈从上往下累加，堆从下往上累加。它们会不会重合呢，异常情况下可能会重合，但是我们的操作系统一般分配的内存是够程序使用的。

值类型是在栈中存储的，引用类型在堆中存储，引用类型的变量指向这个内存地址。

为什么引用类型是这样的存储方式，是考虑到性能问题，复制的时候直接值会导致复制过程非常的慢。所以说计算机所有的程序、语言都是采用值类型和引用类型严格的分离出来。它们的存储、赋值、拷贝机制也是严格的分离出来。是基于内存的空间和 cpu 的计算耗时来做的区分，它并不是故意这么做，故意为难你，它是不得以而为之的。

### typeof

值类型：undefined number string boolean symbol

引用类型：function object（对象，数组，null）

### 深拷贝

```js
// 它要传入一个你要拷贝的对象
function deepClone (obj = {}) {
  // obj是null，或者不是对象或数组，直接返回
  if (typeof obj !== 'object' || obj == null) {
    return obj
  }
  // 初始化返回结果，也就是说我们该返回什么东西，我们先初始化一下
  let result
  // 如果传入的这个值是数组类型的，我们返回的这个结果应该是数组格式的。传入的值如果不是数组的话，返回的结果应该是对象格式的
  if (obj instanceof Array) {
    result = []
  } else {
    result = {}
  }
  // 无论是对象还是数组，它都可以用for in去遍历
  for (let key in obj) {
    // 判断每个key是不是这个对象自己拥有的属性，保证key不是原型上的属性
    if (obj.hasOwnProperty(key)) {
      // 递归调用！！！ 递归就是为了防止比较深层次的东西，我们就需要一层层的去递归才能最终给它完全的拷贝出来。
      // 这样的话才能完成深拷贝。我们考察深拷贝的时候，递归是非常看中的东西。
      // obj的每个key的值都要重新深拷贝然后赋值给result[key]
      result[key] = deepClone(obj[key])
    }
  }
  // 最终它要返回一个你拷贝后的对象
  return result
}
const obj1 = {
  name: 'xxx',
  age: 20,
  address: {
    city: 'beijing'
  },
  arr: ['a', 'b', 'c']
}
const obj2 = deepClone(obj1)
obj2.address.city = 'shanghai'
console.log(obj1.address.city)
```

### 类型转换

#### 隐式类型转换

* 字符串拼接

* ==
  == 会发生隐式类型转换，除了 == null之外，其他一律用 ===

  ```js
  // 判断对象中有没有这个属性
  const obj = {x: 100}
  if (obj.a == null) { }
  // 相当于：
  if (obj.a === null || obj.a === undefined) { }
  ```

  这种规则是 jquery 和 zipto 等源码都在使用的，而且 eslint 也支持这种规则。

* if 语句和逻辑运算

  truly 变量：!!a === true 的变量，就是经过两步非运算如果得出true那就是truly变量。

  flasely 变量：!!a === flase 的变量，就是经过两步非运算如果得出flase那就是flasely变量。

  以下是falsely变量。除此之外都是truly变量：

  ```js
  !!0 === false
  !!NaN === false
  !!'' === false
  !!null === false
  !!undefined === false
  !!false === false
  ```

  逻辑运算

  ```js
  console.log(10 && 0) // 0
  console.log('' || 'abc') // 'abc'
  console.log(!window.abc) // true
  ```

#### 强制类型转换

Number类型和String类型相互转换

#### StringToNumber

##### parseInt 函数

* parseInt 是全局函数，不从属于任何类的方法，且只解析整数。如果字符串前缀是 "0x" 或者 "0X"，则parseInt 将其解释为十六进制数。它解析时会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容，如果第一个非空格字符是非数字字符，则返回 NaN。
* parseInt 还可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是 2~36。

##### parseFloat 函数

它也是全局函数，不从属于任何类的方法，它可以解析整数和浮点数。它不能识别十六进制前缀 "0x" 或 "0X"。它解析时也会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容，如果第一个非空格字符是非数字字符，则返回 NaN。

##### Number

通过 Number 转换函数传入一个字符串，它会试图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制进行转换，并且字符串中不能出现非数字的字符，否则将返回 NaN。

#### NumberToString

* Number类定义的toString()方法：这个方法可以接收表示转换基数（radix，范围在2~36之间）的可选参数，如果不指定此参数，转换规则将是基于十进制。
* Number 类定义的 toFixed 方法：这个方法可以指定小数点后的位数。
* Number 类定义的 toExponential 方法：这个方法使用指数记数法将数字转换为指数形式的字符串，其中小数点前只有一位，小数点后的位数则由参数指定。
* Number 类定义的 toPrecision 方法：这个方法根据指定的有效数字位数将数字转换成字符串。如果有效数字的位数少于数字整数部分的位数，则转换成指数形式。
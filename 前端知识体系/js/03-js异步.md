### 单线程和异步

##### 单线程

只有一个线程，同一时间只能做一件事情。

js 执行和浏览器渲染会互相干扰，不能同时进行，js 执行也会影响后面的 js 执行。

循环过程中，后面的 js 执行和 dom 渲染都是不执行的，浏览器处于卡顿状态。alert 的浏览器行为不关掉，后面的 js 也是不执行的。

```js
var i, sum = 0
for (i = 0; i < 1000000000; i++) {
  sum += i
}
console.log(sum)
console.log(1)
alert('hello')
console.log(2)
```

##### 单线程原因：避免dom渲染的冲突

* 浏览器需要渲染 dom。
* js 可以修改 dom 结构。
* 如果它们同时修改了一个 dom 那就冲突了。

##### 解决方案：异步

由于 js 单线程的机制，我们把需要等待一段时间才能做的事情变成异步，先执行其他的 js 代码，这样就不会阻塞后面代码的执行从而造成页面卡死的状态了。

异步是 js 单线程的一个唯一且合适高效的解决方案，但也有一些问题：

* 没有按照书写的顺序来执行，可读性差
* callback 中不容易模块化

异步是基于 callback 函数形式来调用的，每个异步里面都需要加个回调函数，在合适的时间去执行这个回调函数。

JavaScript 异步写法

* 回调函数
* jquery deferred
* Promise
* async/await
* generator



### event-loop

event loop 是浏览器对异步的实现方式。

事件循环的顺序，决定了 JavaScript 代码的执行顺序。

整体的 js 代码这个宏任务先执行，同步代码执行完后有微任务执行微任务，没有微任务执行下一个宏任务，如此往复循环至结束。

每一次 call stack 结束后，就是每次宏任务结束后，会触发页面渲染，然后再进行下一次循环就是下一个宏任务。

```js
// 修改DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
  .append($p1)
  .append($p2)
  .append($p3)
// 下面代码会先执行，然后页面渲染才会变化。
console.log('length',  $('#container').children().length )
alert('本次 call stack 结束，尚未触发 DOM 渲染')
```

宏任务：页面渲染后再触发，微任务：页面渲染前会触发。

```js
// 修改DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
  .append($p1)
  .append($p2)
  .append($p3)
// 微任务：DOM 渲染之前执行
Promise.resolve().then(() => {
  const length = $('#container').children().length     
  alert(`micro task ${length}`)
})
// 宏任务：DOM 渲染之后执行
setTimeout(() => {    
  const length = $('#container').children().length
  alert(`macro task ${length}`)
})
```

##### 根据函数的调用关系就能知道源码中的大致结构

传参的地方，一个地方接收一个 function，另一个地方就要传入一个 function。

而且回调函数之间只有两层关系，再复杂的结构也可以拆解开成两层两层的关系，最终有互相依赖的函数回调关系的只有那两层。

解读复杂代码能力，尤其是复杂的函数回调关系的梳理。

##### 框架类库插件源码分析

内部定义好构造函数的属性和方法，方法添加到原型上，然后使用了 new 构造函数的方式，我们使用的时候最终都会得到这个构造函数返回的实例对象，这个对象就拥有了框架内部构造函数上的属性和方法，我们就可以使用框架提供给我的功能了。使用的过程我们可以传入我们的配置，框架内部会根据配置来得到不同的功能。

##### 逻辑和计算

逻辑是靠计算的结果去判断的。有时候不是逻辑复杂，而是计算复杂，它们之间相辅相成。

##### 跨 js 文件的时序问题解决，用回调函数

```js
// page1.js
var ensureGetIdFlag = false
var ensureGetIdCallbackQueue = []
function ensureGetId (callback) {
  if (ensureGetIdFlag === true) {
    callback()
    return
  }
  ensureGetIdCallbackQueue.push(callback)
}
$.ajax({
  url: "",
  data: "",
  type: "",
  success: function (data) {
    ensureGetIdFlag = true
    for(var i = ensureGetIdCallbackQueue.length - 1; i >= 0; i--){
      ensureGetIdCallbackQueue[i](data)
    }
  }
})
// page2.js
ensureGetId(function (data) {})
```

##### 工具

想要读取地址栏的中文，要用 decodeURI(window.location.href) 解析一下，不然是乱码。

form 表单提交，不受跨域限制。

API 它就是一个技术点，关注输入什么，输出什么就完了。

流程图框架：jointjs, jsplumb

##### token登录验证

调登录接口后下发一个 token，由后端存入 cookie，以后每次接口请求再从 cookie 中读取这个 token 做验证。

调登录接口后下发一个 token，由前端存入 cookie，以后每次接口请求再从 cookie 中读取这个 token 做验证。

调登录接口后下发一个 token，由前端存入 cookie，以后每次接口请求将这个 token 放到 header 中，后端从 header 中取到 token 做验证。

##### 下载文件

a标签

```js
// 静态
<a href="下载地址" download="下载文件名称">点击下载文件</a>
// 动态生成a标签
var downloadElement = document.createElement('a');
downloadElement.href = '下载地址';
downloadElement.download = '文件名'; // 下载后文件名
document.body.appendChild(downloadElement);
downloadElement.style.display = 'none';
downloadElement.click(); // 点击下载
document.body.removeChild(downloadElement); // 下载完成移除元素
```

window.open()

```js
window.open("下载地址");
```

form表单	

```js
// get
var form = document.createElement('form'); // 定义一个form表单 
form.setAttribute('style', 'display:none');
form.setAttribute('method', 'post');
form.setAttribute('action', '下载地址')               
document.body.appendChild(form);               
from.submit(); // 提交表单，实现下载      
// post
var form = document.createElement('form'); // 定义一个form表单
form.setAttribute('style', 'display:none');
form.setAttribute('target', '');
form.setAttribute('method', 'post');
form.setAttribute('action', '下载地址');
var input1 = document.createElement('input'); // 创建查询参数
input1.setAttribute('type', 'hidden');
input1.setAttribute('name', 'param1');
input1.setAttribute('value', 'value1');
document.body.appendChild(form);
form.appendChild(input1);
form.submit(); // 提交表单，实现下载   
```

接口返回的结果为文件流数据时

```js
// 我们需要将文件流转化为Blob形式，再讲Blob数据转化为下载的链接，即可下载。
var blob = new Blob([后台返回的文件流数据], {type: 'application/x-rar-compressed'});//转化为Blob形式，type为文件类型
var href = window.URL.createObjectURL(blob); // 创建下载的链接
var downloadElement = document.createElement('a'); // 创建a标签
downloadElement.href = href;//a标签中加入下载链接
downloadElement.download = '文件名'; // 下载后文件名
document.body.appendChild(downloadElement);
downloadElement.style.display = 'none';
downloadElement.click(); // 点击下载
document.body.removeChild(downloadElement); // 下载完成移除元素
window.URL.revokeObjectURL(href); // 释放掉blob对象
```

##### 判断数组中对象的某个字段的值是否重复

```js
let arr = [
    { name:'censek', age: 18 },
    { name: 'bob', age: 13 },
    { name: 'john', age: 25 },
    { name: 'censek', age: 6 }
];
 
for (i = 0; i < arr.length - 1; i++) {
    for (j = i + 1; j < arr.length; j++) {
        if (arr[i].name === arr[j].name) {
            console.log("重名了！！");
        }
    }
}
```

##### findLastIndex

```js
Array.prototype.fakeFindLastIndex = function(cb, context) {
  let array = this;
  for (let i = array.length-1; i >=0; i--) {
    const element = array[i];
    if (cb.call(context, element, i, array)) {
      return i;
    }
  }
  return -1;
}	
```

##### jsonToTree

```js
// 方法1
var treeList = [
    {
        title: '系统管理',
        parentName: '',
        parentId: 0,
        id: 1,
    },
    {
        title: '菜单管理',
        parentName: '系统管理',
        parentId: 1,
        id: 11,
    },
    {
        title: '菜单新增',
        parentName: '菜单管理',
        parentId: 11,
        id: 111,
    },
    {
        title: '菜单编辑',
        parentName: '菜单管理',
        parentId: 11,
        id: 112,
    },
    {
        title: '菜单删除',
        parentName: '菜单管理',
        parentId: 11,
        id: 113,
    },
    {
        title: '角色管理',
        parentName: '系统管理',
        parentId: 1,
        id: 22,
    },
    {
        title: '角色新增',
        parentName: '角色管理',
        parentId: 22,
        id: 221,
    },
    {
        title: '角色编辑',
        parentName: '角色管理',
        parentId: 22,
        id: 222,
    },
    {
        title: '角色删除',
        parentName: '角色管理',
        parentId: 22,
        id: 223,
    },
    {
        title: '用户管理',
        parentName: '系统管理',
        parentId: 1,
        id: 33,
    },
    {
        title: '用户新增',
        parentName: '用户管理',
        parentId: 33,
        id: 331,
    },
    {
        title: '用户编辑',
        parentName: '用户管理',
        parentId: 33,
        id: 332,
    },
    {
        title: '用户删除',
        parentName: '用户管理',
        parentId: 33,
        id: 333,
    }
]
function jsonToTree(lists, id, parentId) {
    var idList = {},
        treeList = [];
    for (var i = 0, len = lists.length; i < len; i++) {
        //生成一个以id为键的对象
        idList[lists[i][id]] = lists[i]
    }
    for (var j = 0, len1 = lists.length; j < len1; j++) {
        var aVal = lists[j];
        var aValParent = idList[aVal[parentId]];
        //如果aValParent存在；就说明当前的aVal是aValParent的孩子
        if (aValParent) {
            if ('chindren' in aValParent) {
                aValParent['children'].push(aVal)
            } else {
                aValParent['children'] = [];
                aValParent['children'].push(aVal)
            }
        } else {
            treeList.push(aVal)
        }
    }
    return treeList
}
// 方法2
var data=[
  { id: 40, parentId: 31, note: "的萨达是" }, 
  { id: 20, parentId: 11, note: "的萨达是" },
  { id: 22, parentId: 20, note: "dsadas" },
  { id: 12, parentId: null, note: "dsadasad萨达s" }, 
  { id: 11, parentId: undefined, note: "dqwds" }, 
  { id: 24, parentId: 22, note: "搜索" },
  { id: 34, parentId: 22, note: "搜索" }
]
function fnSetTreeData(data) {
  var data = [...data];
  var tree = data.filter((father) => {
    var branchArr = data.filter((child) => {
      if (father.id == child.parentId) child._hasParent = true;
      return father.id == child.parentId;

      // MARK 为什么这样写就报错 ? 
      // if (father.id == child.parentId) child._hasParent = true;
      // return child._hasParent
    });
    if (branchArr.length > 0) father.children = branchArr;
    return !father._hasParent;
  });
  // MARK 为什么在这里还得加一个过滤
  tree = tree.filter((item) => {
    return !item._hasParent;
  })
  return tree
}
console.log(JSON.stringify(fnSetTreeData(data), null, 2))
// 方法3
var data = [
  { id: 40, parentId: 31, note: "的萨达是" }, 
  { id: 20, parentId: 11, note: "的萨达是" },
  { id: 22, parentId: 20, note: "dsadas" },
  { id: 12, parentId: null, note: "dsadasad萨达s" }, 
  { id: 11, parentId: undefined, note: "dqwds" }, 
  { id: 24, parentId: 22, note: "搜索" },
  { id: 34, parentId: 22, note: "搜索" }
]
function listToTree(data) {
  let arr = JSON.parse(JSON.stringify(data))
  const listChildren = (obj, filter) => {
    [arr, obj.children] = arr.reduce((res, val) => {
      if (filter(val))
        res[1].push(val)
      else
        res[0].push(val)
      return res
    }, [[],[]])
    obj.children.forEach(val => {
      if (arr.length)
      listChildren(val, obj => obj.parentId === val.id)
    })
  }

  const tree = {}
  listChildren(tree, val => arr.findIndex(i => i.id === val.parentId) === -1)
  return tree.children
}
// 方法4
var aaa= [{name:'wwb',id:111},{name:'aaa',id:0,pid:"mei"},{name:'a',id:1,pid:"mei"},{name:'b',id:2,pid:1},{name:'c',id:3,pid:1},{name:'d',id:4,pid:2},{name:'e',id:5,pid:2}];

function test(ary,data){

    var data=data?data:(function(ary){
      var tempAry=[];
      var idList=[];
      ary.forEach(function(item){idList.push(item.id)});
     function deb(id,idList){
         var flag=true;
        for(var ida in idList){
            if(id==idList[ida]){
                flag=false;
            }       
        }
         return flag;
     }

      for(var i=0,len=ary.length;i<len;i++){
        if(ary[i].pid==undefined||(ary[i].pid!=undefined&&deb(ary[i].pid,idList))){
          var obj={name:ary[i].name,id:ary[i].id};
          tempAry.push(obj);
        }
       }
        return tempAry; 
    }(ary));

    var temp=0;
   if(data.constructor==Array){
     for(var i=0,len=data.length;i<len;i++){
        for(var j=0,lenA=ary.length;j<lenA;j++){
           if(ary[j].pid==data[i].id){
           var obj={name:ary[j].name,id:ary[j].id};
           data[i].child=data[i].child||[];
           data[i].child.push(obj);
           temp++;
       }
     }
    }
   }

   if(temp>0){
     if(data.constructor==Array){
      for(var n=0,lenB=data.length;n<lenB;n++){
        data[n].child=test(ary,data[n].child?data[n].child:[]);
        if(data[n].child.length==0){
            delete data[n].child;
        }
          delete data[n].id;
      } 
    }
   }else{
       for(var n=0,lenB=data.length;n<lenB;n++){
          delete data[n].id;
       } 

   }
    return data;

}
var a=test(aaa);
sconsole.log(a)

```


##### 根据函数的调用关系就能知道源码中的大致结构

传参的地方，一个地方接收一个 function，另一个地方就要传入一个 function。

而且回调函数之间只有两层关系，再复杂的结构也可以拆解开成两层两层的关系，最终有互相依赖的函数回调关系的只有那两层。

解读复杂代码能力，尤其是复杂的函数回调关系的梳理。

##### 框架类库插件源码分析

内部定义好构造函数的属性和方法，方法添加到原型上，然后使用了 new 构造函数的方式，我们使用的时候最终都会得到这个构造函数返回的实例对象，这个对象就拥有了框架内部构造函数上的属性和方法，我们就可以使用框架提供给我的功能了。使用的过程我们可以传入我们的配置，框架内部会根据配置来得到不同的功能。

##### 逻辑和计算

逻辑是靠计算的结果去判断的。有时候不是逻辑复杂，而是计算复杂，它们之间相辅相成。

##### 跨 js 文件的时序问题解决，用回调函数

```js
// page1.js
var ensureGetIdFlag = false
var ensureGetIdCallbackQueue = []
function ensureGetId (callback) {
  if (ensureGetIdFlag === true) {
    callback()
    return
  }
  ensureGetIdCallbackQueue.push(callback)
}
$.ajax({
  url: "",
  data: "",
  type: "",
  success: function (data) {
    ensureGetIdFlag = true
    for(var i = ensureGetIdCallbackQueue.length - 1; i >= 0; i--){
      ensureGetIdCallbackQueue[i](data)
    }
  }
})
// page2.js
ensureGetId(function (data) {})
```

##### 技巧

看源码和代码的技巧，看到函数定义先不要管函数里面的内容，因为它还没有执行。执行这个函数的地方再回来看函数体内容。

在控制台中打印实例对象，最前面的名称是这个实例的构造函数的名称。然后下面显示的是这个实例对象的内容。利用这个可以很容易的找出一个库或框架或插件或工具中的实际的构造函数是什么。

##### 工具

想要读取地址栏的中文，要用 decodeURI(window.location.href) 解析一下，不然是乱码。

form 表单提交，不受跨域限制。

API 它就是一个技术点，关注输入什么，输出什么就完了。

流程图框架：jointjs, jsplumb

##### token登录验证

调登录接口后下发一个 token，由后端存入 cookie，以后每次接口请求再从 cookie 中读取这个 token 做验证。

调登录接口后下发一个 token，由前端存入 cookie，以后每次接口请求再从 cookie 中读取这个 token 做验证。

调登录接口后下发一个 token，由前端存入 cookie，以后每次接口请求将这个 token 放到 header 中，后端从 header 中取到 token 做验证。

##### 下载文件

a标签

```js
// 静态
<a href="下载地址" download="下载文件名称">点击下载文件</a>
// 动态生成a标签
var downloadElement = document.createElement('a');
downloadElement.href = '下载地址';
downloadElement.download = '文件名'; // 下载后文件名
document.body.appendChild(downloadElement);
downloadElement.style.display = 'none';
downloadElement.click(); // 点击下载
document.body.removeChild(downloadElement); // 下载完成移除元素
```

window.open()

```js
window.open("下载地址");
```

form表单	

```js
// get
var form = document.createElement('form'); // 定义一个form表单 
form.setAttribute('style', 'display:none');
form.setAttribute('method', 'post');
form.setAttribute('action', '下载地址')               
document.body.appendChild(form);               
from.submit(); // 提交表单，实现下载      
// post
var form = document.createElement('form'); // 定义一个form表单
form.setAttribute('style', 'display:none');
form.setAttribute('target', '');
form.setAttribute('method', 'post');
form.setAttribute('action', '下载地址');
var input1 = document.createElement('input'); // 创建查询参数
input1.setAttribute('type', 'hidden');
input1.setAttribute('name', 'param1');
input1.setAttribute('value', 'value1');
document.body.appendChild(form);
form.appendChild(input1);
form.submit(); // 提交表单，实现下载   
```

接口返回的结果为文件流数据时

```js
// 我们需要将文件流转化为Blob形式，再讲Blob数据转化为下载的链接，即可下载。
var blob = new Blob([后台返回的文件流数据], {type: 'application/x-rar-compressed'});//转化为Blob形式，type为文件类型
var href = window.URL.createObjectURL(blob); // 创建下载的链接
var downloadElement = document.createElement('a'); // 创建a标签
downloadElement.href = href;//a标签中加入下载链接
downloadElement.download = '文件名'; // 下载后文件名
document.body.appendChild(downloadElement);
downloadElement.style.display = 'none';
downloadElement.click(); // 点击下载
document.body.removeChild(downloadElement); // 下载完成移除元素
window.URL.revokeObjectURL(href); // 释放掉blob对象
```


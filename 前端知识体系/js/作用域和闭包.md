### 作用域，自由变量，变量的生命周期

作用域：作用域就是查找变量，对象，函数的的地方，代表了它们合法的使用范围

作用域链：自由变量查找的顺序

自由变量：当前作用域没有定义，但是使用了的变量

#### 变量的生命周期

在javascript中声明一个变量是使用var来声明的。一个变量的声明意味着就是我们在内存当中申请了一个空间用来存储。这个内存也就是我们电脑的运行内存，如果我们一直的声明变量，不释放的话。会占用很大的内存。在c/c++当中是需要程序员在合适的地方手动的去释放变量内存，而javascript和java拥有垃圾回收机制，他们会自己回收。但有的时候我们需要让局部变量的生命周期长一点，这个时候在js当中就有了闭包，他能够很好的解决这个问题。

JavaScript执行过程中内存分配：

* 为变量对象分配需要的内存
* 在分配到的内存中进行读/写操作
* 不再使用时将其销毁，释放内存

内存管理不善，会出现内存泄露，造成浏览器内存占用过多，页面卡顿等问题。

#### 垃圾回收机制

JavaScript中有自动垃圾回收机制，会通过标记清除的算法识别哪些变量对象不再使用，对其进行销毁，释放其内存。也就是说，执行环境会负责管理代码执行过程中使用的内存。开发者也可在代码中手动设置变量值为null（a = null）进行标记清除，让其失去引用，以便下一次垃圾回收时进行有效回收。

局部环境中，函数执行完成后，函数局部环境声明的变量不再需要时，就会被垃圾回收销毁（理想的情况下，闭包会阻止这一过程）。全局环境只有页面退出时才会出栈，解除变量引用。所以开发者应尽量避免在全局环境中创建全局变量，如需使用，也要在不需要时手动标记清除，将其内存释放掉。

### 闭包

闭包这个词，听着很专业，它其实上是一个作用域应用的一个特殊的情况。正常的函数定义在什么地方，就会在什么地方执行。但闭包不一样，一般有两种情况：

##### 函数作为参数被传递

也就是函数在这个地方定义好之后，传递到另一个地方去执行。

```js
function print (fn) {
  let a = 200
  fn()
}
let a = 100
function fn () {
  console.log(a)
}
print(fn) // 100
```

##### 函数做为返回值被返回

函数在这个地方定义好之后，它会被返回到另一个地方去执行。

```js
function create () {
  let a = 100
  return function () {
    console.log(a)
  }
}
let fn = create()
let a = 200
fn() // 100
```

总之它函数定义的地方和函数执行的地方它是不一样的。

自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在函数执行的地方。

### this

this的场景比较多

* 做为普通函数去调用
* 使用call apply bind去调用
* 作为对象方法被调用
* 在class方法中被调用
* 箭头函数，箭头函数中的this是取它上级作用域中this的值。

 this在各个场景中取什么样的值是在函数执行的确时候定的，不是在函数定义的时候确定的。所有场景都适用。

### 闭包应用

#### 1.由于js作用域链的存在，只能内部环境访问外部环境，不能从外部访问内部

```js
function a() {
  var i=0;
  function b() {
    alert(++i)
  }
  return b
}
var c = a()
c()
```

#### 2.由于js变量生命周期的存在，变量无法常驻内存

创建10个'<a>'标签，点击的时候弹出对应的序号。

因为事件绑定的函数定义时里面的i是找的全局作用域 i，当遍历结束后，这个全局i已经变成 10 了。这时点击触发函数里面的i就会向上找到全局变量 i，所以都会弹出 10。

```js
let i, a
for (i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function (e) {
    e.preventDefault()
    alert(i)
  })
  document.body.appendChild(a)
}
```

i变成了块级作用域中的变量，每次for循环执行的时候都会形成一个新的块，这时配合事件绑定的函数就形成了一个闭包，所以每次循环的变量i都会保存下来。这时点击触发函数里面的i就会向上找到块级作用域里的变量i，所以就会弹出对应的 i。

```js
let a
for (let i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function (e) {
    e.preventDefault()
    alert(i)
  })
  document.body.appendChild(a)
}
```

这种写法跟第二种的目的和解释是一样的，只是写法不同。这种情况是针对不会立即执行的函数中存在自由变量的取值的情况可能会被外面作用域里面的数据的改变所影响。解决的办法就是让这个自由变量存在在闭包中，这时它就能常驻内存了。

```js
let i, a
for (i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', (function (i) {
    return function (e) {
      e.preventDefault()
      alert(i)
    }
  })(i))
  document.body.appendChild(a)
}
```

#### 3.闭包内的局部变量不会影响到闭包外的同名变量，即可用闭包形成一个块级作用域

可以通过立即执行函数，来达到隐藏细节的目的

```js
var myModule = (function () {
  var var1 = 1
  var var2 = 2
  function fn1 () {

  }
  function fn2 () {

  }
  return {
    fn1: fn1,
    fn2: fn2
  }
})()
```

这样在模块外部无法修改我们没有暴露出来的变量、函数，来做js模块化。

#### 4.隐藏数据

我们通过闭包把一些数据隐藏起来，然后不让外边去改变。比如我们做一个简单的缓存工具。

闭包隐藏数据，只提供api。缓存的小插件，小工具

```js
function createCache () {
  const data = {} // 闭包中的数据，被隐藏，不被外界访问
  return {
    get (key) {
      return data[key]
    },
    set (key, value) {
      data[key] = value
    }
  }
}
const c = createCache()
c.set('a', 100)
console.log(c.get('a'))
```

为什么说它可以隐藏数据呢，比如我们现在想去不通过set,get直接去改data值怎么改呢，没有办法改。因为这个data是在这个 createCache 的这个作用域里面的。它不会被外界所访问到。也就是它的合法作用域只是createCache这个函数里面，如果你在这个函数外界直接去data.a赋值成200，这个是会报错的。data在这个作用域里没有定义，作用域的自由变量的查找顺序它不会找到createCache函数里面来。这样我们通过return get set返回函数的闭包的一种形式，执行这个函数的时候，因为这个函数是在这个createCache作用域里面的，所以说它能找到这个data，对它做一些修改。所以说这种方式是非常常见的，不管是缓存也好，还是其他的数据也好。比如说jquery的事件绑定和自定义事件，它都是通过这种方式来去隐藏的，就是一个函数里面，我们去把这个数据隐藏，然后只提供一些api在外面，然后去用api，然后这个数据我自己去管理着。所以说这是闭包的一个非常常见和常用的一种方。

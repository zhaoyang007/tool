### 值类型，引用类型

值类型是在栈中存储的，引用类型在堆中存储。

栈，堆，队列在 js 中的运用

* 变量的内存存储方式是使用的栈和堆
* 函数执行会形成一个执行栈
* 事件循环机制会使用到队列来存放异步任务

在计算机变量存储的时候，栈和堆同时存在。栈从上往下累加，堆从下往上累加。异常情况下可能会重合，但是操作系统一般分配的内存是够程序使用的。

引用类型的存储方式，是考虑到性能，复制的时候直接赋值会导致复制过程非常的慢。所以说计算机所有的程序、语言都是采用值类型和引用类型严格的分离出来，是基于内存空间和 cpu 的计算耗时做的区分。

值类型：undefined number string boolean symbol

引用类型：function object（对象，数组，null）



### 类型转换

#### 隐式类型转换

* 字符串拼接

* ==
  == 会发生隐式类型转换，除了 == null之外，其他一律用 === 这种规则是 jquery 和 zipto 等源码都在使用的，而且 eslint 也支持这种规则。

  ```js
  // 判断对象中有没有这个属性
  const obj = {x: 100}
  if (obj.a == null) { }
  // 相当于：
  if (obj.a === null || obj.a === undefined) { }
  ```

* if 语句和逻辑运算

  if 语句和逻辑运算会发生布尔类型的隐式类型转换。

  经过两步非运算得出 true 的变量是 turely，经过两步非运算得出 flase 的变量是 falsely 变量。以下是 falsely 变量，除此之外都是 truely 变量：

  ```js
!!0 === false
  !!NaN === false
  !!'' === false
  !!null === false
  !!undefined === false
  !!false === false
  ```
  

#### 强制类型转换

##### StringToNumber

parseInt(string, radix)：全局函数，把 string 当成 radix 进制数解析成十进制整数，如果字符串前缀是 "0x" 或者 "0X"，则 parseInt 将其解释为十六进制数。解析时会跳过空格，只解析字符串中的第一个数字，如果第一个非空格字符是非数字字符，则返回 NaN。

parseFloat(string)：全局函数，它可以解析整数和浮点数。它不能识别十六进制前缀 "0x" 或 "0X"。解析时会跳过空格，只解析字符串中的第一个数字，如果第一个非空格字符是非数字字符，则返回 NaN。

Number(object)：把对象的值转换为十进制整数或浮点数的数字，如果对象整体的值无法转换为数字，返回 NaN。

* 参数是 Boolean 值，返回 1 和 0。
* 参数是 null 值，返回 0。
* 参数是 undefined，返回 NaN。
* 参数是 Date 对象，返回从 1970 年 1 月 1 日至今的毫秒数。

##### NumberToString

Number 类定义的 toString(radix) 方法：把数字以 radix 进制转换为字符串，如果不指定此参数，基于十进制。

Number 类定义的 toFixed(x) 方法：把数字四舍五入为指定小数位数 x 的字符串。



### 深拷贝

```js
// 传入一个要拷贝的对象
function deepClone (obj = {}) {
  // 传入的不是对象或者是null，直接返回
  if (typeof obj !== 'object' || obj == null) {
    return obj
  }
  // 初始化返回结果
  let result
  // 如果传入是数组，返回的也应该是数组格式。传入的不是数组，返回对象格式。
  if (obj instanceof Array) {
    result = []
  } else {
    result = {}
  }
  // 遍历每个值进行拷贝，对象和数组都可以用for in遍历。
  for (let key in obj) {
    // 判断每个key是不是这个对象自己拥有的属性，保证key不是原型上的属性。
    if (obj.hasOwnProperty(key)) {
      // 递归调用！
      // 如果对象中的某个值还是个对象，要将这个对象也进行拷贝，这样就达到了深拷贝的作用。
      // 将拷贝的每个值一一对应的放到result中。
      result[key] = deepClone(obj[key])
    }
  }
  // 最终返回拷贝后的结果
  return result
}

// 使用
const obj1 = {
  name: 'xxx',
  age: 20,
  address: {
    city: 'beijing'
  },
  arr: ['a', 'b', 'c']
}
const obj2 = deepClone(obj1)
obj2.address.city = 'shanghai'
console.log(obj1.address.city)
```
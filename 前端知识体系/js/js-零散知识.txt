1.根据函数的调用关系就能知道源码中的大致结构。
  传参的地方，一个地方接收一个function，另一个地方就要传入一个function
  而且回调函数之间只有两层关系，再复杂的结构也可以拆解开成两层两层的关系，最终有互相依赖的函数回调关系的只有那两层。
  解读复杂代码能力，尤其是复杂的函数回调关系的梳理
2.框架类库插件源码分析
  内部定义好构造函数的属性和方法，方法添加到原型上，然后使用了new构造函数的方式，我们使用的时候最终都会得到这个
  构造函数返回的实例对象，这个对象就拥有了框架内部构造函数上的属性和方法，我们就可以使用框架提供给我的功能了。使
  用的过程我们可以传入我们的配置，框架内部会根据配置做判断来得到不同的功能。
3.抽象
  借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。比基本计算更高级的一个功能。
  写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。
4.逻辑和计算
  逻辑是靠计算的结果去判断的。有时候不是逻辑复杂，而是计算复杂。他们之间相辅相成。
5.工厂模式
  function Person () {
    var o = {
      name: 'abc'
      f: function () {
        alert(this.name)
      }
    }
    return o
  }
  函数 {
    对象 {
      函数
    }
    return 对象
  }
6.跨js文件的时序问题解决，用回调函数
  // page1.js
    var ensureGetIdFlag = false
    var ensureGetIdCallbackQueue = []
    function ensureGetId (callback) {
      if (ensureGetIdFlag === true) {
        callback()
        return
      }
      ensureGetIdCallbackQueue.push(callback)
    }
    $.ajax({
      url: "",
      data: "",
      type: "",
      success: function (data) {
        ensureGetIdFlag = true
        for(var i = ensureGetIdCallbackQueue.length - 1; i >= 0; i--){
          ensureGetIdCallbackQueue[i](data)
        }
      }
    })
  // page2.js
    ensureGetId(function (data) {

    })
7.栈，堆，队列在js中的运用
  1.变量的内存存储方式是使用的栈和堆
  2.函数执行会形成一个执行栈
  3.事件循环机制会使用到队列来存放异步任务
8.技巧
  1.看源码和代码的技巧，看到函数定义先不要管函数里面的内容，因为它还没有执行。执行这个函数的地方再回来看函数体内容。
  2.在控制台中打印实例对象，最前面的名称是这个实例的构造函数的名称。然后下面显示的是这个实例对象的内容。利用这个可以很容易
    的找出一个库或框架或插件或工具中的实际的构造函数是什么。
9.想要读取地址栏的中文，要用decodeURI(window.location.href)解析一下，不然是乱码
10.form表单提交，不受跨域限制。
11.token登录验证
  1.调登录接口后下发一个token，由后端存入cookie，以后每次接口请求再从cookie中读取这个token做验证。
  2.调登录接口后下发一个token，由前端存入cookie，以后每次接口请求再从cookie中读取这个token做验证。
  3.调登录接口后下发一个token，由前端存入cookie，以后每次接口请求将这个token放到headers中，后端从headers中取到token做验证。
12.bug调试
	1.反复看bug效果，出现的时机
	2.顺序问题，把所有的关键时间点都要打印出来，如开始结束点。
13.api它就是一个技术点，关注输入什么，输出什么就完了。
14.正则
    正则表达式：
      正则表达式(regular expression)是一个描述字符模式的对象。ECMAScript 的 RegExp 类 表示正则表达式，而 
      String 和 正则表达式都定义了进行强大的【模式匹配】和【文本检索】与【替换】的函数。 
      简化对字符串的处理
      计算机处理的主要就是数字和字符串
      正则在字符串中的出现
      正则是模式  字符串是具体
      用正则表示字符串中正则出现的规律
      验证时，正则表达式可以理解为用许多元字符拼成的表示一串字符串的规则
      正则表达式就是用来描述字符串的出现规则的
      正则至少要会查会用 
      一.创建正则表达式
      //无论是正则的方法还是字符串的方法，都是在字符串中去匹配正则
      //原字符串和正则均不会改变，
        二.正则的方法
        1.test() reg.test(str):它是正则表达式的方法，匹配字符串。符合匹配返回true，不符合返回false。
        2.exec() reg.exec(str):它是正则表达式的方法，匹配字符串。如果匹配到了返回第一次匹配到的内容（数组），没匹配到返回bull。
        三、字符串的方法
        1.match() str.match(reg):它是字符串的方法，匹配正则表达式。如果匹配到了没有加全局标志位的正则，则返回第一次匹配到的内容（数组），如果匹配到带有全局标志位的正则，则返回所有匹配到的内容（数组），如果没有匹配到正则表达式，则返回null。
        2.search() str.search(reg):字符串的方法，查找返回第一次匹配到的正则表达式的下标，如果没有匹配到，返回-1  （跟indexOf()方法一样）。
        3.replace() str.replace(reg):字符串的方法，在整个字符串中将匹配到的正则表达式的字符串替换成指定的字符串，如果正则表达式中没有全局标志位g，则只替换第一次匹配到的正则表达式的字符串，如果正则表达式中有全局标志位g,则全部替换，如果没有匹配到就不替换，最后返回替换后的字符串。
        4.split() str.split(reg):字符串的方法，返回字符串被正则表达式分割后的数组，没匹配到返回原字符串
        四、元字符（三、三、二、三个一）：正则表达式元字符是包含特殊含义的字符 。它们有一些特殊功能,可以控制匹配模式的方式。
          三：{} [] ()
          {} : 限定括号前面的一个或一组字符连续出现的次数
          {3} ： 限定前面一个或一组字符连续出现3次
          {3,}: 限定前面一个或一组字符连续出现3次到无限，至少出现3次
          {3,5} : 限定前面一个或一组字符连续出现3次到5次，至少出现3次，最多出现 5次
          [] :表示范围
          ()：表示组，一些分组的应用 $1 $2 ...   RegExp.$1...
        三：* + ？限定括号前面的一个或一组字符连续出现的次数
          * ： {0,} 限定前面一个或一组字符连续出现0次到无限,可以没有
          + ： {1,} 限定前面一个或一组字符连续出现1次到无限,至少出现1次
          ？： {0,1} 限定前面一个或一组字符连续出现0次到1次,至少出现0次，最多出现1次
        二、 ^   $
          ^  : 定头（断头） 限制开头的内容
          $  :定尾（断尾）  限制结尾的内容
        三个一 ： .   |    \
          . : 模糊匹配，一个.可以匹配任何一个字符	
          | : 表示或者
          \ : 转义符
            \d : 表示数字 [0-9]
            \D : 表示非数字 [^0-9]
            \w : 表示字母、数字、下划线  [a-zA-Z0-9_]
            \W : 表示非字母、数字、下划线 [^a-zA-Z0-9_]
            \s : 表示空白符
            \S : 表示非空白符
            \b : 可以匹配是否到了边界
            特殊字符，用\符号转义即可	
        //exec()与match()的区别		
        //exec():不受g的影响，没有（）时，只匹配第一个出现正则，有（）时，会将匹配到第一次出现的的整个正则（父集）与（）匹配到的正则（子集）全部获取到，形成数组
        //match(): 没有（）与g时，只匹配第一个出现 的正则;没有（）但有g时，匹配全部出现的正则;有（）但没有g时，会将匹配到的整个正则（父集）与()匹配到的正则（子集）全部获取到，形成数组;有（）与g时，只匹配父集
        //例
        var pattern = /^([a-z]+)\s([0-9]{4})$/i; //使用分组
        var str = 'google 2012';
        console.log(pattern.exec(str));
        alert(pattern.exec(str)[0]); //google 2012
        alert(pattern.exec(str)[1]); //google
        alert(pattern.exec(str)[2]); //2012
        //得到替换的字符串输出
        var pattern = /8(.*)8/;
        var str = 'This is 8google8';
        var result = str.replace(pattern,'<strong>$1</strong>'); 
        document.write(result);
        //将两个分组的值替换输出
        var pattern = /(.*)\s(.*)/;
        var str = 'google  nbaidu';
        var result = str.replace(pattern, '$2 $1'); 
        document.write(result);
        五.标志位
        g：全局匹配
        i：不区分大小写
        m：启用换行模式（有时字符串不只是一行，不加m就只能匹配第一行字符串内容，加m就可以每一行都匹配）
        六.正则应用：表单验证
    正则上课代码
      一、 创建正则表达式
        1.创建对象的方式
        var re = new RegExp("日本狗",'g'); //参1：正则（规则）参2（标志位）：表示全局匹配 
        var oInput = document.getElementsByTagName("input");
        
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          //alert(re.test(str));
          if(re.test(str)){
            alert("赞");
          }else{
            alert("我们群殴你！");
          }
        };
        
        2.字面量的方式
        var re = /日本狗/g;//参1：正则（规则）参2（标志位）：表示全局匹配 
        var oInput = document.getElementsByTagName("input");
        
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          //alert(re.test(str));
          if(re.test(str)){
            alert("赞");
          }else{
            alert("我们群殴你！");
          }
        };
        二、正则的方法
        1.test()
        2.exec()
        var re = /o/;//参1：正则（规则）参2（标志位）：表示全局匹配 
        var oInput = document.getElementsByTagName("input");
        
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          alert(re.exec(str));
        };
        三、字符串的方法
        1.match() :它是字符串的方法，匹配正则表达式，如果匹配到了没有加全局标志位的正则，则返回第一次匹配到的内容（数组），如果匹配到带有全局标志位的正则，则返回所有匹配到的内容（数组），如果没有匹配到正则表达式，则返回null;
        var re =/o/g;
        var oInput = document.getElementsByTagName("input");
        
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          alert(str.match(re));
        };
        2.search():字符串的方法，查找第一次匹配到的正则表达式的下标，如果没有匹配到，返回-1  (indexOf)
        var re = /o/g;
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          alert(str.search(re));
        };
        3.replace() : 字符串的方法，将匹配到的正则表达式替换成指定的字符串，如果正则表达式中有全局标志位g,则全部替换匹配到的正则表达式。
        var re = /o/g;
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          alert(str.replace(re,'p'));
        };
        4.split()
        var re = /o/g;
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          alert(str.split(re));
        };
        四、元字符（三、三、二、三个一）
        三：  {} [] ()
        {} : 限定括号前面的一个或一组字符连续出现的次数
        {3} ： 限定前面一个或一组字符连续出现3次
        {3,}: 限定前面一个或一组字符连续出现3次到无限，至少出现3次
        {3,5} : 限定前面一个或一组字符连续出现3次到5次，至少出现3次，最多出现 5次
        var re = /^o{3,5}$/gi;  //标志位i:不区分大小写
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          alert(re.test(str));
        };
        [] :表示范围
        var re = /^[abc]{3,5}$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          alert(re.test(str));
        };
        var re = /^[a-zA-Z0-9_!@#\.,]{6,18}$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        var re = /^[^a-zA-Z]{6,18}$/;   //[^a-zA-Z] 非字母
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        var re = /^[\u4e00-\u9fa5]{6,18}$/;   //[^a-zA-Z] 非字母
        //[\u4e00-\u9fa5]:中文
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        （）：表示组
        var re = /^(ab){2}/;   //[^a-zA-Z] 非字母
        //[\u4e00-\u9fa5]:中文
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        
        三、 * + ？  限定括号前面的一个或一组字符连续出现的次数
        * ： {0,} 限定前面一个或一组字符连续出现0次到无限,可以没有
        + ： {1,} 限定前面一个或一组字符连续出现1次到无限,至少出现1次
        ？： {0,1} 限定前面一个或一组字符连续出现0次到1次,至少出现0次，最多出现1次
        var re = /^(ab)?$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        二、 ^   $
        ^  : 定头（断头） 限制开头的内容
        $  :定尾（断尾）  限制结尾的内容
        var re = /(ab)+$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        三个一 ： .   |    \
        .   : 模糊匹配，一个.可以匹配任何一个字符
        var re = /^.o.+$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        
        | : 表示或者
        var re = /^中国|俄罗斯|巴基斯坦$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        
        \ : 转义符
        \d : 表示数字 [0-9]
        var re = /^\d{6}$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        \D : 表示非数字 [^0-9]
        var re = /^\D{6}$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        \w : 表示字母、数字、下划线  [a-zA-Z0-9_]
        var re = /\w{6,18}$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        \W : 表示非字母、数字、下划线 [^a-zA-Z0-9_]
        var re = /\w{6,18}$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        \s : 表示空白符
        var re = /^a\s{6,18}b$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        \S : 表示非空白符
        var re = /^a\s{6,18}b$/;  
        var oInput = document.getElementsByTagName("input");	
        oInput[1].onclick = function(){
          var str = oInput[0].value;
          if(!re.test(str)){
            alert("您输入不合法！");
          }
        };
        
        var pattern = /8(.*)8/; //获取 8..8 之间的任意字符
        var str = 'This is 8google8, dd 8ggg8';
        var arr = str.match(pattern);
        //alert(str.match(pattern));
        //alert(RegExp.$1); //得到第一个分组里的字符串内容
        //RegExp.$1  : 第一个子集（一个小括号是一个子集）
        //RegExp.$2   : 第二个子集
        alert(arr.length);
        for(var i = 0; i < arr.length; i ++){
          document.write(arr[i] + "<br/>");
        }
        
        var pattern = /8(.*)8/g; //获取 8..8 之间的任意字符
        var str = 'This is 8google8, dd 8ggg8';
        //var arr = pattern.exec(str);
        var arr = str.match(pattern);
        //alert(str.match(pattern));
        //alert(RegExp.$1); //得到第一个分组里的字符串内容
        //RegExp.$1  : 第一个子集（一个小括号是一个子集）
        //RegExp.$2   : 第二个子集
        alert(arr.length);
        for(var i = 0; i < arr.length; i ++){
          document.write(arr[i] + "<br/>");
        }
        //exec():不受g的影响，没有（）时，只匹配第一个出现正则，有（）时，会将匹配到的整个正则（父集）与（）匹配到的正则（子集）全部获取到，形成数组
        //match(): 没有（）与g时，只匹配第一个出现 的正则;没有（）但有g时，匹配全部出现的正则;有（）但没有g时，会将匹配到的整个正则（父集)与()匹配到的正则（子集)全部获取到，形成数组;有（）与g时，只匹配父集
        
        var pattern = /8(.*)8/;
        var str = 'This is 8google8';
        var result = str.replace(pattern,'<strong>$1</strong>'); //得到替换的字符串输出
        document.write(result);
        
        var pattern = /(.*)\s(.*)/;
        var str = 'google baidu';
        var result = str.replace(pattern, '$2 $1'); //将两个分组的值替换输出
        document.write(result);
        
        var pattern = /google|baidu|bing/; //匹配三种其中一种字符串
        var str = 'google';
        alert(pattern.test(str));
        
        var pattern = /goo\sgle/; //\s 可以匹配到空格
        var str = 'goo gle';
        alert(pattern.test(str));
        
        var pattern = /google\b/; //\b 可以匹配是否到了边界
        var str = 'google';
        var str2= 'googleaa googlexx google dsdddd';
        alert(pattern.test(str));
        alert(pattern.test(str2));
        
        var pattern = /g\w*gle/; //\w*匹配任意多个所有字母数字_
        var str = 'google';
        alert(pattern.test(str));
        
        var pattern = /google\d*/; //\d*匹配任意多个数字
        /*
        var str = 'google444';
        alert(pattern.test(str));
        
        
        var pattern = /\D{7,}/; //\D{7,}匹配至少 7 个非数字
        var str = 'google8';
        alert(pattern.test(str));
        
        var pattern = /g[a-zA-Z_]*gle/; //[a-z]*表示任意个 a-z 中的字符
        var str = 'google';
        alert(pattern.test(str));
        
        var pattern = /g[^0-9]*gle/; //[^0-9]*表示任意个非 0-9 的字符
        var str = 'google';
        alert(pattern.test(str));
        
        var pattern = /[a-z][A-Z]+/; //[A-Z]+表示 A-Z 一次或多次
        var str = 'gOOGLE';
        alert(pattern.test(str));
        
        var pattern = /g.*gle/; //.匹配 0 到多个
        var str = 'google'; //*,?,+,{n,m}
        alert(pattern.test(str));
        
        var pattern = /^[a-z]+\s[0-9]{4}$/i;
        var str = 'GOogle 2012';
        alert(pattern.exec(str)); //返回整个字符串
        
        var pattern = /^[a-z]+/i; //只匹配字母
        var str = 'google 2012';
        alert(pattern.exec(str)); //返回 google
        
        var pattern = /^([a-z]+)\s([0-9]{4})$/i; //使用分组
        var str = 'google 2012';
        console.log(pattern.exec(str));
        alert(pattern.exec(str)[0]); //google 2012
        alert(pattern.exec(str)[1]); //google
        alert(pattern.exec(str)[2]); //2012
        
        var pattern = /\.\[\/b\]/; //特殊字符，用\符号转义即可
        var str = '.[/b]';
        alert(pattern.test(str));
        
        var pattern = /^\d+/gm; //启用了换行模式
        var str = '1.baidu\n2.google\n3.bing';
        var result = str.replace(pattern, '#');
        alert(result);*/
        
        检查邮政编码//共6位数字，第一位不能为0
        /^[1-9]\d{5}$/
        /^\d{6}$/
        检查文件压缩包//xxx.zip\xxx.gz\xxx.rar
        /^\w+\.(zip|gz|rar)$/
        删除多余空格  //
        str.replace(/\s+/,'');
        删除首尾空格
        str.replace(/^\s+/,'');
        str.replace(/\s+$/,'');
        电子邮件(xxxxx@xxxx(.xxxx)+)
        /^\w+@\w+(\.\w+)+$/
        手机号
        /^[1-3]\d{10}$/
        /^1\d{10}$/
        身份证
        /^\d{17}(\d|X)$/
        日期(xxxx-xx-xx|xxxx/xx/xx|xxxx.xx.xx)
        /^\d{2}|\d{4}[-\/\.]\d{2}[-\/\.]\d{2}$/

        只能输入中文
        str.replace(/[^\u4e00-\u9fa5]/g,'');
        账户名只能使用数字字母下划线，且数字不能开头，长度在6-15之间
        /^[a-zA-Z_]\w{5,14}$/
        验证IP
        (xxx.)xxx.xxx.xxx| 
        /^[12]\d{0,2}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
        254.245.255.255
        240.196.19.5
        /^((25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\.){3}(25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)$/
        将所有的bag、beg、big和bog改为bug
        str.replace(/(bag|beg|big|bog)/g,'bug');
        将所有方法foo(a,b,c)的实例改为foo(b,a,c)
        str.replace(/foo\(([^,]+),([^,]+),([^,]+)\)/g,'foo($2,$1,$3)');
        /*
          IPv4
          A: 1-126      10.0.0.0 私有IP  10.0.0.0  网络段 10.255.255.255  广播地址
          B: 128-191   172.16.0.0 —— 172.31.255.255 私有IP
          C: 192-223   192.168.0.0 _ 192.168.255.255
          D: 224-239  组播
          E: 240-255  科研
          127：回环地址
        */
        身份证：/^[1-9]\d{5}[1-9]\d{3}(0[1-9]|1[0-2])(0[1-9]|(1|2)\d|3[01])\d{3}(\d|x)$/i
        年：/^[1-9]{1}\d{3}$/g
        月：/^([1-9]{1}|(1[0-2]{1}))$/g
        日：/^([1-9]{1}|((1|2){1}\d{1})|(3[01]{1}))$/g;
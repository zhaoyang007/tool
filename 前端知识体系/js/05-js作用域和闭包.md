### 变量的生命周期

在 javascript 中声明一个变量是使用 var 来声明的。一个变量的声明意味着就是我们在内存当中申请了一个空间用来存储。如果我们一直的声明变量，不释放的话。会占用很大的内存。在 c/c++ 当中是需要程序员在合适的地方手动的去释放变量内存，而 javascript 和 java 拥有垃圾回收机制，它们会自己回收。但有的时候我们需要让局部变量的生命周期长一点，这个时候在 js 当中就有了闭包，它能够很好的解决这个问题。

JavaScript 执行过程中内存分配：

* 为变量对象分配需要的内存
* 在分配到的内存中进行读/写操作
* 不再使用时将其销毁，释放内存

垃圾回收机制：

JavaScript 中有自动垃圾回收机制，会通过标记清除的算法识别哪些变量对象不再使用，对其进行销毁，释放其内存。开发者也可在代码中手动设置变量值为 null 进行标记清除，让其失去引用，以便下一次垃圾回收时进行有效回收。

局部环境中，函数执行完成后，函数局部环境声明的变量不再需要时，就会被垃圾回收销毁（理想的情况下，闭包会阻止这一过程）。全局环境只有页面退出时才会出栈，解除变量引用，所以开发者应尽量避免在全局环境中创建全局变量，如需使用，也要在不需要时手动标记清除，将其内存释放掉。



### 闭包

在编程语言领域，闭包表示一种函数。

带有一系列信息的函数。

闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境。

这个古典的闭包定义中，闭包包含两个部分。

* 环境部分
  * 环境
  * 标识符列表
* 表达式部分

在 JavaScript 中找到对应的闭包组成部分。

* 环境部分
  * 环境：函数的词法环境（执行上下文的一部分）
  * 标识符列表：函数中用到的未声明的变量
* 表达式部分：函数体

至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。

这里我们容易产生一个常见的概念误区，有些人会把 JavaScript 执行上下文，或者作用域（Scope，ES3 中规定的执行上下文的一部分）这个概念当作闭包。实际上 JavaScript 中跟闭包对应的概念就是“函数”，可能是这个概念太过于普通，跟闭包看起来又没什么联系，所以大家才不自觉地把这个概念对应到了看起来更特别的“作用域”吧。

> 总结：有两个函数，内部函数使用了外部函数环境中定义的变量，当内部函数执行的时候，外部函数就形成了一个闭包。这个变量可以常驻内存，不被垃圾回收。

作用域：作用域就是变量，对象，函数查找的地方，代表了它们合法的使用范围。

作用域链：自由变量查找的顺序。

自由变量：当前作用域没有定义，但是使用了的变量。

自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在函数执行的地方。

闭包其实是作用域应用的一种特殊情况，正常的函数定义在什么地方，就会在什么地方执行。但闭包不一样，函数定义的地方和函数执行的地方它是不一样的。

##### 函数作为参数被传递

也就是函数在这个地方定义好之后，传递到另一个地方去执行。

```js
function print (fn) {
  let a = 200
  fn()
}
let a = 100
function fn () {
  console.log(a)
}
print(fn) // 100
```

##### 函数做为返回值被返回

函数在这个地方定义好之后，它会被返回到另一个地方去执行。

```js
function create () {
  let a = 100
  return function () {
    console.log(a)
  }
}
let fn = create()
let a = 200
fn() // 100
```



### 闭包应用

1.由于 js 作用域链的存在，只能内部环境访问外部环境，不能从外部访问内部。

```js
function a() {
  var i=0;
  function b() {
    alert(++i)
  }
  return b
}
var c = a()
c()
```

2.由于 js 变量生命周期的存在，变量无法常驻内存

创建 10 个 \<a> 标签，点击的时候弹出对应的序号。

因为事件绑定的函数定义时里面的 i 是找的全局作用域 i，当遍历结束后，这个全局i已经变成 10 了。这时点击触发函数里面的 i 就会向上找到全局变量 i，所以都会弹出 10。

```js
let i, a
for (i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function (e) {
    e.preventDefault()
    alert(i)
  })
  document.body.appendChild(a)
}
```

i 变成了块级作用域中的变量，每次 for 循环执行的时候都会形成一个新的块，这时配合事件绑定的函数就形成了一个闭包，所以每次循环的变量 i 都会保存下来。这时点击触发函数里面的 i 就会向上找到块级作用域里的变量 i，所以就会弹出对应的 i。

```js
let a
for (let i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function (e) {
    e.preventDefault()
    alert(i)
  })
  document.body.appendChild(a)
}
```

这种写法跟第二种的目的和解释是一样的，只是写法不同。这种情况是针对不会立即执行的函数中存在自由变量的取值的情况可能会被外面作用域里的数据的改变所影响。解决的办法就是让这个自由变量存在在闭包中，这时它就能常驻内存了。

```js
let i, a
for (i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', (function (i) {
    return function (e) {
      e.preventDefault()
      alert(i)
    }
  })(i))
  document.body.appendChild(a)
}
```

3.闭包内的局部变量不会影响到闭包外的同名变量，即可用闭包形成一个块级作用域。

可以通过立即执行函数，来达到隐藏细节的目的，这样在模块外部无法修改我们没有暴露出来的变量、函数，可以做 js 模块化。

```js
var myModule = (function () {
  var var1 = 1
  var var2 = 2
  function fn1 () {

  }
  function fn2 () {

  }
  return {
    fn1: fn1,
    fn2: fn2
  }
})()
```

4.隐藏数据

我们通过闭包把一些数据隐藏起来，不让外界去改变，只提供 api，去管理里面的数据。

```js
function createCache () {
  const data = {} // 闭包中的数据，被隐藏，不被外界访问
  return {
    get (key) {
      return data[key]
    },
    set (key, value) {
      data[key] = value
    }
  }
}
const c = createCache()
c.set('a', 100)
console.log(c.get('a'))
```

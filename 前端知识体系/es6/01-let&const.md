##### let

* let 声明的变量是拥有块级作用域的。
* 用 let 声明的全局变量不能通过 window 的属性去访问。
* var 定义的变量可以重复，let 声明的变量不允许重复定义。
* let 声明的变量不会进行变量提升。

##### const

* const 具备以上 let 的所有特点
* const 它定义的是常量。既然是常量，也就是说它不能再被修改了。
* const 不允许先声明再赋值，let, var 都可以，就是声明的时候必须做初始化。



### 作用域分类

##### 全局作用域

在程序的任何一个地方（包括不同的文件）都可以轻易拿到我们定义的变量，那这个变量就是全局变量，它拥有的作用域就是全局作用域。

只要在函数外部定义的变量基本上都是全局变量。

在函数内部或者代码块中没有定义的变量实际上也是全局变量，它们也是具备全局作用域的。

通过定义的全局变量和没有通过定义的全局变量都是挂载到全局对象 window 上的属性，但是通过定义的变量不可以用 delete 删除，没有通过定义的全局变量可以用 delete 删除。

##### 函数作用域

在函数内部定义的变量就是拥有局部作用域，简称函数作用域。

函数作用域让这个变量屏蔽在函数内部，在这个函数内部做的事情，在函数外部得不到任何信息。

但有的时候，我希望这个函数内部的一些值是被外部所共享的，那这个时候该怎么办呢，有两个方式：

* 第一个就是使用 return 向外传递一个值。

* 第二个是可以利用闭包的方式向外传递这个信息。

  ```js
  function test () {
  	var a = 3
    function test2 () {
      return a
    }
    return test2
  }
  ```

  闭包就是我并没有直接向外暴露函数内部的变量 a，暴露的是这个函数，而这个函数可以拿到 a，相当于通过闭包的方式拿到了 a 的信息。

  但是为什么我可以在 test2 中拿到这个变量 a 呢，因为 test2 里面的变量它依然可以向上找，在当前作用域找不到的时候它向上一级作用域找，这就是函数作用域的作用域链。都没有的话它会找到最顶层就是 window 了，如果 window 里也没有，那这个变量就返回 undefined，作用域链就是这么一层一层的向上找的。

##### 块状作用域

es6 中新增加的叫块状作用域。

可以理解为只要有花括号的地方它就是一个块，这个块是独立的，跟外界分离开的。

这个块里不能再用 var 来定义变量，var 声明的变量是有变量提升的，所以 var 声明的变量的作用域是没办法局限在块级作用域内的。

块状作用域加 let 和 const 配合。变量就不会有变量提升，不会变量提升它就老老实实呆在它这个块里面，这个块之外是访问不到块里面的内容的。

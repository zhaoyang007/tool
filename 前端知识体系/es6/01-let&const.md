### let const

这两个是定义变量的方式，在讲清这两个之前，我们必须先讲一下前置条件，就是作用域。

几乎所有编程语言就是在变量中存储值，并要求能读取和修改此值，事实上，在变量中存储值或取出值的能力给程序赋予了状态，如果没有这样的概念，一个程序虽然可以执行一些任务，但是它们将会受到极大的限制而不会非常有趣。

这些变量该如何存储又该如何读取，所以程序员都设定了一些规则，比如哪些地方可以读取变量，哪些地方可以修改变量，这个规则我们管它叫作用域。

#### let

* let 声明的变量是拥有块级作用域的。
* 用 let 声明的全局变量不能通过 window 的属性去访问。
* var 定义的变量可以重复，let 声明的变量不允许重复定义。
* let 声明的变量不会进行变量提升。

#### const

* const 具备以上 let 的所有特点
* const 它定义的是常量。既然是常量，也就是说它不能再被修改了。
* const 不允许先声明再赋值，let, var 都可以。就是在声明的时候没有做初始化的动作是不被允许的。



### js 层面的作用域分类

#### 1.全局作用域

在程序的任何一个地方（包括不同的文件）都可以轻易拿到我们定义的变量，那这个变量就是全局变量，它拥有的作用域就是全局作用域。

只要在函数外部定义的变量基本上都是全局变量。

在函数内部或者代码块中没有定义的变量实际上也是全局变量，它们也是具备全局作用域的。

通过定义的全局变量和没有通过定义的全局变量都是挂载到全局对象 window 上的属性，但是通过定义的变量不可以用delete 删除，没有通过定义的全局变量可以用 delete 删除。

#### 2.函数作用域
在函数内部定义的变量就是拥有局部作用域，简称函数作用域。

函数作用域让这个变量屏蔽在函数内部，在这个函数内部做的事情，在函数外部得不到任何信息。

但有的时候，我希望这个函数内部的一些值是被外部所共享的，那这个时候该怎么办呢，有两个方式：

* 第一个就是使用 return 向外传递一个值。

* 第二个是可以利用闭包的方式向外传递这个信息。

  ```js
  function test () {
  	var a = 3
    function test2 () {
      return a
    }
    return test2
  }
  ```

  闭包就是我并没有直接向外暴露函数内部的变量 a，暴露的是这个函数，而这个函数可以拿到 a，相当于通过闭包的方式拿到了 a 的信息。

  但是为什么我可以在 test2 中拿到这个变量 a 呢，因为 test2 里面的变量它依然可以向上找，在当前作用域找不到的时候它向上一级作用域找，这就是函数作用域的作用域链。都没有的话它会找到最顶层就是 window 了，如果 window 里也没有，那这个变量就返回 undefined，作用域链就是这么一层一层的向上找的。

#### 3.块状作用域

es6 中新增加的叫块状作用域。

可以理解为只要有花括号的地方它就是一个块，而且这个块是独立的，它可以跟外界分离开。

那这个块里的作用域不能再用 var 来定义变量了，因为在 js 里有个概念，叫做变量提升。凡是用 var 声明的变量都会有变量提升的概念。这里如果用 var 配合我的块状作用域来做那就跟变量提升的概念相违背。

我们要做这个隔离块的话，就要用 let 和 const，块状作用域加 let 和 const 配合。变量就不会有变量提升，不会变量提升它就老老实实呆在它这个块里面，这个块之外是访问不到块里面的内容的。

#### 4.动态作用域

this 在各个场景中取什么样的值是在函数执行的时候确定的，不是在函数定义的时候确定的。

this 到底是什么，它跟动态作用域之间有什么关系。

this 是动态指向的，它不是固定指向的。它的作用域就是动态的。所以一般情况下我们管它叫做动态作用域。

因为它是动态的，所以有很多方法能够改变这个 this 指向。	

bind 的意思是让函数动态绑定到一个对象上去，这个时候 this 指向这个对象本身。

```js
window.a = 3
function test () {
	console.log(this.a)
}
test()
test.bind({a: 100})()
```

1.let, const
  1.这两个是定义变量的方式，在讲清这两个之前，我们必须先讲一下前置条件，就是作用域。
  2.那我们来说一下什么是作用域呢，几乎所有编程语言就是在变量中存储值，并要求能读取和修改此值，事实上，在变
    量中存储值或取出值的能力给程序赋予了状态，如果没有这样的概念，一个程序虽然可以执行一些任务，但是它们将
    会受到极大的限制而不会非常有趣。
  3.这些变量该如何存储又该如何读取，所以程序员都设定了一些规则，比如哪些地方可以读取变量，哪些地方可以修改
    变量，这个规则我们管它叫作用域。
  4.js层面的作用域分类
    1.全局作用域
      1.全局作用域的目的
        希望我们在程序的任何一个地方(包括不同的文件)都可以轻易拿到我们定义的变量，那这个变量就是全局变量，
        它拥有的作用域就是全局作用域。
      2.什么时候定义的变量算是全局变量呢
        只要在函数外部定义的变量基本上都是全局变量。
      3.全局变量特别要注意的点
        1.在函数内部或者代码块中没有定义的变量实际上也是全局变量，它们也是具备全局作用域的。
        2.通过定义的全局变量和没有通过定义的全局变量都是挂载到全局对象window上的属性，但是通过定义的变量不
          可以用delete删除，没有通过定义的全局变量可以用delete删除。
    2.函数作用域
      1.在函数内部定义的变量就是拥有局部作用域，简称函数作用域，通常在es6之前，你说局部作用域的时候就是和全
        局作用域相对的，一个是全局作用域，一个是局部作用域。这个局部作用域其实说的就是函数作用域。
      2.函数作用域其实非常简单，让这个变量屏蔽在函数内部，我在这个函数内部做的事情，在函数外部你不要得倒任何
        信息，它是有一个屏蔽作用的，这就是局部作用域的一个概念。
      3.有的时候，我们希望这个变量屏蔽在我的函数内部，但有的时候，我希望这个函数内部的一些值是被外部所共享的，
        那这个时候该怎么办呢，有两个方式：
        1.第一个就是使用return向外传递一个值。
        2.第二个是可以利用闭包的方式向外传递这个信息。
          function test () {
            var a = 3
            function test2 () {
              return a
            }
            return test2
          }
          闭包就是我并没有直接向外暴露函数内部的变量a，暴露的是这个函数，而这个函数可以拿到a，相当于通过闭包
          的方式拿到了a的信息。但是你想没想过为什么我可以在test2中拿到这个变量a呢，因为test2里面的变量它依
          然可以向上找，这就是作用域的本质，在当前作用域找不到的时候它向上一级作用域找。这就是把函数作用域的
          作用域链。都没有的话它会找到最顶层就是window了，如果window里也没有，那这个变量就返回undefined，
          作用域链就是这么一层一层的向上找的。借助函数作用域我们把作用域链又重新回顾了一遍。
    3.块状作用域
      1.es6中新增加的叫块状作用域
      2.可以理解为只要有花括号的地方它就是一个块，而且这个块是独立的，它可以跟外界分离开。
      3.那这个块里的作用域不能再用var来定义变量了，因为在js里面有个概念，叫做变量提升。凡是用var声明的变量都
        会有变量提升的概念。在这里如果用var配合我的块状作用域来做那就跟变量提升的概念相违背。
      4.我们要做这个隔离块的话，就要用let和const，块状作用域加let和const配合。变量就不会有变量提升，不会变
        量提升它就老老实实呆在它这个块里面。而这个块之外是不被访问到块里面的内容的。
    4.动态作用域
      1.this到底是什么，它跟动态作用域之间有什么关系。
      2.this是动态指向的，它不是固定指向的。它的作用域就是动态的。所以一般情况下我们管它叫做动态作用域。它是动
        态的。有很多方法能够改变这个this指向。
        window.a = 3
        function test () {
          console.log(this.a)
        }
        test()
        test.bind({a: 100})()
        bind的意思是说让函数动态绑定到一个对象上去，这个时候的this指向这个对象本身。由这种效果才会导致同一个
        函数却会执行出不同的结果出来。就是因为跟这个动态绑定，动态作用域有关系。
      3.bind, call, apply
        call, apply
          1.可以用来重新定义函数的执行环境，也就是this的指向。(对象拿函数的值)
            1.就是将传进去的对象替换掉函数的this，以此来让这个对象拥有函数中this里面拥有的东西
            2.用来做继承，使对象拥有这个函数内部用this定义的属性和方法
            function ClassA () {
              this.a = 123
            }
            var obj = {}
            console.log(obj.a) // undefined
            classA.call(obj)
            console.log(obj.a) // 123
          2.特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。(函数拿对象的值)
            1.就是让函数有对象中的值。
            function ClassA () {
              console.log(this.a)
            }
            classA() // undefined
            classA.call({a: 123}) // 123
          12注：因为更改this指向就是使对象和this相等了，所以它们之间的值就是一样的了。它们之间有同样的值，以
               函数中的为准。
            function b () {
              this.a = 1
            }
            o = {
              a: 2
            }
            b.call(o) 
            console.log(o.a) // 1
        bind
          1.bind()的作用与call()和apply()一样，都是可以改变函数运行时上下文，区别是call()和apply()在调用
            函数之后会立即执行，而bind()方法调用并改变函数运行时上下文后，返回一个新的函数，供我们需要时再调用
  5.let
    1.let声明的变量是拥有块级作用域的。
    2.用let声明的全局变量不能通过window的属性去访问。
    3.var定义的变量可以重复，let声明的变量不允许重复定义。
    4.let声明的变量不会进行变量提升。
  6.const
    1.const具备以上let的所有特点
    2.const它定义的是常量。既然是常量，也就是说它不能再被修改了。
    3.const不允许先声明再赋值，let, var都可以。就是在声明的时候没有做初始化的动作，这个是不被允许的。
2.数组
  1.ES5中数组有多少种遍历的方法？
    1.for循环
    2.forEach
      forEach跟for做对比，forEach的写法更加简洁，但是它也带来了问题，它不支持break和continue，也就是说当
      你选用forEach对数组进行遍历的时候，你要知道break和continue已经失效了，它所遍历的就是从头到尾，每个元
      素必须遍历到。这是它的用法。
    3.every
      const arr = [1, 2, 3, 4, 5]
      arr.every(function (item) {
        console.log(item) // 1
        // return true
      })
      every去遍历一个数组的时候，它能不能继续向下遍历取决于这个函数体的返回值，而上面这个函数的返回值默认是false，
      也就是说不要继续往下遍历，这是它的默认值，如果你想改变它的默认行为，你要在这个函数体后面加一句，return true，
      也就是说这个时候已经能遍历所有的元素。既然这个时候它和forEach的行为很像了，那为什么要新增every的api，因为
      forEach它有弊端，它是有应用场景的局限性的，它不支持break和continue。但every可以，因为every能不能向下遍
      历取决于你这个函数的返回值，这样就受你程序的控制了。这是它们两个本质的区别。every返回值是布尔值，每个函数体
      都返回true，every的返回值为true，否则为false。
    4.forEach和every虽然不能直接写break和continue，但是可以实现一样的效果。
      1.forEach
        1.continue
          可以使用条件判断的方式实现
        2.break
          1.try catch throw
            let arr = [1, 2, 3, 4, 5]
            try{
              arr.forEach(item => {
                if (item === 3) {
                  throw new Error('出错了')
                } else {
                  console.log(item)
                }
              })
            } catch(e){
              throw e
            }
          2.空跑循环
            在外层加一个标识。这种会影响性能，因为效果是实现了，但是循环并没有停止，会一直遍历到最后。
            let breakFlag = false
            let arr = [1,2,3,4,5]
            arr.forEach(item => {
              if (breakFlag === true) {
                return
              }
              if (item===3) {
                breakFlag = true
                return
              }
              console.log(item)
            })
      2.every可以使用条件判断的方式实现continue。使用条件判断的加上return false的方式实现break。
    5.for in
      for in是为object来做遍历来设计的，不是为数组设计的。它确实能遍历数组，但是会有问题。
      const arr = [1, 2, 3, 4, 5]
      for (let index in arr) {
        console.log(index, arr[index]) // 0 1, 1 2, 2 3, 3 4, 4 5
      }
      之所以for in能遍历数组，有两个因素。第一数组也是对象的一种，第二，数组是可遍历的。在ES6中，关于一个对象是不
      是可遍历的，会有另一种定义，特别强调，一个对象是不是可遍历不是你理解的像数组那样它就是，比如说你觉得对象是可
      遍历的，数组是可遍历的，除了这两种结构之外，都是不可遍历的。如果你用这个方式去判断一个对象是不是可遍历的，那
      就大错特错。数组既然是对象，我是不是就能往这个对象上挂一些属性，比如说arr.a = 8，按照我们刚才讲的，这个自定
      义属性应该不是数组中的一个元素，我们这个数组中的元素是12345。这个时候我增加了一个属性，看看遍历出来的是什么。
      不仅把12345遍历出来了，还把a和8遍历出来了，这个就有点怪异了，数组里面的索引怎么可能是a呢，这个时候你发现它是
      达不到预期的，我的索引0到4，这个时候a按照常规的理解，它不应该是索引，我们说数组的索引一般都是数字，它不应该是
      一个字符串，那么在这里a很明显它就是个字符串。这就是for in遍历数组的瑕疵。因为for in它是为对象设计的，很明显
      数组它也是一个对象，数组的索引，大家认为它就是数字，其实不是的，它也可以是字符串的。但是要注意for in遍历出数
      组的索引index是字符串，for遍历的index是数字。那么for in能不能做break和continue呢，因为这个是遍历的时候
      非常重要的控制元素，for in它是支持break和continue的。
  2.ES6中它们是怎么做遍历的？  
    1.for of 
      你要判断一个对象是不是可遍历的不能用常规的思维说它是不是个数组或者是不是一个object，你如果这么判断那就大错特
      错，既然不能用这个思维去判断一个对象是不是可遍历的，那意味着很多对象它跟数组或object不一样，但是还能被遍历，
      是不是可以这样理解。像every,forEach,for循环，它都是专门针对数组的遍历。而for in它是专门为object设计的遍
      历。也就是说这几种方法就是为数组和object设计的，那除了数组和object之外可遍历的对象拿什么遍历呢，那就是我们
      今天要讲的for of。在es6之前，你要认为只有数组和object可以遍历，没什么问题，因为大家平时的遍历接触的无非就
      是object和数组，那么这两种情况的遍历就用我们上面讲的for,forEach,every,for in这四种方法足够用了，但是到
      了es6的时候不是这样了，es6允许你自定义数据结构，这个数据结构不是数组也不是object，什么样的数据结构都可以，
      什么样的类型都可以，你可以随意组装一个数据结构，组装出来它既不是数组也不是object，但是只要你按照es6的这个标
      准，是可以把它构造成一个可遍历的，但是这个可遍历的对象不能用for,forEach,every,for in去遍历。那怎么办呢，
      就用我们接下来讲的for of。for of它也可以遍历数组，只是它的功能比遍历数组更强大而已。
  3.数组的转换功能
    1.伪数组
      函数的arguments和dom中的nodelist就是伪数组，它和数组非常相似，在理解的时候你通常会认为集合就等于数组，然而
      在编程的时候你发现集合它调用不了数组的api，比如我们刚才说的arguments，如果你直接用arguments.slice()会发现
      报错，说明arguments不具备slice的方法，这个是伪数组的概念。伪数组具备数组的一些特性，比如它们都具备长度都能遍
      历，但是它不能直接调用数组的方法。既然它在特性上像数组，但是又不能直接调用数组的方法，那我们比如说想遍历想查找，
      我们该怎么做呢，首先你要把它转换成数组。因为它是可转换的。
      伪数组具备两个特征：
        1.这个对象是按照索引方式存储数据的
        2.它具备一个length属性
        {0: 'a', 1: 'b', length: 2}这个对象就叫伪数组
    2.es5中将伪数组转换成数组
      [].slice.call(arguments) // 把arguments转换成数组
      [].slice.call(document.querySelectorAll('img')) // 把NodeList转换成数组
    3.es6的做法
      1.Array.from // 这个from就是用来转换伪数组到数组的
        let args = Array.from(arguments)
        let img = Array.from(document.querySelectorAll('img'))
      2.from除了能把伪数组转换成数组这个功能之外，它还具备其他的功能吗
        1.from参数
          Array.from(arrayLike, mapFn, thisArg)
          1.arrayLike  伪数组
          2.mapFn  遍历函数，说明from还具备map也就是遍历的功能
          3.thisArg  mapFn中的this指向
        2.初始化数组长度为5，每项为1
          1.es5
            let array = Array(5)
            for (let i = 0, len = array.length; i < len; i++) {
              array[i] = 1
            }
            这里用forEach不行
          2.es6
            let array = Array.from({length: 5}, function () {return 1})
  4.如何创建一个新数组
    1.es5生成新数组
      1.let array = Array(5)
      2.let array = []
    2.es6
      1.上节讲的Arrar.from也是新生成数组的一种方式
      2.Array.of
        快速的把n个元素放到一个数组里面去，这个方法就是array.of
        1.es5使用生成一个新数组，然后往里面push的方法
        2.es6
          let array = Array.of(1, 2, 3, 4, 5)
      3.Array.prototype.fill
        1.let array = Array(5).fill(1)  // 生成一个长度为5每一项为1的数组
        2.Array().fill(value, start, end)
          value 填充的值
          start 填充指定范围的起始位置，默认值是0
          end 填充指定范围的截止位置，默认值是数组的最后一个元素
        3.不用来生成新数组，也可以用做对已有数组的填充，就是替换数组的某一块区域的值
          // 将数组的第三项第四项更换为8
          let array = [1, 2, 3, 4, 5]
          console.log(array.fill(8, 2, 4)) // [1, 2, 8, 8, 5]
          console.log(array) // [1, 2, 8, 8, 5]
    3.所以以后在业务场景中再生成新数组，不要只知道加一个字面量或用Array的构造函数去做，你有很多种方法，es6至少提
      供给你了三种方法，from,of,fill
  5.如何查找数组
    1.在遍历的过程中去找都可以，只要是遍历都能找到这个元素
    2.关于查找分几个概念
      1.查找的目的是为了验证某个元素在这个数组当中
      2.还有个查找的维度是我要把满足每个条件的筛出来
    3.es5
      1.filter
        let array = [1, 2, 3, 4, 5]
        let find = array.filter(function (item) {
          return item === 3 // return item === 6
        })
        console.log(find) // [3]
        console.log(find) // []
        我们在用es5的filter做查找的时候，如果找到，那返回的这个数组一定是不为空的，也就是数组的长度一定是不为0，找
        到与没找到它都会返回一个数组，你要去判断这个数组的长度来确定元素有或者没有，这是判断有无。filter去查找的时
        候，它会把所有满足条件的元素都给筛出来。所以查找的两个filter都能够达到维度。filter功能上很全面，但是它有缺
        点。如果数组长度非常大，数据非常大，我就想知道这个数组中有没有这个元素，我不关心它有多少个，出现多少次，我要
        确保性能，它虽然能实现这个东西，但它不是最高效的。那么在es6中新增加了一个方法验证查找的，就是来弥补这个缺陷
        的。这个方法叫find。
    4.es6
      1.Array.prototype.find
        let array = [1, 2, 3, 4, 5]
        let find = array.find(function (item) {
          return item === 2
        })
        console.log(find) // 2
        它不关注返回的所有的值，我找到了2我就返回2这个数据，没有就返回undefined，它跟filter的返回值完全不一样。
        filter关注的是满足你条件的所有值。而find关注的是满足你条件的第一个值。找到了满足你条件的第一个值，我就返
        回，不再往下找了。它关注的是有和没有而不是所有。这是它的优点也是它的缺点。这就是find和filter的区别。
      2.Array.prototype.findIndex
        它跟find是一对。原理和特点都是一样的。唯独的区别就是find找符合的元素，findIndex找符合元素的下标。
  6.数组总结
    其实关于数组在es6这一部分新增的功能主要围绕了几个方面。因为我们用数组无非就是这几个吗。遍历转换生成吗。
    1.遍历
    2.转换
      在转换这个过程中，指的是伪数组到数组的转换。
    3.生成
      我们想初始化的时候。那么es6提供了很多的数组生成的方法。非常快捷高效。
    4.查找
      最后一个是，只要你用数组基本上都要用查找。为什么要用数组呢，不就是为了找吗。你不能说我生成了一个数据结构，就把
      数据存那，我不用啦，封存啦。不会的。你存这个数据结构就是为了读取查找。
3.class
  在es5的时候是没有专用的写类的语法，虽然js是一切都是对象的这么一个语言，但es5的时候确实没法做到用专用的语法去写一个
  类，都是用函数去模拟，从es6开始已经有了专用的类的语法。
  1.入门的时候都是这样的。先有一个动物类，这是一个父类，然后在延伸出小猫小狗之类的小动物，这样就是一个子类。我们既然用到类了，那
    一般都会用到父类和子类，因为这是一种继承关系。
  2.es5中的做法
    1.es5中是怎么声明一个类的
      1.es5中是用函数来描写类的，对于一个类来说，肯定要有构造函数，构造函数解决什么问题呢，第一个是传参数，第二个是实例化，也就是
        初始化。
      2.我们要想区分这个动物是什么类别，不能大家都长的一样吧，小猫小狗都是一个动物类别那肯定不可以的。这个时候要定义一个属性
        this.type = type
      3.那这样一个类的声明基本上就做完了。
      4.但是，特别要强调的点，这里只有属性，如果我想定义一个方法怎么办，如果你直接向设置属性一样设置一个方法，就会有一个问题，你
        每一个实例它都有这个方法，你可能会问每个对象下面不就应该type属性和eat方法吗，为什么这样是弊端呢。你想想，type也好
        eat也好，它是这个类应该共有的属性吗。就是说小猫小狗这个实例对象上它应该复用一些东西，比如说吃，动物这个类上就应该有这个方
        法，而不是让每个实例上都挂载这样一个方法。
      let Animal = function (type) {
        this.type = type
        this.eat = function () {}
      }
    2.es5中生成一个实例对象 
      let dog = new Animal('dog')
      let monkey = new Animal('monkey')
      console.log(dog) // Animal {type: 'dog', eat: f}
      console.log(monkey) // Animal {type: 'monkey', eat: f}
      dog实例对象也好monkey实例对象也好，这两个实例对象它有区别，比如说它们的type不一样，但是它们的eat一样吗，对于它俩来说
      是一样的，但是从这两个打印出来的对象来讲，它们各自有各自的eat，这个显然不对。既然它俩都应该继承一个父类，如果这样设计的
      话，那就是每个子类对象上都有父类的所有东西，这个不是很合理，至少eat这种它俩都共同有的东西你不应该再各自生成一份。打个比
      方，它俩eat应该是一样的是吧，因为都继承于父类，如果我把一个eat改掉，另一个的eat改了吗，是没改的，因为它实例化之后这是
      两个对象了，你改任何一个都不会影响另一个，这样的话就违背了继承的原则，什么叫继承，大家都继承于父类的eat，如果父类的eat
      被修改之后，那所有的实例对象都应该跟着改变，这才叫继承，如果做不到那就不对，一百个方法，你会发现每个对象下面都有一堆这玩意
      。显然这是不合理的。
    3.那我们遇到上面的问题应该怎么写呢 
      把它们共有的方法写在这个类的原型上去，函数都有一个prototype这个对象，你可以往这个上面去写，也就是类继承的工作原理，它
      会沿着原型链一直往上找。你会发现eat没有了，它就是把eat挂在了这个原型链上去，它不在这个实例本身，而在它的原型链上
      let Animal = function (type) {
        this.type = type
      }
      Animal.prototype.eat = function () {}
      let dog = new Animal('dog')
      let monkey = new Animal('monkey')
      console.log(dog) // Animal {type: 'dog'}
      console.log(monkey) // Animal {type: 'monkey'} 
      此时，你这样修改eat就不会违背继承的原则，一个实例的公共方法修改，另一个实例也会跟着修改
      dog.constructor.prototype.eat = function () {console.log(111)}
      console.log(dog.eat()) // 111
      console.log(dog.monkey()) // 111
      这样的话，我想改变公共方法的时候，每个实例都可以去改，因为它们是继承于同一个地方，这是跟刚才我们讲的本质的区别。这个
      地方就是用原型链，但是刚才那个做法你是做不到的，因为它实例化的时候每个对象相当于是做了一个备份，备份之间又不相互通，
      所以你改了自己这个公共方法的时候，你发现通过继承的时候你改变不了别人，你只能改变自己。这个就违背了继承的原则，而利用
      这种方式就可以了，我去修改我们共同的方法，那这样大家都跟着变了，你有多少实例也都跟着变，这才是继承的本质。
    4.总结
      1.es5中在做类的定义的时候，如果你把所有共用的东西都写在函数体内部，这个是不合理的。正确的做法是，所有实例对象想共有的
        东西你要放在prototype上去。
      2.为什么这样做还有第二个原因，你要把这个function当成一个构造函数去用，构造函数内部哪些是这个实例对象想自己独一份的
        东西你往里面放，大家通用的东西你放到原型链上去。
  3.es6中的做法
    es6已经有了专用的语法。
    1.定义类
      class Animal {

      }
    2.类定义完了，接着还是刚才那两个步骤，构造函数初始化传参，在es6中它的构造函数是这样的。
      构造函数就是为了传参的
      class Animal {
        // 构造函数
        constructor (type) { 
          this.type = type
        }
        // 公用方法，挂载在原型上的方法
        eat () { 

        }
      }
    3.class只是es5用原型链声明类的一个语法糖，语法不一样，但最后的本质是一样的，这就是语法糖。
  4.类的属性
    前面我们讲了类的定义以及实例化，接下来我们讲一下属性
    1.如果你想保存一个私有属性private
    2.如果我想让我这个属性是只读的
    通过这两个点，我们引出es6中的getter和setter，也就是我们属性的读与写的操作，es6是如何做到属性的保护以及只读。
    class Animal {
      constructor (type) { 
        this.type = type
      }
      get age () {
        return 4
      }
      set age (val) {
        this.realAge = val // 这里不能再给age赋值了，不然就变成死循环了
      }
    }
    let dog = new Animal()
    console.log(dog.age) // 4
    dog.age = 5
    console.log(dog.age) // 4
    console.log(dog.realAge) // 5
    我们想做这个对象的属性是只读的，在es6定义的类比es5的function那种做法要灵活了很多，而且它也扩展了一些功能，它不
    要求你所有的属性都必须写在consturctor也就是构造函数里面，它允许你把这个属性放在类的最顶层，但是你放在顶层的时候
    ，前边一定要加get或者是set，这样就对应着getter和setter，就是读和写，也就是说你如果这个age看上去是一个函数，前
    面如果是get或者set它就变成了属性，这个是之前你绝对没见过的，就是我们特别要注意的点。
    get你可以理解为一个对外的出口，set age里面的赋值就不能是age本身了，你可以是别的。上面get里返回的4，我们只是表示
    它的年龄，但是4和age本身它俩不是一个等量的关系，你可以返回任何值，age只是让你这个实例能访问一个对象访问一个数值访
    问一个入口，你只是用age这个出入口，你可以理解为age是你一个出入口的名称，而不是你这个实例对象的一个属性的名字，它
    增加这个功能的含义就是为了让你控制你的属性的只读或者说是有条件的写入，如果没有setter和getter的话你做不到这样，它
    改变这个属性，你赋成什么，它就改成什么了，但是有了setter和getter后，你会发现，你在set和get这个函数体里面做你任
    何想做的逻辑，这个是之前属性之间的简单的赋值和读取所做不到的。setter和getter它让你做到了你在读写的时候可以灵活改
    变返回值，但是这个返回值跟你这个出入口的名字不要一样。
    let _age = 4
    class Animal {
      constructor (type) { 
        this.type = type
      }
      get age () {
        return _age
      }
      set age (val) {
        if (val > 4 && val < 7) {
          _age = val
        }
      }
    }
    let dog = new Animal('dog')
    console.log(doa.age)
    dog.age = 5
    console.log(dog.age)
    通过这个setter的操作，也就说你可以把setter作为一个拦截，你想给这个age做赋值的时候，它会拦截你，你不满足这个条件
    我就给你拦到外面，满足这个条件我会让你赋值给这个。这样我们做到了它既访问不到了这个真实的_age这个变量，这不就是私有
    属性吗，这样就能够实现私有属性的保护，age是暴露给你这个实例对象操作的出入口，但真实的存储这个年龄的变量它不是age，
    这个age只是给谁来读取这个对象的时候，你给它看的，但并不是它真正存放的地方。这就是set和get的价值所在。
    总结：es5中是怎么读写属性的，就是this.属性，你想拦截，只读，有条件的读和写都做不到。es6通过getter和setter的方式
         能让你在读写属性上面有更大的操作权。甚至可以做一些个性化的定制。
  5.操作方法
    这个方法指两个概念，一个是对象实例的方法；一个是类的静态方法，静态方法它不属于实例对象的，而是属于这个类的。也就是说
    你直接从对象实例上访问这个方法它是没有的，但是你通过这个类来访问这个方法，它是存在的。这就是静态方法和实例对象方法的
    区别。
    1.es5
      let Animal = function (type) {
        this.type = type
        this.eat = function () {}
      }
      Animal.prototype.eat = function () {

      }
      实例对象的方法它是挂载在prototype上或者挂载在this上的。
      es5的静态方法该怎么写
      Animal.walk = function () {}
      可以看出来，静态方法是挂载在Animal这个类上的，而不是挂在prototype上，这个是非常要注意的点。
    2.es6
      class Animal {
        constructor (type) { 
          this.type = type
        }
        // 公用方法，挂载在原型上的实例对象的方法
        eat () { 
          Animal.walk()
        }
        // 定义类的静态方法
        static walk () {

        }
      }
    3.es5, es6的静态方法只是在定义上有区别，在引用上大家都是一样的，因为静态方法就是属于类的，你调用的时候要用类去
      引用这个方法。
    4.在现实的业务开发中，什么时候用实例对象的方法，什么时候用类的静态方法。这个是要特别注意的。
      思考方式
      如果说你的这个方法依赖于对象的某些属性或者是方法，那这个方法就必须定义为类的实例对象方法。如果说我这个方法里面
      不会涉及到实例对象的内容，你就要用类的静态方法，类的静态方法拿不到当前的实例对象。如果你把这个方法定义为一个静
      态方法，那这个方法跟这个实例对象都绝缘了。要根据业务场景和代码设计去决定。它们本身之间没有优点和缺点。只是哪个
      更适合，哪个不适合。
      静态方法一般就是当作一个功能函数来用就好了。
  6.类的继承
    1.es5
      let Animal = function (type) {
        this.type = type
      }
      Animal.prototype.eat = function () {

      }
      现在我们有一个Animal的类，它要做为一个动物类的最顶层的父类。现在我们想再声明一个它的子类叫狗dog，因为狗又分
      好多种，因为狗它是一个群体，你可以用一个类。但是这个狗它属于动物，也就是说dog类应该继承Animal类，这样dog的
      实例就对应着不同属性的小狗，这是一个继承的概念。面向对象之所以强大，就是因为有继承，什么叫继承呢，就是爹有的
      东西可以继承给儿子，你爹有的东西，儿子只要继承他爹，那他的所有的财产所有的东西，即使儿子什么都不动，他都有。换
      句话说，我们这有一个Dog的类，还有一个Animal的类，Animal上声明的所有的属性和方法，Dog即使什么都不干，它会
      继承Animal类的所有属性和方法，这就是继承的概念。
      1.es5如何实现继承的
        es5中继承有很多种实现方法
        let Dog = function () {
          Animal.call(this, 'dog')
        }
        Animal是父类，Dog是子类，Dog类要继承Animal类，你要做的第一件事情就是在Dog的构造函数中要执行Animal的构造
        函数，并且把实例对象的指针指向当前的Dog类。
        Dog.prototype = Animal.prototype
    2.es6
      // 子类不声明构造函数，此时es6给你写了一个默认的constructor
      class Dog extends Animal {
        
      }
      // 子类声明构造函数
      class Dog extends Animal {
        constructor (type) {
          // super调用必须放到构造函数第一行，这个super就是父类的构造函数
          super(type)
        }
      }
  7.类的总结
    我们关于类这块的内容一共讲述了几个知识点。
    1.类的声明
    2.类的属性，getter和setter如何去做类的属性的读和写，功能上比es5强大了很多
    3.方法
    4.继承
4.es6关于function的更新
  1.函数参数的默认值
    1.es5
      function f (x, y, z) {
        // 如何对待参数缺省的处理，利用这种方式实现了默认值。
        if (y === undefined) {
          y = 7
        }
        if (z === undefined) {
          z = 42
        }
        return x + y + z
      }
      这个函数有3个参数x,y,z，x是必须的参数，yz是可选的参数，既然是可选也就是说允许它为空，这是必须传
      和可选的参数的区别，同时对于可选的参数，我们一般情况下希望它提供默认值。
    2.es6
      1.我们在写这个参数的时候，就同时指定了默认值。要把没有默认值的参数往前写，有默认值的往后靠。
        function f (x, y = 7, z = 42) {
          return x + y + z
        }
        console.log(f(1, 8, 43))
      2.中间的参数需要使用默认值时传undefined就行了。
        console.log(f(1, undefined, 43))
      3.参数的默认值可以是包含其他参数的表达式
        function f (x, y = 7, z = x + y) {
          return x + y + z
        }
      4.有的时候我们在函数内部很想知道这个函数到底传入的几个参数，arguments它的作用就是告诉你当前函数的
        参数情况，函数真正被执行的时候传入了多少个参数都在arguments这个伪数组里面，这是es5中的做法。在
        es6的时候函数内部禁止使用arguments，那怎么办呢。
        1.如果你只是想判断传入了多少个参数，换一个做法就是取你函数的length，f.length，也就是函数体本身
          的length属性。这个时候就分情况了，有默认值的和没默认值的。当你不让我用arguments来获取我输入
          的参数的时候，我用函数体的length属性能获取到没有默认值的参数的个数，也就是说它获取的不是你执行
          的时候输入的参数的个数，而是你定义的时候没有默认值的参数的个数。
  2.不确定参数的问题
    1.es5
      使用arguments
      function sum () {
        let num = 0
        // es5伪数组转数组方式
        // Array.prototype.forEach.call(arguments, function (item) {
        //   num += item * 1
        // })
        // es6伪数组转数组方式
        Array.from(arguments).forEach(function (item) {
          num += item * 1
        })
        return num
      }
    2.es6
      使用rest，它的含义是，用...表示这个函数的所有参数都放在nums这个变量中。
      function sum (...nums) {
        let num = 0
        nums.forEach(function (item) {
          num += item * 1
        })
        return num
      }
      rest有两个用处
      1.rest参数是用来获取所有的参数的，而且是函数被执行的时候的参数
      2.nums它是数组，不是伪数组
      3.它还可以拆开，也就是说把所有输出的参数你先指定1,2,3，剩余的不确定的参数都放到它这里面去。就可以啦。
  3.spread
    上面我们讲述了rest参数它用来处理不确定参数的内容，也就是说我的这个函数在定义的时候，参数是不确定的。我
    用rest这个操作来获取这个问题的解决方式。那么还有一种情况是跟它相反的，我的这个函数在设计参数的时候是固定
    的，但是传入的数据是数组，也就是不确定的内容。
    demo: 计算三角形周长
    1.es5
    function sun (x = 1, y = 2, z = 3) {
      return x + y + z
    }
    let data = [4, 5, 6] // 后端返回数据
    sum(data[0], data[1], data[2])
    我们只能把这个数组中的数据按照索引分别取出来对应我们的x,y,z
    sum.apply(this, data)
    使用apply传参是数组的特性，它允许把函数的参数收敛到一个数组中去调用，它会帮你自动的去做0,1,2跟函数的参数
    的对应。
    2.es6
    sum(...data)
    它跟rest理解为是一个反操作，这个反操作是说这个数据是一个数组，我利用...就把数组的内容打散到我指定的x,y,z
    这个上面去。而rest是说你给的这个x,y,z的三个参数我收敛到数组中去。这就是它们两个是相反操作的原因。一个是收
    一个是散。
  4.rest, spread总结
    rest解决的问题是说当参数不确定的时候，我把所有的参数收敛到我的这个数组中来。跟它相反的情况是说我函数定义
    的时候的参数是确定的，但我传入的数据是一个收敛到一个数组中的所有元素，我希望把数组中的按照索引0,1,2分给
    函数定义时的三个参数x,y,z，它是一个相反的操作。
  5.es6的箭头函数
    () => {}
    es5声明函数
    function hello () {}
    let hello = function () {}
    在es6之前声明函数无非就这两种形式
    es6
    let hello = () => {}
    1.有且只有一个参数的时候()可以省略
    2.返回值是表达式时，可以省略{}和return，如果返回值是一个字面量对象，外面要加一个()，这个小括号就当作运算表达式
      的作用。
    this问题
    普通函数和箭头函数对this的指向定义不同了，普通函数是谁在调用这个函数this就指向谁，箭头函数是我在定义的时候this
    指向的是什么，我在执行的时候this还是什么。
5.es6关于object的更新
  let x = 1; let y = 2; let z = 3
  let obj = {
    'x': x,
    y,
    [z]: 5,
    hello: function () {

    }
  }
  1.属性简写
  2.object key值是变量的时候
    1.es5 
      obj[z] = 5
      es5只能这样写，没别的方式
    2.es6 
      在es6增加了一个语法让这个写法变得更加的简洁
      let obj = {
        [z]: 5,
        [y + z]: 6
      }
      这个z的地方可以写任何的变量或者是表达式
  3.object中的函数的简写
    let obj = {
      hello () {}
    }
  4.object中的异步函数
    在es5中是不允许在object对象中增加异步函数的。
    在es6中是允许的，如果你想把object中的函数变成异步的话，前面加一个星号，这样表明了这个方法是异步的。
    let obj = {
      * hello () {}
    }
    这个简写的形式是其实跟这样声明的函数是一摸一样的
    function * hello () {}
    这个是generator函数，执行这个异步函数之后，它并不是像我们常规函数那样去执行函数体了，它是先返回一
    个对象就叫genetator对象，它返回之后要一步一步的操作才能执行函数体里面的内容。
  5.我们除了可以用object存储数据，在es6中给大家设置了新的数据结构来存储数据
    1.Set
      之前你要存储数据，你更多的是用数组或object，现在你可以多了一个选择叫Set。用Set存储数据有一个什么
      好处呢，就是它所存储的数据必须是唯一的，Set存储的成员不允许是重复的，如果你存入了重复的数据，它会
      帮你自动过滤掉。
      1.这样你就实例化了一个Set对象，但是没有初始化任何数据
        let s = new Set()
      2.初始化数据，Set所接受的参数是一个可遍历的对象，而不是只有数组
        let s = new Set([1, 2, 3, 4])
      3.有了一个对象了，我们要往里面存数据该怎么做呢，存数据用它提供的add api
        s.add('hello')
        也可以及联操作
        s.add('hello').add('goodbye')
      4.删除数据，对于数据的操作来说，无非就是写，读，找，删，改五个操作。
        1.删除指定数据
          s.delete('hello')
        2.全部清空
          s.clear()
      5.查找数据，我用这个数据结构的时候，我特别想知道我里面有没有这个数据
        s.has('hello')
      6.set已经存入数据的长度
        s.size
      7.读，遍历
        s.keys() // 返回的是SetIterator，这个是遍历器
        s.values() // 它们都是返回的我们刚才所存储的这个值本身
        我们推测一下Set这种数据结构本质上它还是一个object对象，我们前面在讲object对象的时候，是不是key,
        value的形式，在目前来看，keys返回的是{'hello', 'goodbye'}, values也返回的是这个。不难推测它
        还是object本质，也是key,value的形式存在。这是大家要注意的一个点。
        keys返回的是键，value返回的是值，如果你想返回键值对。
        s.entries() // {'hello' => 'hello', 'goodbye' => 'goodbye'}
        s.forEach(item => {
          console.log(item)
        })
        所有iterator都可以用for of做，set的实例对象它返回的都是iterator对象
        for (let item of s) {
          console.log(item)
        }
      8.改
        Set对象并没有提供让你直接编辑数据的方法。如果你想改的话要先删再添加
    2.Map
      Map是用来实现类似于字典的数据结构。也就是key,value的形式，字典的key,value和object的key,value
      有什么区别呢。Map这个数据结构里面，key可以是任意值，Set是每个元素可以是任意值。
      let map = new Map([[1, 2]])
      console.log(map) // Map(1) {1 => 2}
      传入的这个参数跟set一样是一个可遍历的对象，不同的是这个可遍历对象的每一项必须是[1, 2]，前面是key,
      后面是value。
      1.添加数据
        let map = new Map() // Map(0) {}
        map.set(1, 2) // Map(1) {1 => 2}
        set意味着可以添加可以修改，add只能是添加
      2.删除数据
        map.delete(1) 
        删除的是key
      3.全部清除
        map.clear()
      4.统计map数据条数
        map.size
      5.查找
        map.has(1)
      6.取值
        map.get(1)
      7.拿到所有的key集合，value集合，全部集合
        map.keys() // MapIterator {1, 3}
        map.values() // MapIterator {3, 4}
        map.entries() // MapIterator {1 => 3, 3 => 4}
        再Set的时候这三个拿到的是SetIterator，在这里是MapIterator，不管是SetIterator还是MapIterator，
        它都是Iterator，它都是可遍历对象，既然是可遍历对象，它就可以用forEach，就可以用for of
      8.遍历
        map.forEach((value, key) => {
          console.log(value, key)
        })
        for (let [key, value] of map) {
          console.log(key, value)
        }
        用for fo遍历map的时候一定要写key, value用[]包起来
      9.注意
        1.map键的类型可以是任意的。
          let o = function () {
            console.log('o')
          }
          map.set(o, 4)
          这个是你之前绝对没有见过的，object里面没有拿function做key的。map是可以的，比如说我现在有一个
          函数它做了很多的功能，然后你想给这个函数标记一些数据，那么你就可以用map去存储这个数据了，这样的话就
          可以使这个函数跟这个数据做做一次关联，比如说o下面我可以挂载一些数据。
        2.键的顺序
          遍历出的顺序是跟你初始化或者说你在添加key的时候你的那个key的顺序来决定的。
        3.性能
          在关于object的操作和map的操作的时候，map的性能稍微会有一些优势，既然es6中新增了map这种字典型的数据
          结构，推荐大家以后别再用object去存储数据，而是要使用字典类型的这种数据结构map，希望大家可以学会用新
          的数据结构去解决你的数据问题。比如说set，比如说map，而不是说上来就直接用数组或者object，你的选择项
          要大了很多，你要发挥这些新的数据结构带来的这种特性。
  6.关于对象的复制
    1.es5
      把一个对象挨个遍历一下，再赋值给另一个对象，就实现了对象的拷贝
    2.es6
      Object.assign(target, source)
      assign实现的是浅拷贝，浅拷贝是说对于不是引用类型的值，它给你做数据的替换，对于引用类型的值，它不再遍历
      ，只是把引用的这个对象的地址给你换一下。如果在应用浅拷贝的时候，你可以考虑使用Object.assign，但如果
      说你使用深拷贝在使用assign的时候还要学会递归，就是你如果发现它是一个对象，你要递归用assign再处理，这样
      的话就可以实现深拷贝了。
6.es6在正则方面新增的知识点
  1.y修饰符
  2.u修饰符
7.es6的template新增语法
  解决字符串换行，包含变量或表达式，包含复杂的逻辑运算
  1.es5使用字符串拼接的方式
  2.es6的解决方式
    1.模版字符串
    2.模版字符串
    3.模版字符串结合函数的方式处理复杂的逻辑运算
8.解构赋值Destructure
  如何从一个复杂的数据结构中提取数据
  1.es5
  在es5中从复杂的数据结构中去挑数据是需要层层的遍历或者是引用，会相当麻烦。
  demo: es5从复杂的数据解构中取出我们想要的数据
    let arr = ['hello', 'world']
    let firstName = arr[0]
    let surName = arr[1]
    console.log(firstName, surName)
    为什么要用变量来获取这个数据，如果说这个数据频繁使用，每次都是通过索引去取显然是不合适的，因为每次从数组
    按照索引去取值它是需要花时间的，当你频繁的去取的时候是会消耗性能的。如果你用缓存，也就是用变量来存储下你
    的数据，那就会解决这个性能的问题。这就是为什么在复杂的数据结构中一定要把你关心的或频繁访问的数据拿出来放
    到变量中去。就是这么一个背景。当你的数组足够长，然后你对里面的一些数据感兴趣，你是不是需要频繁的声明变量
    ，然后还要通过索引的方式再赋值给这个变量，当你的代码量很复杂的时候你会发现光这一部分操作就占据了你这个代
    码的很多行。从这个角度讲它就不是很便捷的方式，因为你要逐一操作。
  2.es6
  而es6中所谓的更优雅更便捷的方式就是解构赋值。
  demo: es6从复杂的数据解构中取出我们想要的数据
    let arr = ['hello', 'world']
    let [firstName, surName] = arr
    console.log(firstName, surName)
    es5的时候是通过let两次声明变量，而到了es6只用了一个let，然后它所有的变量放到变量的集合里面，左面是你变
    量的集合，右面是你的数据。这样的话就轻松的拿到了你所关心的数据以及和变量的对应。相当于是一次集体的赋值，
    它不是逐一赋值，是集体的赋值，一下就赋值过去了。这就叫解构赋值。什么叫解构呢，解构就是说把数据给你拆解开，
    拆解开的目的是什么呢，是把你拆解出的数据赋值给一些变量。所以这就是解构赋值的意思。越复杂的数据解构就越会
    体现出解构赋值的优越性。
    1.Array的解构赋值
      let arr = ['a', 'b', 'c', 'd']
      1.如何跳过某个赋值元素
        let [firstName, , thirdName] = arr // 取数组的第一三项 
      2.let [firstName, , thirdName] = new Set([1, 2, 3, 4])
        凡是可遍历的对象的数据解构都可以解构赋值，这个可遍历的对象是什么呢，比如我们前面讲的set，map，字符串。
        数组或者是字符串，你可以用索引来取某一位或某一项内容。但如果是set，我们是怎么获取某一个元素的？是用
        get或者遍历的方式吧，它是不支持索引的。但是利用解构赋值的话，它根本就不用索引的方式，你只要左边写中括
        号，默认按照索引的位置排序去取就可以了。不需要显示的指定索引值。根本就不需要关心右边这个数据解构该怎么
        取的问题。
      3.如果左边不新生成变量，而是把它赋值到一个对象属性上面去，那该怎么做呢？
        let user = {name: 's', surname: 't'}
        1.es5
          user.name = arr[0]
          user.surname = arr[1]
        2.es6
          [user.name, user.surname] = [1, 2]
        解构赋值不仅可以赋简单的变量，还可以赋值对象的属性。
      4.循环
        声明临时变量item用来保存数据
        1.es5
          for (let i = 0, item; i < arr.length; i++) {
            item = arr[i]
          }
        2.es6
          let user = {}
          for (let [k, v] of Object.entries(user)) {
            console.log(k, v)
          }
          这是解构赋值的另一种形式，它在循环体中是这么用的。
      5.rest
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        let [firstName, curName, ...last] = arr
        console.log(firstName, curName, last)
      6.前面讲的都是正常的情况，数据足够多，然后给这个赋值。但我们知道赋值的时候你不能保证你的数据一定是有内
        容的，这不就是极端或者是异常的情况吗。
        let arr = [1, 2, 3]
        let [firstName, curName, ...last] = arr
        console.log(firstName, curName, last) // 1 2 [3]
        let arr = [1, 2]
        console.log(firstName, curName, last) // 1 2 []
        let arr = [1]
        console.log(firstName, curName, last) // 1 undefined []
        let arr = []
        console.log(firstName, curName, last) // undefined undefined []
        当你的数据量不够的时候，通过解构赋值，这个变量的值就跟我们没赋值一样，就是undefined，不是说你给它
        做了解构赋值，这个变量就一定有值，它取决于你的这个数据有没有值，没有的话一律是undefined。
        let arr = []
        console.log(firstName = 'hello', curName, last) // hello undefined []
        如果数据没有你这个变量对应的值的时候不想得到undefined的话，可以在声明变量的时候给它设置一个默认值。
    2.Object的解构赋值
      1.Object解构赋值基础情况
        let options = {
          title: 'menu',
          width: 100,
          height: 200
        }
        let {title, width, height} = options
        console.log(title, width, height)
        简写的方式，新声明的变量必须跟对象属性名一样，如果这个变量跟属性不一样，它解构赋值的时候就不知道你
        这个变量要和哪个属性匹配，取哪个值。
        let {title: title2, width, height} = options
        console.log(title2, width, height)
        如果说你不想让这个变量跟属性名一样，就不能简写了。后面的话必须要有一个变量名称。
      2.默认值的问题
        let {title: title2, width = 130, height} = options
        console.log(title2, width, height)  
      3.rest
        let {title, ...last} = options
        console.log(title2, last)  
      4.复杂的嵌套的数据结构
        let options = {
          size: {
            width: 100,
            height: 200
          },
          items: ['Cake', 'Donut'],
          extra: true
        }
        let {size: {width: width2, height}, items: [item1]} = options
        console.log(width2, height, item1)  
        它是一层一层的对应，解构的过程其实就是按照左边的变量的结构和右边数据的结构要一致，然后我们挨个匹
        配，匹配到之后，右边的是数据项，左边的是变量，一一来对应，一一映射。它是这么一个工作原理。也就是
        说你在用解构赋值左侧声明变量的时候也要跟数据保持一样的解构。
      5.函数参数复杂的时候也可以用解构赋值
9.Promise
  1.回调
    一个函数执行完之后调用另一个函数，这个时候就要用到回调了。尤其第一个函数是异步操作的过程，一定不能说
    把两个函数让它连续执行。它俩如果是并行执行的话起不到a执行完之后再去执行b，这个时候通常是使用回调来完
    成的。回调地狱是a回调b，b回调c，c回调d，层层嵌套。这样会非常难维护。es6中新增的promise对象就是为了
    解决这个异步回调的问题。es5的时候异步都是用回调来完成的。这就是异步操作与回调的关系。
    function loadScript (src, callback) {
      let script = document.createElement('script')
      script.src = src
      script.onload = () => {callback(src)}
      script.onerror = (err) => {callback(err)}
      document.head.append(script)
    }
    loadScript('./1.js', function (src) {
      loadScript('./2.js', function (src) {
        loadScript('./3.js', function (src) {
      
        })
      })
    })
  2.Promise
    1.我们就用es6的promise来解决下前面讲述的问题。
    2.这个时候注意，在封装我们处理异步的函数的时候，我们不用回调了，因为我们是要用promise的方式，就是要
      返回promise对象来做后续的处理，所以我们在这个写法上会有所区别。
    3.function loadScript (src) {
      return new Promise((resolve, reject) => {
        let script = document.createElement('script')
        script.src = src
        script.onload = () => {resolve(src)}
        script.onerror = () => {reject(src)}
        document.head.append(script)
      })
    }
    loadScript('./1.js')
    Promise接受一个函数做为参数。这个函数有两个参数resolve,reject，这个函数体里面要去做我们异步的
    事了，异步成功调用resolve，失败调用reject。
    4.异步函数封装好了之后，我们再来看一下我们怎么去用，因为前面用的时候是通过回调一层层嵌套用的。既
    然promise是用来解决这个问题的，那它的用法肯定跟刚才不一样，肯定不是通过这个函数嵌套去用了。
    loadScript('./1.js')
      .then(loadScript('./2.js'))
      .then(loadScript('./3.js'))
    如果你想加载更多的话，那就是平行写.then干什么.then干什么，这样的话就可以用平行的方式来去表示你
    异步的操作。在写法上它绝对不是一层一层去嵌套的，它是平行的写的。那这样的话，在你后期的维护上以及
    在你的代码可读性上其实是做了很大程度上的增强，这个在实际的业务开发中是非常重要的。
    5.promise的工作原理
      我在执行new Promise()这个对象的时候，这个promise对象它会有一个状态，这个状态叫pending，挂
      起的意思，然后它还有一个结果。在你执行这个new Promise()的时候，你要关心两个值，一个是state状
      态，一个是result结果，初始化的时候状态是pending，结果是undefined。之后的resolve和reject这
      两个方法是用来改变promise状态和结果的。异步成功之后，我调用resolve，resolve会把promise状态
      改成fulfilled，也就是完成，result就是你调用方法传进去的值。异步失败，reject被执行了，promise
      的状态就变成rejected，它的result就是传进去的error。通过resolve或者reject去改变这个promise
      的状态，而且这个状态是单向的，不可逆的。比如我调用了resolve把它的状态从pending改成了fulfilled，
      那这个状态就不可能再变成rejected了。只要pending变为fulfilled或者是从pending变为rejected，
      它都不能回去再换成另一种状态。也就是说resolve和reject只能一个被执行，这关系到你promise对象最终
      的状态和结果的。在整个promise对象运行的过程中，都在执行resolve和reject的过程。
    6.then方法
      1.then到底是怎么用的
        1..then().then()这种链式调用是一个什么样的工作原理，这个是要弄清楚的。
          then方法会返回一个新的promise实例。传的是非函数它会返回一个空的promise对象。因为返回一个空
          的promise对象，它就会认为是resolve的，也就是我们这个fulfilled状态，然后它就能进入到后面的
          then的过程。这样的话也就能保证只要调用then就一定能返回一个promise对象，这样的话就能保证我们
          能连续的使用链式调用。传入了正确的参数then方法时，如果传入的函数中没有手动return的话，then
          也会返回一个新的空的promise实例。如果你想用你的promise对象的结果影响下一个，一定是手动的加
          return返回你的promise实例来控制你接下来的then是什么状态和then是怎么执行的。通过.then是如
          何影响下一步执行的。
        2.then是Promise原型上的方法，也就是说只要是promise对象，它就可以调用.then方法。
        3.then基本语法
          promise.then(onFulfilled, onRejected)
          这两个参数onFulfilled是必选的，onRejected是可选的。
          onFulfilled跟onRejected对应着resolve和reject，因为resolve和reject这两个方法跟你
          promise对象的状态是息息相关的。这两个参数都是函数类型，按照这个语法，then应该传两个函数，
          但是上面的例子我们没传函数，但是它也正确的执行了，这是为什么呢？如果说这两个参数被遗漏或者
          这两个参数是非函数，那这个时候它就忽略掉这两个参数的内容了。既然我们这个东西被忽略掉，它为
          什么又执行了。是因为它去判断你这个参数的时候，这个参数的内容是要做为一个表达式的。什么叫表
          达式，它是表达式它就要计算表达式的值。一旦被计算，那意味着它就要被执行，它被执行就执行了
          promise内的这个过程。
      2.错误的处理
        loadScript('./1.js')
          .then(() => {
            loadScript('./2.js')
          }, err => {
            console.log(err)
          })
          .then(() => {
            loadScript('./3.js')
          }, err => {
            console.log(err)
          })
        then的err回调和catch都是能够捕获到reject抛出的错误。只不过then的err回调是针对一个promise
        对象的错误回调，而catch能接收一系列的异步链式调用的异常，也就是异步链式中写一个catch就能够捕
        获到每一个异步的异常。用catch捕获异常的方式比在每个then上都要部署异常的处理的方式更加的优雅。
        还有就是不要用throw new Error()的方式去触发你的错误，而是要用promise对象中的reject去改变
        promise状态的方式让catch去捕获这种错误。catch它捕获的是改变promise状态也就是promise状态
        变成rejected的时候，它去捕获。
    7.resolve & reject
      Promise有两个静态方法，是用来帮你做类型转换的。比如我想把一个数据转换成一个promise对象。
      Promise.resolve(42)，在一些特殊场景，没有异步操作的时候，它就是一个同步操作，你可以用Promise.
      resolve()的方式加数据。这样就可以把一些非异步的操作变成异步操作，那这样就可以统一的调then方法了。
      这是一个小的技巧。大家可以学会在什么样的场合用它来帮你快速生成一个promise实例。这个是非常有用的一
      个技巧。
    8.关于Promise对异常的处理catch
      loadScript('./1.js')
        .then(() => {
          loadScript('./2.js')
        })
        .then(() => {
          loadScript('./3.js')
        })
        .catch(err => {
          console.log(err)
        })
/* todo      
  1.promise链式调用原理？
  2.then中的错误回调和catch有什么区别？
  3.then中函数返回和不返回promise对象，对链式调用的影响？
*/
    9.all
      上面讲的异步操作是讲述了一个场景，一步骤二步骤三步骤是按照先后顺序加载执行的。但有的时候我们做异步操
      作还有可能是并行的。这也是异步操作的另一个场景。一个是串行一个是并行。因为对异步操作来说无非就两种方
      式，串行和并行。
      123三个接口出去，我不知道哪个接口快，哪个接口先回来。我不管你们是哪个时间点回来的，我只关心你们都回
      来的时候我要把数据聚合。
      const p1 = Promise.resolve(1)
      const p2 = Promise.resolve(2)
      const p3 = Promise.resolve(3)
      Promise.all([p1, p2, p3])
        .then(value => {
          console.log(value) // [1, 2, 3]
        })
      all代表着所有的异步操作完成之后我要干什么。因为有多个异步操作，所以这个all接受一个数组，这个数组就
      是不同的异步操作promise实例。Promise.all它返回的还是一个promise对象。所以利用这个函数你可以轻松
      的去完成不同的并行接口的实现。最终你只要关心.then里面拿到的所有数据。你完全不需要关心每一个异步操作
      它们是谁先回来的。完全不需要关心这些细节。你只要利用Promise.all把你想做的异步操作放进去，然后.then
      中就能拿到它们的所有数据集合。
    10.race
      前面我们讲了串行并行的异步操作。有的时候还有一个场景。
      竞争，谁先到谁先得。一线路二线路都存着我们想要的数据。一二线路有一个线路能加载出来我就用谁的。
      const p1 = () => {
        return new Promise((resolve, reject) => {
          setTimeout(function () {
            resolve(1)
          }, 0)
        })
      }
      const p2 = () => {
        return new Promise((resolve, reject) => {
          setTimeout(function () {
            resolve(2)
          }, 1000)
        })
      }
      Promise.race([p1(), p2()])
        .then(value => {
          console.log(value) // 1
        })
      如果你的应用场景有类似的先到先得的，一定要用race而不是用all。
      有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。
      这种情况下，用Promise.race()实现。由于p1执行较快，Promise的then()将获得结果1。p2仍在继续执行，
      但执行结果将被丢弃。
    11.总结
      希望大家对promise有一个新的认知，关于异步操作一定要想办法用promise去解决，而不是用es5的回调。 
10.Reflect
  1.es6新增的知识点reflect，反射的意思。什么是反射机制呢。
    java的反射机制是在编译阶段不知道是哪个类被加载，java是以类为单元的，而是在运行的时候才加载、执行。
  2.反射机制的意义
    Math.floor.apply(null, [1.72])
    Reflect.apply(Math.floor, null, [1.72])
    在你静态扫描的时候，你不知道是哪个方法在用apply，因为你直接是用的Reflect，这个apply没有绑定到某个方
    法上。当你真正执行这个apply的时候，这个方法是做为一个参数传进来的。当你真正运行apply的时候，才去调
    Reflect这个方法，在静态扫描的时候Math.floor这个方法是并没有被执行的。
  3.反射机制的用途
    1.es5
    let price = 91.5
    if (price > 100) {
      price = Math.floor.apply(null, [price])
    } else {
      price = Math.ceil.apply(null, [price])
    }
    2.es6
    let price = 91.5
    Reflect.apply(price > 100 ? Math.floor : Math.ceil, null, [price])
    因为apply前面必须要指定方法，而用反射的话我直接调用apply，然后根据这个条件再来选择执行apply的时候去
    调用哪个方法。
  4.我们有的时候会根据不同的场景来实例化不同的子类。之前的做法是用if else去new不同的类。现在我们可以用更
    加简洁的方式，也就是反射的方式去实现类的实例。
    js中原生的对象有很多都是类。
    let d = new Date()
    用反射一定要在反射上找到这个api
    它是用来实例化类的。
    Reflect.construct(Date, []) // 这里的这个空数组的参数必须传
    通过这种方式，我就可以轻松的实现调用不同的类去动态的实例化一个对象，而不是通过new的方式去做。
  5.通过apply和construct这两个方法，你要明白
    1.什么是反射机制
    2.什么样的场景下面用这个反射机制比我直接用更加的简单更加的动态化
  6.Reflect.defineProperty
    这个跟Object.defineProperty是一摸一样的。只不过把原来Object下的很多方法都迁移到Reflect。按照w3c
    的规范，是说所有之前作为一个具备反射机制的一些功能性的函数都会放到Reflect上面去。
    区别：返回值不同
  7.Reflect.get
    get就是用来读数据
    const obj = {x: 1, y: 2}
    obj.x
    Reflect.get(obj, 'x')
    帮大家提供了一种读取数据的操作的方式。
  8.获取object对象下面的属性的具体的描述符。
    属性描述符就是值是什么，是不是只读的，可不可以枚举，可不可以配置等等。
    Object.getOwnPropertyDescriptor(obj, 'x')
    Reflect.getOwnPropertyDescriptor(obj, 'x')
  9.某个对象的原型对象是什么
    let d = new Date()
    Reflect.getPrototypeOf(d)
    有的时候当你调用别人的类的实例的时候，你不知道它的原型对象是什么。你可以用这个方法，快速打印出它的原型
    对象上到底部署了哪些方法，你就可以一眼看出来了。
  10.判断一个对象上面有没有一个属性。
    let obj = {x: 1, y: 2}
    obj.x 是不是undefined来验证有没有
    Reflect.has(obj, 'x') 更优雅的方式
    Object下没有这个方法
  11.判断一个对象是不是可扩展的
    let obj = {x: 1, y: 2}
    Object.freeze(obj) // 冻结一个对象
    obj.z = 3 // 冻结后就不可扩展了
    Reflect.isExtensible(obj) // false
    这个方法也可以用作判断一个对象是不是冻结过，是不是处于不可扩展状态。
  12.判断某个对象下面的自有属性
    大家可以看出来，现在obj自身的属性只有x和y，如果你去遍历的话，你发现它的属性不只是x和y，但有的时候我们
    需要判断这个对象自身的属性。因为有的时候这个对象它是有原型链的，原型对象的东西也算它属性的一部分，有时
    我只想知道你自身的属性，而不是原型对象的属性。对象中非原型上的属性都包括。
    Reflect.ownKeys(obj)
    Reflect.ownKeys([1, 2]) // ['0', '1', 'length']
    Symbol: es6中新增加的数据类型，不是很常用
    ownKeys和Symbol也有关系，ownKeys对Symbol也是有处理的。
  13.禁止对象扩展
    let obj = {x: 1, y: 2}
    Reflect.preventExtensions(obj)  
    Reflect.isExtensible(obj) // false
    它起到跟freeze相同的作用，禁止对象扩展
  14.Reflect.set(obj, 'x', 4)
    写数据
  15.给一个实例对象修改它的原型对象，那这样的话就能修改它的原型链了。 
    const arr = [1, 2, 3]
    console.log(Reflect.getPrototypeOf(arr))
    Reflect.setPrototypeOf(arr, String.prototype)
11.Proxy代理
  1.Proxy基本语法
    代理的核心价值是屏蔽原始信息，保证原始信息的安全。
    let o = {
      name: 'xiaoming',
      price: 190
    }
    let d = new Proxy(o, {})
    第一个参数：你要代理谁
    第二个参数：代理之后我能干什么。比如劫持你的构造函数，劫持你的get, set。但是经常使用的就是读和取。因为我
              们在写业务的过程中百分之九十九都是在读写数据，对于其他的操作来说基本用不到。
    name是我的隐私，price这个真实价格我不希望被用户所读取到，这个信息只传递到中介那，中介就不能再往外透露。这
    是代理的含义。
    现在已经对o实现了一个代理，这个d就相当于一个中介的角色。如果我想知道价格是多少中介告诉我的应该是：
    console.log(d.price) // 190
    操作传成{}就相当于没操作，没操作就等于是透传，你得到的就是原始的信息。这显然不符合我们代理的作用。如果你想
    做它的代理的话，这个地方肯定是要有操作的。
    中介的价格加二十万。
    let d = new Proxy(o, {
      get (target, key) {
        if (key === 'price') {
          return target[key] + 20
        } else {
          return target[key]
        }
      }
    })
    这就符合代理，中介的定位
  2.Proxy使用场景
    1.将数据变为只读
      let o = {
        name: 'xiaoming',
        price: 190
      }
      let d = new Proxy(o, {
        get (target, key) {
          return target[key]
        },
        set (target, key, value) {
          return false
        }
      })
      d.price = 300
      console.log(d.price, d.name) // 190 'xiaoming'
      利用这个原则，你就可以保证o不会被修改，因为你要把o保护出来，不要把o暴露出去，你暴露的是中介d，也就是
      说你让用户访问的永远是d对象，而不让用户访问到o。
      es5做法
      for (let [key] of Object.entries(o)) {
        Object.defineProperty(o, key, {
          writable: false
        })
      }
      o.price = 300
      console.log(d.price, d.name) // 190 'xiaoming'
      es5的这种做法是让o彻底的锁死了，不能被修改。不光用户不能改，你自己想对它修改都改不了了。而对于代理来
      说就不一样了，它是有处理空间的，在get,set函数里面是可以进行各种操作的。 从用户的角度看是被锁死的。用
      户操作不了，但中介可以操作。这就是这两者的区别。虽然从结果上看，这两个做法都可以把数据变成只读的，但是
      这两者的原理完全不一样。代理更好用一些，因为代理拦的是用户，我们不能拦我们自己。
    2.校验
      因为我们是做js的，js更多的是对用户交互操作做服务的。这个时候难免会有一些不合理的数据进来，也会有一些
      不合理的操作进来。那我们怎么保护我们的数据呢。比如我们在填表单的时候，一般情况都会有一个默认值，然后用
      户做编写，然后我们拿到最新的那个值，我们通常会做这样的操作。我们如何去保证用户不瞎填不瞎改，能保证我们
      收回来的数据是符合我们规范的，这就是校验。校验是我们js操作里面最频繁最常用的一个功能。之前写可能都耦合
      在业务里面，做这个校验的事情会非常的困难，耦合性非常高。这个显然不是最优的解决方案。proxy会有更加合适
      优雅的方式去帮你做校验的处理。
      let o = {
        name: 'xiaoming',
        price: 190
      }
      需求：
      用上面的数据做表单的收集，默认就是这个数据。现在我们让用户改，不希望他给我们瞎改这个数据
      1.我们这个信息里面有效的数据就两项name,price，我不希望给我增加删除数据。不能破坏我的数据结构
      2.你只能修改我的价格，而且这个价格不能超过300，超过300的那也是无效的数据。也就是拦截无效的数据
      有了这两个原则之后，我们就能保证我们这个数据是有效的，是规范的，然后我们把用户修改的这个数据再报到服务
      端去。
      let d = new Proxy(o, {
        get (target, key) {
          return target[key] || ''
        },
        set (target, key, value) {
          if (Reflect.has(target, key)) {
            if (key === 'price') {
              if (value > 300) {
                return false
              } else {
                target[key] = value
              }
            } else {
              target[key] = value
            }
          } else {
            return false
          }
        }
      })
    3.监控
      为了提升用户体验，有时候我们特别想知道哪些用户在干着违规的操作。因为这样的话会帮助我们改善我们的产品，
      这是提升产品质量非常有效的一个手段，俗称监控。我们希望通过监控发现这样违规的事情并上报到服务端。然后
      我们在服务端拿到所有的数据，再筛选给到产品，这样的话就能帮我们分析用户使用的情况。
      在不符合规则的里面直接写上报的逻辑，但是当你的校验规则有很多个的时候，你把上报的东西再耦合到校验的规
      则里面，如果有十个一百个这样的校验规则，那你就要写十份一百份的上报的的机制。这显然不合理。还有就是封
      装一个上报的模块，听上去也可以，但还是耦合了，如果有一天说要把所有的监控都要去掉或者做些修改，你要去
      模块中把所有的都移除。显然也不合适。
      在这里我们提供一个比较好用的方式。在不符合的规则的时候我要做一个错误的触发，因为本身就是违规了，违规
      的话是不是就要做触发报错啊。报错跟你上报它是两个逻辑，错了就是错了，就算有一天我不想上报，但是我还是
      要处罚错误的，这样就彻底解偶开。
      // 监听错误
      window.addEventListener('error', (e) => {
        console.log(e.message)
        // 上报逻辑
        report('./') // 有一天你想去掉上报逻辑了，注释掉这个代码就行了。我不用在校验规则里找。
      }, true) // 最后一个参数设置成true是要捕获，而不是冒泡
      // 校验规则
      let d = new Proxy(o, {
        get (target, key) {
          return target[key] || ''
        },
        set (target, key, value) {
          if (Reflect.has(target, key)) {
            if (key === 'price') {
              if (value > 300) {
                // 不满足规则错误触发
                throw new TypeError('price exceed 300')
                // return false
              } else {
                target[key] = value
              }
            } else {
              target[key] = value
            }
          } else {
            return false
          }
        }
      })
      我们触发了这么一个错误告诉它这是一个违规操作，这个代码跟我们上报一点关系没有吧。
    4.给实例生成随机唯一只读的id
      class Component {
        contructor () {
          this.proxy = new Proxy({
            id: Math.random().toString(36).slice(-8)
          })
        }
        get id () {
          return this.proxy.id
        }
      }
      let com = new Component()
      let com2 = new Component()
      for (let i = 0; i < 10; i++) {
        console.log(com.id, com2.id)
      }
      com.id = 'abc'
      console.log(com.id, com2.id)
      很多时候的处理你要时常的想起proxy代理。那你的方案是不是就又多了一种。
  3.proxy的撤销
    既然是代理，它可以代理，也是可以被撤销的。也就是让代理失效。
    let o = {
      name: 'xiaoming',
      price: 190
    }
    let d = Proxy.revocable(o, {
      get (target, key) {
        if (key === 'price') {
          return target[key] + 20
        } else {
          return target[key]
        }
      }
    })
    d.proxy就是new Proxy的信息，就是被代理的数据信息
    d.revoke() // 撤销代理的操作
    可撤销的代理就是读完一次可能就不让你读了。临时代理的场景。如阅后即焚的软件的功能。
12.generator发生器
  1.背景，es6如何让遍历停下来？这里的停下来不是退出，比如continue,break等，这些不叫停下来，这些叫退出或跳
    过。我从1到10遍历一遍，我让它输出1之后停下来，我想让它恢复继续再遍历23，然后我想让它停下来，它就可以在3
    的位置再停下来，什么时候我想调起说继续执行，它会再输出4。以此类推，这个叫停下来。每一步都可以控制是不是要
    继续进行。generator就可以帮你做到如何让遍历停下来。
    1.es5
    function loop () {
      for (let i = 0; i < 5; i++) {
        console.log(i)
      }
    }
    loop()
    一旦这个函数被调用，这个for循环就一次执行完了，它是不受控的。不能停下来。
    2.es6 generator的写法
    function * loop () {
      for (let i = 0; i < 5; i++) {
        yield console.log(i)
      }
    }
    const l = loop()
    l.next() // 0
    l.next() // 1
    l.next() // 2
    l.next() // 3
    l.next() // 4
    l.next() // 什么都不会打印了
    这两种写法都在描述一个遍历的过程
    核心语法上有两点区别：(这是在定义上的区别)
    1.function后面要加一个*，*两边都要有空格
    2.你想让它停下的地方要加一个yield关键字
    执行上的区别：
    es5想执行的话直接通过loop去执行的。
    es6是在loop执行完之后返回的一个变量叫l，l并不能直接执行，这个变量是用来控制循环的。l.next()去调用你这
    个遍历中的一步，你不调用next那么这个循环就是暂停状态。执行完一次就暂停，执行完一次就暂停。你每next一次，
    它就按照你的循环往前执行一步。通过这个方式就可以精细化的控制到遍历的每一个节奏，这个就是generator。它这
    个循环是受你控制的。
    应用场景：自定义遍历器，以前我们都是说这个东西能用for循环，它是个数组，它是个集合，我们就能用for循环，不
    是的话我们就用不了，实际上并不是这样的。任意复杂的数据结构你都可以自定义它的遍历。这个在es5是做不到的。在
    es6 generator就可以帮你实现自定义遍历器。它是很重要的一部分内容。
  2.generator语法
    1.从定义来说，generator就是一个函数，但是和普通函数不一样，它多一个*。
    2.函数内部可以使用yield来暂停函数的执行。
    3.在调用的过程中，通过next来恢复程序的执行。
    一共三个组成部分，这个是generator的基本语法。
    4.yield
      function * gen () {
        let val
        val = yield 1 // 遇到yield，然后执行完yield后面的表达式后就会停止。并不会执行赋值操作，在下一次的next在会赋值。
        console.log(val)
      }
      const l = gen()
      l.next() //
      l.next() // undefined
      1.yield关键字在es5中是没有的，这个关键字只能在generator函数内部中使用。关键字做为表达式的一部分，既
        然是表达式，我们很关心它有没有返回值。yield表达式返回undefined，也就是没有返回值。
      2.next找函数体中的yield或者是函数的结尾。这两者找到一个就会暂停或者结束。
      3.yield后面可以加一个*。
        既然我们是用next来控制函数的恢复执行，那它的返回值无非是两个数据。
        1.我当前yield表达式的值是什么。
        2.我的函数是否已经结束。
        3.yield加*之后，它表示的是后面可以是一个遍历的对象，专业术语叫可迭代的对象。或者是一个generator实
          例，也就是yield *后面可以嵌套一个generator函数。
    5.next
      1.用next传值到generator函数中来控制函数内部的数据。next传进来的值是给yield的返回值。也就是说通过改
        变yield返回值的方式来改变函数内部的数据或运行结果。
      2.next里面的value是yield后面的值或者函数return的值。yield后面的值和yield的返回值是不一样的。
      3.只要有yield就会停下来，后面即使是没有代码也需要再next一次这个函数才算执行完。next里的node才为true
      1.function * gen () {
        let val
        val = yield [1, 2, 3]
        console.log(val)
      }
      const l = gen()
      console.log(l.next())
      console.log(l.next())
      // {value: Array(3), done: false}
      // undefined
      // {value: undefined, done: true}
      2.function * gen () {
        let val
        val = yield [1, 2, 3]
        console.log(val)
      }
      const l = gen()
      console.log(l.next(10))
      console.log(l.next(20))
      // {value: Array(3), done: false}
      // 20
      // {value: undefined, done: true}
    6.return 
      退出函数执行。也可以传值，跟next一样。
      l.return()
    7.throw
      function * gen () {
        while (true) {
          try {
            yield 1
          } catch (e) {
            console.log(e.message)
          }
        }
      }
      const g = gen()
      console.log(g.next()) // {value: 1, done: false}
      console.log(g.next()) // {value: 1, done: false}
      console.log(g.next()) // {value: 1, done: false}
      console.log(g.next()) // {value: 1, done: false}
      如果你不用generator，你用es5去写，你的页面已经死掉了，因为无限循环。但是用generator是死不掉的。
      因为它虽然是个无限循环，但是它的节奏是由外部来控制的。它就不是一个无限循环了。
      g.throw(new Error('ss')) // ss
      console.log(g.next()) // {value: 1, done: false}
      类似与continue的方式，绕过去了。抛出异常的方式结束函数运行。
    8.generator应用场景
      1.抽奖模块
        1.es5
          function draw (first = 1, second = 3, third = 5) {
            let firstPrize = ['1A', '1B', '1C', '1D', '1E']
            let secondPrize = ['2A', '2B', '2C', '2D', '2E', '2F', '2G', '2H', '2I']
            let thirdPrize = ['3A', '3B', '3C', '3D', '3E', '3F', '3G', '3H', '3I']
            let result = []
            let random
            // 抽一等奖
            for (let i = 0; i < first; i++) {
              random = Math.floor(Math.random() * firstPrize.length)
              result = result.concat(firstPrize.splice(random, 1))
            }
            // 抽二等奖
            for (let i = 0; i < second; i++) {
              random = Math.floor(Math.random() * secondPrize.length)
              result = result.concat(secondPrize.splice(random, 1))
            }
            // 抽三等奖
            for (let i = 0; i < third; i++) {
              random = Math.floor(Math.random() * thirdPrize.length)
              result = result.concat(thirdPrize.splice(random, 1))
            }
            return result
          }
          let t = draw()
          for (let value of t) {
            console.log(value)
          }
        2.generator
          function * draw (first = 1, second = 3, third = 5) {
            let firstPrize = ['1A', '1B', '1C', '1D', '1E']
            let secondPrize = ['2A', '2B', '2C', '2D', '2E', '2F', '2G', '2H', '2I']
            let thirdPrize = ['3A', '3B', '3C', '3D', '3E', '3F', '3G', '3H', '3I']
            let count = 0
            let random
            while (1) {
              if (count < first) {
                random = Math.floor(Math.random() * firstPrize.length)
                yield firstPrize[random]
                count++
                firstPrize.splice(random, 1)
              } else if (count < first + second) {
                random = Math.floor(Math.random() * secondPrize.length)
                yield secondPrize[random]
                count++
                secondPrize.splice(random, 1)
              } else if (count < first + second + third) {
                random = Math.floor(Math.random() * thirdPrize.length)
                yield thirdPrize[random]
                count++
                thirdPrize.splice(random, 1)
              } else {
                return false
              }
            }
          }
          let d = draw()
          console.log(d.next().value)
          console.log(d.next().value)
          console.log(d.next().value)
          console.log(d.next().value)
          console.log(d.next().value)
          console.log(d.next().value)
          console.log(d.next().value)
          console.log(d.next().value)
          console.log(d.next().value)
          console.log(d.next().value)
          console.log(d.next().value)
          console.log(d.next().value)
      2.处理无限循环的流程
        输出3的倍数，按照es5的写法一定是死循环了。
        function * count (x = 1) {
          while (1) {
            if (x % 3 === 0) {
              yield x
            }
            x++
          }
        }
        let num = count()
        console.log(num.next().value) // 3
        console.log(num.next().value) // 6
        console.log(num.next().value) // 9
        console.log(num.next().value) // 12
        console.log(num.next().value) // 15
13.Iterator
  自定义数据结构的遍历问题，包括可遍历都是指的这个Iterator。
  es6如何让支持遍历的数据结构可遍历呢。
  在复杂的本身不能被遍历的数据结构中遍历出想要的数据集合。
  它是很实用的功能
  1.es5
    let authors = {
      allAuthors: {
        fiction: ['Agla', 'Skks', 'LP'],
        scienceFiction: ['Neal', 'Arthru', 'Ribert'],
        factory: ['J.R.Tole', 'J.M.R', 'Terry P.K']
      },
      Address: []
    }
    let r = []
    for (let [k, v] of Object.entries(authors.allAuthors)) {
      r = r.concat(v)
    }
    console.log(r) // ['Agla', 'Skks', 'LP', 'Neal', 'Arthru', 'Ribert', 'J.R.Tole', 'J.M.R', 'Terry P.K']
  2.es6
    我希望它像一个数组一样就好了，我们希望这么做，我们每次用的时候，我希望每次遍历的时候直接就拿到v啦，这样多好，
    这样是最简单的方式，我就可以拿到每个作者了。我不管你里面的嵌套是什么。我这样简单的一个遍历，我就能拿到我所有
    想要的名单。这样写起来就比上面的简单很多。它不仅写法上要优雅，而且你可以忽略掉这个数据结构里面的内置结构。你
    只要拿到这个对象，然后一遍历就能拿到所有作者的名单。这显而易见是我们想要的。因为从外部看我只关心我拿到的东西，
    我不关心你数据结构内部，这个是非常大的一个区别。对于这样的场景自定义遍历是非常的重要。
    let r = []
    for (let v of authors) {
      r.push(v)
    }
    可是我们现在用这个理想的方式去做，会发现报错，authors is not iterable，authors这个对象它不是可遍历的，
    你直接用这种for of的方式去遍历是不允许的。那我们怎么做才能让它支持这种写法呢。就是iterator，iterator就
    是一个可遍历的接口，如果你想让你的对象支持可遍历，一定是部署了可遍历接口。
    1.既然是部署接口，我们肯定要跟这个对象做关联。
      这个接口就是一个方法。所以你要在这个对象上用挂载方法的方式来部署这个接口。
      authors[Symbol.iterator] = function () {

      }
      这个地方是说这个对象上要挂载一个key，这个key不是一个字符串，它是Symbol.iterator，现在你不需要关心
      Symbol和iterator是什么。只要你想自定义遍历器就必须这么写。没有为什么，就这么规定的。找到这个key之后
      给它一个方法。
    2.这个方法里面既然是部署一个接口，接口怎么实现肯定是不能约束你，不然的话你怎么实现自定义这么一个概念呢。既
      然是自定义，一定是让你随便写。但是随便写还是要有规范的。输入输出它是有制度约束的。输入就是this。this就
      是对象本身。这就是输入。输出就是你的返回值。在这个方法里面随便写，但是输入是固定的，输出是有约束的。不固
      定，但是有约束格式的。中间怎么写那就无所谓了。
      authors[Symbol.iterator] = function () {
        // this
        // 它的返回值的约束必须这样写。我在自定义遍历的接口中一定要返回一个对象。这个对象有一个叫next的方法。
        // 然后这个next方法还要返回一个对象。它返回的这个对象也是有格式要求的。就是一定要有两个字段。一个是
        // done，一个是value。done用来表述你现在遍历是否结束，如果done等于false，说明遍历没结束，done等
        // 于true，说明遍历结束了。所以你知道你的done该怎么赋值了吗。value就是用来告诉你当前所遍历的项的值，
        // 比如说1,2,3,4这是一共有四项。我每遍历的时候，1和2就是你的这个值，当前被遍历到的这个值，你要填到
        // value这个位置。所以你想去写一个自定义遍历的这么一个接口要注意这么几点。这是最简单的iterator遍历
        // 接口的一个规范。必须这么写。这是没写任何业务逻辑的。纯框架。你的这个接口必须满足这些因素，你才是一
        // 个符合规则的遍历器接口。
        return { 
          next () {
            return {
              done: false,
              value: 1
            }
          }
        }
      }
    3.实现上面设定的目标，就是就是能通过简单的遍历就能遍历到所有的值。
      authors[Symbol.iterator] = function () {
        // 这里执行一次
        let allAuthors = this.allAuthors // 拿到allAuthors
        let keys = Reflect.ownKeys(allAuthors) // 拿到allAuthors中所有的key
        let values = [] // 用来保存结果
        return { 
          next () {
            // 这里执行循环的次数
            // 一个技巧，我们在next方法里面去判断我们最终的返回值，因为它是一个遍历的过程，每一个遍历都要返
            // 回一个这个对象，然后里面包含done和value，这是规定的。所以在这里面我们要判断values的长度。
            // 我们用这个values来取，我们不是要对allAthors进行一个遍历吗，但是我们的遍历不会在一开始的过
            // 程中就把所有的都遍历一遍。我不会在每次遍历的时候都把这个对象遍历一遍。那样的话你的计算是多余
            // 的。我们希望在做这个自定义遍历器的时候，我们首先要做的就是说你遍历这个对象的第一个作者，我就
            // 应该找到第一个值，你遍历第二个的时候就应该找到第二个值。换句话说你要在这个自定义遍历的过程中
            // 控制你的指针。让指针先指向第一个值，再指向第二个值，然后以此类推，就是控制每一次给出去一个值。
            // 这个指针的控制逻辑是根据你的数据结构来确定的。在接口内部根据数据结构的特点实现你自己的业务逻
            // 辑。你只要保证返回正确的done和value就好了。
            if (!values.length) {
              if (keys.length) {
                values = allAuthors[keys[0]]
                keys.shift()
              }
            }
            return {
              done: !values.length,
              value: values.shift()
            }
          }
        }
      }
      你就可以把上面这个代码放到一个模块中复用就好了。而在你的业务逻辑中你只要用到这个对象就直接像下面这样遍
      历就好了，在你遍历的时候，你根本就不需要关心这个对象里面的数据结构是什么样的了，在你使用的时候是没有体
      现的。但是最终你就可以拿到这个结果。那这样的话就会做到你的数据结构跟你的业务逻辑是解偶的。这样的话iterator
      就帮你起到了很大的作用。不用iterator你是做不到的。
      let r = []
      for (let v of authors) {
        r.push(v)
      }
      console.log(r)
  3.generator
    为什么我们在部署这个可遍历的接口的时候一定要有那么多的规范和协议。其实这个地方的话有一个真正的协议，这个
    协议是规定了两部分。一部分它专业的术语叫迭代器协议，一部分术语叫可迭代协议。这两个概念就是对应上面遍历器
    接口框架的规范。第一部分对应的就是在这个对象上找一个Symbol.iterator这样的key，然后给它赋值这个function
    方法，管这种叫可迭代协议，你想判断一个对象是不是可迭代的，你就去找这个对象上有没有这个以Symbol.iterator
    为key的方法。如果没有那这个对象就是不可迭代的。这个就叫可迭代协议。反过来你想让它可迭代，就一定要部署以
    Symbol.iterator为key的这么一个方法。一定要有，这是死的，就这么规定的。可迭代协议就是这么规定的。没有
    为什么可言。这是可迭代协议。第二部分叫迭代器协议。既然它可迭代了。那它是怎么的一个迭代的过程呢。这就叫迭
    代器。这个迭代器就要求你必须返回一个对象，这个对象里面有一个方法是无参数的。而且必须命名为next，而next
    的返回值又必须是done和value，这个在js这个语言里面迭代器的协议就这么规定的。也是没有为什么，就这么定义的。
    generator & iterator
    generator和上面说的迭代器协议是一摸一样的。所以如果我们不想像上面那样写那么多规范去做可迭代的接口。不用
    这样显示的写。如果我们在这个地方用generator就默认有了这些东西。所以在iterator这个实现的的时候是可以用
    generator的，就不用自己去写那些next,done,value东西了。所以在iterator里面你可以用generator来大展宏
    图。generater是遵循了迭代器协议的。
    1.使用generator来实现iterator的可迭代接口。
      authors[Symbol.iterator] = function * () {
        let allAuthors = this.allAuthors
        let keys = Reflect.ownKeys(allAuthors)
        let values = []
        // 因为generator里面是通过yield来控制你的遍历节奏的。所以我们就不能像刚才那样是自己判断了。要判断
        // 它是不是空，判断它是不是有值，那都是自己去判断的。但对于yield来说，它不需要你那样去做了。我们就
        // 利用一个无限循环，因为yield具有暂停的功能，我就不需要自己去控制这个节奏。你什么时候没有值了，我
        // 再退出这个无限循环不就好了吗。所以这个地方我们是这么做。
        while (1) {
          if (!values.length) {
            if (keys.length) {
              values = allAuthors[keys[0]]
              keys.shift()
              // 唯独不一样的是不需要你写done,value了，这个节奏不需要你来控制了。
              yield values.shift()
            } else {
              // 如果keys没有了，退出这个无限循环
              return false
            }
          } else {
            yield values.shift()
          }
        }
        // 现在我们没有通过控制done这个节奏，以前是我必须控制这个done来决定是不是结束了。需要我们自己来判断
        // 跟我们使用generator判断的思路不一样。其他的怎么去取作者，怎么去从左到右从上到下遍历都是一样的。
        // 只是节奏的控制方法不一样了。之前是手动的控制done，传递value。而使用generator的话你是通过yield
        // 来做的。完全没有显示的写done和value。你只是用yield传下值就可以了。至于说这个done是不是结束了，
        // 不需要你去来做。因为没有yield之后，它会帮你自动截断。所以这个代码的话写上去要比之前的更加的简洁。
      }
      我们同样实现了上面的目标，用generator来说，我们就是利用了它遵循了迭代器协议。我们不再显示的去手写这个迭
      代器协议了。对比显示的写的写法，generator更加容易理解，更符合我们写代码的逻辑，我无限循环的过程中，因为
      你是个遍历的过程吗，我也不知道它什么时候结束，你只要遍历的话就就来取我这个值，取出一个值后就暂停，下一次
      遍历的时候进入到下一次遍历的值，这个是特别好理解的。如果对generator这种方式不理解，你手写迭代器协议也没
      问题。这两个方法都可以，哪个适合你你就用哪个。但是你的目标就是让它把你的这个不支持可遍历的数据结构变成可
      遍历，这才是你的终极目标。
14.模块化（如何把代码进行模块化设计）
  在es6之前，大家如果想把js分成不同的模块，那一定要借助第三方的框架，比如像require.js，c.js。其实这个是很久
  之前的事情了。到了es6之后，已经有了专门的语法来做模块化设计的导入和导出功能。下面我们就通过代码给大家演示一下
  es6是如何把代码进行模块化设计的。
  首先既然是模块化设计，一定会有导入和导出两个功能。对应的至少两个不同的文件。因为有一个文件要做为模块导出，还有
  另一个文件要做为导入，所以这个我们需要创建两个文件。
  1.导出模块(导出的文件)，导入模块(导入的文件)
    导出的话它可以导出变量，函数，类，对象都可以。导出的关键词叫export。
    对于导入来说其实非常的简单，它也有一个关键字叫import。
    1.导出变量
      export const name = 'hello'
      对于这个模块来说，这个name='hello'它就理解为是写死的，我可以在任何其他的文件引入这个模块来调用name的这
      个变量。
      import {name} from './module'
      在导入的时候你不要忘了加一个{}，这个括号就是引用你刚才那个模块里面定义的名称的作用，它不是解构赋值的作用。
      那个地方叫name，你这里也要叫name。from后面是引用模块的文件名。后面的.js是可以省略的。
    2.导出多个变量
      export const name = 'hello'
      export let addr = 'Beijing'
      import {name, addr} form './module'
    3.到处数组类型变量
      export const name = 'hello'
      export let addr = 'Beijing'
      export var list = [1, 2, 3]
      import {name, addr, list} form './module'
    4.一起导出多个
      const name = 'hello'
      let addr = 'Beijing'
      var list = [1, 2, 3]
      export {
        name,
        addr,
        list
      }
      这种导出多个的写法并不是导出了一个对象，而就是es6模块化导出多个内容的写法。
    5.导出默认值，导入的时候不需要用{}来引用
      const name = 'hello'
      let addr = 'Beijing'
      var list = [1, 2, 3]
      export default name
      export {
        addr,
        list
      }
      我默认导出name的这个变量，同时还导出addr和list。
      import name, {addr, list} form './module'
      只想导出name的时候：
      import name form './module'
    6.使用自己的名字导入
      1.对于默认导出的，导入时可以随意命名。因为每个文件或者说模块可以导出多个内容，但是只能有一个默认导出。
      2.对于普通导出的，导入时都要在{}里面。也可以改名字，但是都必须要知道它在导出时的命名。
        import name, {addr as addr2, list} form './module'
    关于基本的导入导出到这已经有了一个大概的认知。
    es6提供了非常强大的功能就是为了解决模块的导入导出，方便你去做模块化设计，那这样的话，你的代码就有很多是可
    以提炼出来做为一个公共模块被多个文件去引用，利用这种方式，你就可以轻而易举的做到了。
    7.导出函数
      export function say (content) {
        console.log(content)
      }
      import {say} from './module'
    8.导出多个函数（跟上面导出多个变量是一样的。）
      export function say (content) {
        console.log(content)
      }
      export function run (content) {
        console.log('i am running')
      }
      import {say, run} from './module'
    9.函数默认导出
      export default function say (content) {
        console.log(content)
      }
      export function run () {
        console.log('i am running')
      }
      import say, {run} from './module'
    10.导出多个函数
      const say = (content) => {
        console.log(content)
      }
      const run = () => {
        console.log('i am running')
      }
      export {
        say,
        run
      }
      import {say, run} from './module'
    在函数的导入导出上跟上面的变量没有太大的区别。只不过在你export的时候必须显示的声明一下它是函数。这是唯一的
    一个区别。
    11.导出对象
      现在这有一个简单的对象。
      {
        code: 0.
        message: 'success'
      }
      如果我想把这个对象往外导出，按照我们之前的做法的话，一定是加一个export
      export {
        code: 0.
        message: 'success'
      }
      但我们导出多个的时候也是像上面那样的方式。
      但是你发现这个时候呢已经报错了。为什么呢，你想象一下，前面导出多个的时候是用的{}的这种形式。你如果按现在
      这样做的话，它无法区分是导出多个那种形式呢，还是你里面就是要导出个对象呢。还有一种原因是export导出必须要
      有名字。
      这时，你说你用一个{}里面再嵌入一个对象怎么样。
      export {
        {
          code: 0.
          message: 'success'
        }
      }
      它是不支持的。因为对象一定是key,value形式，你这样写的话就不是个对象了。所以从语义上来说，就出现了问题。
      这种的object对象，它是不允许你这么导入导出的。我现在想把这个对象导出怎么办呢。你可以在前面加一个关键字
      default。
      export default {
        code: 0,
        message: 'success'
      }
      你这样default它就可以把后面这个对象进行导出了。这时默认导出的{}就代表对象了。
      那这样呢我们是用了默认导出的方式来导出了一个对象。如果我们真的有多个对象，我们该如何导出呢，换一种思路吗，
      就变量的形式吗。
      const data = {
        code: 0,
        message: 'success'
      }
      const des = {
        age: 20,
        addr: 'Beijing'
      }
      export default {
        data, 
        des
      }
      import obj from './module'
      这个时候，我们能想起之前学过的解构赋值的知识点，是不是在这个地方可以做一个结合。那obj是一个对象，我们能不
      能利用object对象的解构赋值的方式来接受我们刚才导出的两个模块呢。改成：
      import {data, des} from './module'
      这个时候浏览器是报错的。为什么，因为解构赋值是不是用花括号的形式，非默认模块导入的时候是不是也是花括号的形
      式，又冲突了。所以你的解构赋值在导入默认的对象的形式模块的时候是不能用的，但是你可以先接受下来这个模块，然
      后在下面做解构赋值的操作。
      关于对象的导出要比变量函数的导出要麻烦一点，这里主要是解决歧义的问题。因为导出其他模块也是用到对象{}这种形
      式，如果我们再导出这样一个对象的话，它就歧义。引擎就无法理解，你到底是导出一个object对象，还是用object对
      象的形式去导出变量或函数。所以我们要特别注意导出对象的时候要怎么做。
    12.导出一个类
      class Test {
        constructor () {
          this.id = 2
        }
      }  
      export {
        Test
      }
      或者直接导出的时候定义
      export class Test {
        constructor () {
          this.id = 2
        }
      }  
      import {Test} from './module'
    13.导出多个类
      class Test {
        constructor () {
          this.id = 2
        }
      }  
      class Test2 {
        constructor () {
          this.id = 2
        }
      } 
      export {
        Test,
        Test2
      }
      import {Test, Test2} from './module'
    14.默认导出类
      class Test {
        constructor () {
          this.id = 2
        }
      }  
      export default Test
      import Test from './module'
      不用再用对象那样再去包了。 
      或者直接导出的时候定义类
      export default class Test {
        constructor () {
          this.id = 2
        }
      }  
      或者默认导出时不加名字
      export default class {
        constructor () {
          this.id = 2
        }
      }  
      import Test from './module'
    15.导入所有的导出的内容
      import * as Mod from './module'
      也就是说我把你所有的导出的模块都放到Mod这个对象下面去。
      如果你有默认导出，那个default的值在Mod.default里面。
    16.被导出的模块是能在本模块中引用到的。
      export function say () {
        console.log('say')
      }
      export function run () {
        say()
      }
    问题：
    1.导出的都是对象吗，导入也都是按对象去接收的吗？
    2.2导入3，1导入2，那么1能引用到3中的内容吗，就是说相当于1导入了3吗。
  2.模块化之前的自己的总结
    1.es6
      export, export default, import
      1.export与export default均可用于导出常量、函数、文件、模块等
      2.export和export default的区别
        1.export不限变量数可以导出多个，且导出的东西必须要命名过的，导出变量名字(这个名字为上面定义好的值,函数或对象)
          时一定要加上{}，只有在导出时在export后面现命名的时候不需要加{}。
          export default只输出一次
        2.export导出的变量想要使用必须使用{}来盛放，即import时需要知道所加载的变量名或函数名。
          export default不需要，只要import任意一个名字来接收对象即可，即import时可指定任意名字。
    2.CommonJS
      exports, module.exports, require
es7
1.includes
  es7中的数组如何判断元素是否存在。
  在es6的时候，我们利用find去找一个元素是不是存在。es5的时候还讲过filter去过滤有没有一个元素，其实也可以间接
  的判断它有没有。到了es7把这个问题更加的简化了。更加的语义化了。
  const arr = [1, 2, 3, 4, 5, 6, 7]
  console.log(arr.includes(4)) // true
  这个api跟find差不多，但是find更侧重于我找到这个元素，而includes是说这个数组包不包含某个元素。从es7之后，
  你要习惯去用includes来做判断。
2.**
  数学乘方的简写
  console.log(Math.pow(2, 5)) // 32
  console.log(2 ** 5) // 32
es8
1.async/await
  1.async
    声明函数的前面加一个关键字async
    async function firstAsync () {
      return 27 // 引擎会自动帮你转成这种效果Promise.resolve(27)
    }
    promise是在函数内部通过手动的new Promise对象来返回一个promise实例，达到了一个异步操作的过程，这个函数的
    返回值是一个promise对象。这样的话，我们在执行这个函数的时候，就可以调一个.then方法来继续下一步的操作。这个
    就是异步操作的过程。函数的调用就是用来等待异步操作的过程，.then是结果。
    async的作用就是不用你手动返回一个promise，你只要在function前面加一个async，在你返回的不是一个promise的
    时候，它会自动的帮你把返回值变成一个promise实例。
  2.await
    1.
      async function firstAsync () {
        let promise = new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve('now it is done')
          }, 10)
        })
        promise.then(val => {
          console.log(val)
        })
        console.log(2)
        return 3
      }
      firstAsync().then(val => {
        console.log(val)
      })
      // 2
      // 3
      // now it is done
    2.
      async function firstAsync () {
        let promise = new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve('now it is done')
          }, 10)
        })
        console.log(await promise)
        console.log(await 30) // 等价于await Promise.resolve(30)
        console.log(2)
        return 3
      }
      firstAsync().then(val => {
        console.log(val)
      })
      // now it is done
      // 2
      // 3

      await promise它是一个表达式了，表达式它是有一个结果的，表达式最终是用来计算出一个结果的。await后面加了
      一个promise对象它就是一个表达式了。而且这个表达式的值就是你promise所返回的值。await后面必须跟一个promise
      对象，如果不是它会帮你自动处理成一个promise对象。await必须配合async来用。
  3.async和await是promise的语法糖。换了一种写法，背后还是promise的运作原理。只是使用的方式更加清晰，简洁，优雅。    
2.Object keys.values.entries  
  es8新增的对object快速遍历的方法。
  1.
    let grade = {
      'lilei': 96,
      'hanmeimei': 99
    }
    // es5
    let result = []
    for (let k in grade) {
      result.push(k)
    }
    console.log(result) // ['lilei', 'hanmeimei']
    // es8
    console.log(Object.keys(grade)) // ['lilei', 'hanmeimei']
  2.
    keys是遍历所有的key到一个数组
    values是遍历所有的value到一个数组
    entries是把一个不支持遍历的对象变成一个可遍历的对象，并且可以解构赋值
3.新增对字符串补白的方式
  1.es5
    for (let i = 0; i < 32; i++) {
      if (i < 10) {
        console.log(`0${i}`)
      } else {
        console.log(i)
      }
    }
  2.es8
    for (let i = 0; i < 32; i++) {
      console.log(i.toString().padStart(2, '0'))
    }
4.如何获取object数据的描述符
  let data = {
    PortLand: '78/50',
    Dublin: '88/52',
    Lima: '58/40'
  }
  1.后端返回的数据中，其实是包含某一数据的，只是它会有个状态标记这条数据是无用的。如果在打印这个整体的数据的时候，
    你是不应该再显示这条数据的，它是没用的数据。
    你不能直接用：
    delete data.Lima
    这样数据就被删除了，但是这个数据只是现在不显示，以后可能还要用，所以不能删除。
    所以这个地方就要利用描述符了。描述符就是用来告诉你这个对象如何来操作这个数据。
    1.defineProperty
      Object.defineProperty(data, 'Lima', {
        value: '58/40', // 值
        writable: true, // 可写
        enumerable: false, // 可枚举
        configurable: true // 可配置
      })
      console.log(Object.keys(data)) // ['PortLand', 'Dublin']
    2.getOwnPropertyDescriptors
      拿到data这个对象中所有的数据的描述符，利用这个就可以知道data所有数据的信息
      console.log(Object.getOwnPropertyDescriptors(data))
    3.getOwnPropertyDescriptor
      拿到data这个对象中某一项数据的描述符
      console.log(Object.getOwnPropertyDescriptor(data, 'Lima'))
es9
1.for await of
  1.异步操作集合的遍历
    function Gen (time) {
      return new Promise((resolve, reject) => {
        setTimeout(function () {
          resolve(time)
        }, time)
      })
    }
    async function test () {
      let arr = [Gen(2000), Gen(100), Gen(3000)]
      for await (let item of arr) {
        console.log(Date.now(), item)
      }
    }
    test()
    1.for of是用来遍历同步操作的，如果你的数组或集合里面有异步操作for of是不能拿到正确结果的。
    2.使用for of配合await的对于集合中存在几个异步操作的时候，结果不是很理想的。
    2.for await of是真正操作异步结合的。
  2.自定义遍历器中存在异步操作的时候
    const obj = {
      count: 0,
      Gen (time) {
        return new Promise((resolve, reject) => {
          setTimeout(function () {
            resolve({done: false, value: time})
          }, time)
        })
      },
      [Symbol.asyncIterator] () {
        let self = this
        return {
          next () {
            self.count++
            if (self.count < 4) {
              return self.Gen(Math.random() * 1000)
            } else {
              return Promise.resolve({
                done: true,
                value: ''
              })
            }
          }
        }
      }
    }
    async function test () {
      for await (let item of obj) {
        console.log(Date.now(), item)
      }
    }
    test()
2.promise.finally
  const Gen = (time) => {
    return new Promise((resolve, reject) => {
      setTimeout(function () {
        if (time < 500) {
          resolve(time)
        } else {
          reject(time)
        }
      }, time)
    })
  }
  Gen(Math.random() * 1000)
    .then(val => console.log('resolve' + val))
    .catch(err => console.log('reject' + err))
    .finally(() => console.log('finish'))
  finally始终都会被执行
3.新增Object的rest和spread方法
  1.spread
    const input = {
      a: 1,
      b: 2
    }
    const output = {
      ...input,
      c: 3
    }
    console.log(input, output) // {a: 1, b: 2} {a: 1, b: 2, c: 3}
    input.a = 4
    console.log(input, output) // {a: 4, b: 2} {a: 1, b: 2, c: 3}
    Object的spread是使用深拷贝的方式做的，不是直接引用地址的方式。之前要合并对象是非常麻烦的。现在变得很容易。
  2.rest
    const input = {
      a: 1, 
      b: 2,
      c: 3,
      d: 4,
      e: 5
    }
    const {a, b, ...rest} = input
    console.log(a, b, rest) // 1 2 {c: 3, d: 4, e: 5}
4.es9关于正则的新增知识点
  1.dotAll
  2.命名分组捕获
  3.后行断言
  能力大幅提升
es10
es10新增的知识点主要是对原型对象的能力做了增强，它没有一块非常完整的新内容。和对语法的修正。
1.JSON
  JSON.stringify()
  这个api之前有一个bug，就是超出一定范围的unicode展示错误的问题。
  0xD800-0xDFFF之间的字符会因为无法编码成utf8导致显示错误。
  现在es10对这个问题做了一个修正，它会用转义字符的方式让这个范围的字符以非编码的方式存在，这样的话就会有一个正
  常的显示。
2.Array
  1.Array.prototype.flat
    作用：扁平化输出多层嵌套的数组，它会按照一个可指定的深度递归遍历数组。并将所有的元素与遍历到的子数组的元素
         合并为一个新数组返回。其实就是在做扁平化的事情。
    let arr = [1, [2, 3], [4, 5, [6, 7]]]
    console.log(arr.flat(2)) // 1, 2, 3, 4, 5, 6, 7
    这个参数就是递归的次数，数组嵌套的深度。默认值是1。
  2.Array.prototype.flatMap
    既有flat的功能还有map的功能，flatMap就等于先map然后flat
    let arr = [1, 2, 3]
    console.log(arr.map(item => item * 2)) // [2, 4, 6]
    console.log(arr.map(item => [item * 2])) // [[2], [4], [6]]
    console.log(arr.map(item => [item * 2]).flat()) // [2, 4, 6]
    console.log(arr.flatMap(item => [item * 2])) // [2, 4, 6]
3.String
  1.字符串的去除首尾空格
    let str = '   foo   '
    console.log(str.replace(/^\s+/g, '')) // 去除首空格
    console.log(str.replace(/\s+$/g, '')) // 去除尾空格
    console.log(str.replace(/^\s+|\s+$/g, '')) // 去除首尾空格
    console.log(str.trimStart()) // 去除首空格
    console.log(str.trimLeft()) // 去除首空格
    console.log(str.trimEnd()) // 去除尾空格
    console.log(str.trimRight()) // 去除尾空格
    console.log(str.trim()) // 去除首尾空格
  2.matchAll跟正则有关系
4.Object
  1.fromEntries
    数组转object
    const arr = [['foo', 1], ['bar', 2]]
    const obj = Object.fromEntries(arr)
    console.log(obj.bar) // 2
  2.利用entries和fromEntries来使用数组的api操作object
    过滤出key的长度为3的
    const obj = {
      abc: 1,
      def: 2,
      ghijk: 3
    }
    let res = Object.fromEntries(
      Object.entries(obj).filter(([key, val]) => key.length === 3)
    )
    console.log(res)
5.try catch
  捕获异常
  // 之前
  try {

  } catch (e) {

  }
  // es10
  try {

  } catch {

  }
6.bigint
  新增的数据类型
  用来解决处理超过2^53的数字，之前js的处理能力只能处理到这。现在允许你处理一个大于2^53的数字。但它也是数字也
  能进行数字的四则运算。只不过是两种不同的数据类型。数字后面加一个n就变成了bigint数据类型。
  console.log(11n)

### async/await

async/await 跟 Promise 完全不冲突，它用了 Promise 的一些特性，然后又做了一些改进，它们可以结合起来使用。

async 和 await 内部是使用 promise 结合 generator 来实现的。

#### then 只是将 callback 拆分了

它的写法还是异步的写法，本质上还是 callback，因为 then 里面传的是一个函数，只不过比 callback 写法更加模块化，可以链式的串行，不用嵌套很多层。

#### async/await 是直接用同步的写法来写异步

其实我们解决了这么长时间的异步，我们无法改变 js 单线程，异步这种本质。但是单线程，异步的本质导致的问题是我们编写代码的顺序和执行的顺序不一致。所以我们一直在解决那种 callback 所带来的这个问题，现在有了终极解决方案，就是 async/await，它看上去就是一个直接的同步代码写法。

这完全是同步的写法，使用上没有一个回调函数，可能回调函数的事情封装起来了，使用上是完全的同步的写法。

```js
const load = async function () {
  const result1 = await loadImg(src1)
  console.log(result1)
  const result2 = await loadImg(src2)
  console.log(result2)
}
load()
```

#### 语法

* 使用 await，函数必须用 async 标识，这个函数也可以作为一个普通的函数来执行。 
* await 后面必须跟一个 promise 实例，如果不是它会帮你自动处理成一个 promise 对象，await 的返回值就是这个 promise 实例 resolve 或 reject 传出来的结果。

#### async

声明函数的前面加一个关键字 async。

promise 是在函数内部通过手动的 new Promise 对象来返回一个 promise 实例，达到一个异步操作的过程，这个函数的返回值是一个 promise 对象。这样的话，我们在执行这个函数的时候，就可以调一个 .then 方法来继续下一步的操作。这个就是异步操作的过程。函数的调用就是用来等待异步操作的过程，.then 是结果。

async 的作用就是不用你手动返回一个 promise，你只要在 function 前面加一个 async，在你返回的不是一个 promise 的时候，它会自动的帮你把返回值变成一个 promise 实例。

```js
async function firstAsync () {
  return 27 // 引擎会自动帮你转成这种效果Promise.resolve(27)
}
```

```js
async function firstAsync () {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('now it is done')
    }, 10)
  })
  promise.then(val => {
    console.log(val)
  })
  console.log(2)
  return 3
}
firstAsync().then(val => {
  console.log(val)
})
// 2
// 3
// now it is done
```



### Object .keys .values .entries

es8 新增的对 object 快速遍历的方法。

keys 是遍历所有的 key 到一个数组。

values 是遍历所有的 value 到一个数组。

entries 是把一个不支持遍历的对象变成一个可遍历的对象，并且可以解构赋值。

```js
let grade = {
  'lilei': 96,
  'hanmeimei': 99
}
// es5
let result = []
for (let k in grade) {
  result.push(k)
}
console.log(result) // ['lilei', 'hanmeimei']
// es8
console.log(Object.keys(grade)) // ['lilei', 'hanmeimei']
```



### 新增对字符串补白的方式

#### es5

```js
for (let i = 0; i < 32; i++) {
  if (i < 10) {
    console.log(`0${i}`)
  } else {
    console.log(i)
  }
}
```

#### es8

```js
for (let i = 0; i < 32; i++) {
  console.log(i.toString().padStart(2, '0'))
}
```



### 如何获取 object 数据的描述符

后端返回的数据中，某一条数据的是无用的，是不应该再显示这条数据的，它是没用的数据。但你不能直接用：delete data.Lima。这样数据就被删除了，但是这个数据只是现在不显示，以后可能还要用，所以不能删除。所以这个地方就要利用描述符了。

```js
let data = {
  PortLand: '78/50',
  Dublin: '88/52',
  Lima: '58/40'
}
```

描述符就是用来告诉你这个对象如何来操作这个数据。

#### defineProperty

```js
Object.defineProperty(data, 'Lima', {
  value: '58/40', // 值
  writable: true, // 可写
  enumerable: false, // 可枚举
  configurable: true // 可配置
})
console.log(Object.keys(data)) // ['PortLand', 'Dublin']
```

#### getOwnPropertyDescriptors

拿到 data 这个对象中所有的数据的描述符，利用这个就可以知道 data 所有数据的信息

```js
console.log(Object.getOwnPropertyDescriptors(data))
```

#### getOwnPropertyDescriptor

拿到data这个对象中某一项数据的描述符

```js
console.log(Object.getOwnPropertyDescriptor(data, 'Lima'))
```
### 1. v-if 和 v-for 哪个优先级更高？如果两个同时出现，应该怎么优化得到更好的性能？

源码中找答案 compiler/codegen/index.js，查看生成的渲染函数代码。

两者同级时，循环是在条件判断外层，循环的每一条都要走一次条件判断，不管条件是否成立都走了一次循环。

```vue
<p v-for="child in children" v-if="isFolder">{{child.title}}</p>
```

```js
(function anonymous( ) { 
with(this){return _c('div',{attrs:{"id":"demo"}},[_c('h1',[_v("v-for和v-if谁的优先 级高？应该如何正确使用避免性能问题？")]),_v(" "), 
_l((children),function(child){return (isFolder)?_c('p', 
[_v(_s(child.title))]):_e()})],2)} 
})
```

两者不同级时，先判断了条件再看是否执行_l，如果条件是 false，就不用做循环了。这个是它们同时使用的正确方式。

```vue
<template v-if="isFolder"> 
	<p v-for="child in children">{{child.title}}</p> 
</template>
```

```js
(function anonymous( ) { 
with(this){return _c('div',{attrs:{"id":"demo"}},[_c('h1',[_v("v-for和v-if谁的优先 级高？应该如何正确使用避免性能问题？")]),_v(" "), 
(isFolder)?_l((children),function(child){return _c('p', 
[_v(_s(child.title))])}):_e()],2)} 
})
```

结论：

1. 显然 v-for 优先于 v-if 被解析（源码）
2. 如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能
3. 要避免出现这种情况，则在外层嵌套 template，在这一层进行 v-if 判断，然后在内部进行 v-for 循环
4. 如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项，最终给模版渲染的就是最终需要显示的项。不需要在 render 函数中去频繁的判断了。因为 render 函数可能会频繁的执行，如果能让 render 函数代码的执行效率变高，那就是性能优化了。



### ？2. Vue 组件 data 为什么必须是个函数而 Vue 的根实例则没有此限制？

源码中找答案：src/core/instance/state.js - initData()

Vue 组件可能存在多个实例，如果使用对象形式定义 data，则会导致它们共用一个 data 对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，每个组件实例的创建都会在数据初始化 initData 时执行一次该函数，将其作为工厂函数返回全新 data 对象，有效规避多实例之间状态污染问题。而根实例在整个应用程序范围只会创建一个，不需要担心这种情况。



### **3.** 你知道 Vue 中 key 的作用和工作原理吗？说说你对它的理解。

源码中找答案：src\core\vdom\patch.js - updateChildren() 它的作用是递归向下遍历整棵树的重要方法，就是遍历当前节点的所有子节点，并且对他们进行比较，这是 diff 算法中最重要的一个方法。

key 的作用主要是为了高效的更新虚拟 DOM：

由于没有 key，不知道是不是该节点，所以 patch 过程中，判断是否是同一个节点的时候，由于没有 key 是 undefined，所以会将本来不是一个节点的直接判定是一个节点，并强硬的更新节点，效率很低，会多做很多 DOM 操作，性能差。

有 key 的话，会根据 key 找到真正相同的节点，从而减少 patch 的更新次数。更加高效，减少 DOM 操作量，提高性能。



### 4. watch 和 computed 的区别以及怎么选用?

watch：监听器，监听数据的变化，然后做一些我们想做的逻辑。

computed：通过其他数据算出一个新的数据，并且把新的数据缓存下来，当新值依赖的数据没有发生变化，使用的就是缓存的数据，提高了性能，

watch 功能更强大，computed 能实现的 watch 都能实现，computed 底层也是来自于 watch，但是做了更多事情，比如缓存。

computed 更简单高效，优先使用。

有些事情必须使用 watch 实现，比如值变化要和后端交互。就是数据变化时需要执行异步操作或开销较大的操作时使用。



### 5. 你知道 Vue 双向数据绑定的原理吗?

### 6. 简单说一说 Vue 生命周期的理解？

### 7. 你了解哪些 Vue 性能优化方法？

### 8. vue-router 中的导航钩子由那些？

### 9. 简单说一说 Vuex 使用及其理解？



### ？10. 你怎么理解 Vue 中的 diff 算法？

必要性：lifecycle.js - mountComponent()，组件中可能存在多个 key 的变化，一个组件又只有一个 Watcher ，所以需要知道具体哪里发生了变化，这时就必须要用 diff 算法去比对具体哪里变化。

执行方式：patch.js - patchVnode()，patchVnode 是 diff 发生起始的地方，整体策略：深度优先，同层比较 updateChildren() 递归操作。

diff 算法是虚拟 DOM 技术的必然产物：通过新旧虚拟 DOM 的对比（即diff），将变化的地方更新在真实 DOM 上。diff 高效的对比过程也降低了时间复杂度，提高性能。

Vue 中 diff 执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果 oldVnode 和新的渲染结果 newVnode，此过程称为 patch。



### 11. 谈一谈对 Vue 组件化的理解？

组件化：在程序中，将独立的功能和模块单独提出来成为更小的块，有复用性，维护性，测试性，协作性。

Vue 组件化：全局定义，组件定义。

vue-loader 会将 template 编译为 render 函数，.vue 文件最终导出的就是组件配置对象，一个 JS 对象。

 Vue 的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于 VueComponent，扩展于 Vue；

合理的组件划分：将经常变化的内容切割成一个组件。将来频繁执行的渲染函数，更新函数和打补丁的范围就会变得很小了。性能上一定会有好处。功能单一，高内聚，低耦合。

页面组件，业务组件，通用组件。



### 12. Vue 中组件之间的通信方式？

### 13. 谈一谈对 Vue 设计原则的理解？

### 14. 说一说 Vue 响应式理解？

### 15. Vue 为什么要求组件模版只能有一个根元素?

### 16. 你知道 nextTick 的原理吗?

### 17. Vue 如果想要扩展某个组件现有组件时怎么做？

### 18. 什么是递归组件？

### 19. 你对 Vue3.0 的新特性有没有了解？

### 20. 谈谈你对 MVC、MVP 和 MVVM 的理解？
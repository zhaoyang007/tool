Vue全家桶原理剖析
需求分析，设计思路：
  1.vue-router原理
    诉求是浏览器url的地址发生变化的时候，可以知道并且页面里的内容可以重新的渲染一个新的内容，并且不能离开当前页面，就是页面不刷
    新。
    1.url后面加上一个hash
      监听hashchange这个事件，地址发生变化的时候，在路由插件初始化的时候会保留一个路由表。拿到hash变化去路由表里去匹配，就能
      拿到这个路由的定义了，这个定义里有一个关键的选项component，把它拿出来到浏览器里面，我们在页面中放了一个组件是
      <router-view>。这就是实现的关键之所在。在这个组件里，它要做的是把那个路由表里声明的component组件拿出来并给它重新渲染
      一下，所以<router-view>只需要重新执行一下它的render函数，render函数里面有一个h方法，我们只需要用这个h方法把拿出来的
      那个component作为参数一这么重新一渲染，界面中的所有内容就变了。这就是router-vue为什么能够根据hash或历史记录的变化能
      够重新渲染最新内容的原理。
    2.h5的history API，有一个pushState/replaceState事件，利用的真实的url变化，操作history历史记录的堆栈，利用这些事件，
      url是会发生变化的，但是浏览器的行为是依然不跳转。
  2.vuex原理
    有一个视图view，有一个vuex的store实例，store需要提供什么东西才能让视图拿到store里面存储的数据呢？首先store里面有一个
    state，在view里我们会使用$store.state.xx来访问store里的数据。问题是我们现在要实现一个view和store之间的单向数据流，我
    想改state，不能直接在view里去改，必须通过store提供的方法去改。我们需要通过commit方法提交一个mutation。所以在store里必
    须实现一个commit方法。我们要创建一个store这样的类，这个类需要有一个state这样的属性，还需要一个commit方法，还有dispatch
    方法。用户在配置创建store实例的时候，应该用什么方式修改state，称为mutations。这个state状态的变化怎么能够通知界面去重新的
    render呢？答案是数据响应式，要想办法让这个state能够是一个响应式的数据，vue最重要的功能就是实现数据响应式，所以在实现store
    的时候，显然我们对vue有一个强烈的依赖。我们利用vue来做state的数据响应式。state发生变化的时候，可以让界面重新render渲染，
    也就起到了更新的作用。所以vuex是跟vue强耦合的，它们是不可分割的，只能用在vue里面就是这个原因。 
知识储备
  1.vue插件
    router/vuex都是插件
  2.render(h)函数
    在实现router/vuex的时候，多次会用到render函数，在实现一个组件的时候我们可能会用render函数直接去把这个内容渲染出来，而没
    有办法用template方式去声明。
  3.数据响应式
    1.router/vuex中都会利用数据响应式。要用到vue的一个方法，在vue的构造函数上有一个帮助方法Vue.util，这里面有一个专门定义响
      应式的方法叫defineReactive。
    2.数据响应式还可以直接用new Vue({...})的形式，通过在配置中定义data的数据也可以做响应式。这种方式可以用在vuex的state上面。
  4.es6 class
直播课内容
  1.内容
    全家桶的原理及手写
  2.知识点
    1.vue-router
      1.Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。
      2.安装: vue add router
      3.使用核心步骤:
        步骤一:应用vue-router插件，router/index.js
          import Router from 'vue-router'
          Vue.use(Router)
        步骤二:创建Router实例，router/index.js
          // 配置一些选项，其中最重要的选项是routes，routes里面是具体每个路由的配置
          export default new Router({...})
        步骤三:在根组件上添加该实例，main.js
          import router from './router/index'
          new Vue({
            router, // 全局使用是需要把它注册到prototype上去的：Vue.prototype.$router = router。我们有个$router去用。
                    // 我在这只是注册了一个router，它怎么将它挂到prototype上去的呢。router插件里面要做的一件事就是拿出当前
                    // 的选项，然后挂载到Vue.prototype.$router上。不然在任何组件里面没法找到这个router。挂载这个实例是为了
                    // 在所有组件都可以使用$router，可以访问到路由的实例。
          }).$mount("#app");
        步骤四:添加路由视图，App.vue
          // 路由出口，它起到容器或坑的作用，将来所有的内容就会在这里面做刷新和替换。它到底是怎么替换的。router-link和
          // router-view这两个组件为什么可以直接用。说明router插件里面会有这两个组件的声明和注册。
          <router-view></router-view>
        导航
          <router-link to="/">Home</router-link>
          <router-link to="/about">About</router-link>
        通过使用的分析，大概就能知道做vue-router插件有哪些任务了
      4.vue-router源码实现
        1.需求分析
          根据地址的变化，从路由表中获取到最新的component，把它渲染到router-view里，就是让router-view重新渲染。
          1.实现一个插件，vue-router是一个插件：实现VueRouter类和install方法 
          2.实现两个全局组件：router-view用于显示匹配组件内容，router-link用于跳转 
          3.监控url变化：监听hashchange或popstate事件 
          4.响应最新url：创建一个响应式的属性current，当它改变时获取对应组件并显示
        2.实现一个插件:创建VueRouter类和install方法
          创建kvue-router.js
        3.创建router-view和router-link 
          创建krouter-link.js
          创建krouter-view.js
        4.监控url变化 
          定义响应式的current属性，监听hashchange事件
        5.提前处理路由表
          提前处理路由表避免每次都循环
      5.vue-router源码
        所有代码在src
    2.vuex
      1.Vuex 集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以可预测的方式发生变化。
        集中式：整个应用程序的状态集中在一个store中去保存。这也是vuex最大的作用，就是让我们的整个程序的状态在一个很稳定，可
              控的范围内。要是分散到各个组件里头就极容易出问题。因为组件之间要有同步的问题。
        可预测：经过严格的限定，所有使用数据的人都不知道这个数据是哪来的，就是别人直接给它的。它想改这个数据，它也不能直接改，
               必须通过别人提供给它的修改方法。比如commit一个mutation或dispatch一个action，才能去改store里的数据。这
               样的话，不管任何的修改在进到这个store之前，store都可以有计划的预测这些变更。将来调试的时候任何状态变化有问
               题很容易查出来是谁在尝试着变更新的状态。数据变更之前也可以做很多事情，做日志记录，统计分析等。主要是错误的排
               查和可追溯。遵循单向数据流。
        利于同构：而且这样统一的管理很有利有同构开发，服务端渲染ssr只需要在服务器上跑一个vue的实例，然后把当前store里存的状
                态渲染出来，然后把渲染出来这个页面的html信息直接返回给前端就行了。同构是说我在前端和后端写是用相同的结构相
                同的方式。这就是它的一些好处了。以前vue只是一个纯前端的技术，没办法在服务端写，有些前端程序员不会jsp/php，
                那怎么用ssr在服务端渲染呢，于是就有了这么个思路，就是我跑一个vuex在服务器上，然后只需要做一个快照把当前
                store中的状态渲染出来，然后把生成这个快照的html返回给前端。这就是ssr的原理。所以vuex是非常重要的。
        有一个问题需要注意，当状态发生变化的时候怎么通知视图去更行的。也是它和redux最不同的地方。vuex里面依然是用vue管理的
        数据响应式，所有的state都是响应式的。跟router中url的current是一样的。只要state里面的值发生变化，用到这些key的视
        图都会重新render。并不是有什么神奇的力量把store中的值给送到视图来了，只是组件知道数据变了它重新渲染了。它是由于vue
        数据响应式做到的这一点。
      2.整合vuex
        vue add vuex
      3.使用
        核心概念
          state 状态、数据 
          mutations 更改状态的函数 
          actions 异步操作
          store 包含以上概念的容器
        状态 - state 
          state保存应用状态
          export default new Vuex.Store({
            state: { counter:0 },
          })
        状态变更 - mutations 
          mutations用于修改状态，store.js
          export default new Vuex.Store({
            mutations: {
              add(state) {
                state.counter++
              } 
            }
          })
        派生状态 - getters 
          从state派生出新状态，类似计算属性
          export default new Vuex.Store({
            getters: {
              doubleCounter(state) { // 计算剩余数量 
                return state.counter * 2;
              } 
            }
          })
        动作 - actions
          添加业务逻辑，类似于controller
          export default new Vuex.Store({
            actions: {
              add({ commit }) {
                setTimeout(() => {
                  commit('add')
                }, 1000);
              } 
            }
          })
        测试代码:
          <p @click="$store.commit('add')">counter: {{$store.state.counter}}</p>
          <p @click="$store.dispatch('add')">async counter: {{$store.state.counter}}</p> 
          <p>double:{{$store.getters.doubleCounter}}</p>
      4.vuex原理解析
        1.任务分析
          实现一个插件:声明Store类，挂载$store 
          Store具体实现:
            创建响应式的state，保存mutations、actions和getters 
            实现commit根据用户传入type执行对应mutation 
            实现dispatch根据用户传入type执行对应action，同时传递上下文 
            实现getters，按照getters定义对state做派生    
          要实现一个store类，里面有一个state属性，还有两个方法，commit和dispath。commit可以直接改state，dispatch是给它
          传个上下文，让它通过调commit的方式来改state。这是写store之前的一个思路想法。还有一个数据响应式的问题，是通过
          new Vue({data: options.state})的方式将state变成响应式数据的，这样state发生变化，使用state数据的组件就会重新
          render。
        2.初始化:Store声明、install实现，kvuex.js:
        3.实现commit:根据用户传入type获取并执行对应mutation
        4.实现actions:根据用户传入type获取并执行对应mutation
      5.vuex源码
        所有代码在src
        要研究的主要目标是入口index.js，store实例store.js
    3.作业
      1.尝试去看看vue-router的源码，并解答:嵌套路由的解决方式 
        1.做router-view的深度标记
        2.路由匹配时获取代表深度层级的matched数组
      2.尝试去看看vuex的源码，并实现getters的实现
      3.了解vue数据响应原理为下节课做准备 
        vue常见的数据响应式的实现
        Object.defineProperty() // 这是最底层的
        Vue.util.defineReactive()
        Vue.observable()
        new Vue({
          data() {}
        })
        ...等
        这些东西的内部是怎么去做数据修改的追踪拦截的。
        像数组这样的不支持Object.defineProperty()的应该怎么去做。
        界面中视图的更新函数到底从哪来，怎么这个数据变了那个部分就要去更新呢，就会涉及到依赖收集这样的概念。
        
        



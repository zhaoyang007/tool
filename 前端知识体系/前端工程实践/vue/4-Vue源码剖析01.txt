Vue源码剖析01
预习内容
  搭建调试环境
    1.clone源码，获取地址：https://github.com/vuejs/vue.git  版本:2.6.10
    2.安装依赖：npm install
    3.安装rollup，因为vue的打包工具是rollup：npm install -g rollup
    4.修改dev开发脚本：添加 --sourcemap
      我们在打包的时候需要保存当前的一些映射的文件，这样在研究源码的时候可以非常轻易的看到代码它到底在哪个文件中，整个结构就会更
      清晰一些。所以需要修改一下打包脚本package.json。
      "dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev",
    5.然后就可以开始打包工作了，执行开发脚本：npm run dev
      打包成功之后dist下会生成一个全新的vue.js，并且多了一个该文件的map文件vue.js.map，我们在调试的时候就可以和源码之间产生
      一个很好的映射，非常好的去看这些源代码了。
  调试技巧
    1.编写测试文件
      搭建完调试环境后，我们可以创建一个测试脚本来看看我们打包的东西是否正常。在任何地方写都可以，vue有些案例在examples里，我们
      就可以在这来编写测试文件。
      test/01-test.html
      把刚才打包的vue.js引进来。
      剩下的就正常的写一个vue程序就行了。
      编写简单的vue程序，浏览器打开没有报错，并且有vue初始化的一些输出就可以了。
    2.通常情况下需要打开一些指定的文件：ctrl+p
    3.断点
    4.单步执行
      单步跳过函数和单步进入函数
    5.查看调用栈
      研究的过程中，想搞清楚先后之间的调用关系，有时进入过深的时候，往往就懵了搞不清楚了。这时就可以好好的研究这个Call Stack，可
      以很有效的把你的思路去理顺。整个初始化过程是谁，调用的谁，整个过程会显得很清晰。调用栈中就可以很好的看到整个的函数的调用执行
      的流程。
    6.定位当前源文件所在位置，以方便下次再看的时候心中有数，以后就知道这个代码在哪找到了，随着这个过程我研究的次数越来越多，我可能
      就把整个源码的脉络都熟悉了。
      sources代码上右键，找到Reveal in sidebar命令，就是在侧边栏里找到这个文件所在的目录。
直播内容
  除了学习知识之外，还要学会学习方法，比如代码的基本的组织方式，怎么去调试，看到源码之后应该有怎样的策略去拆解它学习它。
  看完官方的实现之后，自己动手琢磨琢磨，反复的去试，思维就逐渐形成了。这样训练能力。
  1.学习目标
    环境搭建
    理顺vue整个源码的学习流程：以后怎么自己去掌握它
    vue初始化过程的研究
    深入数据响应式
  2.知识点
    1.调试环境搭建
    2.源码目录结构
      /dist             发布目录，最终输出的所有js文件都在这里，各个发布版本之间存在差异。
      /examples         范例，里面有我们研究源码时的测试代码
      /flow             2.6这个版本还是基于flow去写的，所以还会有flow这个类型声明文件，针对flow的类型声明
      /types            对ts的类型声明
      /packages         里面有一些核心代码之外的独立库，这些东西它认为不应当是项目核心的东西，它单独的拆分写到这些包里头了，所以它跟我们核心代码无关。
      /scripts          我们要找入口文件，还要跟这个文件里的构建脚本打打交道
      /src              源码，我们就是要研究这里面的所有东西
        /compiler       编译器相关
        /core           核心代码都会在这里头，要常来这里看看啊
          /components   通用组件，keep-alive，为什么只有这一个组件，因为它是所有平台通用的。weex或web平台会有特殊的像transition这样的组件，它会写到其他的目录去。就会写到platforms这个目录的weex或web里头单独去组织，所以代码的分工是非常清楚的。很值得去借鉴。
          /instance     在核心代码中，最应该关心的目录应该是这个。vue的构造函数就会在这里头。查找的思路是什么呢，怎么会找到这里。
          /global-api   全局API
          /observer     响应式相关
          /vdom         虚拟dom相关
      以后研究的过程中应该很清楚的能够找到这些目录和想要的文件才行。
      输出的各个发布版本：
        runtime：仅包含运行时，不包含编译器，写程序的时候不能使用template这个配置项去写字符串的模版。
        common：只能用于像nodejs那边的require的方式称为commonjs，用cjs规范来进行打包的，用于像webpack1等老旧版本打包工具。
        esm：ES模块，主要用于webpack2+这些打包工具。
        umd：universal module definition，就是什么都没写的如vue.js，兼容cjs和amd规范（异步模块）浏览器里面加载模块都希望是异步的啊，所以amd规范特别适合在浏览器里使用，浏览器里面直接用不经过打包工具打包的一般会用这个版本。
    3.找入口
      打包工具的项目怎么找到项目的入口文件，然后从这个入口文件开始研究源码
      入口怎么找，我们的策略是怎样的呢，一般就是先从package.json开始，因为我们打包的时候用的是这个dev，rollup打包的，-c指明了
      配置文件在哪，所以我们去找这个配置文件，就很容易能够找到你想要那个开发版本它的入口entry到底是谁。在这个config.js怎么找你
      想要的版本呢，有一个builds的对象，所有的创建的配置都会在这里头，在package.json中dev命令的后面传了一个参数
      TARGET:web-full-dev，根据这个名字来config.js里找你要的那个配置文件。我们之前做测试调试的就是这个版本，在这这个配置中就
      有我们整个项目的入口文件，我们看代码就知道从哪开始了。研究源码我们要多次与这个入口文件打交道，尤其是初始化过程。
    4.初始化流程
      入口文件 src/platforms/web/entry-runtime-with-compiler.js
        覆盖扩展默认$mount方法，处理template或el选项，执行模版解析和编译工作。
      寻找Vue构造函数 
        src/platforms/web/runtime/index.js（入口文件中引用Vue的地址）
          安装web平台特有指令和组件 
          定义__patch__:补丁函数，执行patching算法进行更新 
          定义$mount:挂载vue实例到指定宿主元素(获得dom并替换宿主元素)
        src/core/index.js
          定义了全局的API
          具体如下:
            Vue.set = set
            Vue.delete = del
            Vue.nextTick = nextTick
            initUse(Vue) // 实现Vue.use函数
            initMixin(Vue) // 实现Vue.mixin函数
            initExtend(Vue) // 实现Vue.extend函数
            initAssetRegisters(Vue) // 注册实现Vue.component/directive/filter
        src/core/instance/index.js
          定义Vue构造函数的地方
          定义Vue实例API
            function Vue (options) { 
              // 构造函数仅执行了_init 
              this._init(options)
            }
            initMixin(Vue) // 实现init函数
            stateMixin(Vue) // 状态相关api $data,$props,$set,$delete,$watch 
            eventsMixin(Vue)// 事件相关api $on,$once,$off,$emit 
            lifecycleMixin(Vue) // 生命周期api _update,$forceUpdate,$destroy 
            renderMixin(Vue) // 渲染api _render,$nextTick
                             // $nextTick：更改数据想立刻看到dom更改的结果。在这行代码的下面看的话，这个结果并没有，因为vue做
                             //            的是异步更新的操作，想要看到dom变化必须写在$nextTick的回调中。
        src/core/instance/init.js
          创建组件实例，初始化其数据、属性、事件等
          初始化方法_init定义的地方
          init代码核心功能：
            initLifecycle(vm)     //zy 声明$parent $root $children $refs
            initEvents(vm)        //zy 处理父组件传入的事件和回调，就是对父组件传入的事件添加监听
            initRender(vm)        //zy 跟渲染相关的东西，渲染相关那肯定也就是跟虚拟dom相关的东西。声明了$slots, $createElement
            //zy 完成了上面三件事之后，会调一个beforeCreate，所以beforeCreate里面可以用上面声明的所有的东西
            callHook(vm, 'beforeCreate') //zy 调用beforeCreate钩子
            initInjections(vm)    //zy 注入数据 // resolve injections before data/props
            initState(vm)         //zy 重要：数据的初始化props，methods，data，computed，watch，数据响应式
            initProvide(vm)       //zy 提供数据 // resolve provide after data/props
            //zy 上面的事情都做完后，会有一个created这个生命周期，这个时候所有的初始化全部完成了，你可以放心大胆做你任何想做的事情了。
            callHook(vm, 'created')
      初始化过程后续
        core/instance/lifecycle.js
          mountComponent
          执行挂载，获取vdom并转换为dom 
        src\core\instance\render.js
          render()
          渲染组件，获取vdom
        src\core\instance\lifecycle.js
          update()
          执行更新，将传入vdom转换为dom，初始化时执行的是dom创建操作
      初始化过程
        new Vue() => _init() => $mount() => mountComponent() => _render() => _update()
        调用init => 初始化各种属性 => 调用mountComponent => 声明updateComponent、创建Watcher => 获取虚拟dom => 把虚拟dom转为真实dom
      测试代码：examples\test\01-init.html
    5.数据响应式
      整体流程
        具体实现是在Vue初始化时，会调用initState，它在下面的文件中定义：
        src/core/instance/state.js
          初始化数据，包括props、methods、data、computed和watch，这里着重关注data初始化
          initData：获取data，设置代理，启动响应式observe
        core/observer/index.js
          observe方法返回一个Observer实例
        core/observer/index.js
          Observer对象根据数据类型执行对应的响应化操作 
          defineReactive定义对象属性的getter/setter，getter负责添加依赖，setter负责通知更新
        core/observer/dep.js
          Dep负责管理一组Watcher，包括watcher实例的增删及通知更新 Watcher
          Watcher
            解析一个表达式并收集依赖，当数值变化时触发回调函数，常用于$watch API和指令中。
            每个组件也会有对应的Watcher，数值变化会触发其update函数导致重新渲染
              export default class Watcher {
                constructor () {}
                get () {}
                addDep (dep: Dep) {}
                update () {}
              }
              相关API: $watcher
        测试代码examples\test\02-1-reactive.html
      数组响应化
        数组数据变化的侦测跟对象不同，我们操作数组通常使用push、pop、splice等方法，此时没有办法得知数据变化。所以vue中采取的策
        略是拦截这些方法并通知dep。
        src\core\observer\array.js
          为数组原型中的7个可以改变内容的方法定义拦截器
        Observer中覆盖数组原型
          if (Array.isArray(value)) {
            // 替换数组原型
            protoAugment(value, arrayMethods) // value.__proto__ = arrayMethods this.observeArray(value)
          }
        这也反映了一个问题，我们平常写代码的时候，有些方式是不可以的。
          items = [1, 3]
          item[0] = 'abc' // no ok
          Vue.set(itme, 0, 'abc') // ok
        测试代码examples\test\02-2-reactive-arr.html
        相关API: Vue.set()/delete()
      Vue2.0中响应式的缺点
        1.各种递归遍历，性能会受影响，如果数据很大，有一个超大的数据，一开始光做这些递归循环去给它们做响应式的拦截就非常非常可怕。
          所以3里才会用Proxy去避免这个事，它只会在外面加壳。
        2.api不统一，对于数组和object是两套方案。所以这两套方案调用的时候很多细节就要知道，尽量去规避这些情况。有时候一不小心就
          会出现数据改了，界面不会变，就是因为没有合适的做这个操作。
        这些问题Proxy都能很好的去解决实现。
作业
  1.理出整体流程思维导图
    理清整体的流程，每个文件从哪开始怎么进去，它们是做什么的，有什么作用，把整个过程流程给理顺理通。
  2.自己尝试编写测试案例调试
    编写测试案例，找一些断点把自己的想法想要观察的地方动手调试一下。这个技能非常重要，它是学习源码深入理解这些问题的一个非常重要的
    手段。
  3.自己研究一下Vue.set/delete/$watch等API
    你在研究这些东西的时候，从哪开始呢，它在哪个文件，但是一开始根本不知道它在哪，不太容易找，怎么办呢，可以写上一个测试的页面，在
    里面调一下你要研究的api接口，一调试不就知道它在哪了吗。这是一个最简单的方式，在我们刚开始学习的阶段是很有效的。
  4.尝试看看vue异步更新队列是如何实现的
    1.Queue
      既然是异步更新，显然要涉及一个概念就是队列Queue，将来vue会创建一个队列，每一次提交更新的时候不会立刻做这件事，而是尝试把这
      个Watcher直接往队列里面放，如果这个Watcher已经在队列里了，会做去重，不让它再进去了。所以一个Watcher在一个队列中只可能出
      现一次，同时对组件里的n个key做了修改，最终进入到队列的Watcher只有一个。
    2.批量异步
Vue初始化流程和数据响应式知识点思维导图
https://www.processon.com/view/link/5d1eb5a0e4b0fdb331d3798c

问题
vue的vdom + diff + 操作dom
就比直接原生或jquery直接操作dom的性能更高吗

github地址
https://github.com/57code/vue-study/tree/web16

手撸Vue，手写mvvm框架
简版的mvvm框架的实现
  数据放生变化会映射到视图中让视图更新，就是数据响应式。
  vue的实现思路是监听拦截一下数据对象的，将来有人访问这个数据，不管是get还是set我都能够知道。vue数据响应式的原理是使用
  Object.defineProperty()给obj设置了一个拦截器。一个getter方法，一个setter方法。通常的做法是用户尝试改这个值的时
  候，就会触发setter方法，就可以在setter方法里做更新操作，让它去改变视图中相对应的值，这样界面就更新了。用户编程的时候
  只需要改数据就行了。典型的数据驱动。这个过程中有一个问题是在更新的操作中需要写innerHTMl或innerText为最新的值，这样
  才能实现视图的更新，在大型的项目开发中，我们不想这样做。我们希望这个更新函数能自己生成。所以编译器这个概念就产生了。这
  个编译器主要的作用是在视图中创建一些语法，比如差值语法就是一个典型的动态绑定，编译器的主要作用是作为一个中间人，可以把
  我们写的模版引擎的语法变成标准的html的更新函数。这就是编译器最终的目标。我们要实现的简版的vue里面如何去做这件事呢？我
  希望这个编译器将来可以得到一些更新函数，每个在模版中绑定的数据都对应着一个更新函数，我们会得到一个更新函数updater，这
  个updater必须知道和谁相关，谁变了之后才会执行它，所以一定要创建一些关系让我们知道setter的时候执行哪个updater，因为
  一个数据在界面中可能有多处绑定。比如界面中有两个{{foo}}一个{{bar}}，相对应就会有三个updater，这几个updater要怎么
  做呢，于是我们创建了一个观察者模式，每一个updater我们都创建一个观察者watcher，它的作用非常简单，只维护一个更新函数，
  将来在界面中编译的时候，会发现绑定的这个值，当我发现它的时候，我把这个watcher和这个值产生一个关联，界面可能会出现两个
  foo，这两个watcher实例和同一个key产生了关联，怎么去管理这种关系呢，我们会在每一个key里创建一个类Dep，现在出现了两个
  关系，一个叫Dep，一个叫watcher。而这个Dep里会有数组会管理多个watcher，一对多的这样的关系就诞生了。将来用户改这个值
  的时候，setter会执行，执行时会从这个值对应的Dep里拿出所有的watcher，执行它们的更新函数。视图就更新了。这就是做简版
  vue的一个实现思路。
理解Vue的设计思想 
  MVVM模式
    一个mvvm框架应当具备的要素。有一个设计思想，就知道怎么大概的去实现。
    MVVM是一个模式
      vm ViewModel叫视图模型。vue最核心的就是中间这个vm，它是中间层，它最重要的作用是作为一个中间人中介者来负责数据
      和视图之间进行交互的。这样有一个纯的js数据，怎么能够进行数据驱动的这种编程呢，我希望有一个中间层能替我做这件事情，
      当我改这个数值的时候，由于数据绑定数据响应式，可以直接在界面中映射显示出来。反过来如果用户通过事件的方式去跟数据
      进行打交道的话，应该能反作用这边的数据。mvvm就是这样的一个过程。
    MVVM框架的三要素:数据响应式、模板引擎及其渲染
      数据响应式:监听数据变化并在视图中更新
        有一个数据想让它动态的响应在视图中，就应当实现这个数据响应式。
        Object.defineProperty() 数据拦截数据劫持，变化的时候能够得知(get)，然后对它进行更新的操作即可（set)
        Proxy
      模版引擎:提供描述视图的模版语法
        为了将动态的数据在视图中表示出来，就需要特定的绑定语法来描述这个视图。所以就需要实现模版引擎的语法。
        插值:{{}}
        指令:v-bind，v-on，v-model，v-for，v-if 
      渲染:如何将模板转换为html
        实现了模版语法之后，我们必须把它解析，因为它不是真正的html，需要把特殊的动态的绑定给生成html，所以还要涉及到渲染。
        模板 => vdom => dom
        把模版转换成虚拟dom，虚拟dom就是js对象，它们可以来描述真实的dom对象vdom和dom之间有一个映射关系。当用户改数值的
        时候，其实用户只是修改虚拟dom。怎么个修改法呢，通过一种生成的方式，比如这个数据一变，就重新生成vdom，它是一棵树，
        能够反应这个视图的基本结构，将来再通过diff算法，把新老树之间做一个对比，得出真正应该做的最小的dom操作。这个就是做
        渲染的一个策略。
    数据响应式原理
      数据变更能够响应在视图中，就是数据响应式。vue2中利用Object.defineProperty()实现变更检测。
      1.简单实现
      2.结合视图
      3.遍历需要响应化的对象
      4.解决嵌套对象问题
      5.解决赋的值是对象的情况
      6.如果添加/删除了新属性无法检测
    Vue中的数据响应化 
      目标代码
        kvue.html
      原理分析
        vue初始化时大概做的事情
          对框架的构造函数Vue实例化的时候会做两件事。
            1.数据响应式，Observer它会劫持所有的属性，这样它就会知道数据将来会放生变化。
            2.编译Compile
              解析模版里面出现的非html的东西。初始化视图。会把Observer劫持的数据get一下得到它的初始值并赋值，这时用户就可以
              看到界面最初的数据了，但是这时数据发生变化，界面不会变。因为现在还没有把整个的闭环连起来，现在还要解决一个问题就
              是当数据发生变化的时候，能让界面也发生变化。怎么做到这一点呢，我们引入了几个新的角色。
              分别是观察者Watcher，它的所用是，将来在界面中只要出现一个绑定，我们就创建一个观察者watcher，这个watcher里面
              会保存一个更新函数，这个更新函数做的事情就是做刚才它发现的那个dom元素的更新操作。这个更新函数只要做一个引用把它
              保存在刚才创建的那个watcher里面就行了。将来只要发现这个数据发生变化的时候，我就执行这个wathcer中的更新函数，界
              面中就更新了。现在这个Watcher和Observer之间还没有产生关联。它们还没有产生闭环，这个闭环的关键是Dep，依赖。Dep
              主要的作用是管理多个watcher，它要管理多个watcher，因为在这个界面中可能绑定的一个数据不止出现一次，所以一个值对
              应的watcher也就不止一个，那这些watcher多了之后，是不是要跟刚才的拦截器这边要产生一个一对多的管理关系啊，怎么管
              理我需要一个管家，就是这个Dep。Observer中的getter里，需要对象数据的每一个key都要和这个Dep建立一个一对一的关系。
              只有这样整个闭环才能形成。将来每个key有个dep，每个dep有多个watcher，这样将来在Observer里，如果这个key发生变
              化了找到它对应的dep，把dep里面的所以watcher的更新函数执行一下，界面中就更新了。
          1. new Vue() 首先执行初始化，对data执行响应化处理，这个过程发生在Observer中
          2. 同时对模板执行编译，找到其中动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中
          3. 同时定义一个更新函数和Watcher，将来对应数据变化时Watcher会调用更新函数
          4. 由于data的某个key在一个视图中可能出现多次，所以每个key都需要一个管家Dep来管理多个Watcher
          5. 将来data中数据一旦发生变化，会首先找到对应的Dep，通知所有Watcher执行更新函数
          总结：
            通过Observer对数据进行数据劫持，在Compile编译模版时会触发该key的getter并且每触发一次生成一个Watcher放到该key
            对应的Dep中管理，每个Watcher里有该key的更新函数Updater，更新函数里做的事就是该key所在位置的dom的对应更新。当
            key值发生变化时，会触发该key的setter，拿到Dep，执行里面收集的watcher中的更新函数。
            
      涉及类型介绍
        KVue:框架构造函数 
        Observer:执行数据响应化(分辨数据是对象还是数组，所以多抽象出来了这一层做这个事，所有的抽象出来的都不是没原因的，不需要抽象的就直接写了) 
        Compile:编译模板，初始化视图，收集依赖(更新函数、watcher创建) 
        Watcher:执行更新函数(更新dom)
        Dep:管理多个Watcher，批量更新
      KVue
        1.框架构造函数:执行初始化 执行初始化，对data执行响应化处理，kvue.js
        2.为$data做代理
      编译 - Compile 
        编译模板中vue模板特殊语法，初始化视图、更新视图
        Compile主要是用来解析模版中的一些特殊语法，像差值绑定，指令。于是思路就比较清晰了。我们解析一下模版里的每一个节点，遍历整
        个dom结构，判断节点的类型，如果是一个文本，看看文本的内容是不是{{}}差值绑定，就把它解析出来，从vm里拿到这个值，给它赋值就
        行，这时候页面就更新了。如果是普通的节点，就看它的属性，遍历属性，并且对它进行递归，因为这些元素可能还有孩子，如果属性里有
        k-xxx，说明它是一个指令，@开头的说明它是一个事件。就可以把这些指令和事件再做单独的处理。大致思路就是这样。
        1.初始化视图
          根据节点类型编译，compile.js
          编译插值，compile.js
          编译元素
        2.依赖收集
          视图中会用到data中某key，这称为依赖。同一个key可能出现多次，每次都需要收集出来用一个Watcher来维护它们，此过程称为依
          赖收集。多个Watcher需要一个Dep来管理，需要更新时由Dep统一通知。
          实现思路
            1. defineReactive时为每一个key创建一个Dep实例
            2. 初始化视图时读取某个key，例如name1，创建一个watcher1
            3. 由于触发name1的getter方法，便将watcher1添加到name1对应的Dep中
            4. 当name1更新，setter触发时，便可通过对应Dep通知其管理所有Watcher更新
        3.创建Watcher，kvue.js
        4.编写更新函数、创建watcher
        5.声明Dep
        6.创建watcher时触发getter
        7.依赖收集，创建Dep实例
      总结：
        1.这些实现，只是vue1.0的实现，因为没有涉及虚拟dom，直接做dom操作，很粗暴，问题也很明显，因为随着程序的扩大，界面中这些
          watcher绑定会大量出现，会导致watcher大量的创建，程序大到一定规模之后就崩了，扛不住了。所以vue1的性能问题主要出在这里。
          扛不住大程序。所以2.0里面做了一个操作是抽取出来一个虚拟dom的概念。一个组件对应一个虚拟dom，每一个组件只有一个watcher，
          组件里有这么多的key，不管哪一个key发生变化，我都通知那一个watcher去执行更新，这个watcher执行更新的时候，它怎么知道
          这个界面中哪个地方发生变化了。所以这就是虚拟dom不得不引进来的必要因素啊，这时候就必须有虚拟dom的概念，我根据最新的值计
          算出来一个新的虚拟dom和老的一比较（diff一下）得到一个差值，就知道是哪里变化了。vue2.0为什么要引入虚拟dom，其实和它对
          于这个watcher粒度的调整有一个直接的关系的，它不是随随便便引进来的，也不是看react的虚拟dom好它就用，这是它升级实现性能
          提升的一个必须要走的步骤。
作业
  实现数组响应式 
    思路：
    1.找到数组原型
      因为在数组的原型中存在着我们希望覆盖的方法
    2.覆盖那些能够修改数组的更新方法，使其可以通知更新
      我们把这些方法给覆盖掉，让它除了做之前的事情之外，还能额外的做上一个更新通知。数据发生变化之后，可以让它发送一个update这样
      的通知，视图中就可以做响应了，这样就实现了数组的响应式操作。
    3.将得到的新的原型设置到数组实例原型上
  完成后续k-model、@xx   
    @xx
    k-model：双向绑定
      语法糖，它实际上做了两个事，value值的设定和事件的监听，就是这两件事的复合。设置v-model就是要实现这两个事情。


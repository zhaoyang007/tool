
第六章：通过源代码掌握webpack打包原理
1.webpack启动过程分析
开始：从webpack命令行说起
  通过npm scripts运行webpack
    开发环境：npm run dev
    生产环境：npm run build
  通过webpack命令直接运行
    webpack entry.js bundle.js
查找webpack入口文件
  在命令行输入命令后，npm会让命令行工具进入node_modules/.bin目录，运行一个命令，如果是全局安装这个包，linux会从
  user/local/bin这个目录去找，局部安装会在当前项目目录的node_modules/.bin目录去找，查找是否存在webpack.sh或
  webpack.cmd文件。如果存在，就执行，不存在，就抛出错误。
  实际的入口文件是：node_modules/webpack/bin/webpack.js
  局部安装，想再node_modules/.bin下面有命令，必须通过package.json中的bin字段进行指定。
  因此启动的过程最终会进入到webpack.js，执行里面的代码。
分析webpack的入口文件：webpack.js
  process.exitCode = 0 // 默认exitCode是0，代表webpack运行的时候是正常的执行返回。中间报错会修改exitCode，并抛出错误。
  const runCommand = (command, args) => {} // 运行某个命令
  const isInstalled = packageName => {}; // 判断某个包是否安装
  const CLIs = []; // webpack可用的CLI：webpack-cli和webpack-command
  const installedClis = CLIs.filter(cli => cli.installed); // 判断两个cli是否安装了
  if (installedClis.length === 0) { // 根据cli安装的数量进行处理
  } else if (installedClis.length === 1) {
  } else {
  }
启动后的结果
  webpack最终找到webpack-cli(或webpack-command)这个npm包，并且执行cli

2.webpack-cli源码阅读
webpack-cli做的事情
  引入yargs，对命令行进行定制。
  分析命令行参数，对各个参数进行转换，组成编译配置项。
  引用webpack，根据配置项进行编译和构建。
从NON_COMPILATION_CMD分析出不需要编译的命令
  webpack-cli处理不需要经过编译的命令，就是不需要实例化webpack的
NON_COMPILATION_ARGS
  webpack-cli提供的不需要编译的命令
  const NON_COMPILATION_ARGS = [
    "init",              // 创建一份webpack配置文件
    "migrate",           // 运行webpack版本迁移
    "add",               // 往webpack配置文件中增加属性
    "remove",            // 往webpack配置文件中删除属性
    "serve",             // 运行webpack-serve
    "generate-loader",   // 生成webpack loader代码
    "generate-plugin",   // 生成webpack plugin代码
    "info"               // 返回与本地环境相关的一些信息
  ];
命令行工具包yargs介绍
  提供命令和分组参数
  动态生成help帮助信息
webpack-cli使用args分析
  参数分组（config/config-args.js），将命令划分为9类：
    Config options: 配置相关参数（文件名称，运行环境等）
    Basic options: 基础参数（entry设置、debug模式设置、watch监听设置、devtool设置）
    Module options: 模块参数，给loader设置扩展
    Output options: 输出设置（输出路径，输出文件名称）
    Advanced options: 高级用法（记录设置、缓存设置、监听频率、bail等）
    Resolving options: 解析参数（alias和解析的文件后缀设置）
    Optimizing options: 优化参数
    Stats options: 统计参数
    options: 通用参数（帮助命令、版本信息等）
options变量
  将命令行或webpack.config.js配置文件的配置解析出来组装成为webpack可识别的配置到options里面。
processOptions(options)函数
  outputOptions根options类似
实例化一个webpack
  webpack = require('webpack')
  compiler = webpack(options)
  new Plugin({
    option: true
  }).apply(compiler)
webpack-cli执行结果
  webpack-cli对配置文件和命令行参数进行转换，最终生成配置选项参数options和outputOptions。
  最终会根据配置参数实例化webpack对象，然后根据一些参数，如有没有--watch，有的话通过监听的方式去运行webpack，
  compiler.watch()没有的话直接运行webpack，compiler.run()。最后执行整个构建流程。

3.Tapable插件架构与Hooks设计
webpack的本质
  webpack可以将其理解成一种基于事件流的编程范例，一系列的插件运行。内部是由各种各样的插件，插件会监听compiler和compilation
  上面定义的关键的事件节点。
webpack里最核心的对象compiler和compilation都是继承自Tapable
  class Compiler extends Tapable {
    //...
  }
  class Compilation extends Tapable {
    //...
  }
Tapable是什么
  Tapable是一个类似于node.js的EventEmitter的库，主要是控制钩子函数的发布与订阅，控制着webpack的插件系统。
  Tapable库暴露了很多Hook(钩子)类，为插件提供挂载的钩子。每个钩子代表一个关键的事件节点，在插件中监听钩子，在不同的阶段做不
  同的事情。
  钩子：两类，同步钩子和异步钩子
  const {
    SyncHook,                   // 同步钩子
    SyncBailHook,               // 同步熔断钩子，遇到return直接返回
    SyncWaterfallHook,          // 同步流水钩子，执行结果可以传递给下一个插件
    SyncLoopHook,               // 同步循环钩子
    AsyncParallelHook,          // 异步并发钩子
    AsyncParallelBailHook,      // 异步并发熔断钩子
    AsyncSeriesHook,            // 异步串行钩子 
    AsyncSeriesBailHook,        // 异步串行熔断钩子
    AsyncSeriesWaterfallHook,   // 异步串行流水钩子
  } = require("tapable")
  Tapable hooks类型
    Hook           所有钩子的后缀
    Waterfall      同步方法，它会传值给下一个函数
    Bail           熔断：当函数有任何返回值，就会在当前执行函数停止
    Loop           监听函数返回true表示继续循环，返回undefined表示结束循环
    Sync           同步方法
    AsyncSeries    异步串行钩子
    AsyncParallel  异步并行执行钩子
  Tapable的使用 - new Hook新建钩子
    Tapable暴露出来的都是类方法，new一个类方法获得我们需要的钩子
    class接受数组参数options，非必传。类方法会根据传参，接受同样数量的参数。
    const hook1 = new SyncHook(['arg1', 'arg2', 'arg3'])
  Tapable的使用 - 钩子的绑定与执行
    Tapable提供了同步&异步绑定钩子的方法，并且它们都有绑定事件和执行事件对应的方法。
    Async*                           Sync*                  
    绑定：tapAsync/tapPromise/tap     绑定：tap
    执行：callAsync/promise           执行：call
  Tapable的使用 - hook基本用法示例
    const hook1 = new SyncHook(['arg1', 'arg2', 'arg3'])
    // 绑定事件到webpack事件流
    hook1.tap('hook1', (arg1, arg2, arg3) => {console.log(arg1, arg2, arg3)})
    // 执行绑定的事件
    hook1.call(1, 2, 3)
  Tapable的使用 - 实际例子演示
    定义一个Car方法，在内部hooks上新建钩子。分别是同步钩子accelerate、break（accelerate接收一个参数）、异步钩子
    calculateRoutes。
    使用钩子对应的绑定和执行方法。
    calculateRoutes使用tapPromise可以返回一个promise对象。

4.Tapable是如何和webpack进行关联起来的？
compiler和compilation上面做hooks的调用。
Tapable是事件的机制，webpack插件机制都是基于Tapable的钩子。
插件有个apply方法，接收一个compiler参数。
插件上面做事件的监听。

5.webpack流程篇：准备阶段
6.webpack流程篇：模块构建和chunk生成阶段
7.webpack流程篇：文件生成
8.动手编写一个简易的webpack(上)
9.动手编写一个简易的webpack(下)

第七章：编写loader和插件

第八章：React全家桶和webpack开发商城项目

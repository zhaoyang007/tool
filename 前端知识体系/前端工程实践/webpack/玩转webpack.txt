第五章：webpack构建速度和体积优化策略
在webpack里面怎么分析构建速度和构建体积
1.初级分析：使用webpack内置的stats
stats：构建的统计信息
  利用webpack内置的stats对象
    它可以帮我们分析基本的一些信息，比如构建总共的时间，构建资源的大小
    package.json中使用stats
      指定输出的是一个json对象，生成一个json文件
      "scripts": {
        "build:stats": "webpack --config webpack.prod.js --json > stats.json"
      }
  node.js中使用
    const webpack = require('webpack')
    const config = require('./webpack.config.js')('production')
    webpack(config, (err, stats) => {
      if (err) {
        return console.error(err)
      }
      if (stats.hasErrors()) {
        return console.error(stats.toString('errors-only'))
      }
      console.log(stats)
    })
  这两种方式颗粒度太粗，看不出问题所在。想要分析实际的问题，比如哪个组件比较大，哪个loader耗的时间比较长，是无法很好的分析出来的。

2.速度分析：使用speed-measure-webpack-plugin
更好的分析webpack构建的速度，怎么找出构建速度问题所在。
使用speed-measure-webpack-plugin
  可以看到每个loader和插件执行耗时，就可以重点的关注耗时较长的loader或插件，针对这些做优化
  const SpeedMeatureWebpackPlugin = require('speed-measure-webpack-plugin')
  const smp = new SpeedMeatureWebpackPlugin()
  const webpackConfig = smp.wrap({
    plugins: [
      new MyPlugin(),
      new MyOtherPlugin()
    ]
  })
速度分析插件作用
  分析整个打包总耗时
  每个loader和插件的耗时情况

3.体积分析：使用webpack-bundle-analyzer
更好的分析项目打包出来的体积的问题所在
使用webpack-bundle-analyzer分析体积
  我们发现打包出来的体积很大，就可以利用这个工具来分析项目的问题出现在哪里。
  它可以把我们的项目打包出来的文件会进行一个分析，能很方便的看出体积的大小。面积越大体积越大，我们可以重点关注这些进行优化。
  const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
  plugins: [
    new BundleAnalyzerPlugin()
  ]
  构建完成后会在8888端口展示体积大小
可以分析哪些问题
  可以很好的分析依赖的第三方模块文件的大小
  也可以分析出我们自己写的业务的组件代码图片大小，针对大的js可以做js的按需加载等优化操作。
增加babel-polyfill试验大的第三方模块的情况

4.使用高版本的webpack和Node.js
在webpack里做速度的优化
使用高版本的wepback和node.js
  在软件这一块，性能往往不是最大的问题，软件不断的迭代过程中，可以不断的提升这个性能，对于构建而言同样是适用的，所以推荐采用
  高版本的webpack和node.js。
使用webpack4：优化原因
  V8带来的优化，V8 6.0的版本带来了大量的优化，很多对原生方法的优化（for of代替forEach、Map和Set代替Object、includes代替indexOf）
  默认使用更快的md4的 hash算法
  webpacks AST可以直接从loader传递给AST，减少解析时间
  使用字符串的方法替代正则表达式
高版本的node.js对原生的js API或js的数据结构是有做一些优化的，因此推荐采用更高版本的node.js
  测试脚本
    验证高版本node.js比低版本node.js性能更快，针对相同的api、相同的代码做比较
      map-performance.js 
    includes和indexOf的性能差异
      compare-includes-indexOf.js

5.多进程/多实例构建
多进程/多实例构建：资源并行解析可选方案
  HappyPack
  thread-loader
  parallel-webpack
多进程/多实例：使用HappyPack解析资源
  原理：每次webpack解析一个模块，HappyPack会将它及它的依赖分配给worker线程中。
  每次webpack解析一个模块，一个进程webpack自身去解析这个模块。HappyPack会将这个模块进行一个划分，比如有多个模块，在
  webpack compiler run方法之后，然后到达HappyPack，它会做一些初始化，创建一个线程池，线程池会将构建任务里面的模块进行分配
  ，比如会将某个模块以及它的依赖分配给HappyPack其中的一个线程，以此类推，那么一个HappyPack的线程池可能会包括多个线程，这些
  线程会各自的处理这些模块以及它的依赖。处理完成之后，会有一个通信的过程，会将处理好的资源传输给HappyPack的主进程，完成整个构
  建的过程。
  plugins: [
    new HappyPack({
      id: 'jsx',
      threads: 4,
      loaders: ['babel-loader']
    }),
    new HappyPack({
      id: 'styles',
      threads: 2,
      loaders: ['style-loader', 'css-loader', 'less-loader']
    })
  ]
多进程/多实例：使用thread-loader解析资源
  webpack4.0原生的提供了thread-loader这个模块，它可以很好的替换HappyPack，来做多进程/多实例的工作。
  原理：跟HappyPack是差不多的。每次webpack解析一个模块，thread-loader会将它及它的依赖分配给worker线程中。
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'thread-loader',
            options: {
              workers: 3
            }
          },
          'babel-loader'
        ]
      }
    ]
  }
  在我们的loader之前放上thread-loader，做一系列的解析，最后会通过thread-loader进行处理。

6.多进程/多实例并行压缩代码
多进程/多实例：并行压缩
上节提到在构建的时候，可以对模块的解析采用多进程多实例的方式去做。同样的，在代码解析完成之后，在做最后的代码输出之前，它有个压缩
阶段，对于代码压缩我们也是可以通过同样的思路，就是通过多进程多实例的并行的压缩代码，来达到我们优化构建速度的目的。
方法一：使用parallel-uglify-plugin插件
  plugins: [
    new ParallelUglifyPluging({
      uglifyJS: {
        output: {
          beautify: false,
          comments: false
        },
        compress: {
          warning: false,
          drop_console: true,
          collapse_vars: true,
          reduce_vars: true
        }
      }
    })
  ]
方法二：uglifyjs-webpack-plugin开启parallel参数（webpack3推荐采用的插件）（不支持es6代码的压缩）
  plugins: [
    new UglifyjsWebpackPlugin({
      uglifyOptions: {
        warnings: false,
        parse: {},
        compress: {},
        mangle: true,
        output: null,
        tiplevel: false,
        nameCache: null,
        ie8: false,
        keep_fnames: false
      },
      parallel: true
    })
  ]
方法三：terser-webpack-plugin开启parallel参数（webpack4默认使用的）（支持es6代码的压缩）
  module.exports = {
    optimization: {
      minimize: true,
      minimizer: [
        new TerserPlugin({
          parallel: true
        })
      ]
    }
  }

7.进一步分包：预编译资源模块
分包：设置Externals（第三章讲过的）
  思路：将react, react-dom基础包通过cdn引入，不打入bundle中。
  方法：使用html-webpack-externals-plugin
  缺点：一个基础库需要指定一个cdn，实际的项目中有很多包，需要引入的script标签太多 。
通过split-chunks-plugin插件分离基础包，它每次还是会对基础包进行分析。
分包来说，更好的方式就是
进一步分包：预编译资源模块
  思路：将react、react-dom、redux、react-redux基础包和业务基础包打包成一个文件。
  方法：使用webpack里面官方内置的插件DLLPlugin进行分包，DLLReferencePlugin对manifest.json引用，这个文件是对分离出来
  的包的描述。然后我们在实际的webpack配置里面可以通过DLLReferencePlugin去引用通过DLLPlugin分离出来的包，引用的时候应用
  manifest.json就可以了，引用后它就会自动的去关联DLLPlugin里面的包。
  使用DLLPlugin进行分包
    需要创建一个单独的构建配置文件，一般会命名为webpack.ddl.js，DLLPlugin也会提高打包的速度。
  使用DLLReferencePlugin引用manifest.json
    在webpack.config.js中引入
      module.exports = {
        plugins: [
          new webpack.DLLReferencePlugin({
            manifest: require('./build/library/manifest.json')
          })
        ]
      }

8.充分利用缓存提升二次构建速度
缓存
目的：提升二次构建速度
缓存思路：
  babel-loader开启缓存
  terser-webpack-plugin开启缓存
  使用cache-loader或者hard-source-webpack-plugin
    针对模块的缓存的开启
有缓存的话node_modules下面会有一个cache目录

9.缩小构建目标
缩小构建目标
  目的：尽可能的减少构建模块
  比如babel-loader不解析node_modules
    module: {
      rules: [
        {
          test: /\.js$/,
          use: 'babel-loader',
          exclude: 'node_modules'
        }
      ]
    }
减少文件搜索范围  
  优化resolve.modules配置（减少模块搜索层级）
    resolve.modules是模块解析的过程，webpack解析时，模块的查找过程和nodejs的模块查找是比较类似的，会从当前的项目找，没
    找到会去找node_modules。会依次去子目录找模块是否存在。
  优化resolve.mainFields配置
    找入口文件的时候，它会根据package.json里面的main字段查找，因为我们发布到npm的组件的package.json会遵守一定的规范，
    都会有main这个字段，我们可以设置查找的时候直接读取main这个字段，这样也减少一些不必要的分析的过程。比如package.json
    里面没有这个main，那它再去读取根项目下的index.js，没有再去找lib下面的index.js，这就是它默认的查找过程，我们这里把
    这个默认的查找过程链路做一个优化，我们只找package.json中main字段指定的入口文件。
  优化resolve.extensions配置
    模块路径的查找，比如import一个文件，没有写后缀，webpack会先去找.js，没有会找.json，默认情况下webpack只支持js和json
    的读取。extensions数组里可以再设置其他的文件，如.jsx .vue .ts等。不过这个数组里面的内容越多的话，查找消耗的时间也会
    越多，因此我们可以缩小extensions查找的范围，比如只设置查找.js，其他文件需要你写的时候写全文件后缀。避免webpack做不必要
    的查找。
  合理使用alias
    别名，简短的缩写。比如模块的路径，我们找react，它可能找了一圈，最后肯定是会找到node_modules里面去，它会经历一系列的
    查找过程，我们可以把这一系列的过程直接给它写好，告诉它比如你遇到了react，就直接从指定的这个路径去找。这个也大大的缩短
    了查找的时间。
  module.exports = {
    // 子模块的查找策略
    resolve: {
      alias: {
        'react': path.resolve(__dirname, './node_modules/react/umd/react.production.min.js'),
        'react-dom': path.resolve(__dirname, './node_modules/react-dom/umd/react-dom.production.min.js')
      },
      modules: [path.resolve(__dirname, 'node_modules')],
      extensions: ['.js'],
      mainFields: ['main']
    }
  }

10.使用Tree Shaking擦除无用的JavaScript和CSS
无用的css如何删除掉？
  PurifyCSS：遍历代码，识别已经用到的css class
  uncss：要求HTML需要通过jsdom加载，所有的样式通过PostCSS解析，通过document.querySelector来识别在html文件里面不存在的
         选择器。
在webpack中如何使用PurifyCSS？
  使用purgecss-webpack-plugin，它不能独立的去使用，而是需要提取css为一个文件后才能使用。在webpack4里面需要和
  mini-css-extract-plugin配合使用，在webpack3里面需要和extract-text-webpack-plugin配合使用。
  new PurgecssWebpackPlugin({
    paths: 
  })

11.使用webpack进行图片压缩
图片资源相对是较大的，我们可以通过在线工具手动进行图片的批量压缩。构建工具一部分的职责就是将平时我们手动完成的事做成自动化。
图片压缩
  要求：基于node库的imagemin或者tinypng API做图片压缩。
  使用：配置image-webpack-loader
imagemin的优点分析
  有很多定制的选项
  可以引入更多第三方优化插件，例如pngquant
  可以处理多种图片格式
imagemin的压缩原理
https://unsplash.com/ 无版图片库

12.使用动态Polyfill服务
构建体积优化：动态polyfill
方案
  babel-polyfill
  babel-plugin-transform-runtime
  自己写polyfill
  polyfil service
polyfil service原理
  识别ua，下发不同的polyfill
使用polyfil service
  polyfill.io官方提供的服务
    https://polyfill.io/v3/polyfill.min.js
  基于官方自建polyfill服务
    //huayang.qq.com/polyfill/v3/polyfill.min.js?unknown=polyfill&features=Promise,Map,Set
体积优化策略总结：
  Scope Hoisting
  Tree Shaking
  公共资源分离
  图片压缩
  动态polyfill

第六章：通过源代码掌握webpack打包原理
1.webpack启动过程分析
开始：从webpack命令行说起
  通过npm scripts运行webpack
    开发环境：npm run dev
    生产环境：npm run build
  通过webpack命令直接运行
    webpack entry.js bundle.js
查找webpack入口文件
  在命令行输入命令后，npm会让命令行工具进入node_modules/.bin目录，运行一个命令，如果是全局安装这个包，linux会从
  user/local/bin这个目录去找，局部安装会在当前项目目录的node_modules/.bin目录去找，查找是否存在webpack.sh或
  webpack.cmd文件。如果存在，就执行，不存在，就抛出错误。
  实际的入口文件是：node_modules/webpack/bin/webpack.js
  局部安装，想再node_modules/.bin下面有命令，必须通过package.json中的bin字段进行指定。
  因此启动的过程最终会进入到webpack.js，执行里面的代码。
分析webpack的入口文件：webpack.js
  process.exitCode = 0 // 默认exitCode是0，代表webpack运行的时候是正常的执行返回。中间报错会修改exitCode，并抛出错误。
  const runCommand = (command, args) => {} // 运行某个命令
  const isInstalled = packageName => {}; // 判断某个包是否安装
  const CLIs = []; // webpack可用的CLI：webpack-cli和webpack-command
  const installedClis = CLIs.filter(cli => cli.installed); // 判断两个cli是否安装了
  if (installedClis.length === 0) { // 根据cli安装的数量进行处理
  } else if (installedClis.length === 1) {
  } else {
  }
启动后的结果
  webpack最终找到webpack-cli(或webpack-command)这个npm包，并且执行cli

2.webpack-cli源码阅读
webpack-cli做的事情
  引入yargs，对命令行进行定制。
  分析命令行参数，对各个参数进行转换，组成编译配置项。
  引用webpack，根据配置项进行编译和构建。
从NON_COMPILATION_CMD分析出不需要编译的命令
  webpack-cli处理不需要经过编译的命令，就是不需要实例化webpack的
NON_COMPILATION_ARGS
  webpack-cli提供的不需要编译的命令
  const NON_COMPILATION_ARGS = [
    "init",              // 创建一份webpack配置文件
    "migrate",           // 运行webpack版本迁移
    "add",               // 往webpack配置文件中增加属性
    "remove",            // 往webpack配置文件中删除属性
    "serve",             // 运行webpack-serve
    "generate-loader",   // 生成webpack loader代码
    "generate-plugin",   // 生成webpack plugin代码
    "info"               // 返回与本地环境相关的一些信息
  ];
命令行工具包yargs介绍
  提供命令和分组参数
  动态生成help帮助信息
webpack-cli使用args分析
  参数分组（config/config-args.js），将命令划分为9类：
    Config options: 配置相关参数（文件名称，运行环境等）
    Basic options: 基础参数（entry设置、debug模式设置、watch监听设置、devtool设置）
    Module options: 模块参数，给loader设置扩展
    Output options: 输出设置（输出路径，输出文件名称）
    Advanced options: 高级用法（记录设置、缓存设置、监听频率、bail等）
    Resolving options: 解析参数（alias和解析的文件后缀设置）
    Optimizing options: 优化参数
    Stats options: 统计参数
    options: 通用参数（帮助命令、版本信息等）
options变量
  将命令行或webpack.config.js配置文件的配置解析出来组装成为webpack可识别的配置到options里面。
processOptions(options)函数
  outputOptions根options类似
实例化一个webpack
  webpack = require('webpack')
  compiler = webpack(options)
  new Plugin({
    option: true
  }).apply(compiler)
webpack-cli执行结果
  webpack-cli对配置文件和命令行参数进行转换，最终生成配置选项参数options和outputOptions。
  最终会根据配置参数实例化webpack对象，然后根据一些参数，如有没有--watch，有的话通过监听的方式去运行webpack，
  compiler.watch()没有的话直接运行webpack，compiler.run()。最后执行整个构建流程。

3.Tapable插件架构与Hooks设计
webpack的本质
  webpack可以将其理解成一种基于事件流的编程范例，一系列的插件运行。内部是由各种各样的插件，插件会监听compiler和compilation
  上面定义的关键的事件节点。
webpack里最核心的对象compiler和compilation都是继承自Tapable
  class Compiler extends Tapable {
    //...
  }
  class Compilation extends Tapable {
    //...
  }
Tapable是什么
  Tapable是一个类似于node.js的EventEmitter的库，主要是控制钩子函数的发布与订阅，控制着webpack的插件系统。
  Tapable库暴露了很多Hook(钩子)类，为插件提供挂载的钩子。每个钩子代表一个关键的事件节点，在插件中监听钩子，在不同的阶段做不
  同的事情。
  钩子：两类，同步钩子和异步钩子
  const {
    SyncHook,                   // 同步钩子
    SyncBailHook,               // 同步熔断钩子，遇到return直接返回
    SyncWaterfallHook,          // 同步流水钩子，执行结果可以传递给下一个插件
    SyncLoopHook,               // 同步循环钩子
    AsyncParallelHook,          // 异步并发钩子
    AsyncParallelBailHook,      // 异步并发熔断钩子
    AsyncSeriesHook,            // 异步串行钩子 
    AsyncSeriesBailHook,        // 异步串行熔断钩子
    AsyncSeriesWaterfallHook,   // 异步串行流水钩子
  } = require("tapable")
  Tapable hooks类型
    Hook           所有钩子的后缀
    Waterfall      同步方法，它会传值给下一个函数
    Bail           熔断：当函数有任何返回值，就会在当前执行函数停止
    Loop           监听函数返回true表示继续循环，返回undefined表示结束循环
    Sync           同步方法
    AsyncSeries    异步串行钩子
    AsyncParallel  异步并行执行钩子
  Tapable的使用 - new Hook新建钩子
    Tapable暴露出来的都是类方法，new一个类方法获得我们需要的钩子
    class接受数组参数options，非必传。类方法会根据传参，接受同样数量的参数。
    const hook1 = new SyncHook(['arg1', 'arg2', 'arg3'])
  Tapable的使用 - 钩子的绑定与执行
    Tapable提供了同步&异步绑定钩子的方法，并且它们都有绑定事件和执行事件对应的方法。
    Async*                           Sync*                  
    绑定：tapAsync/tapPromise/tap     绑定：tap
    执行：callAsync/promise           执行：call
  Tapable的使用 - hook基本用法示例
    const hook1 = new SyncHook(['arg1', 'arg2', 'arg3'])
    // 绑定事件到webpack事件流
    hook1.tap('hook1', (arg1, arg2, arg3) => {console.log(arg1, arg2, arg3)})
    // 执行绑定的事件
    hook1.call(1, 2, 3)
  Tapable的使用 - 实际例子演示
    定义一个Car方法，在内部hooks上新建钩子。分别是同步钩子accelerate、break（accelerate接收一个参数）、异步钩子
    calculateRoutes。
    使用钩子对应的绑定和执行方法。
    calculateRoutes使用tapPromise可以返回一个promise对象。

4.Tapable是如何和webpack进行关联起来的？
compiler和compilation上面做hooks的调用。
Tapable是事件的机制，webpack插件机制都是基于Tapable的钩子。
插件有个apply方法，接收一个compiler参数。
插件上面做事件的监听。

5.webpack流程篇：准备阶段
6.webpack流程篇：模块构建和chunk生成阶段
7.webpack流程篇：文件生成
8.动手编写一个简易的webpack(上)
9.动手编写一个简易的webpack(下)

第七章：编写loader和插件

第八章：React全家桶和webpack开发商城项目

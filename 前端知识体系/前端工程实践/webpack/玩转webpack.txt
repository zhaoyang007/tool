第一章 webpack与构建发展简史
1.使用webpack过程中涉及到的
多页面打包 SSR PWA Prerender 等多种构建场景
多实例构建 并行压缩公共资源分包 tree shaking 动态polyfill 等构建策略
webpack构建的打包速度和体积优化
前端工作流和团队开发规范的实施

2.为什么要深入掌握webpack？
和目前的应用场景和开发方式是息息相关的，现在前端面对多终端的开发，所以面对不同的应用场景，做不同的打包就显得很重要了。比如
针对pc端的中后台应用，我们需要支持单页应用的打包构建。H5页面对性能和可访问性有着极高的要求，因此需要通过构建来支持服务端渲
染和PWA离线缓存。
其次是nodejs的社区异常繁荣，已经有80多万的第三方组件。npm的组件在浏览器的js代码中并不能直接引入，这时就需要借助webpack
等构建工具来快速复用各种优秀成熟的组件，从而加速web开发。
当下流行的三大框架它们的一些语法，比如JSX和Vue指令等在浏览器都是无法直接解析的，也需要构建工具进行转换。
而webpack是构建工具中最耀眼的一颗星，无论你走前端的哪条路线，都需要有很强的webpack知识。熟悉webpack的使用和原理，可以让
你拓宽前端技术栈。在发现页面打包的速度和资源体积的问题时，能够知道如何排查问题和优化，同时熟悉webpack原理，有助于对其他跨
端应用的开发。比如在对小程序 weex ReactNative Electron等框架打包时能够快速上手，

3.初学者学习webpack的困难
webpack里众多的新概念，entry output mode loaders plugins 热更新 code spliting tree shaking等等，会让初学者感到
webpack感到很复杂，造成一定的学习成本。
webpack的进一步学习是有一定学习曲线的。包括webpack打包的速度，体积，页面加载时的性能优化等。是需要具备比较全面的webpack
专业知识。搞懂webpack内部的运行原理和插件机制才能深入掌握的。

4.课程设计思路
基础篇：掌握webpack的核心概念和开发必备技巧
进阶篇：以工程化的思维编写一份健壮可维护的webpack构建配置，同时掌握webpack构建速度和体积的优化策略。
原理篇：通过webpack源码剖析内部运行原理，和编写自定义的loader和插件的能力。
实战篇：从一个web商城项目出发，讲解webpack如何运用到实际的项目中去。并且最大化的提升开发阶段和发布阶段的构建体验。

5.为什么需要构建工具
转换es6语法
转换jsx
css前缀补全/预处理器
压缩混淆
图片压缩

6.前端构建演变之路
无代码压缩和混淆 -》 通过在线工具压缩混淆代码 -》 ant + YUI Toll 在本地对代码压缩混淆 -》 requirejs commonjs模块化概
念的出现，前端模块化的编写方式也越来越复杂，演变出了grunt -》 gulp fis3 -》 rollup webpack parcel

7.为什么选择webpack
社区活跃度
社区生态丰富，官方维护的插件丰富
配置灵活和个性化的插件化扩展
官方更新迭代速度快

8.初识webpack
配置文件名称
  webpack默认配置文件：webpack.config.js
  可以通过webpack --config指定配置文件
webpack配置组成
  主要包括entry output mode module plugins
  打包的入口文件 打包的输出 环境 loader配置 插件配置
webpack零配置
  webpack4允许不写webpack配置文件，会有一个默认的配置，这个配置里只有entry和output两项内容
  input: './src/index.js'
  output: './dist/main.js'

9.环境搭建：安装webpack
安装nvm(https://github.com/nvm-sh/nvm)
  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
  wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
将nvm添加到环境变量里面
  source ~/.bash_profile
nvm list
  列举本地安装的所有nodejs的版本
安装nodejs和npm
  nvm install v10.15.3
  检测是否安装成功：node -v, npm -v
创建空目录和package.json
  mkdir my-project
  cd my-project
  npm init -y
安装 webpack 和 webpack-cli
  webpack4是将webpack的内核和webpack-cli进行了分离，因此在实际的项目使用中需要同时安装这两个。
  npm install webpack webpack-cli --save-dev
  检查是否安装成功：./node_modules/.bin/webpack -v

10.webpack初体验：一个最简单的例子
创建webpack配置文件webpack.config.js
  webpack.config.js它是需要通过module.exports导出一个对象的。这个对象里就是所有webpack的配置。
  webpack.config.js
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.join(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      mode: 'production'
    }
  这样webpack的配置就编写好了。
编写程序的代码
  ./src/index.js
  ./src/helloworld.js
运行打包
  直接运行，不指定webpack配置文件的名称，它会默认使用webpack.config.js这个配置文件
  ./node_modules/.bin/webpack
在dist目录创建html文件
  引入打包好的bundle.js

11.通过npm script运行webpack
在当前项目局部安装的依赖，这个依赖如果有创建一些命令，它是会在node_modules/.bin目录下面创建一个软链接。package.json是
可以默认的读取到.bin目录下的这些命令。所以可以直接在package.json里面增加一个scripts，这里面指定一下webpack就可以了，
在scripts运行webpack时，它就会从node_modules/.bin这个目录里面去寻找对应的命令。scripts里面的就是可以运行的命令，使用
npm run scriptsName 来运行命令。

第二章：webpack基础用法
1.webpack核心概念之entry
entry用来指定webpack的打包入口
  为什么我们需要entry，这个离不开webpack的构建机制，webpack它是一个模块打包器，webpack里面会把一切的资源，不管是js css
  等代码资源，还是图片字体等非代码资源都会当成一个个的模块，所有模块之间存在着依赖关系，因此webpack根据这个入口文件去找到
  它的依赖，会形成一颗依赖树，只要遇到依赖，webpack就会将依赖文件加入到依赖图里面去。最终遍历完后，生成一个打包之后的一些
  资源。这就是entry的基本含义。
entry的用法
  单入口：entry是一个字符串
    单入口一般适用于一个项目里只有一个入口文件，只有一个页面。或者是一个单页应用。
    module.exports = {
      entry: './path/to/my/entry/file.js'
    }
  多入口：entry是一个对象
    多入口适合多页面的场景，多页应用。
    module.exports = {
      entry: {
        app: './src/app.js',
        adminApp: './src/adminApp.js'
      }
    }

2.webpack核心概念之output
output和entry也是息息相关的。entry是用来指定打包的入口，output是用来指定打包的输出。entry对应于源代码，output用来对应于
转换之后的最终结果代码。
output用来告诉webpack如何将编译后的文件输出到磁盘。输出到哪个目录，输出的文件名是什么。
output的用法
  单入口配置
    module.exports = {
      entry: './path/to/my/entry/file.js',
      output: {
        path: __dirname + '/dist',
        filename: 'bundle.js'
      }
    }
  多入口配置
    对于多入口配置，entry是有多个入口的，output里面并没有多个入口的说法，不管一个入口还是多个入口，在output里面都是只有一个
    output，它利用了一个占位符的概念确保文件名称的唯一。
    module.exports = {
      entry: {
        app: './src/app.js',
        search: './src/search.js'
      },
      output: {
        path: __dirname + '/dist',
        filename: '[name].js'
      }
    }

3.webpack核心概念之loaders
webpack开箱即用，原生只支持js和json两种文件类型，对于其他的文件如css less jsx vue指令，webpack是并不了解的，就需要
通过loaders去处理，把它们转化成有效的模块，这样webpack解析的时候才能将它们添加到依赖图中去。
loaders本身是一个函数，接收源代码作为参数，经过loader函数转换之后，返回转换后的结果。这个结果会给下一步去使用。
常见的loaders有哪些
  babel-loader        转换es6 es7等js新特性语法
  css-loader          支持.css文件的加载和解析
  less-loader         将less文件转换成css
  ts-loader           将ts转换成js
  file-loader         进行图片、字体、富媒体等文件的解析和打包
  raw-loader          将文件以字符串的形式进行导入
  thread-loader       多进程打包js和css。正常情况下webpack打包是开一个进程，thread-loader可以让webpack以多进程的
                      形式去打包js和css，会让打包的速度更快。
loaders的用法
  一个webpack配置里面可能会存在多个loader，这些loader是需要放在配置根节点下的module，module是一个对象，这个对象里面有
  一个rules，rules是一个数组，我们只需要把需要用的loader放到rules数组里面就可以了。对于每一个rule，通过test指定匹配规
  则，使用use指定当前使用的loader的名称。
  const path = require('path')
  module.exports = {
    output: {
      filename: 'bundle.js'
    },
    module: {
      rules: [
        {
          test: /\.txt$/,
          use: 'raw-loader'
        }
      ]
    }
  }

4.webpack核心概念之plugins
plugins作用是用来增强webpack的功能，plugins通常是用于打包输出的js文件的优化，资源的管理和环境变量的注入，可以把plugins
理解为任何loaders没办法做到的这种事情都是可以通过plugins去完成。比如构建之前需要手动的去删除打包目录，像这种操作都是可以
通过plugins很灵活的完成，plugins是作用于整个构建过程，就是从构建开始到构建结束整个阶段都是可以去使用这个plugins的。 
常见的plugins有哪些
  CommonsChunkPlugin            通常用在多个页面打包的情况下，可以将每个页面公共的一些js文件模块提取出来。
  CleanWebpackPlugin            清理构建目录
  ExtractTextWebpackPlugin      将css从bundle文件里提取成一个独立的css文件
  CopyWebpackPlugin             将文件或文件目录从一个目录拷贝到最后输出的构建目录里面
  HtmlWebpackPlugin             创建html文件去承载输出的bundle，而不需要每次构建完成之后，在构建的dist目录手动的去
                                创建一个html文件。
  UglifyjsWebpackPlugin         压缩js
  ZipWebpackPlugin              将打包出的资源生成一个zip包
plugins的用法
  在plugins数组里面将定义好的插件放进去就可以了。
  const path = require('path')
  module.exports = {
    output: {
      filename: 'bundle.js'
    },
    plugins: [
      new HtmlWebpackPlugin({template: './src/index.htmls'})
    ]
  }

5.webpack核心概念之mode
mode是用来指定当前打包的的构建环境：production development none。
mode是webpack4里提出的概念。
设置mode的好处是可以通过mode来自动的去触发webpack里面的内置函数，比如你设置成development，webpack会默认的去开启在开发
阶段的一些比较实用的参数和插件的一些功能。设置成production会默认开启在生产阶段的参数和插件的一些功能，设置成none就什么都
不会帮你做。默认值为production。
mode的内置函数功能
  development       设置process.env.NODE_ENV的值为development，可以在构建代码里面用到这个值。
                    默认开启NamedChunksPlugin和NamedModulesPlugin，这两个插件是会在代码热更新阶段很实用，可以在控
                    制台里面打印出是哪个模块发生了热更新，这个模块的路径是什么样的。
  production        设置process.env.NODE_ENV的值为production
                    默认开启FlagDependencyUsagePlugin FlagIncludedChunksPlugin ModuleConcatenationPlugin
                    NoEmitOnErrorsPlugin OccurrenceOrderPlugin SideEffectsFlagPlugin TerserPlugin
  none              不开启任何优化选项

6.解析ECMASCript 6和React JSX
资源解析：解析es6
  使用babel-loader
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.js$/,
            use: 'babel-loader'
          }
        ]
      }
    }
  babel的配置文件是.babelrc
    babel-loader是依赖babel的，因此我们需要在项目里面去使用babel的一个配置文件.babelrc。
    由于我们是要解析es6，因此这里我们添加babel的preset配置。
    babel有两块比较重要的概念，一个是presets，一个是plugins。plugins可以理解成一个plugins对应一个功能，presets是一
    系列babel plugins的集合。这里我们要解析es6，我们只需要安装@babel/preset-env这个preset就可以了。 
      {
        "presets": [
          "@babel/preset-env"
        ],
        "plugins": [
          "@babel/proposal-class-properties"
        ]
      }
  babel是怎么支持es6的解析的
    安装babel
      要解析es6首先需要安装一下@babel/core，然后还需要安装一下es6的preset，也就是@babel/preset-env，我们还需要通过
      babel-loader去解析它们，因此我们还需要安装一下babel-loader。
      npm i @babel/core @babel/preset-env babel-loader -D
    创建.babelrc文件
      添加es6相关的preset
      {
        "presets": [
          "@babel/preset-env"
        ]
      }
    修改webpack配置文件
      增加一个loader的配置
资源解析：解析react jsx
  解析vue的一些语法等跟这个类似。
    在babel的配置文件中增加react的preset的配置。这样就可以解析react相关的语法了。
    {
      "presets": [
        "@babel/preset-env",
        "@babel/preset-react"
      ]
    }
  安装react相关
    npm i react react-dom @babel/preset-react -D

7.解析CSS、Less和Sass
资源解析：解析css
  webpack中想要解析css
    首先需要使用css-loader，作用是用来加载.css文件，加载时机是在代码里面，比如index.js里引用了这个css，这时它就会加载
    .css文件，并且将它转换成一个commonjs对象，插入到js代码里面去。
    然后需要通过style-loader，作用是将样式通过style标签插入到head中，这样样式才能在代码里面显示出来。
  安装css-loader style-loader
    npm i css-loader style-loader -D
  配置css-loader style-loader
    有一点需要注意，loader的调用是链式调用的，执行顺序是从右到左的，因此我们需要先写style-loader，再写css-loader，这样
    的话，它实际执行的时候会先去使用css-loader去解析css，然后再将解析好的css传递给style-loader。
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.css$/,
            use: [
              'style-loader',
              'css-loader'
            ]
          }
        ]
      }
    }
资源解析：解析less和sass
  想解析less只需要在前面的基础之上增加一个less-loader就可以了。less-loader的作用就是将less转换成css。
  安装less 和  less-loader，因为less-loader是依赖于less的。
    npm i less less-loader -D
  配置less
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.less$/,
            use: [
              'style-loader',
              'css-loader',
              'less-loader'
            ]
          }
        ]
      }
    }

8.解析图片和字体
解析资源：解析图片
  要想解析图片需要利用到一个非常实用的loader叫file-loader，它可以处理一些文件，这里只需要匹配上一些图片，比如png svg
  jpg gif等图片资源，然后去使用这个file-loader就可以解析这个图片了。
  安装file-loader
    npm i file-loader -D
  配置图片解析file-loader
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.(png|svg|jpg|gif)$/,
            use: 'file-loader'
          }
        ]
      }
    }
资源解析：解析字体
  在webpack里面解析字体和解析图片做法是一样的，因为图片和字体都不是代码文件。图片和字体的解析都可以采用这个file-loader
  去处理。
  配置字体解析file-loader
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.(woff|woff2|eot|ttf|otf)$/,
            use: 'file-loader'
          }
        ]
      }
    }
图片解析和字体解析的其他方式
  前面是用file-loader去解析图片和字体，除此之外我们还可以用url-loader去做。url-loader和file-loader功能上是差不多的，
  只不过url-loader相比file-loader，它还可以做一个小图片或小字体，自动的做一个base64的一个转换，url-loader内部也是用
  了file-loader。
  怎么做一个小资源的转换
    这里可以看到url-loader它接收一个参数，这个参数是通过options给loader进行传参，传的参数是limit是10240，limit的单
    位是一个字节。
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.(png|svg|jpg|gif)$/,
            use: [{
              loader: 'url-loader',
              options: {
                limit: 10240
              }
            }]
          }
        ]
      }
    }

9.webpack中的文件监听
之前我们修改源代码之后都需要手动的运行一下构建命令，这是比较麻烦的，尤其是在开发的过程中，因此在webpack中做一个文件自动编译
是很有必要的。
文件监听的作用是发现源代码发生变化时，能自动的重新构建出新的文件并输出出来。
webpack开启监听模式，有两种方式：
  启动webpack时，在webpack命令后加上--watch参数
    "scripts": {
      "test": "echo \"Error: no test specified\" && exit 1",
      "build": "webpack",
      "watch": "webpack --watch"
    }
    这种方式有一个缺点，就是webpack自动编译完成之后，浏览器是不会自动刷新的，每次需要手动刷新浏览器。
  在配置webpack.config.js中设置watch: true
    module.exports = {
      // 默认false，也就是不开启
      watch: true,
      // 只有开启监听模式时，watchOptions才有意义
      watchOptions: {
        // 默认为空，不监听的文件或文件夹，支持正则匹配
        ignored: /node_modules/,
        // 监听到变化后会等300ms再去执行，默认300ms
        aggregateTimeout: 300,
        // 判断文件是否发生变化是通过不停轮询系统指定文件有没有变化实现的，默认每秒询问1000次
        poll: 1000
      }
    }
文件监听的原理分析
  webpack会轮询的去判断文件的最后编辑时间是否发生变化。一开始会有一次文件的修改时间，会把这个时间存储起来，下次再有修改的
  时候，就会和上一次的修改时间进行比对，如果发现不一致，它不会立刻的告诉监听者，而是把这个文件的修改先缓存起来，等待一定时
  间aggregateTimeout，这个时间内如果有其他的文件也发生了变化，那么它会把这些变化了的文件列表一起去构建，最后一起把构建的
  结果生成到bundle文件里面来。
  
10.webpack中的热更新及原理分析
热更新：webpack-dev-server
  前面讲到了webpack文件的监听方式，但是它有一个缺点就是每次构建完之后需要手动的刷新浏览器。
  在webpack中，其实有更好的方式，我们可以借助一个webpack-dev-server，每次代码修改，让它自动的去构建，构建完成之后，通过
  这种热更新的方式让浏览器里面的内容自动的去变化。
  wds不需要刷新浏览器。
  wds通常是需要和HotModuleReplacementPlugin插件一起使用，它们两个进行结合之后，可以开启热更新的一个功能。
  wds还有一个优势是它输出的文件不放入磁盘里面，没有磁盘的io操作，它输出的文件是放在内存里面，而不是像watch这种方式是放在本
  地的磁盘文件里面。所以它的构建速度会有更大的优势。
  使用wds
    // package.json
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "build": "webpack",
        "watch": "webpack --watch",
        "dev": "webpack-dev-server --open"
      }
    // webpack.config.js
      // wds主要是在开发过程中使用，在生产环境是不需要用到的。
      mode: "development"
      // 引入webpack自带的HotModuleReplacementPlugin插件
      const webpack = require('webpack')
      plugins: [
        new webpack.HotModuleReplacementPlugin()
      ]
      // 配置devServer
      devServer: {
        // wds服务的基础的目录
        contentBase: './dist',
        // 开启热更新
        hot: true
      }
  运行效果
    npm run dev
    可以看到webpack在进行构建，构建好之后它打开了一个浏览器，浏览器中可以看到它会把构建出来的内容目录都输出出来，然后我们
    代开search.html这个页面。修改内容，测试它会不会自动去变。
热更新：使用webpack-dev-middleware
  这个日常开发也是用的比较多的，与前面实现相同的效果，这种方式更加的灵活。采用这种方式，需要引入一下node的一个server，就是
  我们自己创建一个node server，通常使用express或者koa。wdm可以将webpack输出的文件传输给服务器，这种方式是比较适合比较
  灵活的定制场景。可以对webpack的这种配置可以控制的更多。
  const express = require('express')
  const webpack = require('webpack')
  const webpackDevMiddleWare = require('webpack-dev-middleware')

  const app = express()
  const config = require('./webpack.config.js')
  const compiler = webpack(config)

  app.use(webpackDevMiddleWare(compiler, {
    publicPath: config.output.publicPath
  }))

  app.listen(3000, function() {
    console.log('Example app listening on port 3000')
  })
热更新的原理分析
  要学懂热更新的原理，首先要知道一些概念
    Webpack Compile：也就是webpack的编译器，它的作用是将js的源代码编译成bundlejs就是最后打包好输出的文件。
    HMR Server：用来将热更新的文件传输给HMR Runtime
    Bundle Server：提供文件在浏览器的访问，比如编译好的bundle.js其实在浏览器里面正常访问的是文件目录的访问，bundle server
                  是可以让你通过服务器的方式访问。localhost:8080/bundle.js
    HMR Runtime：会在开发打包的阶段将HMR Runtime注入到浏览器端bundle.js里面，这样的话，浏览器端的bundle.js就可以和服务器
                建立一个连接，通常这个连接是一个websocket，然后就可以更新文件的变化。当它收到有些文件的更新的数据一些回包之
                后，就会自动的更新这个文件。
    bundle.js：构建输出的文件。
  热更新的过程
    热更新有两个过程
    第一个过程是启动阶段，在文件系统里进行一个编译，将初始的代码经过webpack compiler进行一个打包，之后将编译好的文件传输给
    bundle server，它就是一个服务器，它可以让文件以server的方式让浏览器可以访问的到。
    对于文件更新的情况，本地开发时，有文件的变化，这时文件系统发生变化，之后代码还是经过webpack compiler进行编译，编译好之后
    它会将代码发送给HMR Server，HMR Server就可以知道哪些资源哪些模块发生了改变，这里的模块是指源代码部分的这些模块，然后
    HMR Server它就会通知HMR Runtime，HMR Server是在服务端，HMR Runtiem是在客户端，就是HMR server端通知客户端哪些文
    件发生了变化，通常是以json数据进行传输，传输到了HMR Runtime之后，HMR Runtime就会更新我们的代码。最终我们的代码就会经过
    一个改变并且不需要刷新浏览器。这个就是热更新的原理。

11.文件指纹策略：chunkhash、contenthash和hash
什么是文件指纹：打包后输出的文件名后缀。
文件指纹的好处：通常是用来做版本的一些管理。
常见的文件指纹有哪几种：
  Hash：和整个项目的构建相关，在webpack打包阶段，是有compile和compiletion，compile是webpack启动的那一次，它会创建一个
        compile对象，compiletion是每次只要有文件发生了变化，compiletion这个对象是会变化的，这时候的hash是受到compiletion
        影响的，compiletion发生便会hash值也会发生变化。每次只要有一个文件发生变化，所有文件的hash都会发生变化。这是没有必要
        的，这时就会有chunkhash的一个概念。
  Chunkhash：和webpack打包的chunk相关，chunk指的是webpack打包的模块，不同的entry会生成不同的chunk，对于不同的entry的
             入口，其实我们都只需要它们的chunk保持独立就可以了。这样的话我们使用的chunkhash，每个页面，它们有一个文件发生了
             变化，并不会影响其他的页面。因此对于js文件的指纹，我们一般也是采用这个chunkhash。
  Contenthash：某一个页面既有js资源也有css资源，如果css资源也使用chunkhash的话，会有一个问题，就是我们修改了js，但是css
               并没有变，由于css也使用了chunkhash，就会导致css内容没有变，但是发布上去的文件指纹发生了变化。因此对于css
               ，通常我们是根据内容进行文件指纹的生成，采用contenthash。
文件指纹的使用
  js的文件指纹设置
    对于js我们只需要设置输出的output就可以了。
      output: {
        path: __dirname + './dist',
        filename: '[name].[chunkhash:8].js'
      }
  css的文件指纹设置
    css文件正常情况下，我们如果使用了style-loader和css-loader的话，那么这个css会由这个style-loader将这个css插入到
    style里面并且放到head头部。这时并没有独立的一个css文件，因此我们通常会采用MiniCssExtractPlugin这个插件把style-loader
    里面的css提取成一个独立的文件，因此对于css的文件指纹我们也是设置在MiniCssExtractPlugin里面，给它设置一个filename，
    并且使用contenthash。
      plugins: [
        new MiniCssExtractPlugin({
          filename: '[name].[contenthash:8].css'
        })
      ]
  图片或字体的文件指纹设置
    这时候我们是设置在file-loader或url-loader里面，然后给它传递一个options参数，这里我们使用的就是hash，这里的hash和前面
    提到的js的hash是不太一样的。对于图片和字体的hash和代码里js和css使用的hash含义是不一样的。这里的hash其实也是指文件内容的
    hash，这个hash是采用md5生成的，通常我们会将打包之后的图片放到一个images文件夹里面，这里我们采用[hash]占位符，还有其他的
    占位符，[ext]资源后缀名，[path]文件相对路径，[folder]文件所在文件夹。
      module: {
        rules: [
          {
            test: /\.(png|svg|jpg|gif)$/,
            use: {
              loader: 'file-loader',
              options: {
                name: 'img/[name].[hash:8].[ext]'
              }
            }
          }
        ]
      }
  实际设置
    为了方便演示，我们创建一个生产环境的webpack配置，因为webpack的chunkhash是没办法和热更新的HotModuleReplacementPlugin
    一起使用的。所以我们创建一个新的配置。分别创建webpack.dev.js和webpack.prod.js。生产环境是不需要代码热更新的。将生产和
    开发的配置分开。
    修改npm script分别指定生产和开发的配置文件。
    增加文件指纹（指纹的配置都是针对生产环境的）
      1.增加js的文件指纹，在webpack.prod.js配置中，直接修改output，给它加一个chunkhash。
      2.增加字体和图片的文件指纹，在webpack.prod.js配置中，在file-loader或url-loader中的options中配置name，加上hash。
      3.增加css的文件指纹，目前并没有将css提取成一个独立的css文件，没有办法看到css文件指纹的效果。所以我们需要把css提取成一
        个对立的文件。也就是使用MiniCssExtractPlugin这个插件，在这个插件中给css设置文件指纹。在webpack.prod.js配置中。
          把这个插件加进去，在插件配置中传递一个filename，设置文件指纹contenthash。
            plugins: [
              new MiniCssExtractPlugin({
                filename: '[name].[contenthash:8].css'
              })
            ]
          还需要把这个插件的loader也加进去，需要注意的一点是，插件是把css提取成独立的一个文件，这个插件它的loader是没办法和
          style-loader一起使用的，因为它们之间的功能是互斥的，style-loader是把样式插入到head里面，而这个插件是把样式提取
          出来，所以它们之间是有一些冲突的。所以说如果你想把这个css提取出一个独立的css文件，这个时候我们首先是要把style-loader
          删掉，删掉之后再使用这个插件的loader就可以了。
            {
              test: /\.css$/,
              use: [
                MiniCssExtractPlugin.loader,
                'css-loader'
              ]
            },
            {
              test: /\.less$/,
              use: [
                MiniCssExtractPlugin.loader,
                'css-loader',
                'less-loader'
              ]
            }
  注意：
    1.css/sass/less等css相关文件经过对应的loader处理之后，最上层的处理必须为style-loader将css样式放到style标签中或者
      使用文件提取的插件将css单独提取成独立css文件。两者必须存在一个，这样样式才能有效。两者同时存在，style-loader在前，生
      成独立css文件，style-loader失效；提取文件的插件loader在前，打包编译过不了。
    2.处理css和css预处理器互相独立的，配置不互相干扰。
    3.只有生产环境需要提取单独的css文件。
    4.指纹的配置都是在生产环境中需要的，开发环境不需要。

12.HTML 、CSS和JavaScript代码压缩
js文件的压缩
  webpack4里面，webpack内置了uglifyjs-webpack-plugin插件，所以我们默认打包出来的js文件就已经压缩过了。我们不需要再做
  其他的操作。当然你也可以手动的去安装这个插件，然后给它设置一些额外的参数，比如默认开启它的并行压缩。
css文件的压缩
  webpack3的时候我们可以通过css-loader去设置一个minify参数来压缩css，但是css-loader在1.0的版本之后去掉了这个参数，所以
  现在我们在做css的压缩是没办法直接通过css-loader设置参数的方式去压缩。这里我们是需要optimize-css-assets-webpack-plugin
  这个插件，使用这个插件的同时，我们还需要安装一下预处理器cssnano这个css的处理器，然后我们匹配到所有的css文件，然后在用这个
  css处理器进行css的压缩。
    new OptimizeCssAssetsWebpackgin({
      assectNameRegExp: /\.css$/g,
      cssProcessor: require('cssnano')
    })
html文件的压缩
  说到html文件的压缩，不得不谈一个很强大的插件，这个基本上是使用webpack一定会接触的一个插件，叫html-webpack-plugin，这个
  插件要想压缩html，其实我们只需要给这个插件设置一个压缩参数就可以了，这个插件它自身是支持传入一个minify这个参数，这个参数我
  们可以把空格，换行符号，注释全部的处理掉从而来达到一个压缩效果。
    new HtmlWebpackPlugin({
      template: path.join(__dirname, './src/index.html'), // HtmlWebpackPlugin它的html模版所在的位置
      filename: 'index.html', // 指定打包出来的html的文件名称
      chunks: ['index'], // 指定生成的这个html它要使用哪些chunk
      inject: true, // 打包出来的chunk的js css会自动的注入到html中来。
      minify: {
        html5: true,
        collapseWhitespace: true,
        perserveLineBreaks: false,
        minifyCSS: true,
        minifyJS: true,
        removeComments: false
      }
    }),
    new HtmlWebpackPlugin({
      template: path.join(__dirname, './src/search.html'), // HtmlWebpackPlugin它的html模版所在的位置
      filename: 'search.html', // 指定打包出来的html的文件名称
      chunks: ['search'], // 指定生成的这个html它要使用哪些chunk
      inject: true, // 打包出来的chunk的js css会自动的注入到html中来。
      minify: {
        html5: true,
        collapseWhitespace: true,
        perserveLineBreaks: false,
        minifyCSS: true,
        minifyJS: true,
        removeComments: false
      }
    })
    通常而言一个页面需要对于一个HtmlWebpackPlugin，我们这里有两个页面，所以要再加入一个HtmlWebpackPlugin

第二章我们主要是学习了在webpack里面的核心概念

第三章：webpack进阶用法
前面的章节，我们学习了webpack的基本用法，主要是包括webpack里面的一些基本概念，还有一个webpack的资源解析。还有热更新，代码
指纹，代码压缩等待。
这一章节，我们将会介绍webpack更加深入的用法，比如在webpack里面，增强css的一些解析功能，在webpack里面我们做的一些Tree 
Shaking，Scope Hoisting，代码分割等等一些比较高级的用法。还会介绍webpack处理打包之外的一些其他的场景，比如怎么通过webpack
打包一个组件或者工具库出来。

1.自动清理构建目录产物
每次构建的时候不会自动的清理目录，而是每次构建之前手动删除这个目录，如果不手动删除，就会造成构建的输出目录output文件越来越多。
针对这个问题，我们可以通过npm scripts来做一个目录的清理，在每次构建之前，在scripts里增加一个前置的操作，做完目录的删除之后
再运行webpack。
  rm -rf ./dist && webpack
  也可以通过rimraf这个库来做。
  rimraf ./dist && webpack
这个方法并不是非常的优雅，我们可以借助webpack插件的一个功能，在webpack里面它提供了一个比较好的一个插件clean-webpack-plugin，
我们可以通过这个插件避免每次构建前需要手动删除dist。这个插件我们只需要把它安装之后引入进来，使用这个插件的时候，它会默认的去删除
output指定的输出目录。

2.PostCSS插件autoprefixer自动补齐CSS3前缀




第一章 webpack与构建发展简史（基础篇）
1.使用webpack过程中涉及到的
多页面打包 SSR PWA Prerender 等多种构建场景
多实例构建 并行压缩公共资源分包 tree shaking 动态polyfill 等构建策略
webpack构建的打包速度和体积优化
前端工作流和团队开发规范的实施

2.为什么要深入掌握webpack？
和目前的应用场景和开发方式是息息相关的，现在前端面对多终端的开发，所以面对不同的应用场景，做不同的打包就显得很重要了。比如
针对pc端的中后台应用，我们需要支持单页应用的打包构建。H5页面对性能和可访问性有着极高的要求，因此需要通过构建来支持服务端渲
染和PWA离线缓存。
其次是nodejs的社区异常繁荣，已经有80多万的第三方组件。npm的组件在浏览器的js代码中并不能直接引入，这时就需要借助webpack
等构建工具来快速复用各种优秀成熟的组件，从而加速web开发。
当下流行的三大框架它们的一些语法，比如JSX和Vue指令等在浏览器都是无法直接解析的，也需要构建工具进行转换。
而webpack是构建工具中最耀眼的一颗星，无论你走前端的哪条路线，都需要有很强的webpack知识。熟悉webpack的使用和原理，可以让
你拓宽前端技术栈。在发现页面打包的速度和资源体积的问题时，能够知道如何排查问题和优化，同时熟悉webpack原理，有助于对其他跨
端应用的开发。比如在对小程序 weex ReactNative Electron等框架打包时能够快速上手，

3.初学者学习webpack的困难
webpack里众多的新概念，entry output mode loaders plugins 热更新 code spliting tree shaking等等，会让初学者感到
webpack感到很复杂，造成一定的学习成本。
webpack的进一步学习是有一定学习曲线的。包括webpack打包的速度，体积，页面加载时的性能优化等。是需要具备比较全面的webpack
专业知识。搞懂webpack内部的运行原理和插件机制才能深入掌握的。

4.课程设计思路
基础篇：掌握webpack的核心概念和开发必备技巧
进阶篇：以工程化的思维编写一份健壮可维护的webpack构建配置，同时掌握webpack构建速度和体积的优化策略。
原理篇：通过webpack源码剖析内部运行原理，和编写自定义的loader和插件的能力。
实战篇：从一个web商城项目出发，讲解webpack如何运用到实际的项目中去。并且最大化的提升开发阶段和发布阶段的构建体验。

5.为什么需要构建工具
转换es6语法
转换jsx
css前缀补全/预处理器
压缩混淆
图片压缩

6.前端构建演变之路
无代码压缩和混淆 -》 通过在线工具压缩混淆代码 -》 ant + YUI Toll 在本地对代码压缩混淆 -》 requirejs commonjs模块化概
念的出现，前端模块化的编写方式也越来越复杂，演变出了grunt -》 gulp fis3 -》 rollup webpack parcel

7.为什么选择webpack
社区活跃度
社区生态丰富，官方维护的插件丰富
配置灵活和个性化的插件化扩展
官方更新迭代速度快

8.初识webpack
配置文件名称
  webpack默认配置文件：webpack.config.js
  可以通过webpack --config指定配置文件
webpack配置组成
  主要包括entry output mode module plugins
  打包的入口文件 打包的输出 环境 loader配置 插件配置
webpack零配置
  webpack4允许不写webpack配置文件，会有一个默认的配置，这个配置里只有entry和output两项内容
  input: './src/index.js'
  output: './dist/main.js'

9.环境搭建：安装webpack
安装nvm(https://github.com/nvm-sh/nvm)
  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
  wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
将nvm添加到环境变量里面
  source ~/.bash_profile
nvm list
  列举本地安装的所有nodejs的版本
安装nodejs和npm
  nvm install v10.15.3
  检测是否安装成功：node -v, npm -v
创建空目录和package.json
  mkdir my-project
  cd my-project
  npm init -y
安装 webpack 和 webpack-cli
  webpack4是将webpack的内核和webpack-cli进行了分离，因此在实际的项目使用中需要同时安装这两个。
  npm install webpack webpack-cli --save-dev
  检查是否安装成功：./node_modules/.bin/webpack -v

10.webpack初体验：一个最简单的例子
创建webpack配置文件webpack.config.js
  webpack.config.js它是需要通过module.exports导出一个对象的。这个对象里就是所有webpack的配置。
  webpack.config.js
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.join(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      mode: 'production'
    }
  这样webpack的配置就编写好了。
编写程序的代码
  ./src/index.js
  ./src/helloworld.js
运行打包
  直接运行，不指定webpack配置文件的名称，它会默认使用webpack.config.js这个配置文件
  ./node_modules/.bin/webpack
在dist目录创建html文件
  引入打包好的bundle.js

11.通过npm script运行webpack
在当前项目局部安装的依赖，这个依赖如果有创建一些命令，它是会在node_modules/.bin目录下面创建一个软链接。package.json是
可以默认的读取到.bin目录下的这些命令。所以可以直接在package.json里面增加一个scripts，这里面指定一下webpack就可以了，
在scripts运行webpack时，它就会从node_modules/.bin这个目录里面去寻找对应的命令。scripts里面的就是可以运行的命令，使用
npm run scriptsName 来运行命令。

第二章：webpack基础用法（基础篇）
1.webpack核心概念之entry
entry用来指定webpack的打包入口
  为什么我们需要entry，这个离不开webpack的构建机制，webpack它是一个模块打包器，webpack里面会把一切的资源，不管是js css
  等代码资源，还是图片字体等非代码资源都会当成一个个的模块，所有模块之间存在着依赖关系，因此webpack根据这个入口文件去找到
  它的依赖，会形成一颗依赖树，只要遇到依赖，webpack就会将依赖文件加入到依赖图里面去。最终遍历完后，生成一个打包之后的一些
  资源。这就是entry的基本含义。
entry的用法
  单入口：entry是一个字符串
    单入口一般适用于一个项目里只有一个入口文件，只有一个页面。或者是一个单页应用。
    module.exports = {
      entry: './path/to/my/entry/file.js'
    }
  多入口：entry是一个对象
    多入口适合多页面的场景，多页应用。
    module.exports = {
      entry: {
        app: './src/app.js',
        adminApp: './src/adminApp.js'
      }
    }

2.webpack核心概念之output
output和entry也是息息相关的。entry是用来指定打包的入口，output是用来指定打包的输出。entry对应于源代码，output用来对应于
转换之后的最终结果代码。
output用来告诉webpack如何将编译后的文件输出到磁盘。输出到哪个目录，输出的文件名是什么。
output的用法
  单入口配置
    module.exports = {
      entry: './path/to/my/entry/file.js',
      output: {
        path: __dirname + '/dist',
        filename: 'bundle.js'
      }
    }
  多入口配置
    对于多入口配置，entry是有多个入口的，output里面并没有多个入口的说法，不管一个入口还是多个入口，在output里面都是只有一个
    output，它利用了一个占位符的概念确保文件名称的唯一。
    module.exports = {
      entry: {
        app: './src/app.js',
        search: './src/search.js'
      },
      output: {
        path: __dirname + '/dist',
        filename: '[name].js'
      }
    }

3.webpack核心概念之loaders
webpack开箱即用，原生只支持js和json两种文件类型，对于其他的文件如css less jsx vue指令，webpack是并不了解的，就需要
通过loaders去处理，把它们转化成有效的模块，这样webpack解析的时候才能将它们添加到依赖图中去。
loaders本身是一个函数，接收源代码作为参数，经过loader函数转换之后，返回转换后的结果。这个结果会给下一步去使用。
常见的loaders有哪些
  babel-loader        转换es6 es7等js新特性语法
  css-loader          支持.css文件的加载和解析
  less-loader         将less文件转换成css
  ts-loader           将ts转换成js
  file-loader         进行图片、字体、富媒体等文件的解析和打包
  raw-loader          将文件以字符串的形式进行导入
  thread-loader       多进程打包js和css。正常情况下webpack打包是开一个进程，thread-loader可以让webpack以多进程的
                      形式去打包js和css，会让打包的速度更快。
loaders的用法
  一个webpack配置里面可能会存在多个loader，这些loader是需要放在配置根节点下的module，module是一个对象，这个对象里面有
  一个rules，rules是一个数组，我们只需要把需要用的loader放到rules数组里面就可以了。对于每一个rule，通过test指定匹配规
  则，使用use指定当前使用的loader的名称。
  const path = require('path')
  module.exports = {
    output: {
      filename: 'bundle.js'
    },
    module: {
      rules: [
        {
          test: /\.txt$/,
          use: 'raw-loader'
        }
      ]
    }
  }

4.webpack核心概念之plugins
plugins作用是用来增强webpack的功能，plugins通常是用于打包输出的js文件的优化，资源的管理和环境变量的注入，可以把plugins
理解为任何loaders没办法做到的这种事情都是可以通过plugins去完成。比如构建之前需要手动的去删除打包目录，像这种操作都是可以
通过plugins很灵活的完成，plugins是作用于整个构建过程，就是从构建开始到构建结束整个阶段都是可以去使用这个plugins的。 
常见的plugins有哪些
  CommonsChunkPlugin            通常用在多个页面打包的情况下，可以将每个页面公共的一些js文件模块提取出来。
  CleanWebpackPlugin            清理构建目录
  ExtractTextWebpackPlugin      将css从bundle文件里提取成一个独立的css文件
  CopyWebpackPlugin             将文件或文件目录从一个目录拷贝到最后输出的构建目录里面
  HtmlWebpackPlugin             创建html文件去承载输出的bundle，而不需要每次构建完成之后，在构建的dist目录手动的去
                                创建一个html文件。
  UglifyjsWebpackPlugin         压缩js
  ZipWebpackPlugin              将打包出的资源生成一个zip包
plugins的用法
  在plugins数组里面将定义好的插件放进去就可以了。
  const path = require('path')
  module.exports = {
    output: {
      filename: 'bundle.js'
    },
    plugins: [
      new HtmlWebpackPlugin({template: './src/index.htmls'})
    ]
  }

5.webpack核心概念之mode
mode是用来指定当前打包的的构建环境：production development none。
mode是webpack4里提出的概念。
设置mode的好处是可以通过mode来自动的去触发webpack里面的内置函数，比如你设置成development，webpack会默认的去开启在开发
阶段的一些比较实用的参数和插件的一些功能。设置成production会默认开启在生产阶段的参数和插件的一些功能，设置成none就什么都
不会帮你做。默认值为production。
mode的内置函数功能
  development       设置process.env.NODE_ENV的值为development，可以在构建代码里面用到这个值。
                    默认开启NamedChunksPlugin和NamedModulesPlugin，这两个插件是会在代码热更新阶段很实用，可以在控
                    制台里面打印出是哪个模块发生了热更新，这个模块的路径是什么样的。
  production        设置process.env.NODE_ENV的值为production
                    默认开启FlagDependencyUsagePlugin FlagIncludedChunksPlugin ModuleConcatenationPlugin
                    NoEmitOnErrorsPlugin OccurrenceOrderPlugin SideEffectsFlagPlugin TerserPlugin
  none              不开启任何优化选项

6.解析ECMASCript 6和React JSX
资源解析：解析es6
  使用babel-loader
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.js$/,
            use: 'babel-loader'
          }
        ]
      }
    }
  babel的配置文件是.babelrc
    babel-loader是依赖babel的，因此我们需要在项目里面去使用babel的一个配置文件.babelrc。
    由于我们是要解析es6，因此这里我们添加babel的preset配置。
    babel有两块比较重要的概念，一个是presets，一个是plugins。plugins可以理解成一个plugins对应一个功能，presets是一
    系列babel plugins的集合。这里我们要解析es6，我们只需要安装@babel/preset-env这个preset就可以了。 
      {
        "presets": [
          "@babel/preset-env"
        ],
        "plugins": [
          "@babel/proposal-class-properties"
        ]
      }
  babel是怎么支持es6的解析的
    安装babel
      要解析es6首先需要安装一下@babel/core，然后还需要安装一下es6的preset，也就是@babel/preset-env，我们还需要通过
      babel-loader去解析它们，因此我们还需要安装一下babel-loader。
      npm i @babel/core @babel/preset-env babel-loader -D
    创建.babelrc文件
      添加es6相关的preset
      {
        "presets": [
          "@babel/preset-env"
        ]
      }
    修改webpack配置文件
      增加一个loader的配置
资源解析：解析react jsx
  解析vue的一些语法等跟这个类似。
    在babel的配置文件中增加react的preset的配置。这样就可以解析react相关的语法了。
    {
      "presets": [
        "@babel/preset-env",
        "@babel/preset-react"
      ]
    }
  安装react相关
    npm i react react-dom @babel/preset-react -D

7.解析CSS、Less和Sass
资源解析：解析css
  webpack中想要解析css
    首先需要使用css-loader，作用是用来加载.css文件，加载时机是在代码里面，比如index.js里引用了这个css，这时它就会加载
    .css文件，并且将它转换成一个commonjs对象，插入到js代码里面去。
    然后需要通过style-loader，作用是将样式通过style标签插入到head中，这样样式才能在代码里面显示出来。
  安装css-loader style-loader
    npm i css-loader style-loader -D
  配置css-loader style-loader
    有一点需要注意，loader的调用是链式调用的，执行顺序是从右到左的，因此我们需要先写style-loader，再写css-loader，这样
    的话，它实际执行的时候会先去使用css-loader去解析css，然后再将解析好的css传递给style-loader。
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.css$/,
            use: [
              'style-loader',
              'css-loader'
            ]
          }
        ]
      }
    }
资源解析：解析less和sass
  想解析less只需要在前面的基础之上增加一个less-loader就可以了。less-loader的作用就是将less转换成css。
  安装less 和  less-loader，因为less-loader是依赖于less的。
    npm i less less-loader -D
  配置less
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.less$/,
            use: [
              'style-loader',
              'css-loader',
              'less-loader'
            ]
          }
        ]
      }
    }

8.解析图片和字体
解析资源：解析图片
  要想解析图片需要利用到一个非常实用的loader叫file-loader，它可以处理一些文件，这里只需要匹配上一些图片，比如png svg
  jpg gif等图片资源，然后去使用这个file-loader就可以解析这个图片了。
  安装file-loader
    npm i file-loader -D
  配置图片解析file-loader
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.(png|svg|jpg|gif)$/,
            use: 'file-loader'
          }
        ]
      }
    }
资源解析：解析字体
  在webpack里面解析字体和解析图片做法是一样的，因为图片和字体都不是代码文件。图片和字体的解析都可以采用这个file-loader
  去处理。
  配置字体解析file-loader
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.(woff|woff2|eot|ttf|otf)$/,
            use: 'file-loader'
          }
        ]
      }
    }
图片解析和字体解析的其他方式
  前面是用file-loader去解析图片和字体，除此之外我们还可以用url-loader去做。url-loader和file-loader功能上是差不多的，
  只不过url-loader相比file-loader，它还可以做一个小图片或小字体，自动的做一个base64的一个转换，url-loader内部也是用
  了file-loader。
  怎么做一个小资源的转换
    这里可以看到url-loader它接收一个参数，这个参数是通过options给loader进行传参，传的参数是limit是10240，limit的单
    位是一个字节。
    const path = require('path')
    module.exports = {
      entry: './src/index.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            test: /\.(png|svg|jpg|gif)$/,
            use: [{
              loader: 'url-loader',
              options: {
                limit: 10240
              }
            }]
          }
        ]
      }
    }

9.webpack中的文件监听
之前我们修改源代码之后都需要手动的运行一下构建命令，这是比较麻烦的，尤其是在开发的过程中，因此在webpack中做一个文件自动编译
是很有必要的。
文件监听的作用是发现源代码发生变化时，能自动的重新构建出新的文件并输出出来。
webpack开启监听模式，有两种方式：
  启动webpack时，在webpack命令后加上--watch参数
    "scripts": {
      "test": "echo \"Error: no test specified\" && exit 1",
      "build": "webpack",
      "watch": "webpack --watch"
    }
    这种方式有一个缺点，就是webpack自动编译完成之后，浏览器是不会自动刷新的，每次需要手动刷新浏览器。
  在配置webpack.config.js中设置watch: true
    module.exports = {
      // 默认false，也就是不开启
      watch: true,
      // 只有开启监听模式时，watchOptions才有意义
      watchOptions: {
        // 默认为空，不监听的文件或文件夹，支持正则匹配
        ignored: /node_modules/,
        // 监听到变化后会等300ms再去执行，默认300ms
        aggregateTimeout: 300,
        // 判断文件是否发生变化是通过不停轮询系统指定文件有没有变化实现的，默认每秒询问1000次
        poll: 1000
      }
    }
文件监听的原理分析
  webpack会轮询的去判断文件的最后编辑时间是否发生变化。一开始会有一次文件的修改时间，会把这个时间存储起来，下次再有修改的
  时候，就会和上一次的修改时间进行比对，如果发现不一致，它不会立刻的告诉监听者，而是把这个文件的修改先缓存起来，等待一定时
  间aggregateTimeout，这个时间内如果有其他的文件也发生了变化，那么它会把这些变化了的文件列表一起去构建，最后一起把构建的
  结果生成到bundle文件里面来。
  
10.webpack中的热更新及原理分析
热更新：webpack-dev-server
  前面讲到了webpack文件的监听方式，但是它有一个缺点就是每次构建完之后需要手动的刷新浏览器。
  在webpack中，其实有更好的方式，我们可以借助一个webpack-dev-server，每次代码修改，让它自动的去构建，构建完成之后，通过
  这种热更新的方式让浏览器里面的内容自动的去变化。
  wds不需要刷新浏览器。
  wds通常是需要和HotModuleReplacementPlugin插件一起使用，它们两个进行结合之后，可以开启热更新的一个功能。
  wds还有一个优势是它输出的文件不放入磁盘里面，没有磁盘的io操作，它输出的文件是放在内存里面，而不是像watch这种方式是放在本
  地的磁盘文件里面。所以它的构建速度会有更大的优势。
  使用wds
    // package.json
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "build": "webpack",
        "watch": "webpack --watch",
        "dev": "webpack-dev-server --open"
      }
    // webpack.config.js
      // wds主要是在开发过程中使用，在生产环境是不需要用到的。
      mode: "development"
      // 引入webpack自带的HotModuleReplacementPlugin插件
      const webpack = require('webpack')
      plugins: [
        new webpack.HotModuleReplacementPlugin()
      ]
      // 配置devServer
      devServer: {
        // wds服务的基础的目录
        contentBase: './dist',
        // 开启热更新
        hot: true
      }
  运行效果
    npm run dev
    可以看到webpack在进行构建，构建好之后它打开了一个浏览器，浏览器中可以看到它会把构建出来的内容目录都输出出来，然后我们
    代开search.html这个页面。修改内容，测试它会不会自动去变。
热更新：使用webpack-dev-middleware
  这个日常开发也是用的比较多的，与前面实现相同的效果，这种方式更加的灵活。采用这种方式，需要引入一下node的一个server，就是
  我们自己创建一个node server，通常使用express或者koa。wdm可以将webpack输出的文件传输给服务器，这种方式是比较适合比较
  灵活的定制场景。可以对webpack的这种配置可以控制的更多。
  const express = require('express')
  const webpack = require('webpack')
  const webpackDevMiddleWare = require('webpack-dev-middleware')

  const app = express()
  const config = require('./webpack.config.js')
  const compiler = webpack(config)

  app.use(webpackDevMiddleWare(compiler, {
    publicPath: config.output.publicPath
  }))

  app.listen(3000, function() {
    console.log('Example app listening on port 3000')
  })
热更新的原理分析
  要学懂热更新的原理，首先要知道一些概念
    Webpack Compile：也就是webpack的编译器，它的作用是将js的源代码编译成bundlejs就是最后打包好输出的文件。
    HMR Server：用来将热更新的文件传输给HMR Runtime
    Bundle Server：提供文件在浏览器的访问，比如编译好的bundle.js其实在浏览器里面正常访问的是文件目录的访问，bundle server
                  是可以让你通过服务器的方式访问。localhost:8080/bundle.js
    HMR Runtime：会在开发打包的阶段将HMR Runtime注入到浏览器端bundle.js里面，这样的话，浏览器端的bundle.js就可以和服务器
                建立一个连接，通常这个连接是一个websocket，然后就可以更新文件的变化。当它收到有些文件的更新的数据一些回包之
                后，就会自动的更新这个文件。
    bundle.js：构建输出的文件。
  热更新的过程
    热更新有两个过程
    第一个过程是启动阶段，在文件系统里进行一个编译，将初始的代码经过webpack compiler进行一个打包，之后将编译好的文件传输给
    bundle server，它就是一个服务器，它可以让文件以server的方式让浏览器可以访问的到。
    对于文件更新的情况，本地开发时，有文件的变化，这时文件系统发生变化，之后代码还是经过webpack compiler进行编译，编译好之后
    它会将代码发送给HMR Server，HMR Server就可以知道哪些资源哪些模块发生了改变，这里的模块是指源代码部分的这些模块，然后
    HMR Server它就会通知HMR Runtime，HMR Server是在服务端，HMR Runtiem是在客户端，就是HMR server端通知客户端哪些文
    件发生了变化，通常是以json数据进行传输，传输到了HMR Runtime之后，HMR Runtime就会更新我们的代码。最终我们的代码就会经过
    一个改变并且不需要刷新浏览器。这个就是热更新的原理。

11.文件指纹策略：chunkhash、contenthash和hash
什么是文件指纹：打包后输出的文件名后缀。
文件指纹的好处：通常是用来做版本的一些管理。
常见的文件指纹有哪几种：
  Hash：和整个项目的构建相关，在webpack打包阶段，是有compile和compiletion，compile是webpack启动的那一次，它会创建一个
        compile对象，compiletion是每次只要有文件发生了变化，compiletion这个对象是会变化的，这时候的hash是受到compiletion
        影响的，compiletion发生便会hash值也会发生变化。每次只要有一个文件发生变化，所有文件的hash都会发生变化。这是没有必要
        的，这时就会有chunkhash的一个概念。
  Chunkhash：和webpack打包的chunk相关，chunk指的是webpack打包的模块，不同的entry会生成不同的chunk，对于不同的entry的
             入口，其实我们都只需要它们的chunk保持独立就可以了。这样的话我们使用的chunkhash，每个页面，它们有一个文件发生了
             变化，并不会影响其他的页面。因此对于js文件的指纹，我们一般也是采用这个chunkhash。
  Contenthash：某一个页面既有js资源也有css资源，如果css资源也使用chunkhash的话，会有一个问题，就是我们修改了js，但是css
               并没有变，由于css也使用了chunkhash，就会导致css内容没有变，但是发布上去的文件指纹发生了变化。因此对于css
               ，通常我们是根据内容进行文件指纹的生成，采用contenthash。
文件指纹的使用
  js的文件指纹设置
    对于js我们只需要设置输出的output就可以了。
      output: {
        path: __dirname + './dist',
        filename: '[name].[chunkhash:8].js'
      }
  css的文件指纹设置
    css文件正常情况下，我们如果使用了style-loader和css-loader的话，那么这个css会由这个style-loader将这个css插入到
    style里面并且放到head头部。这时并没有独立的一个css文件，因此我们通常会采用MiniCssExtractPlugin这个插件把style-loader
    里面的css提取成一个独立的文件，因此对于css的文件指纹我们也是设置在MiniCssExtractPlugin里面，给它设置一个filename，
    并且使用contenthash。
      plugins: [
        new MiniCssExtractPlugin({
          filename: '[name].[contenthash:8].css'
        })
      ]
  图片或字体的文件指纹设置
    这时候我们是设置在file-loader或url-loader里面，然后给它传递一个options参数，这里我们使用的就是hash，这里的hash和前面
    提到的js的hash是不太一样的。对于图片和字体的hash和代码里js和css使用的hash含义是不一样的。这里的hash其实也是指文件内容的
    hash，这个hash是采用md5生成的，通常我们会将打包之后的图片放到一个images文件夹里面，这里我们采用[hash]占位符，还有其他的
    占位符，[ext]资源后缀名，[path]文件相对路径，[folder]文件所在文件夹。
      module: {
        rules: [
          {
            test: /\.(png|svg|jpg|gif)$/,
            use: {
              loader: 'file-loader',
              options: {
                name: 'img/[name].[hash:8].[ext]'
              }
            }
          }
        ]
      }
  实际设置
    为了方便演示，我们创建一个生产环境的webpack配置，因为webpack的chunkhash是没办法和热更新的HotModuleReplacementPlugin
    一起使用的。所以我们创建一个新的配置。分别创建webpack.dev.js和webpack.prod.js。生产环境是不需要代码热更新的。将生产和
    开发的配置分开。
    修改npm script分别指定生产和开发的配置文件。
    增加文件指纹（指纹的配置都是针对生产环境的）
      1.增加js的文件指纹，在webpack.prod.js配置中，直接修改output，给它加一个chunkhash。
      2.增加字体和图片的文件指纹，在webpack.prod.js配置中，在file-loader或url-loader中的options中配置name，加上hash。
      3.增加css的文件指纹，目前并没有将css提取成一个独立的css文件，没有办法看到css文件指纹的效果。所以我们需要把css提取成一
        个对立的文件。也就是使用MiniCssExtractPlugin这个插件，在这个插件中给css设置文件指纹。在webpack.prod.js配置中。
          把这个插件加进去，在插件配置中传递一个filename，设置文件指纹contenthash。
            plugins: [
              new MiniCssExtractPlugin({
                filename: '[name].[contenthash:8].css'
              })
            ]
          还需要把这个插件的loader也加进去，需要注意的一点是，插件是把css提取成独立的一个文件，这个插件它的loader是没办法和
          style-loader一起使用的，因为它们之间的功能是互斥的，style-loader是把样式插入到head里面，而这个插件是把样式提取
          出来，所以它们之间是有一些冲突的。所以说如果你想把这个css提取出一个独立的css文件，这个时候我们首先是要把style-loader
          删掉，删掉之后再使用这个插件的loader就可以了。
            {
              test: /\.css$/,
              use: [
                MiniCssExtractPlugin.loader,
                'css-loader'
              ]
            },
            {
              test: /\.less$/,
              use: [
                MiniCssExtractPlugin.loader,
                'css-loader',
                'less-loader'
              ]
            }
  注意：
    1.css/sass/less等css相关文件经过对应的loader处理之后，最上层的处理必须为style-loader将css样式放到style标签中或者
      使用文件提取的插件将css单独提取成独立css文件。两者必须存在一个，这样样式才能有效。两者同时存在，style-loader在前，生
      成独立css文件，style-loader失效；提取文件的插件loader在前，打包编译过不了。
    2.处理css和css预处理器互相独立的，配置不互相干扰。
    3.只有生产环境需要提取单独的css文件。
    4.指纹的配置都是在生产环境中需要的，开发环境不需要。

12.HTML 、CSS和JavaScript代码压缩
js文件的压缩
  webpack4里面，webpack内置了uglifyjs-webpack-plugin插件，所以我们默认打包出来的js文件就已经压缩过了。我们不需要再做
  其他的操作。当然你也可以手动的去安装这个插件，然后给它设置一些额外的参数，比如默认开启它的并行压缩。
css文件的压缩
  webpack3的时候我们可以通过css-loader去设置一个minify参数来压缩css，但是css-loader在1.0的版本之后去掉了这个参数，所以
  现在我们在做css的压缩是没办法直接通过css-loader设置参数的方式去压缩。这里我们是需要optimize-css-assets-webpack-plugin
  这个插件，使用这个插件的同时，我们还需要安装一下预处理器cssnano这个css的处理器，然后我们匹配到所有的css文件，然后在用这个
  css处理器进行css的压缩。
    new OptimizeCssAssetsWebpackgin({
      assectNameRegExp: /\.css$/g,
      cssProcessor: require('cssnano')
    })
html文件的压缩
  说到html文件的压缩，不得不谈一个很强大的插件，这个基本上是使用webpack一定会接触的一个插件，叫html-webpack-plugin，这个
  插件要想压缩html，其实我们只需要给这个插件设置一个压缩参数就可以了，这个插件它自身是支持传入一个minify这个参数，这个参数我
  们可以把空格，换行符号，注释全部的处理掉从而来达到一个压缩效果。
    new HtmlWebpackPlugin({
      template: path.join(__dirname, './src/index.html'), // HtmlWebpackPlugin它的html模版所在的位置
      filename: 'index.html', // 指定打包出来的html的文件名称
      chunks: ['index'], // 指定生成的这个html它要使用哪些chunk
      inject: true, // 打包出来的chunk的js css会自动的注入到html中来。
      minify: {
        html5: true,
        collapseWhitespace: true,
        perserveLineBreaks: false,
        minifyCSS: true,
        minifyJS: true,
        removeComments: false
      }
    }),
    new HtmlWebpackPlugin({
      template: path.join(__dirname, './src/search.html'), // HtmlWebpackPlugin它的html模版所在的位置
      filename: 'search.html', // 指定打包出来的html的文件名称
      chunks: ['search'], // 指定生成的这个html它要使用哪些chunk
      inject: true, // 打包出来的chunk的js css会自动的注入到html中来。
      minify: {
        html5: true,
        collapseWhitespace: true,
        perserveLineBreaks: false,
        minifyCSS: true,
        minifyJS: true,
        removeComments: false
      }
    })
    通常而言一个页面需要对于一个HtmlWebpackPlugin，我们这里有两个页面，所以要再加入一个HtmlWebpackPlugin

第三章：webpack进阶用法（基础篇）
前面的章节，我们学习了webpack的基本用法，主要是包括webpack里面的一些基本概念，还有一个webpack的资源解析。还有热更新，代码
指纹，代码压缩等待。
这一章节，我们将会介绍webpack更加深入的用法，比如在webpack里面，增强css的一些解析功能，在webpack里面我们做的一些Tree 
Shaking，Scope Hoisting，代码分割等等一些比较高级的用法。还会介绍webpack处理打包之外的一些其他的场景，比如怎么通过webpack
打包一个组件或者工具库出来。

1.自动清理构建目录产物
每次构建的时候不会自动的清理目录，而是每次构建之前手动删除这个目录，如果不手动删除，就会造成构建的输出目录output文件越来越多。
针对这个问题，我们可以通过npm scripts来做一个目录的清理，在每次构建之前，在scripts里增加一个前置的操作，做完目录的删除之后
再运行webpack。
  rm -rf ./dist && webpack
  也可以通过rimraf这个库来做。
  rimraf ./dist && webpack
这个方法并不是非常的优雅，我们可以借助webpack插件的一个功能，在webpack里面它提供了一个比较好的一个插件clean-webpack-plugin，
我们可以通过这个插件避免每次构建前需要手动删除dist。这个插件我们只需要把它安装之后引入进来，使用这个插件的时候，它会默认的去删除
output指定的输出目录。

2.PostCSS插件autoprefixer自动补齐CSS3前缀
在webpack中对css增强的一些功能，现在由于移动设备的浏览器众多，因此我们需要面对很多兼容性的问题，有些兼容问题我们可以在构建
阶段去尽量避免的，比如css3前缀的问题，为什么css3的属性需要添加前缀呢，因为由于浏览器的标准并没有完全的统一，目前来看还是有
四种浏览器内核，IE Trident(-ms), Firefox Geko(-moz), Chrome Webkit(-webkit), Opera Presto(-o)。以前我们都是手
动的去补齐前缀，很浪费时间。
在webpack里面我们是可以通过PostCSS插件的autoprefixer来自动补齐css3前缀的。
autoprefixer是css的一个后置处理器，与less和sass不同，less和sass是css的一个预处理器，预处理器一般是在打包前置去处理，
autoprefixer是在样式处理好之后，代码最终生成完之后，再对它进行后置处理。
使用autoprefixer
  autoprefixer插件通常是和postcss-loader一起使用的。postcss-loader的功能是比较强大的，除了做css样式补全之外，它还可以
  做支持css module，还可以支持style lint等等。
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [
          'style-loader',
          'css-loader',
          'less-loader',
          {
            loader: 'postcss-loader',
            options: {
              plugins: () => [
                require('autoprefixer')({
                  overrideBrowserslist: ["last 2 version", ">1%", "IOS 7"] // browsers这个参数可以指定autoprefixer所需要兼容的浏览器的版本
                })
              ]
            }
          }
        ]
      }
    ]
  }

3.移动端CSS px自动转换成rem
在webpack里面怎么去做css另外的一个特性的增强，主要是怎么通过webpack自动去做rem的转换，为什么要谈这个话题呢，不得不提及浏览器
的分辨率，移动设备流行之后，我们以ios为例，不同机型的分辨率是不一样的，这对前端开发来说，就会造成比较大的问题，就是需要不断的对
页面进行适配。以前有一种比较常用的方式，就是使用css的媒体查询去实现响应式的布局，我们需要在不同的分辨率下面设置不同的样式代码。这
个是比较影响开发效率的。
有没有比较好的方式呢，css3里面提出了一个rem的单位，就是根元素font-size的大小，也就是说rem它是一个相对的单位，px是绝对单位，
给元素设定了一个px，它不管在什么样的设备下面，它表现都是一致的，它都是会占那么大的一个宽高，但如果你设置的是rem的话，它就会自动
的适配这些机型，在不同的机型下面它的相对的宽度，相对的字体的大小是不一样的，这样是可以满足我们的要求的。
在webpack里使用rem
  因为我们希望编写代码的时候，能够按照一定的设计稿的规范去编写代码，常见的是375*750宽度的设计稿，编写完代码时，其实我们还是按照
  px的单位去写，然后通过构建工具，自动的将px转换成rem，这个工具就是px2rem-loader，这是第一步。
    npm i px2rem-loader -D
    {
      test: /\.less$/,
      use: [
        MiniCssExtractPlugin.loader,
        'css-loader',
        'less-loader',
        {
          loader: 'postcss-loader',
          options: {
            plugins: () => [
              require('autoprefixer')({
                overrideBrowserslist: ["last 2 version", ">1%", "ios 7"]
              })
            ]
          }
        },
        {
          loader: 'px2rem-loader',
          options: {
            remUnit: 75, // rem相对于px的转换的一个单位，75代表1rem=75px，这个比较适合750的设计稿，量的是750个像素对应着10个rem。
            remPrecision: 8 // px转成rem，后面小数点的位数。
          }
        }
      ]
    }
  第二步，px转换成rem之后，我们需要知道一个rem单位等于多少px，就需要我们在页面打开的时候动态的去计算根元素font-size的值，我们
  可以利用手淘里面比较成熟的方案lib-flexible库，它会自动的根据当前设备的宽高来计算根元素实际的font-size的值。
    https://github.com/amfe/lib-flexible
    lib-flexible我们需要直接的引用它，所以要-S
    npm i lib-flexible -S
    使用lib-flexible计算实际的设备分辨率根元素的font-size大小。
    手动的将代码引入进来，这段代码不能把它打包到js里面去，页面打开的时候就需要马上的计算这个值，所以它的位置需要前置放在前面的位置。
    如果我们想把一些库内联到html里面去，目前构建还不支持，下节将会讲解在webpack里面怎么做代码资源的内联，比如怎么将打包出来的样式
    内联到html里面去，怎么将一个js库直接内联进来，怎么内联图片字体等等。

4.静态资源内联
在webpack里的资源内联，这个也是比较重要的一个功能
资源内联的意义
  我们的代码如css js怎么内联到html里面去，或者是怎么把一些图片字体等等内联到代码里面去，这个有什么意义呢，资源内联的意义主要
  从两个方面来看
  从代码的层面：（代码层面的一些体验和初始化等内容）
    我们打开一个页面要做一些初始化的脚本，如上节中rem计算的js库，要在打开页面的时候就要去计算。
    上报相关的点，page start，css初始化，css加载完成，js初始化和js加载完成等等代码。这些都是需要内联到html里面去，而不能
    直接放到最终打包的js脚本中去。
    css内联到html中去，避免页面闪动。
  从请求层面：资源内联可以减少http网络请求数。
    比如小图片或字体内联到代码里面去。小图片和字体的内联直接使用url-loader就可以了。
html和js的内联
  raw-loader的功能就是读取一个文件，把这个文件的内容返回成一个string，把这个string插入到对应的位置，html-webpack-plugin
  默认使用的是ejs模版引擎，所以这里我们可以直接使用${}这种语法，它是可以直接识别的了的。
  raw-loader内联html
    <%= require('raw-loader!./meta.html') %>
  raw-loader内联js
    <script><%= require('raw-loader!babel-loader!../../node_modules/lib-flexible/flexible.js') %></script>
css内联
  方案一：借助style-loader
    {
      loader: 'style-loader',
      options: {
        insertAt: 'top', // 样式插入到<head>
        singleton: true // 将所有style标签合并成一个
      }
    }
  方案二：html-inline-css-webpack-plugin
    它针对打包好的css chunk的代码，把它内联到html的head中。

5.多页面应用打包通用方案
多页面应用（MPA）概念
  多页面发布上线之后，它有很多个入口。
  每一次页面跳转的时候，后台服务器都会返回一个新的html文档。
  多页面优势
    1.每个页面之间是解偶的
    2.对seo更友好
多页面打包基本思路
  每个页面对应一个entry，一个html-webpack-plugin
  缺点：每次新增或删除页面需要手动修改webpack配置构建脚本
多页面打包通用方案
  动态获取entry和设置html-webpack-plugin数量
  通过程序的思维动态获取某一个目录下面指定的入口文件，需要有一个约定，把所有的页面都放在src的目录下面，每个页面的入口文件都约定为
  index.js，这样我们就可以通过js脚本去获取src里面所有的目录，就可以知道入口文件的数量，打包的时候动态的设置html-webpack-plugin
  。相比于自己写这个脚本，webpack里面有一个更通用的做法是通过glob这个库，glob的原理类似linux操作系统下面文件通配匹配的概念，根据
  匹配信息返回匹配到的目录内容，我们根据这个目录内容进行操作就可以了。
    entry: glob.sync(path.join(__dirname, './src/*/index.js'))
    // 动态设置entry和HtmlWebpackPlugin
    const setMPA = () => {
    const entry = {}
    const htmlWebpackPlugins = []
    const entryFiles = glob.sync(path.join(__dirname, './src/*/index.js'))
    Object.keys(entryFiles)
      .map(index => {
        const entryFile = entryFiles[index]
        const match = entryFile.match(/src\/(.*)\/index\.js/)
        const pageName = match && match[1]
        entry[pageName] = entryFile
        htmlWebpackPlugins.push(new HtmlWebpackPlugin({
          template: path.join(__dirname, `./src/${pageName}/index.html`),
          filename: `${pageName}.html`,
          chunks: [pageName],
          inject: true,
          minify: {
            html5: true,
            collapseWhitespace: true,
            perserveLineBreaks: false,
            minifyCSS: true,
            minifyJS: true,
            removeComments: false
          }
        }))
      })
    return {
      entry,
      htmlWebpackPlugins
    }
  }
  const {entry, htmlWebpackPlugins} = setMPA()

6.使用sourcemap
sourcemap是开发中的一个利器，webpack打包的时候会将源代码打包成一个bundle文件，bundle文件就是经过了loader转换，插件处理，
构建过程中的转换，最终会生成一个大的js文件，如果直接去看这个js文件，是没办法调试的。这时就需要sourcemap。
功能作用：通过source map定位到源代码
开发环境开启，线上环境关闭
  如果线上不关闭，会把我们的业务逻辑暴露出来，线上排查问题的时候可以将sourcemap上传到错误监控系统。
sourcemap关键字
  eval：使用eval将模块代码包裹起来，每一段代码块后面会有一段sourcemap文件url来指定sourcemap的信息。
  source map：产生.map文件，sourcemap文件和打包出来的对应文件分离的
  cheap：不包含列信息，只包含行信息
  inline：sourcemap内容和代码是在一起的，打包的时候会将sourcemap和源代码打包在一起，sourcemap的内容内联到代码文件里面去。
  module：包含了loader的sourcemap，出错的时候会进一步的定位。
sourcemap类型
  可以根据前面的关键字排列组合得到。
本地开发时使用sourcemap进行代码调试
  在webpack.dev.js devtoo中加入sourcemap

7.提取页面公共资源 /* todo */
基础库的分离
  思路：将react react-dom vue等基包库通过cdn引入，不打入bundle中。
  方法：使用html-webpack-externals-plugin
    new HtmlWebpackExternalsPlugin({
      externals: [
        {
          module: 'react',
          entry: 'https://cdn.bootcdn.net/ajax/libs/react/15.6.0/react.min.js',
          global: 'React'
        },
        {
          module: 'react-dom',
          entry: 'https://cdn.bootcdn.net/ajax/libs/react/15.6.0/react-dom.min.js',
          global: 'ReactDOM'
        }
      ]
    })
    然后在html中将react和react-dom依赖脚本引入进来。
  利用split-chunks-plugin进行公共脚本分离
    split-chunks-plugin是webpack4内置的功能非常强大的插件，做代码分割基本是离不开这个插件的，用来代替commons-chunk-plugin，
    optimization: {
      splitChunks: {
        chunks: "async",
        minSize: 30000, // 抽离的公共包最小的大小，单位是字节
        maxSize: 0, // 抽离的公共包最大的大小，单位是字节
        minChunks: 1, // 使用的次数超过这个就提取成公共的文件
        maxAsyncRequests: 5, // 
        maxInitialRequests: 3, // 同时请求的异步资源的次数
        automaticNameDelimiter: '~',
        name: true,
        cacheGroups: {
          vendors: {
            test: /[\\/]node_modules[\\/]/,
            priority: -10
          },
          default: {
            minChunks: 2,
            priority: -20,
            reuseExistingChunk: true
          }
        }
      }
    }
    可以看出来这个插件是很复杂的，也从侧面反映出这个插件的功能强大。
    chunks参数说明
      async：只异步引入的库进行分离（默认）
      initial：只同步引入的库进行分离
      all：所有引入的库进行分析（推荐）
    利用split-chunks-plugin分离基础包
      test：匹配出需要分离的包
      使用时还需要把vendors的chunk添加到HtmlWebpackPlugin的chunk里面
      optimization: {
        splitChunks: {
          cacheGroups: {
            commons: {
              test: /(react|react-dom)/,
              name: "vendors",
              chunks: "all"
            }
          }
        }
      }
    利用split-chunks-plugin分离页面公共文件
      optimization: {
        splitChunks: {
          minSize: 0,
          cacheGroups: {
            commons: {
              name: "commons",
              chunks: "all",
              minChunks: 2
            }
          }
        }
      }
  
8.Tree Shaking的使用和原理分析
Tree Shaking（摇树优化）
Tree Shaking在webpack4已经默认支持了，在生产环境mode: 'production'是默认开启的。
在.babelrc里设置modules: false即可
概念：一个模块可能有多个方法，Tree Shaking就是只把用到的方法打入bundle，没用到的方法会在uglify阶段被擦除掉。
使用Tree Shaking，写法必须是es6的语法，cjs的模块的方式不支持。
使用：production mode的情况下默认开启，在.babelrc里设置modules: false即可。
Tree Shaking原理 
  DCE(Elimination)，有下面三种情况：
    代码不会被执行，不可到达
      if () {
        console.log('这段代码永远不会执行')
      }
    代码执行的结果不会被用到
    代码只会影响死变量（只写不读），前面定义改变了这个变量，最后并没有用到这个变量
  Tree Shaking也是利用了DCE的这个特点，从而来分析，看看哪些代码是需要被删除掉的。
  代码擦除：Tree Shaking将没有用到的代码加一些注释来标记，在uglify阶段删除无用代码。

9.Scope Hoisting使用和原理分析 /* todo */
在webpack4里面很重要的一个特性。
没有开启Scope Hoisting的现象：
  构建之后的代码存在大量的闭包代码。对于每一个模块打包出来是会有一个函数的包裹。
会导致的问题：
  大量函数的闭包包裹代码，会导致导报出来的bundle.js文件体积增大（模块越多越明显）。
  由于是通过函数闭包的形式包裹代码，运行代码时创建的函数作用域就会变多，内存开销变大。
为什么webpack打包的时候，会打包出这么多函数包裹来把代码包裹起来呢，这就需要做下面的分析。
模块转换分析
  webpack会将模块转化成模块初始化函数，这里会做两件事情：
  1.把这个模块加一个包裹。
  2.将import代码转换成__webpack_require，export也会做相应的转换。
进一步分析webpack模块机制
  打包出来的是一个IIFE（匿名闭包）
  modules是一个数组，每一项是一个模块初始化函数，会传递给函数
  __webpack_require用来加载模块，返回module.exports
  通过WEBPACK_REQUIRE_MOTHOD(0)启动程序
对上面提到的包裹代码做优化
scope hoisting原理
  将所有模块的代码按照引用顺序放在一个函数作用域里面，然后适当的重命名一些变量以防止变量名冲突。
  对比：通过scope hoisting可以减少函数声明代码和内存开销。
scope hoisting使用
  webpack3里面需要手动的加一行代码
    new webpack.optimize.ModuleConcatenationPlugin()
  webpack4 mode为production默认开启
  必须是es6语法，cjs不支持

10.代码分割和动态import
前面介绍的split-chunks-plugin提取基础包和公共的内容，这个是初步的代码分割的内容。
这节介绍代码分割另外一个比较常用的手段，动态import或cjs里面的require.ensure语法
代码分割的意义
  对大的web应用而言，将所有的代码都放在一个文件中显然是不够有效的，特别是你的代码在一些情况下才会用到，首屏加载不会用到的。这
  时候我们针对首屏会打出一个js文件，对于其他的页面或tab切换的场景可以通过按需加载，也就是js懒加载的形式，它和懒加载图片是一样
  的道理，我们用到了这个脚本再加载它。这就是webpack里面提供的一个懒加载的功能，webpack将你的代码库分割成chunks（语块），当
  代码运行到需要它们的时候再进行加载。
适用场景：
  抽离相同代码到一个共享块
  脚本懒加载，用到的时候再加载，使得初始下载的代码更小
    commonjs：require.ensure
    es6：动态import（webpack比较推荐的一种方式，目前还没有原生支持，需要安装babel插件支持这种语法）
      import xxx from 'xxx' 是静态的，动态的是我们使用到的时候再import，动态的import功能和require比较像，可以通过逻辑
      按需加载，而不是要一开始就把这个模块加载进来。
      使用动态import：
        安装babel插件：
          npm i @babel/plugin-syntax-dynamic-import -D
        将这个插件添加到.babelrc配置文件的plugins中去
          {
            pulgins: ["@babel/plugin-syntax-dynamic-import"]
          }
        然后就可以在我们的代码中使用动态的import语法了。
          import('./text.js') // 返回的是promise对象
            .then(Text => {
              // Text就是import的这个文件export出去的内容
              console.log(Text)
            })
      代码分割的效果：
        使用了动态import的文件会分割出去一个js文件，当你代码用到的时候再异步的请求加载这个js文件。
      原理
        webpack使用jsonp的形式动态的添加一个<script>脚本进来。

11.在webpack中使用ESLint
eslint的必要性
  写js代码的时候将明显的问题及时的暴露出来，通过规范的一个检查，推荐使用eslint，eslint检查js是比较主流的做法。
行业里面优秀的eslint规范实践
  airbnb：eslint-config-airbnb eslint-config-airbnb-base
制定团队的eslint规范，遵循以下原则
  不重复造轮子，基于eslint:recommend配置去改进
  能够帮助发现代码错误的规则，全部开启 
  帮助保持团队的代码风格统一，而不是限制开发体验
eslint如何执行落地，常用的有两种方案
  1.和CI/CD系统集成
    把代码检查放在CI/CD的pipeline里面去 
    使用：
      本地开发阶段增加precommit钩子
      安装husky
        npm i husky -D
      增加npm script，通过lint-staged增量检查修改的文件，如果代码有语法问题会阻止你这次的提交
        "script": {
          "precommit": "lint-staged"
        },
        "lint-staged": {
          "linters": {
            "*.{js,scss}": ["eslint --fix", "git add"]
          }
        }
  2.和webpack等构建工具集成
    我们进行webpack构建的时候，如果遇见了eslint的语法问题，就直接中断构建，语法修改正确后才能构建成功。
    使用：
      比较适合新的项目，一开始就使用了eslint的项目。不适合老的项目去接入，因为这种方案，webpack构建的时候它会默认把所有的
      文件都会进行检查。
      使用eslint-loader，构建时检查js规范。
      module: {
        rules: [
          {
            test: /\.js$/,
            exclude: /node_modules/,
            use: {
              'babel-loader',
              'eslint-loader'
            }
          }
        ]
      }

12.webpack打包组件和基础库
webpack里面怎么去打包一个组件或一个库。
我们日常开发过程中，除了使用webpack去打包我们的业务项目之外，webpack还有其他的一些场景，比如通过webpack去打包一个组件，
去做server render，或者prerender等等场景。
对于打包组件或基础库，除了webpack，rollup更加适合打包组件和库，因为它打包相对webpack更加纯粹，使用更加简单。但是由于
webpack功能比较强大，使用webpack打包组件和库的场景还是很多的。
实际案例：实现一个大整数加法库的打包
  需要打包压缩版和非压缩版本。
  使用的时候支持AMD/CJS/ESM模块引入，也支持script标签方式引入。
库的目录结构和打包要求
  /dist
    large-number.js
    large-number.min.js
  webpack.config.js
  package.json
  index.js
  /src
    index.js
支持的模块使用方式
  支持ES module 
    import * as largeNumber from 'large-number'
    largeNumber.add('999', '1')
  支持CJS
    const largeNumber = require('large-number')
    largeNumber.add('999', '1')
  支持AMD
    require(['large-number'], function(large-number) {
      largeNumber.add('999', '1')
    })
  直接通过script引入，脚本发布到cdn上去
    <script src="https://unpkg.com/large-numer"></script>
    <script>
      largeNumber.add('999', '1')
    </script>
如何将库暴露出去
  打包组件和打包业务项目差别不大。打包组件的时候要针对output去额外设置一些内容，比如library libraryExport libraryTarget等
  library：指定库它暴露出去的库的名称，同时也可以通过全局变量的方式去引入到它。
  libraryTarget：支持库引入的方式，设置成umd就可以支持上述四种方式的引用。
  libraryExport：如果不设置成default，要通过largeNumber.default使用，不是很方便。
  module.exports = {
    entry: {
      'large-number': './src/index.js',
      'large-number.min': './src/index.js'
    },
    output: {
      filename: '[name].js',
      library: 'largeNumber',
      libraryTarget: 'umd',
      libraryExport: 'default'
    }
  }
如何只对.min压缩，通过include设置只压缩min.js结尾的文件
  optimization: {
    minimize: true,
    minimizer: [
      // 压缩js，遇到se6不会报错
      new TerserPlugin({
        include: /\.min\.js$/
      })
    ]
  }
设置入口文件
package.json的main字段为index.js
if (process.env.NODE_ENV === 'production') {
  module.exports = require('./dist/large-number.min.js')
} else {
  module.exports = require('./dist/large-number.js')
}
发布到npm上面去
  添加描述 "description": "大整数加法打包"
  增加npm script钩子，每次npm publish的时候会执行一下打包
    "scripts": {
      "test": "echo \"Error: no test specified\" && exit 1",
      "build": "webpack",
      "prepublish": "webpack"
    }
  登陆npm账号
    npm login
  发布
    npm publish

13.webpack实现SSR打包（上）/* todo */
14.webpack实现SSR打包（下）/* todo */
下节：在webpack里面怎么去做一个prerender这种场景，渲染骨架屏。/* todo 这个怎么没讲 */

15.优化构建时命令行的显示日志
构建的过程，命令行里面会有一大堆的信息打印出来，很多不需要开发者关注，开发者更加关注的是，构建是否成功，构建报错的信息，构建
warning的信息。对于构建成功的详细的信息，比如loader里输出的日志，插件的处理日志等并不是太需要关注的。
统计信息stats
  在webpack里用来输出统计的信息，通常可以分析一些构建速度或构建体积的时候，也可以到这个stats里分析一些数据出来。
  常见的stats有这些值。
    Preset	            Alternative	            Description
    "errors-only"           none              只在发生错误时输出
    "minimal"               none          只在发生错误或有新的编译时输出
    "none"                 false                  没有输出
    "normal"                true                  标准输出
    "verbose"               none                  全部输出
设置stats
  生产环境直接设置。
  开发环境如果用的是webpack-dev-server，就设置到这里面去。
命令行更加明显的提示信息
  使用friendly-errors-webpack-plugin，对于构建成功，警告，错误都有一个很明显的信息提示。
    success：构建成功的日志提示
    warning：构建警告的日志提示
    error：构建报错的日志提示
  有些框架或库会使用这个插件的
  stats设置成errors-only

16.构建异常和中断处理
在webpack里面怎么做错误的捕获和异常的处理。
如何判断构建是否成功？
  构建完之后，接下来要部署或做一些其他的操作比如代码的同步文件的同步等这些操作，这时候像CI/CD的系统或者发布系统它怎么知道这次
  构建是否成功呢。
  可以每次构建完之后输入一个 echo $? 获取错误码。如果错误码不为0的话，说明这次构建是失败的。也可以获取到error的信息。
webpack4之前构建失败不会抛出错误码。
webpack4给我们抛出了错误码，但是我们想针对异常的情况需要加额外的处理怎么做呢？
  1.每次捕获报错
  2.通过node.js中的process.exit规范去把错误码抛出来。这个规范也是尊从命令行里面的error
    0表示成功完成，回调函数中，err为null
    非0表示执行失败，回调函数中，err不为null，err.code就是传给exit的数字
如何主动捕获并处理构建错误？
  通过compiler这个对象，compiler在每次构建结束后会触发done这个hook，我们只要监听done这个hook，就可以对它进行额外的一些操作。
  比如数据上报相关的信息。错误信息可以通过stats获取到。
  plugins: [
    function() {
      this.hooks.done.tap('done', stats => {
        if (stats.compilation.errors && stats.compilation.errors.length && process.argv.indexOf('--watch') === -1) {
          console.log('build error')
          process.exit(1)
        }
      })
    }
  ]

第四章：编写可维护的webpack构建配置（进阶篇）
1.构建配置包设计
把之前的用法做到更加的通用，让我们其他的业务项目都能够用的上来，把构建包做到更加的通用。设计这个构建包的思路。
构建配置抽离成npm包的意义
  通用性
    业务开发者无需关注构建配置，创建好一个项目就可以马上使用把项目run起来，极大的提升开发效率
    统一团队构建脚本
  可维护性
    构建配置合理的拆分，做到更加的通用，后面维护也更加的方便，比如增加或修改一个新功能，能很方便的从构建包里找到相应的位置进行
    修改。如果把所有的配置放到一个文件里面，非常难改，改一个地方可能影响其他的环境配置。
    readme文档、ChangeLog文档，告诉开发者怎么使用这个构建包。
  构建质量
    冒烟测试、单元测试、测试覆盖率
    持续集成
构建配置管理的可选方案
  1.通过多个配置文件管理不同环境的构建，webpack --config参数进行控制
  2.将构建配置设计成一个库，用的时候直接使用这个库。比如hjs-webpack Neutrino webpack-blocks
  3.抽成一个工具进行管理，通过命令行工具来管理我们的构建配置。比如：create-react-app kyt nwb
  4.将所有的构建配置放到一个文件，通过--env参数控制分支选择。
构建配置包设计
  通过多个配置文件管理不同环境的webpack配置
    基础配置：webpack.base.js
    开发环境：webpack.dev.js
    生产环境：webpack.prod.js
    ssr环境：webpack.ssr.js
  抽离成一个npm包统一管理
    规范：要遵循这些规范 git commit 日志、readme、eslint规范、semver规范
    质量：需要我们的构建包有 冒烟测试、单元测试、测试覆盖率和CI 这些功能
    做好了规范和质量这两块，那基本上可以保证我们的构建配置它的长期的可维护性和质量保证。
  通过webpack merge组合配置
    比如我们的基础配置和开发配置有一些内容需要组合的情况下，如果使用数组的Array.prototype.concat或Object.assign这种组合
    起来会比较麻烦，webpack-merge的功能更加强大。
    const merge = require('webpack-merge')
    module.exports = merge(baseConfig, devConfig)

2.功能模块设计和目录结构
功能模块设计
  构建包功能设计
    基础配置：webpack.base.js
      资源解析
        解析es6
        解析react
        解析css
        解析less
        解析图片
        解析字体
      样式增强
        css前缀补齐
        css px转换成rem
      目录清理
      多页面打包
      命令行信息显示优化
      错误捕获和处理
      css提取成一个单独的文件
    开发阶段配置：webpack.dev.js
      代码热更新
        css热更新
        js热更新
      sourcemap
    生产阶段配置：webpack.prod.js
      代码压缩
      文件指纹
      tree shaking 
      scope hoisting
      速度优化
        基础包cdn
      体积优化
        代码分割
    ssr配置：webpack.ssr.js
      output的libraryTarget设置
      css解析ignore
目录结构设计
  目录结构的设计也是根据功能设计来制定的。
  test //测试代码，冒烟测试，单元测试
  lib // 包的源码
    webpack.base.js
    webpack.dev.js
    webpack.prod.js
    webpack.ssr.js
  README.md
  CHANGELOG.md
  .eslintrc.js
  package.json
  index.js // 入口文件

3.使用ESLint规范构建脚本
使用eslint-config-airbnb-base
eslint --fix 可以自动处理空格
.eslintrc.js
  module.exports = {
    "parser": "babel-eslint",
    "extends": "airbnb-base",
    "env": {
      "browser": true,
      "node": true
    }
  }

4.冒烟测试介绍和实际运用
冒烟测试是指对提交测试的软件在进行详细深入的测试之前而进行的预测试，就是软件开发人员在提交测试之前，会自己检查一下基本的功能
是否可用，这种预测试的主要目的是暴露导致软件需要重新发布的基本功能失效等严重问题。
构建配置包我们冒烟测试需要做什么事情呢？
  构建是否成功
  每次构建完成的build目录是否有内容输出
    是否有js css等静态资源文件
    是否有html文件
测试的这个步骤，如果每次发版之前，自己去找一个项目手动的去运行，这个是比较繁琐的
  所以我们也是通过一些测试工具去运行上面的步骤，每次发版之前运行一下npm run test，它会先把这个构建包进行webpack打包，看看
  是否有报错，同时生成一些产物，如果这两步都是ok的，那就说明我们这一次冒烟测试进行的是比较顺利的。
判断构建是否成功
  在事例项目里面运行构建，看看是否有报错。
  将我们编写的webpack配置传给webpack函数，webpack函数执行这个功能，执行完之后，在它的回调函数里面有一个err和stats，err
  是单次构建有没有报错，有报错说明我们这次构建是不成功的，没有报错说明这次构建没问题，没有问题我们可以把基本的一些统计信息输出
  出来，比如构建的速度，相关的构建资源列表等。
  const prodConfig = require('./webpack.prod.js')
  webpack(prodConfig, (err, stats) => {
    if (err) {
      console.error(err)
      process.exit(2)
    }
    console.log(stats.toString({
      colors: true,
      modules: false,
      children: false,
      chunks: false,
      chunkModules: false
    }))
  })
判断基本功能是否正常
  借助单元测试工具
  编写mocha测试用例
    是否有js css等静态资源文件
    是否有html文件
  判断有无这些文件的测试用例跑的没问题，那就说明我们的基本功能也是ok的。

5.单元测试和测试覆盖率
冒烟测试保证了构建包的基本功能可用，更加细节的部分怎么保证呢，这时候就需要单元测试。
市面上，比较流行的单元测试的方式。
  单纯的测试框架，需要断言库
    测试框架：mocha, ava
    断言库：.chai .should.js .expect .bsetter-assert
  集成框架，开箱即用
    jasmine jest
  极简API
编写单元测试用例
  技术选型：mocha + chai
  测试代码：describe it except
  测试命令：mocha add.test.js
  add.test.js 
    const expect = require('chai').expect
    const add = require('../src/add')
    describe('use expect: src/add.js', () => {
      it('add(1, 2) === 3', () => {
        expect(add(1, 2).to.equal(3))
      })
    })
单元测试接入
  1.安装mocha + chai
    npm i mocha chai -D
  2.新建test目录，并增加xxx.test.js测试文件
  3.在package.json中的scripts字段增加test命令
    "scripts": {
      "test": "./node_modules/.bin/_mocha"
    }
  4.执行测试命令
    npm run test
测试覆盖率
  推荐使用gotwarlost/istanbul
  安装npm i istanbul -D
  使用istanbul cover test.js

6.持续集成和Travis CI
每次发布版本之前都应该有持续集成的功能，看我们的的单元测试用例是否正常跑过，跑过的代码才能合入到主干里面来。
持续集成的作用
  优点：
    快速发现错误
      每次git commit的时候都会自动的去持续集成，如果这次提交对功能有影响，可以通过持续集成的方式快速的告诉你这次提交的代码
      是有问题的，你就可以及时的修复这个问题。
    防止分支大幅偏离主干
      有时主干处于快速更新的状态
    持续集成能让我们的产品快速迭代，同时保证质量
    核心措施是，代码集成到主干之前，必须通过自动化测试，只要有一个测试用例失败，就不能集成。
github最流行的CI
接入Travis CI
  1.https://trivis-ci.org/ 使用github账号登录
  2.在https://trivis-ci.org/account/repositories 为项目开启权限
  3.项目根目录下新增.travis.yml配置文件 
    每次git commit的时候会自动的触发CI的功能，它会运行这个配置文件中定义的脚本 
.travis.yml文件内容
  language: node_js
  sudo: false
  cache:
    apt: true
    directories:
      - node_modules
  node_js: stable # 设置相应的版本
  install:
    - npm install -D # 安装构建器依赖
    - cd ./test/template-project
    - npm install -D # 安装模版项目依赖
  script:
    -npm test
实际项目接入travis CI的流程
  1.在githb中创建一个项目
  2.在travis-ci中激活该项目，这时我们的项目就接入travis-ci了。
  3.clone项目
  4.把之前构建包的代码挪过来
  5.项目根目录下新增.travis.yml配置文件 
  6.上传代码

7.发布构建包到npm社区
发布npm 
先到npm搜索要发布的包名有没有被别人用到
添加用户：npm adduser
登录npm账户：npm login
升级版本：
  升级补丁版本号：npm version patch
  升级小版本号：npm version minor
  升级大版本号：npm version major
  升级版本前需要提交git
  运行相应的命令会自动的帮你更新对应的版本号。它会自动帮你git提交一次版本号的更新。
  每次发布版本之前需要打个git tag：git tap v1.0.1。运行npm version它也会自动的帮你打这个tag 
  提交远程：git push origin master
生成这个包当前版本的changelog
发布版本：npm publish

8.Git Commit规范和changelog生成
基础包良好的commit规范有助于我们后续维护代码
良好的git commit规范优势：
  加快code review的流程
  根据规范的git commit的元数据可以快速的生成changelog文档，这样就避免手动的编写changelog消耗的时间。
  后续维护者可以知道feature被修改的原因
技术方案
  git commit提交格式
    统一团队git commit日志标准，便于后续代码review和版本发布
    使用angular的git commit日志作为基本规范
      提交类型限制为：feat,fix,docs,style,refactor,pref,test,chore,revert等
      提交信息分为两部分，标题（首字母不大写，末尾不要标点）、主体内容（正常的描述信息即可）
    日志提交时友好的类型选择提示
      commitize工具
    不符合要求格式的日志拒绝提交的保障机制
      使用vilidate-commit-msg工具
      需要同时在客户端、git server hook做
    统一changelog文档信息生成
      使用conventional-changelog-cli工具
提交格式要求
<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>
格式说明如下：
共有三块内容：commit的头部，body内容，提交的尾部
  头部：
    type: 代表某次提交的类型
      feat: 新增特性
      fix: 修改bug
      docs: 文档修改
      style: 代码格式修改，空格、缩进、逗号等，不改变代码逻辑
      refactor: 代码重构，没有增加新功能feature或修复bug
      pref: 优化相关，如性能提升，体验优化等
      test: 测试用例修改，包括单元测试，集成测试等
      chore: 改变构建流程，或增加依赖库、工具等
      revert: 回滚到上一个版本
    scope: 作用域, commit影响的范围, 比如: route, component, utils, build...
    subject: commit的概述, 目的的简短描述, 建议符合 50/72 formatting
  内容：
    正常情况下写这个头部就已经符合一个标注的git commit规范的要求。不过有时候某一次提交可能影响很大，或做的事情很多，这时通过
    subject还不能很好的描述这一次提交做的事情，这时候可以在body里面分为几行去写，做了什么事情都可以详细的写在这里。
    body: commit 具体修改内容, 可以分为多行, 建议符合 50/72 formatting
  尾部：
    比如这次提交是修复了一个bug，可以贴上bug单的链接。或者修复一个issue，可以贴上issue的链接，把issue close掉。
    footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接。
有这个规范还是不够的。
本地开发阶段增加precommit钩子
  对于git commit的信息也是需要通过一个工具来让git commit的规则能够很好的运作起来。
  安装husky
    npm i husky -D
  通过commitmsg钩子校验信息
    npm i vilidate-commit-msg conventional-changelog-cli -D
    "scripts": {
      "commitmsg": "vilidate-commit-msg",
      "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0"
    }
    vilidate-commit-msg也是尊从angularjs提交规范
    每次git commit的时候，就会通过vilidate-commit-msg去检查这一次提交git的格式，如果是符合规范的，它就会允许你提交上去，
    不符合规范，就会提交失败。
    每次发布版本的时候可以运行changelog这个命令，可以很方便的生成一个changelog文档出来，这个版本信息就会全部的生成出来，包
    括两块内容，一个是bugfix，对应于fix；一个是feature，对应于feat。

9.语义化版本（Semantic Versioning）规范格式
开源项目版本信息案例（react）
  软件的版本通常由三位组成，形如：X.Y.Z
  版本是严格递增的，此处是：16.2.0 -> 16.3.0 -> 16.3.1
  在发布重要版本时，可以发布alpha，beta，rc等先行版本
遵守semver规范的优势
  semver规范是github提出来，当时也是为了解决软件开发领域里面依赖地狱的问题，主要是用来规范依赖的软件包，在日常的开发过程中，
  会依赖各种各样的依赖，这个依赖它也会依赖其他的依赖，这是就很容易形成一个依赖地狱，如果一旦依赖的版本号，没有一个很好的规范，
  很容易出现一些循环依赖，或者依赖之间会有一些冲突，尊从semver这个规范就能避免这个问题。
  优势：
    避免出现循环依赖
    依赖冲入减少
语义化版本（Semantic Versioning）规范格式
  主版本号：当你做了不兼容的API修改
  次版本号：当你做了向下兼容的功能性新增
  修订号：当你做了向下兼容的问题修复
先行版本号
  先行版本号可以作为发布正式版之前的版本，格式是在修订版本号后面加上一个连接号（-），再加上一连串以点（.）分割的标识符，标识符
  可以由英文数字和连接号（[0-9A-Za-z-]）组成。
  alpha：是内部测试版，一般不向外发布，会有很多bug。一般只有测试人员使用。
  beta：是外部小范围的测试版，这个阶段的版本会一直加入新的功能。在alhpa版之后推出。
  rc：Release Candidate，公测，系统平台上就是发行候选版本。rc版不会再加入新的功能，主要着重于除错。

第五章：webpack构建速度和体积优化策略
在webpack里面怎么分析构建速度和构建体积
1.初级分析：使用webpack内置的stats
stats：构建的统计信息
  利用webpack内置的stats对象
    它可以帮我们分析基本的一些信息，比如构建总共的时间，构建资源的大小
    package.json中使用stats
      指定输出的是一个json对象，生成一个json文件
      "scripts": {
        "build:stats": "webpack --config webpack.prod.js --json > stats.json"
      }
  node.js中使用
    const webpack = require('webpack')
    const config = require('./webpack.config.js')('production')
    webpack(config, (err, stats) => {
      if (err) {
        return console.error(err)
      }
      if (stats.hasErrors()) {
        return console.error(stats.toString('errors-only'))
      }
      console.log(stats)
    })
  这两种方式颗粒度太粗，看不出问题所在。想要分析实际的问题，比如哪个组件比较大，哪个loader耗的时间比较长，是无法很好的分析出来的。

2.速度分析：使用speed-measure-webpack-plugin
更好的分析webpack构建的速度，怎么找出构建速度问题所在。
使用speed-measure-webpack-plugin
  可以看到每个loader和插件执行耗时，就可以重点的关注耗时较长的loader或插件，针对这些做优化
  const SpeedMeatureWebpackPlugin = require('speed-measure-webpack-plugin')
  const smp = new SpeedMeatureWebpackPlugin()
  const webpackConfig = smp.wrap({
    plugins: [
      new MyPlugin(),
      new MyOtherPlugin()
    ]
  })
速度分析插件作用
  分析整个打包总耗时
  每个loader和插件的耗时情况

3.体积分析：使用webpack-bundle-analyzer
更好的分析项目打包出来的体积的问题所在
使用webpack-bundle-analyzer分析体积
  我们发现打包出来的体积很大，就可以利用这个工具来分析项目的问题出现在哪里。
  它可以把我们的项目打包出来的文件会进行一个分析，能很方便的看出体积的大小。面积越大体积越大，我们可以重点关注这些进行优化。
  const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
  plugins: [
    new BundleAnalyzerPlugin()
  ]
  构建完成后会在8888端口展示体积大小
可以分析哪些问题
  可以很好的分析依赖的第三方模块文件的大小
  也可以分析出我们自己写的业务的组件代码图片大小，针对大的js可以做js的按需加载等优化操作。
增加babel-polyfill试验大的第三方模块的情况

4.使用高版本的webpack和Node.js
在webpack里做速度的优化
使用高版本的wepback和node.js
  在软件这一块，性能往往不是最大的问题，软件不断的迭代过程中，可以不断的提升这个性能，对于构建而言同样是适用的，所以推荐采用
  高版本的webpack和node.js。
使用webpack4：优化原因
  V8带来的优化，V8 6.0的版本带来了大量的优化，很多对原生方法的优化（for of代替forEach、Map和Set代替Object、includes代替indexOf）
  默认使用更快的md4的 hash算法
  webpacks AST可以直接从loader传递给AST，减少解析时间
  使用字符串的方法替代正则表达式
高版本的node.js对原生的js API或js的数据结构是有做一些优化的，因此推荐采用更高版本的node.js
  测试脚本
    验证高版本node.js比低版本node.js性能更快，针对相同的api、相同的代码做比较
      map-performance.js 
    includes和indexOf的性能差异
      compare-includes-indexOf.js

5.多进程/多实例构建
多进程/多实例构建：资源并行解析可选方案
  HappyPack
  thread-loader
  parallel-webpack
多进程/多实例：使用HappyPack解析资源
  原理：每次webpack解析一个模块，HappyPack会将它及它的依赖分配给worker线程中。
  每次webpack解析一个模块，一个进程webpack自身去解析这个模块。HappyPack会将这个模块进行一个划分，比如有多个模块，在
  webpack compiler run方法之后，然后到达HappyPack，它会做一些初始化，创建一个线程池，线程池会将构建任务里面的模块进行分配
  ，比如会将某个模块以及它的依赖分配给HappyPack其中的一个线程，以此类推，那么一个HappyPack的线程池可能会包括多个线程，这些
  线程会各自的处理这些模块以及它的依赖。处理完成之后，会有一个通信的过程，会将处理好的资源传输给HappyPack的主进程，完成整个构
  建的过程。
  plugins: [
    new HappyPack({
      id: 'jsx',
      threads: 4,
      loaders: ['babel-loader']
    }),
    new HappyPack({
      id: 'styles',
      threads: 2,
      loaders: ['style-loader', 'css-loader', 'less-loader']
    })
  ]
多进程/多实例：使用thread-loader解析资源
  webpack4.0原生的提供了thread-loader这个模块，它可以很好的替换HappyPack，来做多进程/多实例的工作。
  原理：跟HappyPack是差不多的。每次webpack解析一个模块，thread-loader会将它及它的依赖分配给worker线程中。
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'thread-loader',
            options: {
              workers: 3
            }
          },
          'babel-loader'
        ]
      }
    ]
  }
  在我们的loader之前放上thread-loader，做一系列的解析，最后会通过thread-loader进行处理。

6.多进程/多实例并行压缩代码
多进程/多实例：并行压缩
上节提到在构建的时候，可以对模块的解析采用多进程多实例的方式去做。同样的，在代码解析完成之后，在做最后的代码输出之前，它有个压缩
阶段，对于代码压缩我们也是可以通过同样的思路，就是通过多进程多实例的并行的压缩代码，来达到我们优化构建速度的目的。
方法一：使用parallel-uglify-plugin插件
  plugins: [
    new ParallelUglifyPluging({
      uglifyJS: {
        output: {
          beautify: false,
          comments: false
        },
        compress: {
          warning: false,
          drop_console: true,
          collapse_vars: true,
          reduce_vars: true
        }
      }
    })
  ]
方法二：uglifyjs-webpack-plugin开启parallel参数（webpack3推荐采用的插件）（不支持es6代码的压缩）
  plugins: [
    new UglifyjsWebpackPlugin({
      uglifyOptions: {
        warnings: false,
        parse: {},
        compress: {},
        mangle: true,
        output: null,
        tiplevel: false,
        nameCache: null,
        ie8: false,
        keep_fnames: false
      },
      parallel: true
    })
  ]
方法三：terser-webpack-plugin开启parallel参数（webpack4默认使用的）（支持es6代码的压缩）
  module.exports = {
    optimization: {
      minimize: true,
      minimizer: [
        new TerserPlugin({
          parallel: true
        })
      ]
    }
  }

7.进一步分包：预编译资源模块
分包：设置Externals（第三章讲过的）
  思路：将react, react-dom基础包通过cdn引入，不打入bundle中。
  方法：使用html-webpack-externals-plugin
  缺点：一个基础库需要指定一个cdn，实际的项目中有很多包，需要引入的script标签太多 。
通过split-chunks-plugin插件分离基础包，它每次还是会对基础包进行分析。
分包来说，更好的方式就是
进一步分包：预编译资源模块
  思路：将react、react-dom、redux、react-redux基础包和业务基础包打包成一个文件。
  方法：使用webpack里面官方内置的插件DLLPlugin进行分包，DLLReferencePlugin对manifest.json引用，这个文件是对分离出来
  的包的描述。然后我们在实际的webpack配置里面可以通过DLLReferencePlugin去引用通过DLLPlugin分离出来的包，引用的时候应用
  manifest.json就可以了，引用后它就会自动的去关联DLLPlugin里面的包。
  使用DLLPlugin进行分包
    需要创建一个单独的构建配置文件，一般会命名为webpack.ddl.js，DLLPlugin也会提高打包的速度。
  使用DLLReferencePlugin引用manifest.json
    在webpack.config.js中引入
      module.exports = {
        plugins: [
          new webpack.DLLReferencePlugin({
            manifest: require('./build/library/manifest.json')
          })
        ]
      }

8.充分利用缓存提升二次构建速度
缓存
目的：提升二次构建速度
缓存思路：
  babel-loader开启缓存
  terser-webpack-plugin开启缓存
  使用cache-loader或者hard-source-webpack-plugin
    针对模块的缓存的开启
有缓存的话node_modules下面会有一个cache目录

9.缩小构建目标
缩小构建目标
  目的：尽可能的减少构建模块
  比如babel-loader不解析node_modules
    module: {
      rules: [
        {
          test: /\.js$/,
          use: 'babel-loader',
          exclude: 'node_modules'
        }
      ]
    }
减少文件搜索范围  
  优化resolve.modules配置（减少模块搜索层级）
    resolve.modules是模块解析的过程，webpack解析时，模块的查找过程和nodejs的模块查找是比较类似的，会从当前的项目找，没
    找到会去找node_modules。会依次去子目录找模块是否存在。
  优化resolve.mainFields配置
    找入口文件的时候，它会根据package.json里面的main字段查找，因为我们发布到npm的组件的package.json会遵守一定的规范，
    都会有main这个字段，我们可以设置查找的时候直接读取main这个字段，这样也减少一些不必要的分析的过程。比如package.json
    里面没有这个main，那它再去读取根项目下的index.js，没有再去找lib下面的index.js，这就是它默认的查找过程，我们这里把
    这个默认的查找过程链路做一个优化，我们只找package.json中main字段指定的入口文件。
  优化resolve.extensions配置
    模块路径的查找，比如import一个文件，没有写后缀，webpack会先去找.js，没有会找.json，默认情况下webpack只支持js和json
    的读取。extensions数组里可以再设置其他的文件，如.jsx .vue .ts等。不过这个数组里面的内容越多的话，查找消耗的时间也会
    越多，因此我们可以缩小extensions查找的范围，比如只设置查找.js，其他文件需要你写的时候写全文件后缀。避免webpack做不必要
    的查找。
  合理使用alias
    别名，简短的缩写。比如模块的路径，我们找react，它可能找了一圈，最后肯定是会找到node_modules里面去，它会经历一系列的
    查找过程，我们可以把这一系列的过程直接给它写好，告诉它比如你遇到了react，就直接从指定的这个路径去找。这个也大大的缩短
    了查找的时间。
  module.exports = {
    // 子模块的查找策略
    resolve: {
      alias: {
        'react': path.resolve(__dirname, './node_modules/react/umd/react.production.min.js'),
        'react-dom': path.resolve(__dirname, './node_modules/react-dom/umd/react-dom.production.min.js')
      },
      modules: [path.resolve(__dirname, 'node_modules')],
      extensions: ['.js'],
      mainFields: ['main']
    }
  }

10.使用Tree Shaking擦除无用的JavaScript和CSS
无用的css如何删除掉？
  PurifyCSS：遍历代码，识别已经用到的css class
  uncss：要求HTML需要通过jsdom加载，所有的样式通过PostCSS解析，通过document.querySelector来识别在html文件里面不存在的
         选择器。
在webpack中如何使用PurifyCSS？
  使用purgecss-webpack-plugin，它不能独立的去使用，而是需要提取css为一个文件后才能使用。在webpack4里面需要和
  mini-css-extract-plugin配合使用，在webpack3里面需要和extract-text-webpack-plugin配合使用。
  new PurgecssWebpackPlugin({
    paths: 
  })

11.使用webpack进行图片压缩
图片资源相对是较大的，我们可以通过在线工具手动进行图片的批量压缩。构建工具一部分的职责就是将平时我们手动完成的事做成自动化。
图片压缩
  要求：基于node库的imagemin或者tinypng API做图片压缩。
  使用：配置image-webpack-loader
imagemin的优点分析
  有很多定制的选项
  可以引入更多第三方优化插件，例如pngquant
  可以处理多种图片格式
imagemin的压缩原理
https://unsplash.com/ 无版图片库

12.使用动态Polyfill服务
构建体积优化：动态polyfill
方案
  babel-polyfill
  babel-plugin-transform-runtime
  自己写polyfill
  polyfil service
polyfil service原理
  识别ua，下发不同的polyfill
使用polyfil service
  polyfill.io官方提供的服务
    https://polyfill.io/v3/polyfill.min.js
  基于官方自建polyfill服务
    //huayang.qq.com/polyfill/v3/polyfill.min.js?unknown=polyfill&features=Promise,Map,Set
体积优化策略总结：
  Scope Hoisting
  Tree Shaking
  公共资源分离
  图片压缩
  动态polyfill

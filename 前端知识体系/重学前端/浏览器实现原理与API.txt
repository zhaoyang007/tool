1.浏览器：一个浏览器是如何工作的？（阶段一）
  1.对于前端开发来说，我们平时与浏览器打交道的时间是最多的。可浏览器对前端同学来说更多像一个神秘黑盒子的存在。我们仅仅知道它
    能做什么，而不知道它是如何做到的。
  2.在我面试和接触过的前端开发者中，70% 的前端同学对这部分的知识内容只能达到“一知半解”的程度。甚至还有一部分同学会质疑这部分
    知识是否重要：这与我们的工作相关吗，学多了会不会偏移前端工作的方向？
  3.事实上，我们这里所需要了解的浏览器工作原理只是它的大致过程，这部分浏览器工作原理不但是前端面试的常考知识点，它还会辅助你的
    实际工作，学习浏览器的内部工作原理和个中缘由，对于我们做性能优化、排查错误都有很大的好处。
  4.在我们的课程中，我也会控制浏览器相关知识的粒度，把它保持在“给前端工程师了解浏览器”的水准，而不是详细到“给浏览器开发工程师
    实现浏览器”的水准。
  5.那么，我们今天开始，来共同思考一下。一个浏览器到底是如何工作的。
  6.实际上，对浏览器的实现者来说，他们做的事情，就是把一个 URL 变成一个屏幕上显示的网页。
  7.这个过程是这样的：
    1.浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；
    2.把请求回来的 HTML 代码经过解析，构建成 DOM 树；
    3.计算 DOM 树上的 CSS 属性；
    4.最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；
    5.一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；
    6.合成之后，再绘制到界面上。
      浏览器工作原理.jpg
    7.我们在开始详细介绍之前，要建立一个感性认识。我们从 HTTP 请求回来开始，这个过程并非一般想象中的一步做完再做下一步，而是
      一条流水线。
    8.从 HTTP 请求回来，就产生了流式的数据，后续的 DOM 树构建、CSS 计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出：
      即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。
    9.首先我们来介绍下网络通讯的部分。
  8.HTTP 协议
    1.浏览器首先要做的事就是根据 URL 把数据取回来，取回数据使用的是 HTTP 协议，实际上这个过程之前还有 DNS 查询，不过这里就
      不详细展开了。
    2.我先来了解下 HTTP 的标准。
    3.HTTP 标准由 IETF 组织制定，跟它相关的标准主要有两份：
      HTTP1.1 https://tools.ietf.org/html/rfc2616
      HTTP1.1 https://tools.ietf.org/html/rfc7234
    4.HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 
      Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。
    5.大部分情况下，浏览器的实现者只需要用一个 TCP 库，甚至一个现成的 HTTP 库就可以搞定浏览器的网络通讯部分。HTTP 是纯粹的
      文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。
    6.下面，我们试着用一个纯粹的 TCP 客户端来手工实现 HTTP 一下：
  9.实验
    1.我们的实验需要使用 telnet 客户端，这个客户端是一个纯粹的 TCP 连接工具（安装方法）。
    2.首先我们运行 telnet，连接到极客时间主机，在命令行里输入以下内容：
      telnet time.geekbang.org 80
    3.这个时候，TCP 连接已经建立，我们输入以下字符作为请求：
      GET / HTTP/1.1
      Host: time.geekbang.org
    4.按下两次回车，我们收到了服务端的回复：
      HTTP/1.1 301 Moved Permanently
      Date: Fri, 25 Jan 2019 13:28:12 GMT
      Content-Type: text/html
      Content-Length: 182
      Connection: keep-alive
      Location: https://time.geekbang.org/
      Strict-Transport-Security: max-age=15768000

      <html>
      <head><title>301 Moved Permanently</title></head>
      <body bgcolor="white">
      <center><h1>301 Moved Permanently</h1></center>
      <hr><center>openresty</center>
      </body>
      </html>
    5.这就是一次完整的 HTTP 请求的过程了，我们可以看到，在 TCP 通道中传输的，完全是文本。
    6.在请求部分，第一行被称作 request line，它分为三个部分，HTTP Method，也就是请求的“方法”，请求的路径和请求的协议和
      版本。
    7.在响应部分，第一行被称作 response line，它也分为三个部分，协议和版本、状态码和状态文本。
    8.紧随在 request line 或者 response line 之后，是请求头 / 响应头，这些头由若干行组成，每行是用冒号分隔的名称和值。
    9.在头之后，以一个空行（两个换行符）为分隔，是请求体 / 响应体，请求体可能包含文件或者表单数据，响应体则是 HTML 代码。
  10.HTTP 协议格式
    1.根据上面的分析，我们可以知道 HTTP 协议，大概可以划分成如下部分。
      http协议格式.jpg
    2.我们简单看一下，在这些部分中，path 是请求的路径完全由服务端来定义，没有很多的特别内容；而 version 几乎都是固定字符串；
      response body 是我们最熟悉的 HTML，我在后面会有专门的课程介绍，这里也就不多讲了。
    3.下面我们就来逐个给你介绍其它部分。
  11.HTTP Method（方法）
    1.我们首先来介绍一下 request line 里面的方法部分。这里的方法跟我们编程中的方法意义类似，表示我们此次 HTTP 请求希望执行的
      操作类型。方法有以下几种定义：
      GET
      POST
      HEAD
      PUT
      DELETE
      CONNECT
      OPTIONS
      TRACE
    2.浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法。
    3.HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起
    4.PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。
    5.CONNECT 现在多用于 HTTPS 和 WebSocket。
    6.OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。
  12.HTTP Status code（状态码）和 Status text（状态文本）
    1.接下来我们看看 response line 的状态码和状态文本。常见的状态码有以下几种。
      1xx：临时回应，表示客户端请继续。
      2xx：请求成功。
        200：请求成功。
      3xx: 表示请求的目标有变化，希望客户端进一步处理。
        301&302：永久性与临时性跳转。
        304：跟客户端缓存没有更新。
      4xx：客户端请求错误。
        403：无权限。
        404：表示请求的页面不存在。
        418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议）
      5xx：服务端请求错误。
        500：服务端错误。
        503：服务端暂时性错误，可以一会再试。
    2.对我们前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 HTTP 库直接处理掉了，不会让上层应用知晓。
    3.2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。
    4.3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 
      更接近于一种报错，提示客户端下次别来了。
    5.304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，
      当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。
  13.HTTP Head (HTTP 头)
    1.HTTP 头可以看作一个键值对。原则上，HTTP 头也是一种数据，我们可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一
      些特殊的 HTTP 头，我们现在就来了解一下它们。
    2.在 HTTP 标准中，有完整的请求 / 响应头规定，这里我们挑几个重点的说一下：
    3.我们先来看看 Request Header。
      httpRequestHeader.png
    4.接下来看一下 Response Header。
      httpResponseHeader.png
    5.这里仅仅列出了我认为比较常见的 HTTP 头，这些头是我认为前端工程师应该做到不需要查阅，看到就可以知道意思的 HTTP 头。完
      整的列表还是请你参考我给出的 rfc2616 标准。
  14.HTTP Request Body
    1.HTTP 请求的 body 主要用于提交表单场景。实际上，HTTP 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就
      可以了。一些常见的 body 格式是：
      application/json
      application/x-www-form-urlencoded
      multipart/form-data
      text/xml
    2.我们使用 HTML 的 form 标签提交产生的 HTML 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有
      文件上传时，则会使用 multipart/form-data。
  15.HTTPS
    1.在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 
      Request-Response 模式。
    2.我们首先来了解下 HTTPS。HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者
      篡改。
    3.HTTPS 的标准也是由 RFC 规定的，你可以查看它的详情链接：
      https://tools.ietf.org/html/rfc2818
    4.HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它
      实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。
  16.HTTP 2
    1.HTTP 2 是 HTTP 1.1 的升级版本，你可以查看它的详情链接。
      https://tools.ietf.org/html/rfc7540
    2.HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用。
    3.服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来  
      的并行度不高，从而导致的性能问题。
    4.TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输
      窗口小的问题。
    5.Note: 其实很多优化涉及更下层的协议。IP 层的分包情况，和物理层的建连时间是需要被考虑的。
  17.结语
    1.在这一节内容中，我们一起学习了浏览器的第一步工作，也就是“浏览器首先使用 HTTP 协议或 HTTPS 协议，向服务端请求页面”的
      这一过程。
    2.在这个过程中，掌握 HTTP 协议是重中之重。我从一个小实验开始，带你体验了一次完整的 HTTP 请求过程。我们一起先分析了 HTTP 
      协议的结构。接下来，我分别介绍了 HTTP 方法、HTTP 状态码和状态文本、HTTP Head 和 HTTP Request Body 几个重点需要注
      意的部分。
    3.最后，我还介绍了 HTTPS 和 HTTP 2 这两个补充版本，以便你可以更好地熟悉并理解新的特性。
    4.你在工作中，是否已经开始使用 HTTPS 和 HTTP 2 协议了呢？用到了它们的哪些特性，请留言告诉我吧。
2.浏览器：一个浏览器是如何工作的？（阶段二）
  1.你好，我是 winter，今天我们继续来看浏览器的相关内容。
  2.我在上一篇文章中，简要介绍了浏览器的工作大致可以分为 6 个阶段，我们昨天讲完了第一个阶段，也就是通讯的部分：浏览器使用 HTTP 
    协议或者 HTTPS 协议，向服务端请求页面的过程。
  3.今天我们主要来看两个过程：如何解析请求回来的 HTML 代码，DOM 树又是如何构建的。
    解析HTML代码DOM树构建.png
  4.解析代码
    1.我们在前面讲到了 HTTP 的构成，但是我们有一部分没有详细讲解，那就是 Response 的 body 部分，这正是因为 HTTP 的 
      Response 的 body，就要交给我们今天学习的内容去处理了。
    2.HTML 的结构不算太复杂，我们日常开发需要的 90% 的“词”（指编译原理的术语 token，表示最小的有意义的单元），种类大约只有
      标签开始、属性、标签结束、注释、CDATA 节点几种。
    3.实际上有点麻烦的是，由于 HTML 跟 SGML 的千丝万缕的联系，我们需要做不少容错处理。“<?”和“<%”什么的也是必须要支持好的，
      报了错也不能吭声。
  5. 1. 词（token）是如何被拆分的
    1.首先我们来看看一个非常标准的标签，会被如何拆分：
      <p class="a">text text text</p>
    2.如果我们从最小有意义单元的定义来拆分，第一个词（token）是什么呢？显然，作为一个词（token），整个 p 标签肯定是过大了
      （它甚至可以嵌套）。
    3.那么，只用 p 标签的开头是不是合适吗？我们考虑到起始标签也是会包含属性的，最小的意义单元其实是“<p“，所以“<p”就是我们的
      第一个词（token）。
    4.我们继续拆分，可以把这段代码依次拆成词（token）：
      <p “标签开始”的开始；
      class=“a” 属性；
      > “标签开始”的结束；
      text text text 文本；
      </p> 标签结束。
    5.这是一段最简单的例子，类似的还有什么呢？现在我们可以来来看看这些词（token）长成啥样子：
      解析代码词token.png
    6.根据这样的分析，现在我们讲讲浏览器是如何用代码实现，我们设想，代码开始从 HTTP 协议收到的字符流读取字符。
    7.在接受第一个字符之前，我们完全无法判断这是哪一个词（token），不过，随着我们接受的字符越来越多，拼出其他的内容可能性就
      越来越少。
    8.比如，假设我们接受了一个字符“ < ” 我们一下子就知道这不是一个文本节点啦。
    9.之后我们再读一个字符，比如就是 x，那么我们一下子就知道这不是注释和 CDATA 了，接下来我们就一直读，直到遇到“>”或者空格，
      这样就得到了一个完整的词（token）了。
    10.实际上，我们每读入一个字符，其实都要做一次决策，而且这些决定是跟“当前状态”有关的。在这样的条件下，浏览器工程师要想实现
      把字符流解析成词（token），最常见的方案就是使用状态机。
  6. 2. 状态机
    1.绝大多数语言的词法部分都是用状态机实现的。那么我们来把部分词（token）的解析画成一个状态机看看： 
      词的解析状态机.png
    2.当然了，我们这里的分析比较粗略，真正完整的 HTML 词法状态机，比我们描述的要复杂的多。更详细的内容，你可以参考HTML 官方
      文档https://html.spec.whatwg.org/multipage/parsing.html#tokenization，HTML 官方文档规定了 80 个状态
      （顺便一说，HTML 是我见过唯一一个标准中规定了状态机实现的语言，对大部分语言来说，状态机是一种实现而非定义）。
    3.这里我们为了理解原理，用这个简单的状态机就足够说明问题了。
    4.状态机的初始状态，我们仅仅区分 “< ”和 “非 <”：
      如果获得的是一个非 < 字符，那么可以认为进入了一个文本节点；
      如果获得的是一个 < 字符，那么进入一个标签状态。
    5.不过当我们在标签状态时，则会面临着一些可能性。
      比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。
      如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。
      如果下一个字符是字母，那么可以确定进入了一个开始标签。
      如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。
    6.我们可以看到，用状态机做词法分析，其实正是把每个词的“特征字符”逐个拆开成独立状态，然后再把所有词的特征字符链合并起来，
      形成一个联通图结构。
    7.由于状态机设计属于编译原理的基本知识，这里我们仅作一个简要的介绍。
    8.接下来就是代码实现的事情了，在 C/C++ 和 JavaScript 中，实现状态机的方式大同小异：我们把每个函数当做一个状态，参数是
      接受的字符，返回值是下一个状态函数。（这里我希望再次强调下，状态机真的是一种没有办法封装的东西，所以我们永远不要试图封
      装状态机。）
    9.为了方便理解和试验，我们这里用 JavaScript 来讲解，图上的 data 状态大概就像下面这样的：
      var data = function(c){
          if(c=="&") {
              return characterReferenceInData;
          }
          if(c=="<") {
              return tagOpen;
          }
          else if(c=="\0") {
              error();
              emitToken(c);
              return data;
          }
          else if(c==EOF) {
              emitToken(EOF);
              return data;
          }
          else {
              emitToken(c);
              return data;
          }
      };
      var tagOpenState = function tagOpenState(c){
          if(c=="/") {
              return endTagOpenState;
          }
          if(c.match(/[A-Z]/)) {
              token = new StartTagToken();
              token.name = c.toLowerCase();
              return tagNameState;
          }
          if(c.match(/[a-z]/)) {
              token = new StartTagToken();
              token.name = c;
              return tagNameState;
          }
          if(c=="?") {
              return bogusCommentState;
          }
          else {
              error();
              return dataState;
          }
      };
      //……
    10.这段代码给出了状态机的两个状态示例：data 即为初始状态，tagOpenState 是接受了一个“ < ” 字符，来判断标签类型的状态。
    11.这里的状态机，每一个状态是一个函数，通过“if else”来区分下一个字符做状态迁移。这里所谓的状态迁移，就是当前状态函数返
      回下一个状态函数。
    12.这样，我们的状态迁移代码非常的简单：
      var state = data;
      var char
      while(char = getInput())
          state = state(char);
    13.这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的
      字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。
    13.状态函数通过代码中的 emitToken 函数来输出解析好的 token（词），我们只需要覆盖 emitToken，即可指定对解析结果的处理
      方式。
    14.词法分析器接受字符的方式很简单，就像下面这样：
      function HTMLLexicalParser(){
          //状态函数们……
          function data() {
              // ……
          }
          function tagOpen() {
              // ……
          }
          // ……
          var state = data;
          this.receiveInput = function(char) {
              state = state(char);
          }
      }
    15.至此，我们就把字符流拆成了词（token）了。
  7.构建 DOM 树
    1.接下来我们要把这些简单的词变成 DOM 树，这个过程我们是使用栈来实现的，任何语言几乎都有栈，为了给你跑着玩，我们还是用 
      JavaScript 来实现吧，毕竟 JavaScript 中的栈只要用数组就好了。
      function HTMLSyntaticalParser(){
          var stack = [new HTMLDocument];
          this.receiveInput = function(token) {
              //……
          }
          this.getOutput = function(){
              return stack[0];
          }
      }
    2.我们这样来设计 HTML 的语法分析器，receiveInput 负责接收词法部分产生的词（token），通常可以由 emitToken 来调用。
    3.在接收的同时，即开始构建 DOM 树，所以我们的主要构建 DOM 树的算法，就写在 receiveInput 当中。当接收完所有输入，栈顶
      就是最后的根节点，我们 DOM 树的产出，就是这个 stack 的第一项。
    4.为了构建 DOM 树，我们需要一个 Node 类，接下来我们所有的节点都会是这个 Node 类的实例。
    5.在完全符合标准的浏览器中，不一样的 HTML 节点对应了不同的 Node 的子类，我们为了简化，就不完整实现这个继承体系了。我们
      仅仅把 Node 分为 Element 和 Text（如果是基于类的 OOP 的话，我们还需要抽象工厂来创建对象），
      function Element(){
          this.childNodes = [];
      }
      function Text(value){
          this.value = value || "";
      }
    6.前面我们的词（token）中，以下两个是需要成对匹配的：
      tag start
      tag end
    7.根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。
    8.对于 Text 节点，我们则需要把相邻的 Text 节点合并起来，我们的做法是当词（token）入栈时，检查栈顶是否是 Text 节点，如
      果是的话就合并 Text 节点。
    9.同样我们来看看直观的解析过程：
      <html maaa=a >
          <head>
              <title>cool</title>
          </head>
          <body>
              <img src="a" />
          </body>
      </html>
    10.通过这个栈，我们可以构建 DOM 树：
      栈顶元素就是当前节点；
      遇到属性，就添加到当前节点；
      遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；
      遇到注释节点，作为当前节点的子节点；
      遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；
      遇到 tag end 就出栈一个节点（还可以检查是否匹配）。
    11.我在文章里面放了一个视频，你可以点击查看用栈构造 DOM 树的全过程。
    12.当我们的源代码完全遵循 XHTML（这是一种比较严谨的 HTML 语法）时，这非常简单问题，然而 HTML 具有很强的容错能力，奥妙
      在于当 tag end 跟栈顶的 start tag 不匹配的时候如何处理。
    13.于是，这又有一个极其复杂的规则，幸好 W3C 又一次很贴心地把全部规则都整理地很好，我们只要翻译成对应的代码就好了，以下这
      个网站呈现了全部规则。你可以点击查看。
      http://www.w3.org/html/wg/drafts/html/master/syntax.html#tree-construction
  8.结语
    1.好了，总结一下。在今天的文章中，我带你继续探索了浏览器的工作原理，我们主要研究了解析代码和构建 DOM 树两个步骤。在解析代
      码的环节里，我们一起详细地分析了一个词（token）被拆分的过程，并且给出了实现它所需要的一个简单的状态机。
    2.在构建 DOM 树的环节中，基本思路是使用栈来构建 DOM 树为了方便你动手实践，我用 JavaScript 实现了这一过程。
    3.今天给你留的题目是：在语法和词法的代码，我已经给出了大体的结构，请你试着把内容补充完整吧。
3.浏览器：一个浏览器是如何工作的？（阶段三）
  1.在上一节课中，我已经讲了浏览器的 DOM 构建过程，但是这个构建的 DOM，实际上信息是不全的，它只有节点和属性，不包含任何的样
    式信息。
  2.我们这一节课就来讲讲：浏览器是如何把 CSS 规则应用到节点上，并给这棵朴素的 DOM 树添加上 CSS 属性的。
  3.整体过程
    1.首先我们还是要感性地理解一下这个过程。
    2.首先 CSS 选择器这个名称，可能会给你带来一定的误解，觉得好像 CSS 规则是 DOM 树构建好了以后，再进行选择并给它添加样式
      的。实际上，这个过程并不是这样的。
    3.我们回忆一下我们在浏览器第一节课讲的内容，浏览器会尽量流式处理整个过程。我们上一节课构建 DOM 的过程是：从父到子，从先
      到后，一个一个节点构造，并且挂载到 DOM 树上的，那么这个过程中，我们是否能同步把 CSS 属性计算出来呢？
    4.答案是肯定的。
    5.在这个过程中，我们依次拿到上一步构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。所以，从这个
      角度看，所谓的选择器，应该被理解成“匹配器”才更合适。
    6.我在 CSS 语法部分，已经总结了选择器的各种符号，这里再把它列出来，我们回顾一下。
      空格: 后代，选中它的子节点和所有子节点的后代节点。
      >: 子代，选中它的子节点。
      +：直接后继选择器，选中它的下一个相邻节点。
      ~：后继，选中它之后所有的相邻节点。
      ||：列，选中表格中的一列。
    7.关于选择器的知识，我会在 CSS 的部分继续讲解。这里我们主要介绍浏览器是如何实现这些规则的。
    8.不知道你有没有发现，这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原
      则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。
    9.也就是说，未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，
      而父节点会先于子节点构建。
    10.理解了 CSS 构建的大概过程，我们下面来看看具体的操作。
    11.首先，我们必须把 CSS 规则做一下处理。作为一门语言，CSS 需要先经过词法分析和语法分析，变成计算机能够理解的结构。
    12.这部分具体的做法属于编译原理的内容，这里就不做赘述了。我们这里假设 CSS 已经被解析成了一棵可用的抽象语法树。
    13.我们在之前的 CSS 课程中已经介绍过 compound-selector 的概念，一个 compound-selector 是检查一个元素的规则，而一
      个复合型选择器，则是由数个 compound-selector 通过前面讲的符号连接起来的。
  4.后代选择器 “空格”
    1.我们先来分析一下后代选择器，我们来一起看一个例子：
      a#b .cls {
          width: 100px;
      }
    2.可以把一个 CSS 选择器按照 compound-selector 来拆成数段，每当满足一段条件的时候，就前进一段。
    3.比如，在上面的例子中，当我们找到了匹配 a#b 的元素时，我们才会开始检查它所有的子代是否匹配 .cls。
    4.除了前进一段的情况，我们还需要处理后退的情况，比如，我们这样一段代码：
      <a id=b>
          <span>1<span>
          <span class=cls>2<span>
      </a>
      <span class=cls>3<span>
    5.当遇到 时，必须使得规则 a#b .cls 回退一步，这样第三个 span 才不会被选中。后代选择器的作用范围是父节点的所有子节点，
      因此规则是在匹配到本标签的结束标签时回退。
  5.后继选择器“ ~ ”
    1.接下来我们看下后继选择器，跟后代选择器不同的地方是，后继选择器只作用于一层，我们来看一个例子：
      .cls~* {
          border:solid 1px green;
      }
      <div>
      <span>1<span>
      <span class=cls>2<span>
      <span>
          3
          <span>4</span>
      <span>
      <span>5</span>
      </div>
    2.这里 .cls 选中了 span 2 然后 span 3 是它的后继，但是 span 3 的子节点 span 4 并不应该被选中，而 span 5 也是它
      的后继，因此应该被选中。
    3.按照 DOM 树的构造顺序，4 在 3 和 5 中间，我们就没有办法像前面讲的后代选择器一样通过激活或者关闭规则来实现匹配。
    4.但是这里有个非常方便的思路，就是给选择器的激活，带上一个条件：父元素。
    5.注意，这里后继选择器，当前半段的 .cls 匹配成功时，后续 * 所匹配的所有元素的父元素都已经确定了（后继节点和当前节点父元
      素相同是充分必要条件）。在我们的例子中，那个 div 就是后继节点的父元素。
  6.子代选择器“ >”
    1.我们继续看，子代选择器是如何实现的。
    2.实际上，有了前面讲的父元素这个约束思路，我们很容易实现子代选择器。区别仅仅是拿当前节点作为父元素，还是拿当前节点的父元
      素作为父元素。
      div>.cls {
          border:solid 1px green;
      }
      <div>
      <span>1<span>
      <span class=cls>2<span>
      <span>
          3
          <span>4</span>
      <span>
      <span>5</span>
      </div>
    3.我们看这段代码，当 DOM 树构造到 div 时，匹配了 CSS 规则的第一段，因为是子代选择器，我们激活后面的 .cls 选择条件，并
      且指定父元素必须是当前 div。于是后续的构建 DOM 树构建过程中，span 2 就被选中了。
  7.直接后继选择器“ +”
    1.直接后继选择器的实现是上述中最为简单的了，因为它只对唯一一个元素生效，所以不需要像前面几种一样反复激活和关闭规则。
    2.一个最简单的思路是，我们可以把它当作检查元素自身的选择器来处理。即我们把 #id+.cls 都当做检查某一个元素的选择器。
    3.另外的一种思路是：给后继选择器加上一个 flag，使它匹配一次后失效。你可以尝试一下，告诉我结果。
  8.列选择器“ || ”
    1.列选择器比较特别，它是专门针对表格的选择器，跟表格的模型建立相关，我们这里不详细讲了。
  9.其它
    1.我们不要忘记，CSS 选择器还支持逗号分隔，表示“或”的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。
    2.比如：
      a#b, .cls {

      }
    3.我们当作两条规则来处理：
      a#b {

      }
      .cls {

      }  
    4.还有一个情况，就是选择器可能有重合，这样，我们可以使用树形结构来进行一些合并，来提高效率：
      #a .cls {

      }

      #a span {

      }
      #a>span {

      }
    5.这里实际上可以把选择器构造成一棵树：
      #a
        < 空格 >.cls
        < 空格 >span
        >span
    6.需要注意的是，这里的树，必须要带上连接符。
  10.结语
    1.这一节我们讲解了 CSS 计算的过程。CSS 计算是把 CSS 规则应用到 DOM 树上，为 DOM 结构添加显示相关属性的过程。在这一
      节中，我们主要介绍了选择器的几种复合结构应该如何实现。
    2.在这一步骤之后，我们得到了一棵带有 CSS 属性的树，为我们后续打下了基础。
    3.最后留一个问题，你认为 CSS 语法解析成什么结构，最适合我们进行 CSS 计算。
4.浏览器：一个浏览器是如何工作的？（阶段四）
  1.我们书接上文。浏览器进行到这一步，我们已经给 DOM 元素添加了用于展现的 CSS 属性，接下来，浏览器的工作就是确定每一个元素
    的位置了。我们的基本原则仍然不变，就是尽可能流式地处理上一步骤的输出。
  2.在构建 DOM 树和计算 CSS 属性这两个步骤，我们的产出都是一个一个的元素，但是在排版这个步骤中，有些情况下，我们就没法做到
    这样了。
  3.尤其是表格相关排版、Flex 排版和 Grid 排版，它们有一个显著的特点，那就是子元素之间具有关联性。
  4.基本概念
    1.首先我们先来介绍一些基本概念，使你可以感性地认识一下我们平常说的各种术语。
    2.“排版”这个概念最初来自活字印刷，是指我们把一个一个的铅字根据文章顺序，放入板框当中的步骤，排版的意思是确定每一个字的
      位置。
    3.在现代浏览器中，仍然借用了这个概念，但是排版的内容更加复杂，包括文字、图片、图形、表格等等，我们把浏览器确定它们位置的
      过程，叫作排版。
    4.浏览器最基本的排版方案是正常流排版，它包含了顺次排布和折行等规则，这是一个跟我们提到的印刷排版类似的排版方案，也跟我们
      平时书写文字的方式一致，所以我们把它叫做正常流。
    5.浏览器的文字排版遵循公认的文字排版规范，文字排版是一个复杂的系统，它规定了行模型和文字在行模型中的排布。行模型规定了行
      顶、行底、文字区域、基线等对齐方式。（你还记得小时候写英语的英语本吗？英语本上的四条线就是一个简单的行模型。）
    6.此外，浏览器支持不同语言，因为不同语言的书写顺序不一致，所以浏览器的文本排版还支持双向文字系统。
    7.浏览器又可以支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是所谓的盒模型。
    8.在正常流的基础上，浏览器还支持两类元素：绝对定位元素和浮动元素。
      1.绝对定位元素把自身从正常流抽出，直接由 top 和 left 等属性确定自身的位置，不参加排版计算，也不影响其它元素。绝对定
        位元素由 position 属性控制。
      2.浮动元素则是使得自己在正常流的位置向左或者向右移动到边界，并且占据一块排版空间。浮动元素由 float 属性控制。
    9.除了正常流，浏览器还支持其它排版方式，比如现在非常常用的 Flex 排版，这些排版方式由外部元素的 display 属性来控制（注
      意，display 同时还控制元素在正常流中属于 inline 等级还是 block 等级）。
  5.正常流文字排版
    1.我们会在 CSS 部分详细介绍正常流排版的行为，我们这里主要介绍浏览器中的正常流。正常流是唯一一个文字和盒混排的排版方式，
      我们先从文字来讲起。
    2.要想理解正常流，我们首先要回忆一下自己如何在纸上写文章。
    3.首先，纸是有固定宽度的，虽然纸有固定高度，但是我们可以通过下一页纸的方式来接续，因此我们不存在写不下的场景。
    4.我们书写文字的时候，是从左到右依次书写，每一个字跟上一个字都不重叠，文字之间有一定间距，当写满一行时，我们换到下一行去
      继续写。
    5.书写中文时，文字的上、下、中轴线都对齐，书写英文时，不同字母的高度不同，但是有一条基线对齐。
    6.实际上浏览器环境也很类似。但是因为浏览器支持改变排版方向，不一定是从左到右从上到下，所以我们把文字依次书写的延伸方向称
      为主轴或者主方向，换行延伸的方向，跟主轴垂直交叉，称为交叉轴或者交叉方向。
    7.我们一般会从某个字体文件中获取某个特定文字的相关信息。我们获取到的信息大概类似下面：
      文字相关信息横行版本.png
    8.纵向版本：
      文字相关信息纵向版本.png
    9.这两张图片来自著名开源字体解析库 freetype，实际上，各个库对字体的理解大同小异，我们注意一下，advance 代表每一个文字
      排布后在主轴上的前进距离，它跟文字的宽 / 高不相等，是字体中最重要的属性。
    10.除了字体提供的字形本身包含的信息，文字排版还受到一些 CSS 属性影响，如 line-height、letter-spacing、
      word-spacing 等。
    11.在正常流的文字排版中，多数元素被当作长方形盒来排版，而只有 display 为 inline 的元素，是被拆成文本来排版的（还有一
      种 run-in 元素，它有时作为盒，有时作为文字，不太常用，这里不详细讲了）。
    12.display 值为 inline 的元素中的文字排版时会被直接排入文字流中，inline 元素主轴方向的 margin 属性和 border 属性
      （例如主轴为横向时的 margin-left 和 margin-right）也会被计算进排版前进距离当中。
    13.注意，当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。
    14.这样，即使没有元素包裹，混合书写方向的文字也可以形成一个盒结构，我们在排版时，遇到这样的双向文字盒，会先排完盒内再排
      盒外。
  6.正常流中的盒
    1.在正常流中，display 不为 inline 的元素或者伪元素，会以盒的形式跟文字一起排版。多数 display 属性都可以分成两部分：
      内部的排版和是否 inline，带有 inline- 前缀的盒，被称作行内级盒。
    2.根据盒模型，一个盒具有 margin、border、padding、width/height 等属性，它在主轴方向占据的空间是由对应方向的这几个
      属性之和决定的，而 vertical-align 属性决定了盒在交叉轴方向的位置，同时也会影响实际行高。
    3.所以，浏览器对行的排版，一般是先行内布局，再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。
    4.块级盒比较简单，它总是单独占据一整行，计算出交叉轴方向的高度即可。
  7.绝对定位元素  
    1.position 属性为 absolute 的元素，我们需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到
      其父级的 position 非 static 元素即可。
  8.浮动元素排版
    1.loat 元素非常特别，浏览器对 float 的处理是先排入正常流，再移动到排版宽度的最左 / 最右（这里实际上是主轴的最前和最后）。
    2.移动之后，float 元素占据了一块排版的空间，因此，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮
      动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。float 元素排布完成后，float 元素所在的行需要重新确定位置。
  9.其它的排版
    1.CSS 的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如 Flex 排版，支持了 flex 属性，flex 属性将每一行
      排版后的剩余空间平均分配给主轴方向的 width/height 属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的。
  10.结束
    1.这一部分，我们以正常流为主，介绍了浏览器的排版基本概念及一些算法。这里，我主要介绍了正常流中的文字排版、正常流中的盒、绝
      对定位元素、浮动元素排版这几种情况。最后，我还简单介绍了一下 Flex 排版。这属于进阶版的排版方式了，你可以了解一下。
    2.你平时喜欢使用方式排版呢，欢迎留言告诉我。
5.浏览器：一个浏览器是如何工作的？（阶段五）
  1.你好，我是 winter。我们的浏览器系列已经进行到最后一篇。
  2.在之前的几篇文章中，我们已经经历了把 URL 变成字符流，把字符流变成词（token）流，把词（token）流构造成 DOM 树，把不含样
    式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM 树，并且根据样式信息，计算了每个元素的位置和大小。
  3.那么，我们最后的步骤，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。
  4.渲染
    1.首先我们来谈谈渲染这个词，渲染也是个外来词，它是英文词 render 的翻译，render 这个词在英文里面，有“导致”“变成”的意思，
      也有“粉刷墙壁”的意思。
    2.在计算机图形学领域里，英文 render 这个词是一个简写，它是特指把模型变成位图的过程。我们把 render 翻译成“渲染”，是个非
      常有意思的翻译，中文里“渲染”这个词是一种绘画技法，是指沾清水把墨涂开的意思。
    3.所以，render 翻译成“渲染”，我认为是非常高明的，对 render 这个过程，用国画的渲染手法来概括，是颇有神似的。
    4.我们现在的一些框架，也会把“从数据变成 HTML 代码的过程”称为 render，其实我觉得这是非常具有误导性的，我个人是非常不喜欢
      这种命名方式，当然了，所谓“文无第一”，在自然语言的范围里，我们很难彻底否定这种用法的合理性。
    5.不过，在本篇文章中，我们可以约定一下，本文中出现的“渲染”一词，统一指的是它在图形学的意义，也就是把模型变成位图的过程。
    6.这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是 DOM 树中占据浏览器内存最多
      的信息，我们在做内存占用优化时，主要就是考虑这一部分）。
    7.浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 
      inline 元素，可能会分成多行）。每一个盒对应着一张位图。
    8.这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：图形和文字。
    9.盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类。这就像我们实现 HTTP 协议必须要基于 TCP 库一样，这一部分，
      我们需要一个底层库来支持。
    10.一般的操作系统会提供一个底层库，比如在 Android 中，有大名鼎鼎的 Skia，而 Windows 平台则有 GDI，一般的浏览器会做一
      个兼容层来处理掉平台差异。
    11.这些盒的特性如何绘制，每一个都有对应的标准规定，而每一个的实现都可以作为一个独立的课题来研究，当年圆角 + 虚线边框，可
      是难倒了各个浏览器的工程师。考虑到这些知识互相都比较独立，对前端工程师来说也不是特别重要的细节，我们这里就不详细探究了。
    12.盒中的文字，也需要用底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形。
    13.字形分为像素字形和矢量字形两种。通常的字体，会在 6px 8px 等小尺寸提供像素字形，比较大的尺寸则提供矢量字形。矢量字形
      本身就需要经过渲染才能继续渲染到元素的位图上去。目前最常用的字体库是 Freetype，这是一个 C++ 编写的开源的字体库。
    14.在最普遍的情况下，渲染过程生成的位图尺寸跟它在上一步排版时占据的尺寸相同。
    15.但是理想和现实是有差距的，很多属性会影响渲染位图的大小，比如阴影，它可能非常巨大，或者渲染到非常遥远的位置，所以为了优
      化，浏览器实际的实现中会把阴影作为一个独立的盒来处理。
    16.注意，我们这里讲的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结
      果能够最大程度被缓存，减少重新渲染。
  5.合成
    1.合成是英文术语 compositing 的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。
    2.我们上一小节中讲到，渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为
      合成层），把一部分子元素渲染到合成的位图上面。
    3.看到这句话，我想你一定会问问题，到底是为哪些元素创建合成后的位图，把哪些子元素渲染到合成的位图上面呢？
    4.这就是我们要讲的合成的策略。我们前面讲了，合成是一个性能考量，那么合成的目标就是提高性能，根据这个目标，我们建立的原则
      就是最大限度减少绘制次数原则。
    5.我们举一个极端的例子。如果我们把所有元素都进行合成，比如我们为根元素 HTML 创建一个合成后的位图，把所有子元素都进行合成，
      那么会发生什么呢？
    6.那就是，一旦我们用 JavaScript 或者别的什么方式，改变了任何一个 CSS 属性，这份合成后的位图就失效了，我们需要重新绘制
      所有的元素。
    7.那么如果我们所有的元素都不合成，会怎样呢？结果就是，相当于每次我们都必须要重新绘制所有的元素，这也不是对性能友好的选择。
    8.那么好的合成策略是什么呢，好的合成策略是“猜测”可能变化的元素，把它排除到合成之外。
    9.我们来举个例子：  
      <div id="a">
          <div id="b">...</div>
          <div id="c" style="transform:translate(0,0)"></div>
      </div>
    10.假设我们的合成策略能够把 a、b 两个 div 合成，而不把 c 合成，那么，当我执行以下代码时：
      document.getElementById("c").style.transform = "translate(100px, 0)";
    11.我们绘制的时候，就可以只需要绘制 a 和 b 合成好的位图和 c，从而减少了绘制次数。这里需要注意的是，在实际场景中，我们的 
      b 可能有很多复杂的子元素，所以当合成命中时，性能提升收益非常之高。
    12.目前，主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。
    13.但是，这样的猜测准确性有限，所以新的 CSS 标准中，规定了 will-change 属性，可以由业务代码来提示浏览器的合成策略，灵
      活运用这样的特性，可以大大提升合成策略的效果。
  6.绘制
    1.绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只
      需要把最终要显示的位图交给操作系统即可。
    2.一般最终位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或者驱动就可以了，这取决于浏览器运
      行的环境。不过无论如何，我们把任何位图合成到这个“最终位图”的操作称为绘制。
    3.这个过程听上去非常简单，这是因为在前面两个小节中，我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，
      实际上就是按照 z-index 把它们依次绘制到屏幕上。
    4.然而如果在实际中这样做，会带来极其糟糕的性能。
    5.有一个一度非常流行于前端群体的说法，讲做 CSS 性能优化，应该尽量避免“重排”和“重绘”，前者讲的是我们上一课的排版行为，后
      者模糊地指向了我们本课程三小节讲的三个步骤，而实际上，这个说法大体不能算错，却不够准确。
    6.因为，实际上，“绘制”发生的频率比我们想象中要高得多。我们考虑一个情况：鼠标划过浏览器显示区域。这个过程中，鼠标的每次移
      动，都造成了重新绘制，如果我们不重新绘制，就会产生大量的鼠标残影。
    7.这个时候，限制绘制的面积就很重要了。如果鼠标某次位置恰巧遮盖了某个较小的元素，我们完全可以重新绘制这个元素来完成我们的
      目标，当然，简单想想就知道，这种事情不可能总是发生的。
    8.计算机图形学中，我们使用的方案就是“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域。
    9.当鼠标移动、元素移动或者其它导致需要重绘的场景发生时，我们只重新绘制它所影响到的几个矩形区域就够了。比矩形区域更小的影
      响最多只会涉及 4 个矩形，大型元素则覆盖多个矩形。
    10.设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂。
    11.我们重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交集部分绘制即可。
  7.结语
    1.在这一节课程中，我们讲解了浏览器中的位图操作部分，这包括了渲染、合成和绘制三个部分。渲染过程把元素变成位图，合成把一部
      分位图变成合成层，最终的绘制过程把合成层显示到屏幕上。
    2.当绘制完成时，就完成了浏览器的最终任务，把一个 URL 最后变成了一个可以看的网页图像。当然了，我们对每一个部分的讲解，都
      省略了大量的细节，比如我们今天讲到的绘制，就有意地无视了滚动区域。
    3.尽管如此，对浏览器工作原理的感性认识，仍然可以帮助我们理解很多前端技术的设计和应用技巧，浏览器的工作原理和性能部分非常
      强相关，我们在实践部分的性能优化部分，会再次跟你做一些探讨。
    4.实际上，如果你认真阅读浏览器系列的课程，是可以用 JavaScript 实现一个玩具浏览器的，我非常希望学习课程的同学中能有人这
      样做，一旦你做到了，收益会非常大。这就是我今天留给你的课外作业，你可以尝试一下。
6.浏览器DOM：你知道HTML的节点有哪几种吗？
  1.今天我们进入浏览器 API 的学习, 这一节课，我们来学习一下 DOM API。
  2.DOM API 是最早被设计出来的一批 API，也是用途最广的 API，所以早年的技术社区，常常用 DOM 来泛指浏览器中所有的 API。不
    过今天这里我们要介绍的 DOM，指的就是狭义的文档对象模型。
  3.DOM API 介绍
    1.首先我们先来讲一讲什么叫做文档对象模型。
    2.顾名思义，文档对象模型是用来描述文档，这里的文档，是特指 HTML 文档（也用于 XML 文档，但是本课不讨论 XML）。同时它又
      是一个“对象模型”，这意味着它使用的是对象这样的概念来描述 HTML 文档。
    3.说起 HTML 文档，这是大家最熟悉的东西了，我们都知道，HTML 文档是一个由标签嵌套而成的树形结构，因此，DOM 也是使用树形
      的对象模型来描述一个 HTML 文档。
    4.DOM API 大致会包含 4 个部分。
      节点：DOM 树形结构中的节点相关 API。
      事件：触发和监听事件相关 API。
      Range：操作文字范围相关 API。
      遍历：遍历 DOM 需要的 API。
    5.事件相关 API 和事件模型，我们会用单独的课程讲解，所以我们本篇文章重点会为你介绍节点和遍历相关 API。
    6.DOM API 数量很多，我希望给你提供一个理解 DOM API 设计的思路，避免单靠机械的方式去死记硬背。
  4.节点
    1.DOM 的树形结构所有的节点有统一的接口 Node，我们按照继承关系，给你介绍一下节点的类型。
      DOM节点类型.png
    2.在这些节点中，除了 Document 和 DocumentFrangment，都有与之对应的 HTML 写法，我们可以看一下。
      Element: <tagname>...</tagname>
      Text: text
      Comment: <!-- comments -->
      DocumentType: <!Doctype html>
      ProcessingInstruction: <?a 1?>
    3.我们在编写 HTML 代码并且运行后，就会在内存中得到这样一棵 DOM 树，HTML 的写法会被转化成对应的文档模型，而我们则可以
      通过 JavaScript 等语言去访问这个文档模型。
    4.这里我们每天都需要用到，要重点掌握的是：Document、Element、Text 节点。
    5.DocumentFragment 也非常有用，它常常被用来高性能地批量添加节点。因为 Comment、DocumentType 和 
      ProcessingInstruction 很少需要运行时去修改和操作，所以有所了解即可。
  5.Node
    1.Node 是 DOM 树继承关系的根节点，它定义了 DOM 节点在 DOM 树上的操作，首先，Node 提供了一组属性，来表示它在 DOM 树
      中的关系，它们是：
      parentNode
      childNodes
      firstChild
      lastChild
      nextSibling
      previousSibling
    2.从命名上，我们可以很清晰地看出，这一组属性提供了前、后、父、子关系，有了这几个属性，我们可以很方便地根据相对位置获取元
      素。当然，Node 中也提供了操作 DOM 树的 API，主要有下面几种。
      appendChild
      insertBefore
      removeChild
      replaceChild
    3.这个命名跟上面一样，我们基本可以知道 API 的作用。这几个 API 的设计可以说是饱受诟病。其中最主要的批评是它不对称——只有
      before，没有 after，而 jQuery 等框架都对其做了补充。
    4.实际上，appendChild 和 insertBefore 的这个设计，是一个“最小原则”的设计，这两个 API 是满足插入任意位置的必要 API，
      而 insertAfter，则可以由这两个 API 实现出来。
    5.我个人其实不太喜欢这个设计，对我而言，insertAt(pos) 更符合审美一些。当然，不论喜不喜欢，这个标准已经确定，我们还是必
      须要掌握它。
    6.这里从设计的角度还想要谈一点，那就是，所有这几个修改型的 API，全都是在父元素上操作的，比如我们要想实现“删除一个元素的
      上一个元素”，必须要先用 parentNode 获取其父元素。
    7.这样的设计是符合面向对象的基本原则的。还记得我们在 JavaScript 对象部分讲的对象基本特征吗？“拥有哪些子元素”是父元素的
      一种状态，所以修改状态，应该是父元素的行为。这个设计我认为是 DOM API 中好的部分。
    8.到此为止，Node 提供的 API 已经可以很方便（大概吧）地对树进行增、删、遍历等操作了。
    9.除此之外，Node 还提供了一些高级 API，我们来认识一下它们。
      compareDocumentPosition 是一个用于比较两个节点中关系的函数。
      contains 检查一个节点是否包含另一个节点的函数。
      isEqualNode 检查两个节点是否完全相同。
      isSameNode 检查两个节点是否是同一个节点，实际上在 JavaScript 中可以用“===”。
      cloneNode 复制一个节点，如果传入参数 true，则会连同子元素做深拷贝。
    10.DOM 标准规定了节点必须从文档的 create 方法创建出来，不能够使用原生的 JavaScript 的 new 运算。于是 document 对
      象有这些方法。
      createElement
      createTextNode
      createCDATASection
      createComment
      createProcessingInstruction
      createDocumentFragment
      createDocumentType
    11.上面的这些方法都是用于创建对应的节点类型。你可以自己尝试一下。
  6.Element 与 Attribute
    1.Node 提供了树形结构上节点相关的操作。而大部分时候，我们比较关注的是元素。Element 表示元素，它是 Node 的子类。
    2.元素对应了 HTML 中的标签，它既有子节点，又有属性。所以 Element 子类中，有一系列操作属性的方法。
    3.我们需要注意，对 DOM 而言，Attribute 和 Property 是完全不同的含义，只有特性场景下，两者才会互相关联（这里在后面我
      会详细讲解，今天的文章里我就不展开了）。
    4.首先，我们可以把元素的 Attribute 当作字符串来看待，这样就有以下的 API：
      getAttribute
      setAttribute
      removeAttribute
      hasAttribute
    5.如果你追求极致的性能，还可以把 Attribute 当作节点：
      getAttributeNode
      setAttributeNode
    6.此外，如果你喜欢 property 一样的访问 attribute，还可以使用 attributes 对象，比如 
      document.body.attributes.class = “a” 等效于 document.body.setAttribute(“class”, “a”)。
  7.查找元素
    1.document 节点提供了查找元素的能力。比如有下面的几种。
      querySelector
      querySelectorAll
      getElementById
      getElementsByName
      getElementsByTagName
      getElementsByClassName
    2.我们需要注意，getElementById、getElementsByName、getElementsByTagName、getElementsByClassName，这几个 
      API 的性能高于 querySelector。
    3.而 getElementsByName、getElementsByTagName、getElementsByClassName 获取的集合并非数组，而是一个能够动态更
      新的集合。
    4.我们看一个例子：
      var collection = document.getElementsByClassName('winter');
      console.log(collection.length);
      var winter = document.createElement('div');
      winter.setAttribute('class', 'winter')
      document.documentElement.appendChild(winter)
      console.log(collection.length);
    5.在这段代码中，我们先获取了页面的 className 为 winter 的元素集合，不出意外的话，应该是空。
    6.我们通过 console.log 可以看到集合的大小为 0。之后我们添加了一个 class 为 winter 的 div，这时候我们再看集合，可
      以发现，集合中出现了新添加的元素。
    7.这说明浏览器内部是有高速的索引机制，来动态更新这样的集合的。所以，尽管 querySelector 系列的 API 非常强大，我们还是
      应该尽量使用 getElement 系列的 API。
  8.遍历
    1.前面已经提到过，通过 Node 的相关属性，我们可以用 JavaScript 遍历整个树。实际上，DOM API 中还提供了 NodeIterator 
      和 TreeWalker 来遍历树。
    2.比起直接用属性来遍历，NodeIterator 和 TreeWalker 提供了过滤功能，还可以把属性节点也包含在遍历之内。
    3.NodeIterator 的基本用法示例如下：
      var iterator = document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT, null, false);
      var node;
      while(node = iterator.nextNode())
      {
          console.log(node);
      }
    4.这个 API 的设计非常老派，这么讲的原因主要有两点，一是循环并没有类似“hasNext”这样的方法，而是直接以 nextNode 返回
      null 来标志结束，二是第二个参数是掩码，这两个设计都是传统 C 语言里比较常见的用法。
    5.放到今天看，这个迭代器无法匹配 JavaScript 的迭代器语法，而且 JavaScript 位运算并不高效，掩码的设计就徒增复杂性了。
    6.这里请你注意一下这个例子中的处理方法，通常掩码型参数，我们都是用按位或运算来叠加。而针对这种返回 null 表示结束的迭代
      器，我使用了在 while 循环条件中赋值，来保证循环次数和调用 next 次数严格一致（但这样写可能违反了某些编码规范）。
    7.我们再来看一下 TreeWalker 的用法。
      var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null, false)
      var node;
      while(node = walker.nextNode())
      {
          if(node.tagName === "p")
              node.nextSibling();
          console.log(node);
      }
    8.比起 NodeIterator，TreeWalker 多了在 DOM 树上自由移动当前节点的能力，一般来说，这种 API 用于“跳过”某些节点，或
      者重复遍历某些节点。
    9.总的来说，我个人不太喜欢 TreeWalker 和 NodeIterator 这两个 API，建议需要遍历 DOM 的时候，直接使用递归和 Node 
      的属性。
  9.Range
    1.Range API 是一个比较专业的领域，如果不做富文本编辑类的业务，不需要太深入。这里我们就仅介绍概念和给出基本用法的示例，
      你只要掌握即可。
    2.Range API 表示一个 HTML 上的范围，这个范围是以文字为最小单位的，所以 Range 不一定包含完整的节点，它可能是 Text 
      节点中的一段，也可以是头尾两个 Text 的一部分加上中间的元素。
    3.我们通过 Range API 可以比节点 API 更精确地操作 DOM 树，凡是 节点 API 能做到的，Range API 都可以做到，而且可以做
      到更高性能，但是 Range API 使用起来比较麻烦，所以在实际项目中，并不常用，只有做底层框架和富文本编辑对它有强需求。
    4.创建 Range 一般是通过设置它的起止来实现，我们可以看一个例子：
      var range = new Range(),
          firstText = p.childNodes[1],
          secondText = em.firstChild
      range.setStart(firstText, 9) // do not forget the leading space
      range.setEnd(secondText, 4)
    5.此外，通过 Range 也可以从用户选中区域创建，这样的 Range 用于处理用户选中区域:
      var range = document.getSelection().getRangeAt(0);
    6.更改 Range 选中区段内容的方式主要是取出和插入，分别由 extractContents 和 insertNode 来实现。
      var fragment = range.extractContents()
      range.insertNode(document.createTextNode("aaaa"))
    7.最后我们看一个完整的例子。
      var range = new Range(),
          firstText = p.childNodes[1],
          secondText = em.firstChild
      range.setStart(firstText, 9) // do not forget the leading space
      range.setEnd(secondText, 4)

      var fragment = range.extractContents()
      range.insertNode(document.createTextNode("aaaa"))
    8.这个例子展示了如何使用 range 来取出元素和在特定位置添加新元素。
  10.总结
    1.在今天的文章中，我们一起了解了 DOM API 的内容。DOM API 大致会包含 4 个部分。
      节点：DOM 树形结构中的节点相关 API。
      事件：触发和监听事件相关 API。
      Range：操作文字范围相关 API。
      遍历：遍历 DOM 需要的 API。
    2.DOM API 中还提供了 NodeIterator 和 TreeWalker 来遍历树。比起直接用属性来遍历，NodeIterator 和 TreeWalker 提
      供了过滤功能，还可以把属性节点也包含在遍历之内。
    3.除此之外，我们还谈到了 Range 的一些基础知识点，这里你掌握即可。
    4.最后，我给你留了一个题目，请你用 DOM API 来实现遍历整个 DOM 树，把所有的元素的 tagName 打印出来。
  11.补充阅读：命名空间
    1.我们本课介绍的所有 API，特意忽略了命名空间。
    2.在 HTML 场景中，需要考虑命名空间的场景不多。最主要的场景是 SVG。创建元素和属性相关的 API 都有带命名空间的版本：
      document
        createElementNS
        createAttributeNS
      Element
        getAttributeNS
        setAttributeNS
        getAttributeNodeNS
        setAttributeNodeNS
        removeAttributeNS
        hasAttributeNS
        attributes.setNamedItemNS
        attributes.getNamedItemNS
        attributes.removeNamedItemNS
    3.若要创建 Document 或者 Doctype，也必须要考虑命名空间问题。DOM 要求从 document.implementation 来创建。
      document.implementation.createDocument
      document.implementation.createDocumentType
    4.除此之外，还提供了一个快捷方式，你也可以动手尝试一下。
      document.implementation.createHTMLDocument
7.浏览器CSSOM：如何获取一个元素的准确位置
  1.在前面的课程中，我们已经学习了 DOM 相关的 API，狭义的 DOM API 仅仅包含 DOM 树形结构相关的内容。今天，我们再来学习一
    类新的 API：CSSOM。
  2.我想，你在最初接触浏览器 API 的时候，应该都有跟我类似的想法：“好想要 element.width、element.height 这样的 API 啊”。
  3.这样的 API 可以直接获取元素的显示相关信息，它们是非常符合人的第一印象直觉的设计，但是，偏偏 DOM API 中没有这样的内容。
  4.随着学习的深入，我才知道，这样的设计是有背后的逻辑的，正如 HTML 和 CSS 分别承担了语义和表现的分工，DOM 和 CSSOM 也有
    语义和表现的分工。
  5.DOM 中的所有的属性都是用来表现语义的属性，CSSOM 的则都是表现的属性，width 和 height 这类显示相关的属性，都属于我们今
    天要讲的 CSSOM。
  6.顾名思义，CSSOM 是 CSS 的对象模型，在 W3C 标准中，它包含两个部分：描述样式表和规则等 CSS 的模型部分（CSSOM），和跟元
    素视图相关的 View 部分（CSSOM View）。
  7.在实际使用中，CSSOM View 比 CSSOM 更常用一些，因为我们很少需要用代码去动态地管理样式表。
  8.在今天的文章中，我来分别为你介绍这两部分的 API。
  9.CSSOM
    1.首先我们来介绍下 CSS 中样式表的模型，也就是 CSSOM 的本体。
    2.我们通常创建样式表也都是使用 HTML 标签来做到的，我们用 style 标签和 link 标签创建样式表，例如：
      <style title="Hello">
      a {
        color:red;
      }
      </style>
      <link rel="stylesheet" title="x" href="data:text/css,p%7Bcolor:blue%7D">
    3.我们创建好样式表后，还有可能要对它进行一些操作。如果我们以 DOM 的角度去理解的话，这些标签在 DOM 中是一个节点，它们有
      节点的内容、属性，这两个标签中，CSS 代码有的在属性、有的在子节点。这两个标签也遵循 DOM 节点的操作规则，所以可以使用 
      DOM API 去访问。
    4.但是，这样做的后果是我们需要去写很多分支逻辑，并且，要想解析 CSS 代码结构也不是一件简单的事情，所以，这种情况下，我们
      直接使用 CSSOM API 去操作它们生成的样式表，这是一个更好的选择。
    5.我们首先了解一下 CSSOM API 的基本用法，一般来说，我们需要先获取文档中所有的样式表：
      document.styleSheets
    6.document 的 styleSheets 属性表示文档中的所有样式表，这是一个只读的列表，我们可以用方括号运算符下标访问样式表，也可
      以使用 item 方法来访问，它有 length 属性表示文档中的样式表数量。
    7.样式表只能使用 style 标签或者 link 标签创建（对 XML 来说，还可以使用，咱们暂且不表）。
    8.我们虽然无法用 CSSOM API 来创建样式表，但是我们可以修改样式表中的内容。
      document.styleSheets[0].insertRule("p { color:pink; }", 0)
      document.styleSheets[0].removeRule(0)
    9.更进一步，我们可以获取样式表中特定的规则（Rule），并且对它进行一定的操作，具体来说，就是使用它的 cssRules 属性来实现：
      document.styleSheets[0].cssRules
    10.这里取到的规则列表，同样是支持 item、length 和下标运算。
    11.不过，这里的 Rules 可就没那么简单了，它可能是 CSS 的 at-rule，也可能是普通的样式规则。不同的 rule 类型，具有不同
      的属性。
    12.我们在 CSS 语法部分，已经为你整理过 at-rule 的完整列表，多数 at-rule 都对应着一个 rule 类型：
      CSSStyleRule
      CSSCharsetRule
      CSSImportRule
      CSSMediaRule
      CSSFontFaceRule
      CSSPageRule
      CSSNamespaceRule
      CSSKeyframesRule
      CSSKeyframeRule
      CSSSupportsRule
    13.具体的规则支持的属性，建议你可以用到的时候，再去查阅 MDN 或者 W3C 的文档，在我们的文章中，仅为你详细介绍最常用的 
      CSSStyleRule。
    14.CSSStyleRule 有两个属性：selectorText 和 style，分别表示一个规则的选择器部分和样式部分。
    15.selector 部分是一个字符串，这里显然偷懒了没有设计进一步的选择器模型，我们按照选择器语法设置即可。
    16.style 部分是一个样式表，它跟我们元素的 style 属性是一样的类型，所以我们可以像修改内联样式一样，直接改变属性修改规
      则中的具体 CSS 属性定义，也可以使用 cssText 这样的工具属性。
    17.此外，CSSOM 还提供了一个非常重要的方法，来获取一个元素最终经过 CSS 计算得到的属性：
      window.getComputedStyle(elt, pseudoElt);
    18.其中第一个参数就是我们要获取属性的元素，第二个参数是可选的，用于选择伪元素。
    19.好了，到此为止，我们可以使用 CSSOM API 自由地修改页面已经生效的样式表了。接下来，我们来一起关注一下视图的问题。
  10.CSSOM View
    1.CSSOM View 这一部分的 API，可以视为 DOM API 的扩展，它在原本的 Element 接口上，添加了显示相关的功能，这些功能，
      又可以分成三个部分：窗口部分，滚动部分和布局部分，下面我来分别带你了解一下。
  11.窗口 API
    1.窗口 API 用于操作浏览器窗口的位置、尺寸等。
      moveTo(x, y) 窗口移动到屏幕的特定坐标；
      moveBy(x, y) 窗口移动特定距离；
      resizeTo(x, y) 改变窗口大小到特定尺寸；
      resizeBy(x, y) 改变窗口大小特定尺寸。
    2.此外，窗口 API 还规定了 window.open() 的第三个参数：
      window.open("about:blank", "_blank" ,"width=100,height=100,left=100,right=100" )  
    3.一些浏览器出于安全考虑没有实现，也不适用于移动端浏览器，这部分你仅需简单了解即可。下面我们来了解一下滚动 API。
  12.滚动 API
    1.要想理解滚动，首先我们必须要建立一个概念，在 PC 时代，浏览器可视区域的滚动和内部元素的滚动关系是比较模糊的，但是在移
      动端越来越重要的今天，两者必须分开看待，两者的性能和行为都有区别。
  13.视口滚动 API
    1.可视区域（视口）滚动行为由 window 对象上的一组 API 控制，我们先来了解一下：
      scrollX 是视口的属性，表示 X 方向上的当前滚动距离，有别名 pageXOffset；
      scrollY 是视口的属性，表示 Y 方向上的当前滚动距离，有别名 pageYOffset；
      scroll(x, y) 使得页面滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 {top, left}；
      scrollBy(x, y) 使得页面滚动特定的距离，支持传入配置型参数 {top, left}。
    2.通过这些属性和方法，我们可以读取视口的滚动位置和操纵视口滚动。不过，要想监听视口滚动事件，我们需要在 document 对象上
      绑定事件监听函数：
      document.addEventListener("scroll", function(event){
        //......
      })
    3.视口滚动 API 是页面的顶层容器的滚动，大部分移动端浏览器都会采用一些性能优化，它和元素滚动不完全一样，请大家一定建立这
      个区分的意识。
  14.元素滚动 API
    1.接下来我们来认识一下元素滚动 API，在 Element 类（参见 DOM 部分），为了支持滚动，加入了以下 API。
      scrollTop 元素的属性，表示 Y 方向上的当前滚动距离。
      scrollLeft 元素的属性，表示 X 方向上的当前滚动距离。
      scrollWidth 元素的属性，表示元素内部的滚动内容的宽度，一般来说会大于等于元素宽度。
      scrollHeight 元素的属性，表示元素内部的滚动内容的高度，一般来说会大于等于元素高度。
      scroll(x, y) 使得元素滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 {top, left}。
      scrollBy(x, y) 使得元素滚动到特定的位置，支持传入配置型参数 {top, left}。
      scrollIntoView(arg) 滚动元素所在的父元素，使得元素滚动到可见区域，可以通过 arg 来指定滚到中间、开始或者就近。
    2.除此之外，可滚动的元素也支持 scroll 事件，我们在元素上监听它的事件即可：
      element.addEventListener("scroll", function(event){
        //......
      })
    3.这里你需要注意一点，元素部分的 API 设计与视口滚动命名风格上略有差异，你在使用的时候不要记混。
  15.布局 API
    1.最后我们来介绍一下布局 API，这是整个 CSSOM 中最常用到的部分，我们同样要分成全局 API 和元素上的 API。
  16.全局尺寸信息
    1.window 对象上提供了一些全局的尺寸信息，它是通过属性来提供的，我们一起来了解一下来这些属性。
      window对象上全局的尺寸信息.png
      window.innerHeight, window.innerWidth 这两个属性表示视口的大小。
      window.outerWidth, window.outerHeight 这两个属性表示浏览器窗口占据的大小，很多浏览器没有实现，一般来说这两个属性无关紧要。
      window.devicePixelRatio 这个属性非常重要，表示物理像素和 CSS 像素单位的倍率关系，Retina 屏这个值是 2，后来也出现了一些 3 倍的 Android 屏。
      window.screen （屏幕尺寸相关的信息）
        window.screen.width, window.screen.height 设备的屏幕尺寸。
        window.screen.availWidth, window.screen.availHeight 设备屏幕的可渲染区域尺寸，一些 Android 机器会把屏幕的一部分预留做固定按钮，所以有这两个属性，实际上一般浏览器不会实现的这么细致。
        window.screen.colorDepth, window.screen.pixelDepth 这两个属性是固定值 24，应该是为了以后预留。
    2.虽然 window 有这么多相关信息，在我看来，我们主要使用的是 innerHeight、innerWidth 和 devicePixelRatio 三个属性，
      因为我们前端开发工作只需要跟视口打交道，其它信息大概了解即可。
  17.元素的布局信息
    1.最后我们来到了本节课一开始提到的问题，我们是否能够取到一个元素的宽（width）和高（height）呢？
    2.实际上，我们首先应该从脑中消除“元素有宽高”这样的概念，我们课程中已经多次提到了，有些元素可能产生多个盒，事实上，只有盒
      有宽和高，元素是没有的。
    3.所以我们获取宽高的对象应该是“盒”，于是 CSSOM View 为 Element 类添加了两个方法：
      getClientRects();
      getBoundingClientRect()。
    4.getClientRects 会返回一个列表，里面包含元素对应的每一个盒所占据的客户端矩形区域，这里每一个矩形区域可以用 x, y, 
      width, height 来获取它的位置和尺寸。
    5.getBoundingClientRect ，这个 API 的设计更接近我们脑海中的元素盒的概念，它返回元素对应的所有盒的包裹的矩形区域，需
      要注意，这个 API 获取的区域会包括当 overflow 为 visible 时的子元素区域。
    6.根据实际的精确度需要，我们可以选择何时使用这两个 API。
    7.这两个 API 获取的矩形区域都是相对于视口的坐标，这意味着，这些区域都是受滚动影响的。
    8.如果我们要获取相对坐标，或者包含滚动区域的坐标，需要一点小技巧：
      var offsetX = document.documentElement.getBoundingClientRect().x - element.getBoundingClientRect().x;
    9.如这段代码所示，我们只需要获取文档跟节点的位置，再相减即可得到它们的坐标。
    10.这两个 API 的兼容性非常好，定义又非常清晰，建议你如果是用 JavaScript 实现视觉效果时，尽量使用这两个 API。
  18.结语
    1.今天我们一起学习了 CSSOM 这一类型的 API。我们首先就说到了，就像 HTML 和 CSS 分别承担了语义和表现的分工，DOM 和 
      CSSOM 也有语义和表现的分工。
    2.CSSOM 是 CSS 的对象模型，在 W3C 标准中，它包含两个部分：描述样式表和规则等 CSS 的模型部分（CSSOM），和跟元素视图相
      关的 View 部分（CSSOM View）。
    3.最后留给你一个问题，写好欢迎留言来讨论，请找一个网页，用我们今天讲的 API，把页面上的所有盒的轮廓画到一个 canvas 元素上。
8.浏览器事件：为什么会有捕获过程和冒泡过程？
  1.你好，我是 winter。这一节课，我们进入了浏览器的部分，一起来学习一下事件。
  2.事件概述
    1.在开始接触具体的 API 之前，我们要先了解一下事件。一般来说，事件来自输入设备，我们平时的个人设备上，输入设备有三种：
      键盘；
      鼠标；
      触摸屏。
    2.这其中，触摸屏和鼠标又有一定的共性，它们被称作 pointer 设备，所谓 pointer 设备，是指它的输入最终会被抽象成屏幕上面的
      一个点。但是触摸屏和鼠标又有一定区别，它们的精度、反应时间和支持的点的数量都不一样。
    3.我们现代的 UI 系统，都源自 WIMP 系统。WIMP 即 Window Icon Menu Pointer 四个要素，它最初由施乐公司研发，后来被微
      软和苹果两家公司应用在了自己的操作系统上（关于这个还有一段有趣的故事，我附在文末了）。
    4.WIMP 是如此成功，以至于今天很多的前端工程师会有一个观点，认为我们能够“点击一个按钮”，实际上并非如此，我们只能够点击鼠标
      上的按钮或者触摸屏，是操作系统和浏览器把这个信息对应到了一个逻辑上的按钮，再使得它的视图对点击事件有反应。这就引出了我们
      第一个要讲解的机制：捕获与冒泡。
  3.捕获与冒泡
    1.很多文章会讲到捕获过程是从外向内，冒泡过程是从内向外，但是这里我希望讲清楚，为什么会有捕获过程和冒泡过程。
    2.我们刚提到，实际上点击事件来自触摸屏或者鼠标，鼠标点击并没有位置信息，但是一般操作系统会根据位移的累积计算出来，跟触摸屏
      一样，提供一个坐标给浏览器。
    3.那么，把这个坐标转换为具体的元素上事件的过程，就是捕获过程了。而冒泡过程，则是符合人类理解逻辑的：当你按电视机开关时，你
      也按到了电视机。
    4.所以我们可以认为，捕获是计算机处理事件的逻辑，而冒泡是人类处理事件的逻辑。
    5.以下代码展示了事件传播顺序：
      <body>
        <input id="i"/>
      </body>

      document.body.addEventListener("mousedown", () => {
        console.log("key1")
      }, true)

      document.getElementById("i").addEventListener("mousedown", () => {
        console.log("key2")
      }, true)

      document.body.addEventListener("mousedown", () => {
        console.log("key11")
      }, false)

      document.getElementById("i").addEventListener("mousedown", () => {
        console.log("key22")
      }, false)
    6.我们监听了 body 和一个 body 的子元素上的鼠标按下事件，捕获和冒泡分别监听，可以看到，最终产生的顺序是：
      “key1”
      “key2”
      “key22”
      “key11”
    7.这是捕获和冒泡发生的完整顺序。
    8.在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。
    9.在我们实际监听事件时，我建议这样使用冒泡和捕获机制：默认使用冒泡模式，当开发组件时，遇到需要父元素控制子元素的行为，可以
      使用捕获机制。
    10.理解了冒泡和捕获的过程，我们再看监听事件的 API，就非常容易理解了。
    11.addEventListener 有三个参数：
      事件名称；
      事件处理函数；
      捕获还是冒泡。
    12.事件处理函数不一定是函数，也可以是个 JavaScript 具有 handleEvent 方法的对象，看下例子：
      var o = {
        handleEvent: event => console.log(event)
      }
      document.body.addEventListener("keydown", o, false);
    13.第三个参数不一定是 bool 值，也可以是个对象，它提供了更多选项。
      once：只执行一次。
      passive：承诺此事件监听不会调用 preventDefault，这有助于性能。
      useCapture：是否捕获（否则冒泡）。
    14.实际使用，在现代浏览器中，还可以不传第三个参数，我建议默认不传第三个参数，因为我认为冒泡是符合正常的人类心智模型的，大
      部分业务开发者不需要关心捕获过程。除非你是组件或者库的使用者，那就总是需要关心冒泡和捕获了。
  4.焦点
    1.我们讲完了 pointer 事件是由坐标控制，而我们还没有讲到键盘事件。
    2.键盘事件是由焦点系统控制的，一般来说，操作系统也会提供一套焦点系统，但是现代浏览器一般都选择在自己的系统内覆盖原本的焦点
      系统。
    3.焦点系统也是视障用户访问的重要入口，所以设计合理的焦点系统是非常重要的产品需求，尤其是不少国家对可访问性有明确的法律要求。
    4.在旧时代，有一个经典的问题是如何去掉输入框上的虚线框，这个虚线框就是 Windows 焦点系统附带的 UI 表现。
    5.现在 Windows 的焦点已经不是用虚线框表示了，但是焦点系统的设计几十年间没有太大变化。
    6.焦点系统认为整个 UI 系统中，有且仅有一个“聚焦”的元素，所有的键盘事件的目标元素都是这个聚焦元素。
    7.Tab 键被用来切换到下一个可聚焦的元素，焦点系统占用了 Tab 键，但是可以用 JavaScript 来阻止这个行为。
    8.浏览器 API 还提供了 API 来操作焦点，如：
      document.body.focus();
      document.body.blur();
    9.其实原本键盘事件不需要捕获过程，但是为了跟 pointer 设备保持一致，也规定了从外向内传播的捕获过程。
  5.自定义事件
    1.除了来自输入设备的事件，还可以自定义事件，实际上事件也是一种非常好的代码架构，但是 DOM API 中的事件并不能用于普通对象，
      所以很遗憾，我们只能在 DOM 元素上使用自定义事件。
    2.自定义事件的代码示例如下（来自 MDN）：
      var evt = new Event("look", {"bubbles":true, "cancelable":false});
      document.dispatchEvent(evt);
    3.这里使用 Event 构造器来创造了一个新的事件，然后调用 dispatchEvent 来在特定元素上触发。
    4.我们可以给这个 Event 添加自定义属性、方法。
    5.注意，这里旧的自定义事件方法（使用 document.createEvent 和 initEvent）已经被废弃。
  6.总结
    1.今天这一节课，我们讲了浏览器中的事件。
    2.我们分别介绍了事件的捕获与冒泡机制、焦点机制和自定义事件。
    3.捕获与冒泡机制来自 pointer 设备输入的处理，捕获是计算机处理输入的逻辑，冒泡是人类理解事件的思维，捕获总是在冒泡之前发生。
    4.焦点机制则来自操作系统的思路，用于处理键盘事件。除了我们讲到的这些，随着输入设备的不断丰富，还有很多新的事件加入，如 
      Geolocation 和陀螺仪等。
    5.最后给你留个小问题。请你找出你所知道的所有事件类型，和它们的目标元素类型。
  7.WIMP 的小故事
    1.WIMP 是由 Alan Kay 主导设计的，这位巨匠，同时也是面向对象之父和 Smalltalk 语言之父。
    2.乔布斯曾经受邀参观施乐，他见到当时的 WIMP 界面，认为非常惊艳，不久后就领导苹果研究了新一代麦金塔系统。
    3.后来，在某次当面对话中，乔布斯指责比尔盖茨抄袭了 WIMP 的设计，盖茨淡定地回答：“史蒂夫，我觉得应该用另一种方式看待这个
      问题。这就像我们有个叫施乐的有钱邻居，当我闯进去想偷走电视时，却发现你已经这么干了。”
    4.但是不论如何，苹果和微软的数十代操作系统，极大地发展了这个体系，才有了我们今天的 UI 界面。
9.浏览器API（小实验）：动手整理全部API
  1.你好，我是 winter。今天我们来讲讲浏览器 API。
  2.浏览器的 API 数目繁多，我们在之前的课程中，已经一起学习了其中几个比较有体系的部分：比如之前讲到过的 DOM 和 CSSOM 等等。
    但是，如果你留意过，会发现我们讲到的 API 仍然是标准中非常小的一部分。
  3.这里，我们不可能把课程变成一本厚厚的 API 参考手册，所以这一节课，我设计了一个实验，我们一起来给 API 分分类。
  4.我们按照每个 API 所在的标准来分类。所以，我们用代码来反射浏览器环境中全局对象的属性，然后我们用 JavaScript 的 filter 
    方法来逐步过滤掉已知的属性。
  5.接下来，我们整理 API 的方法如下：
    从 Window 的属性中，找到 API 名称；
    查阅 MDN 或者 Google，找到 API 所在的标准；
    阅读标准，手工或者用代码整理出标准中包含的 API；
    用代码在 Window 的属性中过滤掉标准中涉及的 API。
  6.重复这个过程，我们可以找到所有的 API 对应的标准。首先我们先把前面已经讲过的 API 过滤掉。
  7.##JavaScript 中规定的 API
  8.大部分的 API 属于 Window 对象（或者说全局对象），我们可以用反射来看一看现行浏览器中已经实现的 API，我这里使用 Mac 下
    的 Chrome 72.0.3626.121 版本。
  9.我们首先调用 Object.getOwnPropertyNames(window)。在我的环境中，可以看到，共有 821 个属性。
  10.这里包含了 JavaScript 标准规定的属性，我们做一下过滤：
    {
        let js = new Set();
        let objects = ["BigInt", "BigInt64Array", "BigUint64Array", "Infinity", "NaN", "undefined", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Array", "Date", "RegExp", "Promise", "Proxy", "Map", "WeakMap", "Set", "WeakSet", "Function", "Boolean", "String", "Number", "Symbol", "Object", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray", "Atomics", "JSON", "Math", "Reflect", "escape", "unescape"];
        objects.forEach(o => js.add(o));
        let names = Object.getOwnPropertyNames(window)
        names = names.filter(e => !js.has(e));
    }
  11.这一部分我们已经在 JavaScript 部分讲解过了（JavaScript 对象：你知道全部的对象分类吗），所以这里我就采用手工的方式过滤
    出来。
  12.DOM 中的元素构造器
    1.接下来我们看看已经讲过的 DOM 部分，DOM 部分包含了 document 属性和一系列的构造器，我们可以用 JavaScript 的 
      prototype 来过滤构造器。
      names = names.filter( e => {
          try { 
              return !(window[e].prototype instanceof Node)
          } catch(err) {
              return true;
          }
      }).filter( e => e != "Node")
    2.这里我们把所有 Node 的子类都过滤掉，再把 Node 本身也过滤掉，这是非常大的一批了。
  13.Window 对象上的属性
    1.接下来我们要找到 Window 对象的定义，我们在下面链接中可以找到。
      https://html.spec.whatwg.org/#window
    2.这里有一个 Window 接口，是使用 WebIDL 定义的，我们手工把其中的函数和属性整理出来，如下：
      window,self,document,name,location,history,customElements,locationbar,menubar, personalbar,
      scrollbars,statusbar,toolbar,status,close,closed,stop,focus, blur,frames,length,top,opener,parent,
      frameElement,open,navigator,applicationCache,alert,confirm,prompt,print,postMessage
    3.接下来，我们编写代码，把这些函数和属性，从浏览器 Window 对象的属性中去掉，JavaScript 代码如下：
      {
          let names = Object.getOwnPropertyNames(window)
          let js = new Set();
          let objects = ["BigInt", "BigInt64Array", "BigUint64Array", "Infinity", "NaN", "undefined", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Array", "Date", "RegExp", "Promise", "Proxy", "Map", "WeakMap", "Set", "WeakSet", "Function", "Boolean", "String", "Number", "Symbol", "Object", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray", "Atomics", "JSON", "Math", "Reflect", "escape", "unescape"];
          objects.forEach(o => js.add(o));
          names = names.filter(e => !js.has(e));

          names = names.filter( e => {
              try { 
                  return !(window[e].prototype instanceof Node)
              } catch(err) {
                  return true;
              }
          }).filter( e => e != "Node")

          let windowprops = new Set();
          objects = ["window", "self", "document", "name", "location", "history", "customElements", "locationbar", "menubar", " personalbar", "scrollbars", "statusbar", "toolbar", "status", "close", "closed", "stop", "focus", " blur", "frames", "length", "top", "opener", "parent", "frameElement", "open", "navigator", "applicationCache", "alert", "confirm", "prompt", "print", "postMessage", "console"];
          objects.forEach(o => windowprops.add(o));
          names = names.filter(e => !windowprops.has(e));
      }
    4.我们还要过滤掉所有的事件，也就是 on 开头的属性。
      names = names.filter( e => !e.match(/^on/))
    5.webkit 前缀的私有属性我们也过滤掉：
      names = names.filter( e => !e.match(/^webkit/))
    6.除此之外，我们在 HTML 标准中还能找到所有的接口，这些我们也过滤掉：
      let interfaces = new Set();
      objects = ["ApplicationCache", "AudioTrack", "AudioTrackList", "BarProp", "BeforeUnloadEvent", "BroadcastChannel", "CanvasGradient", "CanvasPattern", "CanvasRenderingContext2D", "CloseEvent", "CustomElementRegistry", "DOMStringList", "DOMStringMap", "DataTransfer", "DataTransferItem", "DataTransferItemList", "DedicatedWorkerGlobalScope", "Document", "DragEvent", "ErrorEvent", "EventSource", "External", "FormDataEvent", "HTMLAllCollection", "HashChangeEvent", "History", "ImageBitmap", "ImageBitmapRenderingContext", "ImageData", "Location", "MediaError", "MessageChannel", "MessageEvent", "MessagePort", "MimeType", "MimeTypeArray", "Navigator", "OffscreenCanvas", "OffscreenCanvasRenderingContext2D", "PageTransitionEvent", "Path2D", "Plugin", "PluginArray", "PopStateEvent", "PromiseRejectionEvent", "RadioNodeList", "SharedWorker", "SharedWorkerGlobalScope", "Storage", "StorageEvent", "TextMetrics", "TextTrack", "TextTrackCue", "TextTrackCueList", "TextTrackList", "TimeRanges", "TrackEvent", "ValidityState", "VideoTrack", "VideoTrackList", "WebSocket", "Window", "Worker", "WorkerGlobalScope", "WorkerLocation", "WorkerNavigator"];
      objects.forEach(o => interfaces.add(o));
      names = names.filter(e => !interfaces.has(e));
    7.这样过滤之后，我们已经过滤掉了所有的事件、Window 对象、JavaScript 全局对象和 DOM 相关的属性，但是，竟然还剩余了很多
      属性！你是不是很惊讶呢？好了，接下来我们才进入今天的正题。
  14.其它属性
    1.这些既不属于 Window 对象，又不属于 JavaScript 语言的 Global 对象的属性，它们究竟是什么呢？
    2.我们可以一个一个来查看这些属性，来发现一些我们以前没有关注过的标准。
    3.首先，我们要把过滤的代码做一下抽象，写成一个函数：
      function filterOut(names, props) {
          let set = new Set();
          props.forEach(o => set.add(o));
          return names.filter(e => !set.has(e));
      }
    4.每次执行完 filter 函数，都会剩下一些属性，接下来，我们找到剩下的属性来看一看。
  15.ECMAScript 2018 Internationalization API
    1.在我的浏览器环境中，第一个属性是：Intl。
    2.查找这些属性来历的最佳文档是 MDN，当然，你也可以使用 Google。
    3.总之，经过查阅，我发现，它属于 ECMA402 标准，这份标准是 JavaScript 的一个扩展，它包含了国际化相关的内容：
      http://www.ecma-international.org/ecma-402/5.0/index.html#Title
    4.ECMA402 中，只有一个全局属性 Intl，我们也把它过滤掉：
      names = names.filter(e => e != "Intl")
    5.再来看看还有什么属性。
  16.Streams 标准
    1.接下来我看到的属性是： ByteLengthQueuingStrategy。
    2.同样经过查阅，它来自 WHATWG 的 Streams 标准：
      https://streams.spec.whatwg.org/#blqs-class
    3.不过，跟 ECMA402 不同，Streams 标准中还有一些其它属性，这里我手工查阅了这份标准，并做了整理。
    4.接下来，我们用代码把它们跟 ByteLengthQueuingStrategy 一起过滤掉：
      names = filterOut(names, ["ReadableStream", "ReadableStreamDefaultReader", "ReadableStreamBYOBReader", 
      "ReadableStreamDefaultController", "ReadableByteStreamController", "ReadableStreamBYOBRequest", 
      "WritableStream", "WritableStreamDefaultWriter", "WritableStreamDefaultController", "TransformStream", 
      "TransformStreamDefaultController", "ByteLengthQueuingStrategy", "CountQueuingStrategy"]);
    5.好了，过滤之后，又少了一些属性，我们继续往下看。
  17.WebGL
    1.接下来我看到的属性是：WebGLContext​Event。
    2.显然，这个属性来自 WebGL 标准：
      https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15
    3.我们在这份标准中找到了一些别的属性，我们把它一起过滤掉：
      names = filterOut(names, ["WebGLContextEvent","WebGLObject", "WebGLBuffer", "WebGLFramebuffer", 
      "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLTexture", "WebGLUniformLocation", 
      "WebGLActiveInfo", "WebGLShaderPrecisionFormat", "WebGLRenderingContext"]);
    4.过滤掉 WebGL，我们继续往下看。
  18.Web Audio API
    1.下一个属性是 WaveShaperNode。这个属性名听起来就跟声音有关，这个属性来自 W3C 的 Web Audio API 标准。
    2.我们来看一下标准：
      https://www.w3.org/TR/webaudio/
    3.Web Audio API 中有大量的属性，这里我用代码做了过滤。得到了以下列表：
      ["AudioContext", "AudioNode", "AnalyserNode", "AudioBuffer", "AudioBufferSourceNode", 
      "AudioDestinationNode", "AudioParam", "AudioListener", "AudioWorklet", "AudioWorkletGlobalScope", 
      "AudioWorkletNode", "AudioWorkletProcessor", "BiquadFilterNode", "ChannelMergerNode", 
      "ChannelSplitterNode", "ConstantSourceNode", "ConvolverNode", "DelayNode", "DynamicsCompressorNode", 
      "GainNode", "IIRFilterNode", "MediaElementAudioSourceNode", "MediaStreamAudioSourceNode", 
      "MediaStreamTrackAudioSourceNode", "MediaStreamAudioDestinationNode", "PannerNode", "PeriodicWave", 
      "OscillatorNode", "StereoPannerNode", "WaveShaperNode", "ScriptProcessorNode", "AudioProcessingEvent"]
    4.于是我们把它们也过滤掉：
      names = filterOut(names, ["AudioContext", "AudioNode", "AnalyserNode", "AudioBuffer", 
      "AudioBufferSourceNode", "AudioDestinationNode", "AudioParam", "AudioListener", "AudioWorklet", 
      "AudioWorkletGlobalScope", "AudioWorkletNode", "AudioWorkletProcessor", "BiquadFilterNode", 
      "ChannelMergerNode", "ChannelSplitterNode", "ConstantSourceNode", "ConvolverNode", "DelayNode", 
      "DynamicsCompressorNode", "GainNode", "IIRFilterNode", "MediaElementAudioSourceNode", 
      "MediaStreamAudioSourceNode", "MediaStreamTrackAudioSourceNode", "MediaStreamAudioDestinationNode", 
      "PannerNode", "PeriodicWave", "OscillatorNode", "StereoPannerNode", "WaveShaperNode", 
      "ScriptProcessorNode", "AudioProcessingEvent"]);
    5.我们继续看下一个属性。
  19.Encoding 标准
    1.在我的环境中，下一个属性是 TextDecoder，经过查阅得知，这个属性也来自一份 WHATWG 的标准，Encoding：
      https://encoding.spec.whatwg.org/#dom-textencoder
    2.这份标准仅仅包含四个接口，我们把它们过滤掉：
      names = filterOut(names, ["TextDecoder", "TextEncoder", "TextDecoderStream", "TextEncoderStream"]);
    3.我们继续来看下一个属性。
  20.Web Background Synchronization
    1.下一个属性是 SyncManager，这个属性比较特殊，它并没有被标准化，但是我们仍然可以找到它的来源文档：
      https://wicg.github.io/BackgroundSync/spec/#sync-manager-interface
    2.这个属性我们就不多说了，过滤掉就好了。
  21.Web Cryptography API
    1.我们继续看下去，下一个属性是 SubtleCrypto，这个属性来自 Web Cryptography API，也是 W3C 的标准。
      https://www.w3.org/TR/WebCryptoAPI/
    2.这份标准中规定了三个 Class 和一个 Window 对象的扩展，给 Window 对象添加了一个属性 crypto。
      names = filterOut(names, ["CryptoKey", "SubtleCrypto", "Crypto", "crypto"]);
    3.我们继续来看。
  22.The Screen Orientation API
    1.下一个属性是 ScreenOrientation，它来自 W3C 的 The Screen Orientation API 标准：
      https://www.w3.org/TR/screen-orientation/
    2.它里面只有 ScreenOrientation 一个接口，也是可以过滤掉的。
  23.结语
    1.到 Screen Orientation API，我这里看到还剩 300 余个属性没有处理，剩余部分，我想把它留给大家自己来完成。
    2.我们可以看到，在整理 API 的过程中，我们可以找到各种不同组织的标准，比如：
      ECMA402 标准来自 ECMA；
      Encoding 标准来自 WHATWG；
      WebGL 标准来自 Khronos；
      Web Cryptography 标准来自 W3C；
      还有些 API，根本没有被标准化。
    3.浏览器环境的 API，正是这样复杂的环境。我们平时编程面对的环境也是这样的一个环境。
    4.所以，面对如此繁复的 API，我建议在系统掌握 DOM、CSSOM 的基础上，你可以仅仅做大概的浏览和记忆，根据实际工作需要，选择
      其中几个来深入学习。
    5.做完这个实验，你对 Web API 的理解应该会有很大提升。
    6.这一节课的问题就是完成所有的 API 到标准的归类，不同的浏览器环境应该略有不同，欢迎你把自己的结果留言一起讨论。
### 原型

* 每个 class 都有显示原型 prototype

* 每个实例都有隐式原型 \_\_proto\_\_

* 实例的隐式原型 \_\_proto\_\_ 指向对应 class 的显示原型 prototype

* prototype 中有一个 constructor 属性，用来引用它的构造函数，Person.prototype.constructor === Person，这是一种循环引用。




### 原型链

我们把这个由 \_\_proto\_\_ 串起来的直到 Object.prototype.\_\_proto\_\_ 为 null 的链叫做原型链。

对象在获取属性或方法的时候，先在自身的属性和方法中寻找，如果找不到则顺着隐式原型 \_\_proto\_\_ 指向的原型链一直向上查找。

原型链关系：

```js
var zjh = new Person()
zjh.__proto__ === Person.prototype 
Person.prototype.__proto__ === Object.prototype 
Object.prototype.__proto__ === null 
        
Object.__proto__ === Function.prototype 
Function.__proto__ === Function.prototype 
Function.prototype.__proto__ === Object.prototype 
Object.prototype.__proto__ === null // 原型链顶端
```

instanceof：

instanceof 是判断一个对象是由哪个 class 构建出来的，由于父类也参与了构建实例的一部分，所以 instanceof 父类得到的也是 true，instanceof 也是顺着原型链往上找的。Object 是所有类的父类，所有对象都是继承自 Object，它是原型链的末端。

```js
[] instanceof Array // true
[] instanceof Object // true
{} instanceof Object // true

xialuo instanceof Student // true
xialuo instanceof People // true
xialuo instanceof Object // true
```



### 继承

继承就是从抽象到具象的一个关系，从高级到低级的一个关系。

#### 对象冒充继承

this 是函数调用的时候才确定的，用要继承的对象来调用函数，这个对象就变成了函数的 this，也就继承了函数 this 上的属性和方法。

##### 对象冒充内部实现原理

哪个函数要被继承，就调用哪个函数。用继承的对象调用。

```js
function ClassA(sColor) {
  this.color = sColor
  this.sayColor = function () {
    alert(this.color)
  }
}
function ClassB(sColor) {
  this.newMethod = ClassA
  this.newMethod(sColor)
  delete this.newMethod 
  // 以上三步就是call和apply内部实现的核心步骤
}
```

##### call,apply,bind

call 和 apply 关注的就是 this 和传参两件事。

call 和 apply 可以用来重新定义函数的 this 指向，就是将传进去的对象替换掉函数的 this，使对象拥有这个函数内部用 this 定义的属性和方法，从而达到继承的目的。

```js
function ClassA () {
	this.a = 123
}
var obj = {}
console.log(obj.a) // undefined
classA.call(obj)
console.log(obj.a) // 123
```

call 和 apply 可以实现多重继承，一个子类能够继承多个父类，F1 可以同时从 F2, F3 ... 继承。

call 和 apply 改变了函数的 this，并且执行了该函数，而 bind 是改变了函数的 this，但并不会立即执行函数，而是返回一个绑定了 this 的新函数。

bind 的作用与 call 和 apply 一样，都是可以改变函数运行时上下文，区别是 call 和 apply 在调用函数之后会立即执行，而 bind 方法调用并改变函数运行时上下文后，返回一个新的函数，供我们需要时再调用。

##### call apply bind 方法的内部实

https://www.cnblogs.com/echolun/p/12144344.html
https://www.cnblogs.com/guaidianqiao/p/7762205.html
https://www.cnblogs.com/echolun/p/12178655.html

call

```js
// es5
Function.prototype.call_ = function (obj) {
  //判断是否为null或者undefined,同时考虑传递参数不是对象情况
  obj = obj ? Object(obj) : window
  var args = []
  // 注意i从1开始
  for (var i = 1, len = arguments.length; i < len; i++) {
  	args.push("arguments[" + i + "]")
  };
  obj.fn = this // 此时this就是函数fn
  var result = eval("obj.fn(" + args + ")") // 执行fn
  delete obj.fn // 删除fn
  return result
}

// es6
Function.prototype.call_ = function (obj) {
  obj = obj ? Object(obj) : window
  obj.fn = this
  // 利用拓展运算符直接将arguments转为数组
  let args = [...arguments].slice(1)
  let result = obj.fn(...args)
  delete obj.fn
  return result
}
```

apply   

```js
// es5
Function.prototype.apply_ = function (obj, arr) {
  obj = obj ? Object(obj) : window
  obj.fn = this
  var result
  if (!arr) {
    result = obj.fn()
  } else {
    var args = []
    // 注意这里的i从0开始
    for (var i = 0, len = arr.length; i < len; i++) {
      args.push("arr[" + i + "]")
    }
    result = eval("obj.fn(" + args + ")") // 执行fn
  }
  delete obj.fn //删除fn
  return result
}

// es6
Function.prototype.apply_ = function (obj, arr) {
  obj = obj ? Object(obj) : window
  obj.fn = this
  let result
  if (!arr) {
    result = obj.fn()
  } else {
    result = obj.fn(...arr)
  }
  delete obj.fn
  return result
}
```

bind

```js
// es5 方法1
Function.prototype.bind1 = function () {
  // 将函数参数解析为数组
  const args = Array.prototype.slice.call(arguments)
  // 获取 this (取出数组第一项，数组剩余的就是传递的参数)
  const t = args.shift()
  const self = this // 当前函数
  // 返回一个函数
  return function () {
    // 执行原函数，并返回结果
    return self.apply(t, args)
  }
}
// 使用
function fn1 (a, b, c) {
  console.log('this', this)
  console.log(a, b, c)
  return 'this is fn1'
}
const fn2 = fn1.bind({x: 100}, 10, 20, 30)
const res = fn2()
console.log(res)

// es5 方法2
Function.prototype.bind_ = function (obj) {
  if (typeof this !== "function") {
    throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
  };
  var args = Array.prototype.slice.call(arguments, 1);
  var fn = this;
  // 创建中介函数
  var fn_ = function () {};
  var bound = function () {
    var params = Array.prototype.slice.call(arguments);
    // 通过constructor判断调用方式，为true this指向实例，否则为obj
    fn.apply(this.constructor === fn ? this : obj, args.concat(params));
    console.log(this);
  };
  fn_.prototype = fn.prototype;
  bound.prototype = new fn_();
  return bound;
}

// es6
Function.prototype.bind = function(thisArg) {
  if(typeof this !== 'function'){
    throw new TypeError(this + 'must be a function')
  }
  // 存储函数本身
  const _this  = this
  // 去除thisArg的其他参数 转成数组
  const args = [...arguments].slice(1)
  // 返回一个函数
  const bound = function() {
    // 可能返回了一个构造函数，我们可以 new F()，所以需要判断
    if (this instanceof bound) {
      return new _this(...args, ...arguments)
    }
    // apply修改this指向，把两个函数的参数合并传给thisArg函数，并执行thisArg函数，返回执行结果
    return _this.apply(thisArg, args.concat(...arguments))
  }
  return bound
}
```

##### call apply 应用场景

检验数据类型：

```js
function type(obj) {
  var regexp = /\s(\w+)\]/
  var result =  regexp.exec(Object.prototype.toString.call(obj))[1]
  return result
}
console.log(type([123]))      // Array
console.log(type('123'))      // String
console.log(type(123))        // Number
console.log(type(null))       // Null
console.log(type(undefined))  // Undefined
```

数组取最大/小值：

```js
var arr = [11, 1, 0, 2, 3, 5];
// 取最大
var max1 = Math.max.call(null, ...arr)
var max2 = Math.max.apply(null, arr)
// 取最小
var min1 = Math.min.call(null, ...arr)
var min2 = Math.min.apply(null, arr)
```

伪数组转数组：

```js
var fn = function () {
  var arr = Array.prototype.slice.call(arguments)
  console.log(arr) // [1, 2, 3, 4]
};
fn(1, 2, 3, 4);
```

#### 原型链继承

对象继承类

```js
o.__proto__ = F.prototype  
```

类继承类

```js
F1.prototype.__proto__ = F2.prototype
```

#### 混合方式继承

对象冒充可以传参数和继承构造函数内部属性，但是不能继承到原型，原型链可以继承原型，但是不能传参数也不能继承构造函数内部，所以要使用混合模式。

```js
// ClassA
function ClassA(sColor) {
  this.color = sColor
}
ClassA.prototype.sayColor = function() {
  alert(this.color)
}
// ClassB继承ClassA
function ClassB(sColor, sName) {
  ClassA.call(this, sColor)
  this.name = sName
}
ClassB.prototype.__proto__ = ClassA.prototype

//new和es6的extends实现的继承就是上面的这两个方式的结合。
```

#### class 和继承

class 是面向对象的一个语法实现。class 本质上类似于一个模版，我们可以通过这个模版去构建一些东西。构建的时候，我们可以去复制上一些属性和方法。

当我们有很多个 class，这个 class 中有一些比较通用的属性的时候，我们就可以把它抽离出来。通过 extends 这个关键字来做继承。里面通过 super 来执行父类的构造函数，然后扩展和重写它的一些方法。

```js
// es6 类继承
class People {}
class Student extends People {}
// Student继承于People，所以Student的原型的隐式原型正好指向People的显示原型。
console.log(Student.prototype.__proto__ === People.prototype) // true

console.log(People.prototype.__proto__ === Object.prototype) // true
console.log(Object.prototype.__proto__ === null) // true 原型链顶端
```

#### new 继承

构造函数创建实例的过程本身就是一种继承，new 的内部其实是做了继承里面的合体工作

```js
ClassB.prototype = new ClassA()
```

new 操作符的作用：new Fn(arguments) 的时候 js 内部就会调用下面这个 New 函数

```js
function New (Fn, arguments) {
  var o = {}									 // 创建一个新对象
  o.__proto__ = Fn.prototype	 // 继承构造函数的原型
  Fn.apply(o, arguments)		   // 继承构造函数内部，并传参     
  return o                     // 如果构造器返回的是对象，则返回，否则返回第一步创建的对象。
}   
```



### 原型应用

#### 手写一个简易的 jquery

```js
// jquery是做dom查询的，所以首先constructor里面要传入一个selector
class jQuery {
  constructor (selector) {
    const result = document.querySelectorAll(selector)
    const length = result.length
    for (let i = 0; i < length; i++) {
  		this[i] = result[i]
    }
    this.length = length
    this.selector = selector
  }
  get (index) {
    return this[index]
  }
  each (fn) {
    for (let i = 0; i < this.length; i++) {
    const elem = this[i]
    fn(elem)
  	}
	}
  on (type, fn) {
    return this.each(elem => {
      elem.addEventListener(type, fn, false)
    })
  }
	// 可以扩展很多dom 操作 api
  // ...
}
// 使用
const $p = new jQuery('p')
$p.get(1)
$p.each(elem => console.log(elem.nodeName))
$p.on('click', elem => console.log('clicked'))
```

#### 插件和扩展性

1.插件：直接往原型里添加方法

```js
// 这就是所谓的jquery插件
jQuery.prototype.dialog = function (info) {
  alert(info)
}
$p.dialog('abc')就有了
```

2.扩展性：继承后，扩展自己的新方法。

```js
class myJQuery extends jQuery {
  constructor (selector) {
    super(selector) // super执行父类的构造函数，就可以把jQuery这个父类的构造函数内部的复杂性全部包含，不用再把jQuery构造函数里面复杂的逻辑写一遍。
  }
  // 扩展自己的方法，造一个新轮子
  addClass (classname) {
    
  }
  style (data) {

  }
}
```

### 布局发展历程

* 早期以 table 为主，因为表格的解析并不是流式的，如果表格很长，浏览器会把整个表格的代码拉完之后才会解析，会造成用户等待的时间过长。现代浏览器这个问题其实已经不存在了，所以可以适当使用 table 布局。
* 后来以技巧性布局为主的经典，并不是主要用来布局的，这些方法会遇到很多困难。
* 现在有 flexbox / grid，正统的专门用来布局的。



### 什么是布局

简单来说就是 HTML 页面的整体结构或骨架，类似于传统的报纸或杂志中的排版。

没有一招鲜吃遍天的解决方案。



### 表格布局

后来的 css 规范中，可以设定一个元素长得像表格。

```css
table {
  width: 800px;
  height: 200px;
  border-collapse: collapse;
}
.table {
  width: 800px;
  height: 200px;
	display: table;
}
.table-row {
  display: table-row;
}
.table-cell {
  display: table-cell;
}
.left { background-color: lightgreen;}
.right { background-color: lightblue;}
```

```html
<table>
  <tr>
    <td class="left">左</td>
    <td class="right">右</td>
  </tr>
</table>
<div class="table">
  <div class="table-row">
    <div class="table-cell left">左</div>
    <div class="table-cell right">右</div>
  </div>
</div>
```



### inline-block 布局

像文本一样排 block 元素。

需要处理间隙：因为文字之间是有间隙的，所以每个 inline-block 的元素之间也存在间隙。解决办法是把父元素的字体大小设为 0。在里面的元素设置相应的字体大小。或者把空白去掉或改成注释。

缺点：做自适应比较困难。比较适合做定宽的布局。



### float 布局

浮动元素会脱离文档流，但是不会脱离文本流。这种布局方式正是 float 本身的含义，float 本来就是用来做类似于图文混排的文字环绕之类的效果的。

浮动元素会形成“块”（BFC）。

#### 清除浮动

为什么要清除浮动：

* 浮动元素不会占据父元素的布局空间，父元素布局的时候不会去管浮动元素，有可能浮动元素就会超出父元素从而对其他的元素产生影响，所以作为父元素一定要清除浮动，保证对外面是无害的，不会影响其他元素。

* 解决浮动元素的父元素高度塌陷的问题。

##### 1. 父级添加 overflow 属性（父元素添加 overflow: hidden; ）（不推荐）

通过触发 BFC 方式（就是负责接管自己的宽高），实现清除浮动。

```css
.fahter {
  /* 设置了overflow 属性，父元素就需要知道内容的高度来设置相应的行为，所以这种方式就可以阻止高度塌陷，从而清除浮     			动 */
  overflow: hidden; /* auto 也可以 */
}
```

优点：代码简洁。

缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素。

##### 2. 额外标签法（不推荐）

在最后一个浮动标签后，新加一个标签，给其设置 clear: both; 

优点：通俗易懂，方便。

缺点：添加无意义标签，语义化差。

##### 3. 使用 after 伪元素清除浮动（推荐使用）

有一个元素超出浮动元素的部分，刚好到浮动元素的最下面，这时父级可以根据这个元素而被撑起来，撑起来的位置刚好是浮动元素的最下面，就刚好是整个父级应有的高度。

```css
.clearfix::after {/*正常浏览器清除浮动方法*/
  content: " ";
  display: block; /* 伪元素默认是 inline 的，inline 元素无法帮我们做清除浮动的事情。 */
  height: 0;
  /* 
  	clear: both;的意思是保证这个元素的左右两边都是干净的，没有浮动元素，因为这个浮动元素是尽量靠上的，所以这个			元素只能在浮动元素的下方才能保证左右都没有浮动元素，这个位置就是放置 clear: both; 元素的地方。就是靠这个元		素把父级撑起来，从而把浮动的影响去掉，解决高度塌陷。
  */
  clear: both; 
  visibility: hidden;
  overflow：hidden;
}
.clearfix {
  *zoom: 1; /*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
}
```

##### 4. 使用 before 和 after 双伪元素清除浮动（推荐使用）（万能清除法）

```css
.clearfix::before, .clearfix::after {
  display: block;
  content: " ";
}
.clearfix::after {
  clear: both;
}
.clearfix {
  *zoom: 1; /*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
}
```



### flexbox 布局

标准提供的真正用于布局的方式。

* 弹性盒子：每个盒子是有弹性的，可以伸缩的。
* 盒子本来就是并列的，解决了并列的问题，布局基本就解决了。因为纵向就是一个一个堆叠起来的，不需要我们做任何事情。所以布局的难点就是怎么把块横向的堆叠起来。
* 指定宽度即可。提供了更多关于宽度的控制。

可以指定盒子的对齐方式，占不满空间时和占多了空间时怎么办，要不要换行，指定顺序。

flexbox 的写法中间有过三次变更，每个浏览器兼容的写法不一样，所以要写很多兼容的写法来兼容不同浏览器。这样大部分的浏览器是可以兼容的。react native 和微信小程序可以直接用 flex 布局。



### grid 布局



### 自适应

同一个页面在不同尺寸的屏幕下，页面都能完美呈现。

自适应的一些概念：

* 像素：https://github.com/jawil/blog/issues/21
* viewport
* rem
  * css单位
  * 根据跟标签html的字体大小进行计算
  * em是相对于父元素字体大小进行计算
* http://www.woshipm.com/ucd/198774.html
  * 分辨率(像素) 1920PX * 1080PX
  * 设备尺寸 5.2英寸
  * 像素密度(ppi, 每英寸所拥有的像素数目)
    * ppi = √(横向^2 + 纵向^2) / 屏幕尺寸(inch)
  * 小结：
    * 我们平时做的适配就是关心的分辨率而不是屏幕尺寸。
    * 在同一个设备上，它的像素个数和像素大小是固定的了，也就是系统的最高分辨率，这是厂商在出厂时就设置好了的，只有不同的设备之间，才有像素大小的区别。像素这个东西，就像金箍，能变大能变小。系统调节分辨率是使用虚拟色彩块来充当部分像素块，以达到降低分辨率的效果。
    * 像素密度是决定屏幕显示清晰度的。也就是分辨率和尺寸大小共同决定的。



### 响应式

同一个页面在不同尺寸的屏幕下，元素的排列、展示的形式都会不同。

企业站、资讯类等等页面结构简单的网站，适合响应式。

优点：

* 节省成本，只写一套网页就能让多种终端完美适配

缺点：

* 有兼容问题，低版本浏览器不兼容
* 页面体积会变大，移动端访问耗费流量，响应速度变慢
* 代码冗余，开发难度增大

主要方法：

* 设计的支持：隐藏 + 折行 + 自适应空间

* 技术实现

  * rem：通过 html 的字体大小来确定元素大小，使用这个单位进行布局，针对不同大小的屏幕给出不同大小的字号，元素就会跟着缩放。rem 有时换算完是不精准的。

  * viewport：确定要将页面整个界面放到多大。

  * media query：媒体查询，根据不同设备的特性来匹配不同的样式，给小屏和大屏分别写一套样式。大屏幕的样式写在上面，优先满足小屏。

    ```css
    @media screen and (min-width:750px){
      section div{
        width: 50%;
      }
    }
    ```



### 移动端布局

响应式百分比布局

百分比  flex布局  vw vh    rem

@media


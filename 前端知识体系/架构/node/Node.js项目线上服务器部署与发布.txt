生产环境所需要素
1.购买自己的域名
2.购买自己的服务器
3.域名备案
4.配置服务器应用环境
    用户的权限
    无密码的登陆
    nodejs应用的环境
    必备的包和组件的安装搭建 
    端口的转发
    ssl证书的生成和配置
    nginx的安装和配置
    防火墙
    本地数据库自动备份的机制
5.安装配置数据库
    数据库的角色
    读写的权限
    自动备份的机制
6.项目远程部署发布与更新

部署之路

购买域名
    1.域名厂商
        爱名网，阿里云，DNSPod
    2.域名选择的方法和习惯
        不要选择混合域名，要么纯数字要么纯英文，便于传播，纯英文>纯数字>纯拼音。
        域名越短越好。
        不要选择太个性化的后缀。.com .cn .net .cc，.cn比较便宜

主机选择
    1.现在是云的时代，许多公司的服务器也通常是部署在云上的，不需要再像以前去跑到某个机房里去换配件，加网线，装系统等，
      现在通过云主机可以很方便的连上主机对外提供服务
    2.选择知名的大厂商，尽量选择国内的厂商
    3.阿里云主机的选购流程
        产品 云计算基础服务 弹性计算 云服务器ECS 
        入门配置 镜像版本选择吴邦图 14.04 64位

域名备案
    在阿里云购买的域名和服务器就可以在阿里云上进行备案

远程登陆服务器
    1.ssh 用户名@主机
    输入密码

    fdisk -l 查看服务器上的磁盘
    df -h 查看硬盘使用情况
    control + d 退出当前的命令行环境

    使用其他用户而不是root这个超级权限的管理员的身份进去登陆服务器进行各种操作，因为会很危险，可能会删掉或修改掉一些敏感文件的内容
    如果我们是通过一个相对低权限的用户来操作现对不那么敏感的一些内容的话，那整个运维的安全性就能得到一个提升
    配置root权限的一些账号
    
    2.增加用户
    adduser 用户名 
    输入这个用户的密码
    输入用户的信息

    对刚刚创建的用户进行授权
    gpasswd -a 用户名 sudo
    通过pgasswd可以让这个用户它以sudo的角色来调用系统命令，这样它有一个相对比较高的权限能够调用到只有超级权限才能调用到的一些命令，但是必须输入密码
    这时这个用户就进入到了sudo这个组里面去了

    sudo visudo
    找到# User privilege specification
    增加一行
    用户名 ALL=(ALL:ALL) ALL

    service ssh restart 重启ssh这个功能

    3.通过私钥认证的方式无密码登陆服务器
        本地操作
            1.生成ssh公钥，私钥
                ssh-keygen -t rsa -b 4096 -C "v_zhaoyang09@baidu.com"
            2.开启ssh代理
                eval "$(ssh-agent -s)"
            3.将ssh的key加入代理中
                ssh-add ~/.ssh/id_rsa
            走到这本地就有了配置好的钥匙文件了
        服务器操作
            123同上
            4.在.ssh目录下执行一个动作来创建一个授权文件
                vi authorized_keys
            5.将想要登陆到这台服务器的本地的电脑的公钥放到上面创建的授权文件里面去。当电脑来登陆这个服务器的时候呢，这个服务器会验证
            它提交过来的私钥以及它之前拷贝过来的公钥，当它算法匹配之后，这个服务器才会向它敞开大门
            这时服务器上就持有了弄台电脑上的公钥，那么这台电脑就可以来登陆这个服务器了，而且是不需要输密码的情况下来登陆
            6.chmod 600 authorized_keys
            sudo service ssh restart
            sudo就是让用户以root的权限来操作一些敏感的命令，这时要输入的密码就是root用户的密码

修改服务器默认登陆端口
    1.修改配置文件
    sudo vi /etc/ssh/sshd_config
    端口的范围是0～65536，0～1024通常被系统程序所占用，而且必须以root的身份才能启动。
    Port 39999
    UseDNS no
    AllowUsers 用户名
    2.重启ssh服务
    sudo service ssh restart
    3.再次登陆服务器使用
    ssh -p 39999 用户名@120.26.235.4
    4.关闭root密码登陆
    因为此时的用户已经拥有了root所有的权限，所以为了安全考虑就禁用掉root这个用户来登陆服务器
    sudo vi /etc/ssh/sshd_config
    PermitRootLogin no
    PasswordAuthentication no
    PermitEmptyPasswords no
    5.重启ssh服务
    sudo service ssh restart

control + a 光标到头
control + e 光标到尾

配置iptables和Fail2Ban增强安全防护
    iptables
        1.升级更新吴邦图
        sudo apt-get update && sudo apt-get upgrade  
        2.清空现有的iptables规则
        sudo iptables -F
        3.添加规则
        sudo vi /etc/iptables.up.rules
        *filter
        -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 允许所有建立起来的连接
        -A OUTPUT -j ACCEPT # 允许所有出去的流量
        -A INPUT -p tcp --dport 443 -j ACCEPT # 允许https这种协议下的请求的连接
        -A INPUT -p tcp --dport 80 -j ACCEPT # 允许http这种协议下的请求的连接。(所有的网站理论上来说访问一台服务器的话都是从80端口进去的)
        -A INPUT -p tcp -m state --state NEW --dport 39999 -j ACCEPT # 为ssh这种登陆方式来建立通道
        -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT # 允许从外网某台服务器上来ping到这台服务器，为了我们方便测试服务器有没有停机啊或者是某个机房的网络不通啊光缆被挖断啊，我们都是通过ping这种方式
        -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables denied:" --log-level 7 # 记录下来这些被拒绝的请求
        -A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --set # 对恶意访问网站的ip加以拦截，恶意的频繁的访问
        -A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --update --seconds 60 --hitcount 150 -j DROP # 对恶意访问网站的ip加以拦截
        -A INPUT -j REJECT # 拒绝所有其他的这些进到服务器的流量
        -A FORWARD -j REJECT # 拒绝所有其他的这些进到服务器的流量
        COMMIT
        4.写好配置项之后呢，就要告诉iptables这个配置文件在哪里
        sudo iptables-restore < /etc/iptables.up.rules
        5.查看防火墙有没有被成功的建立起来，有没有成功的启动
        sudo ufw status
        6.激活防火墙ufw
        sudo ufw enable
        7.防火墙建立起来之后呢，我们需要把这个路径设置一下，我们让它可以开机之后自动启动，因为有时候可能会有停机之类的操作，我们通过创建shell脚本来做。
        sudo vi /etc/network/if-up.d/iptables
        #!/bin/sh 通过这个我们来指定它是一个可执行的脚本 
        iptables-restore /etc/iptables.up.rules
        再给予这个脚本它执行的权限。+x是执行的意思
        sudo chmod +x /etc/network/if-up.d/iptables

        这样就配置好了iptables
    Fail2Ban安防模块
        1.它可以看作是一个防御性的动作库，通过监控系统的日志文件，根据检测到的任何可疑的行为可以触发不同的环境动作，比如说将产生可疑行为的目标执行一个ip锁定等等
        2.安装
        sudo apt-get install fail2ban
        3.安装之后打开配置文件
        sudo vi /etc/fail2ban/jail.conf
        bantime = 3600
        destemail = 自己邮箱
        action = %(action_mw)s
        4.查看fail2ban有没有运行
        sudo service fail2ban status
        5.停掉fail2ban
        sudo service fail2ban stop
        5.开启fail2ban
        sudo service fail2ban start

    综上都是一些基础性的相对比较简单的安全配置，这些配置都算是举手之劳，却可以让一台很裸的服务器大大提高安全的一个防护等级，虽然目前等级还不够，但是比起一台裸的服务器
    已经高了很多了，那对付一些常规简单的恶意行为也是绰绰有余，如果想要更高的安全等级，需要我们做更多的运维知识的储备，就比如说我们可以对这个生产的服务器它的登陆设置一个
    ip的绑定或者是限制，只有特定内网的ip的及其才能登陆到这台服务器。也就是我们通俗所讲的在内网架设一台跳板机，通过我们本地的电脑连上跳板机，再从跳板机登陆到生产服务器

搭建服务器nodejs生产环境
    1.在安装之前对系统更新一下
    sudo apt-get update
    2.安装相关的模块或者包文件
    sudo apt-get install vim openssl build-essential libssl-dev wget curl git
    3.安装nodejs,我们会选用nvm这个工具方便升级和管理nodejs不同的版本
    到github上去搜索nvm，在它里面找到这个脚本curl或者wget，拷贝这段脚本在服务器上去执行，它就会自己去下载这个脚本然后去执行脚本里面的内容，来下载nvm
    4.再打开一个终端重新登陆到服务器
    输入nvm，就会出现很多的命令的一些用法和提示，说明我们已经把这个工具给安装上去了
    5.安装nodejs
    nvm install v6.9.5
    6.安装完毕了，我们需要把这个版本来指定一下啊
    nvm use v6.9.5
    nvm alias default v6.9.5
    7.查看node版本
    node -v
    8.指定npm下载源为淘宝的源
    npm --registry=https://registry.npm.taobao.org install -g npm
    9.查看你怕吗版本
    npm -v
    10.增加系统文件监控数目
    echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p
    11.安装cnpm替代npm
    npm --registry=https://registry.npm.taobao.org install -g cnpm
    12.查看cnpm版本
    cnpm -v
    13.node安装完毕后，顺手把一些常用的工具就是全局的工具包也安装一下
    npm i pm2 webpack gulp grunt-cli
    14.现在服务器上node环境已经是完备了，我们现在来测试一下
    用户的根目录下，我们创建一个文件吧
    vi app.js
    const http = require('http')
    http.createServer(function (req, res) {
        res.writeHead(200, {'Content-Type': 'text/plain'})
        res.end('来自幕客的力量')
    }).listen(8081)
    console.log('server running on http://120.26.235.4:8081/')
    14.通过node启动这个服务器脚本
    node app.js
    此时我们通过浏览器访问这个地址http://120.26.235.4:8081/，就能访问成功并成功返回服务端返回的结果了。
    那么我们现在就访问到了服务器，通过ip加端口这种方式访问到了服务器上返回的纯文本

借助pm2让nodejs服务常驻
    我们想要把一个静态站点开起来其实是需要满足两个条件的
        1.这个静态站点可以持续而且是稳定的提供对外的web服务
        2.这个站点可以从外网直接访问到，比如说通过域名或者是ip的方式来访问到
    1.让服务可以持续的稳定的运行 
    在终端启动的这个node服务，其实它的生命周期就仅限于终端的当前的会话周期，如果说终端关掉了，或者是在终端里面退出了，那其实这个服务就中断了，
    那显然这个不是我们想要的一个结果，我们想要的是不仅仅是服务可以在后台运行，而且是可以在出现异常的时候可以做到自动重启，那么这里我们会用到pm2
    这个nodejs部署还有进程管理的工具
    2.安装pm2到全局
    npm install pm2 -g
    3.安装之后其实就非常简单，我们就在项目的根目录下，我们可以直接通过
    pm2 start app.js
    就能够把这个服务跑起来
    4.跑起来之后呢，我们可以通过
    pm2 list
    来列出这台服务器上当前所运行的这些个node服务都有哪一些
    5.查看某一个应用它的详细的信息
    pm2 show app
    app是应用的名字
    6.查看当前实时的日志
    pm2 logs
    这里我们就能看到应用启动之后所打印的这些信息，这边都有
    7.这时我们的这个服务已经是在服务器中稳定的运行了，那么这就是pm2它的一个神奇的效果，能够帮我们去运维我们node这个服务本身，出现异常的时候呢，
    可以帮我们去做自动重启，包括这些异常日志的一个收集等等
    8.这样我们就解决掉第一个问题了

配置nginx反向代理nodejs端口
    现在我们解决上一章提到的第二个问题，让web服务可以通过80端口被外网所访问到。
    目前我们是跑在8081这个端口，通过80端口是没法启动的，原因是我们imooc_manager这个用户下nodejs是不具备root的运行权限的，所以不能监听0～1024之间的
    任何一个端口，当然也包括80端口，强制通过sudo的话来启动node服务也不是不可以，一个是我们需要额外的去配置，一个是我们需要放大node程序的一个权限，这多
    少会带来一些额外的风险还有成本。我们先不通过域名来访问，我们先直接通过ip来达到访问的效果的怎么做呢，那解决这个问题的话我们就需要引入nginx，用root级
    别的权限来启动对80端口的监听，同时把来自80端口的流量分配给node服务的另外一个端口，实现这种服务的一个代理，那如果服务器只需要放一个网站程序的话，那解
    析网站到服务器的一个网址，网站程序监听80端口就可以了。那如果是服务器有很多个应用，借助nginx的话不仅可以实现端口的一个代理，还可以实现负载均衡，让它
    来判断是来自哪个域名或者是ip的一个访问，从而根据一个配置的规则将这个请求原封不动的转发给特定的端口或者是特定的某几台机器啊，在我们这个案例中呢就是把
    80端口的请求都转发到nodejs启动的这个8081端口来处理啊。
    1.移除apache
    一般来说刚购买的阿里云服务器可能预装apache,我们如果没有特别的项目的话是用不到的，所以可以把它给删了
    停掉apache服务
    sudo service apache2 stop
    sudo service apache stop
    删除apache
    update-rc.d -f apache2 remove
    移除apache
    sudo apt-get remove apache2
    这样就清干净了
    2.更新包列表
    sudo apt-get update
    3.安装nginx
    sudo apt-get install nginx
    4.安装完之后呢，我们来检查一下nginx的版本
    nginx -v
    5.进入nginx目录下，我们看一下下面有哪些文件
    cd /etc/nginx
    6.进入conf.d
    cd conf.d
    7.新建一个配置文件
    sudo vi imooc-com-8081.conf
    使用服务的域名和端口来命名nginx配置文件
    8.编辑这个配置文件
    因为在一开始我们就考虑到将来可能会有多个项目对应到多个服务在我们的服务器后端，所以说我们一开始就可能要考虑到这种负载均衡的这种场景，那么这时我们可以通过
    upstream来设定一个简单的，即便是现在我们不去设置这个策略，那将来升级的时候或者将来去改动的时候，我们已经把这个路给铺好了啊
    # 负载均衡
    upstream imooc {
        server 127.0.0.1:8081;
    }
    # 定义服务器
    server {
        listen 80;
        server_name 120.26.235.4; # 服务器ip

        location / {
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $http_host;
            proxy_set_header X-Nginx-Proxy true;

            # 配置指令来实现代理，把域名代理到集群的名字上面或者说应用的名字上面
            proxy_pass http://imooc;
            proxy_redirect off;

        }
    }

    ## nginx的原理就是访问的服务器代理到另一台服务器上面，一个是访问的服务器，一个是代理的服务器
    8.找到nginx.conf这个配置文件
    # 会把conf.d文件夹下面的所有配置文件都加载进来
    include /etc/nginx/conf.d/*.conf;
    # 会把sites-enabled文件夹下面的所有文件都加载进来
    include /etc/nginx/sites-enabled/*;
    9.测试一下这个配置文件我们写的对不对，来检测一下配置文件有没有错误
    sudo nginx -t
    10.重启nginx
    sudo nginx -s reload
    11.现在我们通过这个ip地址就能直接访问到了我们服务器上跑在8081端口上的node的服务，配置完域名解析之后，我们也能够通过域名的方式来访问到这个服务。
    也就是说，现在我们内部的端口的转发，就是代理这个东西已经是跑通了啊
    12.我们再从网页上来看一下服务器返回的头信息吧，控制台切换到network，找到这个请求，可以看到服务器返回的Headers里面的Server信息，里面标注了nginx
    和版本号
        1.隐藏nginx版本信息，这样的话就会让我们的nginx对外呢不那么透明
        sudo vi nginx.conf
        server_tokens off;
        2.重载nginx
        sudo service nginx reload

更改域名的DNS根服务器

配置解析项目的域名A记录和CNAME

服务器配置安装MongoDB
在Ubuntu14.04上安装MongoDB
    一台服务器跑应用，一台服务器放数据
    1.在服务器上安装MongoDB
    浏览器地址栏输入
    mongodb install on ubuntu docs
    按照步骤来
        1.导入public key
        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4
        2.为mongodb的配置文件来创建一个列表
        echo "deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/4.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list
        3.更新本地包
        sudo apt-get update
        4.安装
        sudo apt-get install -y mongodb-org
        5.安装过程中出现问题时，可能时安装源的问题
        因为我们现在用的是阿里云服务器，它默认的安装源也是阿里云，可能就会出错，所以我们可以先把阿里云这个源屏蔽掉试一下。
        sudo vi /etc/apt/apt.conf
        注释掉阿里云的mirrors镜像
        # Acquire::http::Proxy "http://mirrors.aliyun.com/";
        然后重新走一遍上面的流程
        6.安装v3.4版本
        将文档地址中的manual改成v3.4就可以了
        7.因为我们给aliyun的源给注释掉了，所以在安装mongodb的时候应该会很慢，我们来编辑一份文件，把这个镜像重新来改一下
        cd /etc/apt/sources.list.d
        这个下面就是刚才我们所新加的这个源的一个列表，我们现在来编辑这份列表
        sudo vi mongodb-org-3.4.list
        现在它的这个源是http://repo.mongodb.org/apt/ubuntu
        我们可以强制把它改成是阿里云的http://mirrors.aliyun.org/mongodb/apt/ubuntu
        8.重新跑一遍这个更新
        sudo apt-get update
        9.更新之后就可以安装了
        sudo apt-get install -y mongodb-org
        这样它就会从阿里云的镜像上来获取源文件啊，速度就会快很多
        10.安装完毕后，我们现在来把这个服务给开起来
        sudo service mongod start
        11.检查有没有开启成功
            1.cat /var/log/mongodb/mongod.log
            来检查一下这个日志文件啊
            2.或者直接在命令行里输入mongo
            mongo
        12.更改防火墙配置，允许mongo默认连接的本地27017的端口
        sudo vi /etc/iptables.up.rules
        找到ping下面添加
        # mongodb connect
        -A INPUT -s 127.0.0.1 -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPT
        -A OUTPUT -d 127.0.0.1 -p tcp --source-port 27017 -m state --state ESTABLISHED -j ACCEPT
        13.重载上面的iptables配置文件
        sudo iptables-restore < /etc/iptables.up.rules
        14.然后我们再从本地来通过mongo来连一下这个实例，这样就成功的进到了mongodb的命令行终端中，就说明mongod实例已经是成功开启了啊
        15.刚才是成功的把mongodb服务给开起来了，那怎么停掉呢
        sudo service mongod stop
        就可以终止这个服务
        重启
        sudo service mongod restart
        16.现在有个问题，就是mongodb的数据库的端口默认是跑在27017的这个端口上的，所有人都知道，所以说出于一个最基本的安全的考虑，我们需要把这个
        默认端口给改一下
        打开配置文件
        sudo vi /etc/mongod.conf
        找到port这里
        port: 19999
        17.然后再重新启动这个服务
        sudo service mongod restart
        18.还要在防火墙里改一下之前给mongodb配置的端口
        19.然后再把防火墙重新载入一下
        sudo iptables-restore < /etc/iptables.up.rules
        20.载入之后，我们再重新再连这个数据库，通过mongo直接连，它默认的就是27017的端口，肯定是不行的。这样就连接失败了
        那我们可以指定端口
        mongo --port 19999
        这样的话我们就重新进到数据库的终端里面去了啊
        21.那么关于配置和优化mongodb数据库的性能啊，包括安全性，修改数据存放的位置，日志存放的位置等等，都会有很多的细节，我们可以在配置文件
        里面进行修改，特别是针对生产环境下的mongodb数据库，它里面的读写，访问的权限啊

往线上MongoDB倒入单表数据或数据库
    一个项目在上线的时候呢，可能一开始是没有任何数据的，也可能一开始有一些初始化的数据
    这节演示一下如何往线上的服务器中来导入初始的数据啊
    那第一种情况就是把一个完整的数据库全部都导到线上去
        1.本地数据库备份，就是把这个数据打包，备份出来，然后把备份后的数据文件再同步到线上
        mongodump -h 127.0.0.1:27017 -d indust-app -o indust-app-backup
        最好是把这个打包后的文件放到一个统一的文件夹里面，免得不太好找
        2.然后把导出的文件夹打包一下
        tar zcvf indust-app.tar.gz indust-app-backup
        indust-app.tar.gz这个是我们打包之后的压缩包的名字
        indust-app-backup是打包的源文件
        这样本地就多了一个tar包
        3.将本地压缩包上传服务器
        那么本地备份之后呢，我们可以通过scp命令把这个本地的压缩包上传到服务器，那这里要注意，我们执行这个scp的时候是在我们电脑的本地，而不是在服务器上啊
        scp -P 39999 ./indust-app-backup.tar.gz imooc_manager@120.26.235.4:/home/imooc_manager/dbbackup/
        这样就上传成功了
        4.对服务器上的tar包进行解压缩
        tar xvf indust-app.tar.gz
        5.将这个数据库导入我们线上刚刚配置完端口的mongodb里面去
        mongorestore --host 127.0.0.1:19999 -d indust-app ./dbbackup/indust-app-backup/indust-app
        indust-app要导入的数据库的名字
        ./dbbackup/indust-app-backup/indust-app 指定从哪导
        这样就导入成功了
        6.查看数据有没有存储到里面去
        mongo --port 19999
        到数据库里面去之后，我们通过use这个命令，切换到这个数据库
        use indust-app
        show tables
        可以看到这些表都在里面了
        找个表看下里面的数据
        db.creations.find({})
        就可以看到这么多数据都已经成功被导进来了
        到这完整的数据库就已经是导入成功了
    第二种情况就是我们需要为一个已有的数据库导入一张或者是几张单表，这种情况比较适用于比如新增一些用户列表或者新增一些创意数据或者是初始化一些管理的角色等等啊
        1.本地导出单表
        mongoexport -d imooc-movie -c users -q '{"name": {$ne: null}}' -o ./movie-users.json
        -d imooc-movie 指定导出的是哪个数据库名
        -c users 指的是哪一张表
        -q '{"name": {$ne: null}}' 指导出的表是用户不为空的数据
        -o ./movie-users.json 导出到哪里
        2.把这个导出的json上传到服务器上去
        scp -P 39999 ./movie-users.json imooc_manager@120.26.235.4:/home/imooc_manager/dbbackup/
        3.到服务器上进行操作，把这个用户的单表数据导入到mongodb里面去
        mongoimport --host 127.0.0.1:19999 -d imooc-movie -c users ./movie-users.json
        imooc-movie 要导入数据的数据库
        -c users 指定导出的是这张表 
        ./movie-users.json 要导入的数据
        这样就导入成功了啊
        4.查看一下数据是否导入成功
        进入数据库
        mongo --port 19999
        5.切换到imooc-movie这个数据库里面去
        use imooc-movie
        6.展示数据表
        show tables
        6.查看表中数据
        db.users.find({})
    导入的数据库有误需要删掉的情况
        1.删掉整个数据库
        mongo --host 127.0.0.1:19999 imcoo-movie --eval "db.dropDatabase()"
        imcoo-movie 数据库的名字
        这样就把这个电影的这个数据库给清空了
        2.查看是否删除成功
        进入mongodb
        mongo --port 19999
        查看有哪些数据库
        show dbs

为上线项目配置MongoDB数据库读写权限
    数据库是一个网站或者是一个互联网应用的大脑，里面存储了整个产品线或者是整个公司的数据资产，所以它一定要具备一定的安全性。
    我们知道的关系型数据库都是有权限控制的，什么用户能访问什么库什么表，什么用户可以进行插入或者更新的操作，而有的用户就只有读取的权限，比如说
    mysql安装配置之后会有一个默认自带的mysql的数据库，里面会有一张user表，用来存放用户以及用户的权限，而mongodb这种非关系型数据库有没有这样的表呢
    最基本的mongodb的安全来如何控制
    在正式设置权限之前呢，我们需要对mongodb的权限系统有一个大概的了解，大概有这么四点
        1.mongodb是没有默认的管理员账号的，所以说要先添加管理员的账号，然后再开启权限来认证
        2.只有切换到admin这个数据库之后，添加的账号才算是管理员账号
        3.用户只能在用户所在的数据库来登陆，包括管理员账号
        4.管理员可以管理所有的数据库，但是不能直接管理其他数据库，首先要到admin里面认证之后才可以 
    1.首先我们对整个mongodb的数据库设立一个超级权限，其实就是管理员
        1.进入到mongo的命令行环境下
        mongo --port 19999
        2.切换到admin的数据库
        use admin
        3.创建用户
        db.createUser({user: 'imooc_cases_owner', pwd: 'Safe1*24$', roles: [{role: 'userAdminAnyDatabase', db: 'admin'}]})
        现在呢管理员就已经是添加了，这个管理员是可以间接的管理所有的数据库的
        4.在admin的这个数据库下面对上面的用户登陆进行授权
        db.auth('imooc_cases_owner', 'Safe1*24$')
        返回值是1，说明授权成功了
        到了这步之后呢，我们就可以对其他的数据库进行授权了
        5.给其他数据库进行授权
            电影网站
            1.切换到电影网站的数据库
            use imooc-movie
            2.创建这个数据库的用户
            db.createUser({user: 'imooc_movie_runner', pwd: 'F**k9001$', roles: [{role: 'readWrite', db: 'imooc-movie'}]})
            上面配置的意思就是我们让imooc_movie_runner这个用户对imooc-movie这个数据库具有读写的权限
            那这个数据库的读写的用户已经创建了，我们还需要为这个数据库来多创建一个用户，创建一个备份的角色，就是说这个备份的角色可以定期或者不定期的
            对我们的这个数据库进行备份操作，但是它只有读的权限，而没有写的权限
            db.createUser({user: 'imooc_movie_wheel', pwd: 'B**kup2017$', roles: [{role: 'read', db: 'imooc-movie'}]})
            到这，电影网站的数据库我们这边就已经配置完了
            狗狗说
            1.配置狗狗说后台的数据库
            先切换到admin里面，先到admin的下面，我们通过超级管理员的这个身份进行授权
            use admin
            2.我们切换到这个admin之后呢，重新进行这个授权认证的操作
            db.auth('imooc_cases_owner', 'Safe1*24$')
            3.然后再切换到imooc-app这个数据库
            use imooc-app
            4.创建这个数据库的用户
            db.createUser({user: 'imooc_app_runner', pwd: 'Ack!24$', roles: [{role: 'readWrite', db: 'imooc-app'}]})
            5.创建备份用户
            db.createUser({user: 'imooc_app_wheel', pwd: 'Do0r53#', roles: [{role: 'read', db: 'imooc-app'}]})
            小程序
            1.use admin
            2.db.auth('imooc_cases_owner', 'Safe1*24$')
            3.use indust-app
            4.db.createUser({user: 'indust_app_runner', pwd: 'Fa*e24$', roles: [{role: 'readWrite', db: 'indust-app'}]})
            5.db.createUser({user: 'indust_app_wheel', pwd: 'T*K233$', roles: [{role: 'read', db: 'indust-app'}]})
            微信公众号
            1.use admin
            2.db.auth('imooc_cases_owner', 'Safe1*24$')
            3.use imooc-wechat
            4.db.createUser({user: 'imooc_wechat_runner', pwd: 'B*le81$', roles: [{role: 'readWrite', db: 'imooc-wechat'}]})
            5.db.createUser({user: 'imooc_wechat_wheel', pwd: 'G*nk36$', roles: [{role: 'read', db: 'imooc-wechat'}]})
        那么到这里为止呢，这4个数据库，我们创建了4个用户，同时创建了4个备份的用户，一共是8个用户
        我们现在退出
        exit
        6.现在退出之后呢，这个mongodb的用户虽然创建，但现在还不能验证，因为没有把它的验证模式开起来，我们现在通过在服务器上修改配置文件的方式把它开起来啊
        sudo vi /etc/mongod.conf
        找到security就是安全，在它下面添加一行
        security:
          authorization: 'enabled'
        那么这个配置呢就改完了，我们现在需要让这个配置来生效
        就是重启mongodb这个服务
        sudo service mongod restart
        重启之后呢，我们进入到数据库里面
        mongo --port 19999
        show dbs
        这时就会报错了，现在就没有权限去执行这个脚本，我们就必须通过刚才的命令
        use admin
        db.auth('imooc_cases_owner', 'Safe1*24$')
        这是就可以执行show dbs命令了
        它就会把本地的数据库显示出来
        退出
        exit
        7.如果想直接登陆到某个数据库里面怎么做呢
        mongo 127.0.0.1:19999/imooc-movie -u imooc_movie_runner -p F**k9001$
        imooc-movie 数据库的名字
        imooc_movie_runner 数据库所创建的用户名
        -p F**k9001$ 登陆这个数据库用户的密码
        如果能执行以下两个命令，就说明登陆进来了，而且是有权限操作的
        show tables
        db.users.find({})
        8.我们在部署一台新的服务器的时候，最好是像以上这样，先设想好整个的服务器上要部署几个项目，或者说会有多少个数据库，那么这些数据库会来承接什么样
        的项目，我们先规划好数据库和项目的对应关系以及数据库的名字，甚至是规划好每一个数据库它的用户名，它的权限，它的密码，然后把这些命令呢都提前在
        本地的记事本上写下来，这样呢就会让你的这个部署变得简单一点。当然了，肯定会有一些突发的情况，比如说应用要下线了，需要导出来这个数据库，或者是
        一个新的应用要上线，我们需要重新建立一个数据库，或者说设定一个新的用户，那下节呢我们来尝试一下复杂一点的情况啊

从一台服务器迁移数据到另一个线上MongoDB中
    除了一开始在没有设置权限密码的时候导入或者是导出数据库，那如果说一个数据库已经在线上投入使用了，在正常运行，那这个时候怎么来执行这个导入或者导出
    动作呢，其实这些操作啊，去搜索一下文档或看一下官网的话，都能是自己摸索出来的，但是考虑到的确这种场景还算是时不时会遇到，比如说服务器欠费啦，服务器
    ip被屏蔽啦，服务器的机房光缆被挖断啦，服务器需要升级到高配置或者是降到低配置。如何对线上的数据库进行操作，或者说如何从一台生产服务器已有的数据库
    的数据迁移到另外一台正在运行的服务器。
    1.先导出数据
    首先在服务器上新建一个文件夹
    mkdir db
    cd db
    我们把数据导到这
    mongodump -h 127.0.0.1:19999 -d indust-app -u indust_app_wheel -p T*k233$ -o indust-app-old
    2.打包导出的文件夹
    tar zcvf indust-app-old.tar.gz indust-app-old
    3.除了需要迁移一个数据库之外，我们还要尝试一下迁移一张单表
    mongoexport -h 127.0.0.1:19999 -d imooc-movie -u imooc_movie_wheel -p B**kup2017$ -c users -q '{"name": {$ne: null}}' -o ./movie-users-old.json
    4.以上是在这个生产服务器上执行了两个导出，一个是单表一个是数据库，我们需要做这个迁移的话，就把这个数据给上传到另外一台服务器上，这边可以进行这样一个操作啊，
    就是我们先转一圈，先把这些文件先下载到本地电脑，然后在从本地上传到另外一台服务器，现在切换到本地的终端里面去。
    5.下载到本地电脑
    scp -P 39999 imooc_manager@120.26.235.4:/home/imooc_manager/db/indust-app-old.tar.gz ./
    scp -P 39999 imooc_manager@120.26.235.4:/home/imooc_manager/db/movie-users-old.json ./
    那么这两个都下载完了，那现在呢等于说把本地看成一个中转站啊，我们从本地重新把这两个文件上传到目标服务器中。
    从本地把另外一台服务器上的备份的文件传到这个文件夹下，然后在这个新的服务器上来模拟线上生产服务器来导入数据的过程啊。
    6.在本地电脑上传文件到目标服务器
    scp -P 39999 ./movie-users-old.json imooc_manager@120.26.235.4:/home/imooc_manager/newdb
    scp -P 39999 ./indust-app-old.tar.gz imooc_manager@120.26.235.4:/home/imooc_manager/newdb
    7.在目标服务器中
    新建文件夹
    mkdir newdb
    cd newdb
    解压缩tar包
    tar xvf indust-app-old.tar.gz
    8.连接数据库
    mongo --port 19999
    9.创建两个新的数据库
    新的电影网站数据库
        1.切换到admin
        use admin
        2.进行授权
        db.auth('imooc_cases_owner', 'Safe1*24$')
        3.切换到新的数据库
        use imooc-movie-target
        4.为它来创建一个读写的权限用户
        db.createUser({user: 'imooc_movie_target', pwd: 'movie_target', roles: [{role: 'readWrite', db: 'imooc-movie-target'}]})
    新的小程序数据库
        1.use admin
        2.db.auth('imooc_cases_owner', 'Safe1*24$')
        3.use indust-app-target
        4.db.createUser({user: 'indust_app_target', pwd: 'indust_target', roles: [{role: 'readWrite', db: 'indust-app-target'}]})
    exit
    10.现在呢我们来执行这个导入的动作
    数据库
    mongorestore -h 127.0.0.1:19999 -d indust-app-target -u indust_app_target -p indust_target ./newdb/indust-app-old/indust-app
    -d indust-app-target 数据库
    -u indust_app_target 用户名
    -p indust_target 密码
    ./newdb/indust-app-old/indust-app 数据位置
    单表
    mongoimport -h 127.0.0.1:19999 -d imooc-movie-target -u imooc_movie_target -p movie_target -c user ./newdb/movie-users-old.json
    -c user 需要指定导入到哪个表
    11.检查有没有导入成功
    电影网站数据库
    mongo 127.0.0.1:19999/imooc-movie-target -u imooc_movie_target -p movie_target
    show tables
    db.users.find({})
    exit 退出
    小程序数据库
    mongo 127.0.0.1:19999/indust-app-target -u indust_app_target -p indust_target
    show tables
    db.categories.find({})
    exit 退出
    12.那现在我们就成功的把一台服务器上的一个完整的项目数据库以及一个数据单表成功的导出后又导入到了在线上运行的另外一台服务器上，整个流程操作起来还是比较简单的，
    但是步骤有点繁琐，而且需要在线上通过命令行来操作，加上角色权限密码的设定啊，很容易出错，所以千万一定要小心再小心。

为数据库实现定时备份方案
    1.编辑一个备份的脚本
    在服务器根目录下
    mkdir tasks
    cd tasks
    vi movie.backup.sh
    #!这个是脚本的一个格式啊，来表明它是一个可执行的一个脚本
    #!/bin/sh
    # 声明一个变量，来表示备份的数据库的一个目录
    backUpFolder=/home/imooc_manager/backup/movie
    # 设置一个当前的日期
    date_now=`date +%Y_%m_%d_%H%M`
    backFileName=movie_$date_now
    # 然后进行我们的操作，我们在脚本里面呢来模拟这个动作
    # 首先进入到备份目录下
    cd $backUpFolder
    # 到这个目录下之后呢，首先创建一个文件夹啊
    mkdir -p $backFileName
    # 然后呢来执行导出
    mongodump -h 127.0.0.1:19999 -d imooc-movie -u imooc_movie_wheel -p B**kup2017$ -o $backFileName
    # 那么这就导出了，导出之后呢，我们把这个数据通过tar命令把它进行一个压缩
    tar zcvf $backFileName.tar.gz $backFileName
    # 等到打包结束之后呢，我们来清理一下现场，来删掉这个临时的备份目录啊
    rm -rf $backFileName
    # 那整个的备份流程就完成了，但是现在有一个问题就是，我们所备份的数据文件呢都在服务器上的硬盘所存着，如果说服务器被人给攻击了或者说在深夜
    来操作这个服务器，可能会出现一些误操作，那么这个数据文件呢可能会被删除，所以说建议是把我们这个数据包呢再传到一个私有云上或者说一个第三方
    的云平台，比如说七牛或者阿里云，或者说我们自建的一台服务器也可以啊。
    2.执行上面创建的脚本
    sudo sh ./tasks/movie.backup.sh
    成功的话就会在我们设定的目录里面出现我们压缩的数据文件
    那么我们用来备份的这个脚本就已经实现了啊
    3.把这个定时任务给跑起来
    来启动系统的自动任务的一个设定啊
    crontab -e
    进入到nano编辑器里面
    找到# m h dom mon dow command
    在下面添加一行
    13 00 * * * sh /home/imooc_manager/tasks/movie.backup.sh
    意思是每天的凌晨13分跑一次我们的备份脚本来进行备份
    按下control+x，shift+y，回车

上传数据库备份到七牛私有云
    1.那么这个上传到云端的脚本呢，我们可以通过nodejs来实现啊，比如说在/tasks下面创建一个upload.js
    cd /tasks
    vi upload.js
    其实像这个代码的话我们是可以直接拷贝过来啊，七牛的官方是有这个示例代码的
    // 首先引入七牛的这个模块啊
    var qiniu = require("qiniu");
    var parts = process.env.NODE_ENV.split('@')
    var file = parts[1] + '.tar.gz'
    var filePath = parts[0] + '/' + file
    //需要填写你的 Access Key 和 Secret Key
    qiniu.conf.ACCESS_KEY = 'Access_Key';
    qiniu.conf.SECRET_KEY = 'Secret_Key';
    //要上传的空间
    bucket = 'Bucket_Name';
    //上传到七牛后保存的文件名
    key = file;
    //构建上传策略函数
    function uptoken(bucket, key) {
    var putPolicy = new qiniu.rs.PutPolicy(bucket+":"+key);
    return putPolicy.token();
    }
    //生成上传 Token
    token = uptoken(bucket, key);
    //要上传文件的本地路径
    //filePath = './ruby-logo.png'
    //构造上传函数
    function uploadFile(uptoken, key, localFile) {
    var extra = new qiniu.io.PutExtra();
        qiniu.io.putFile(uptoken, key, localFile, extra, function(err, ret) {
        if(!err) {
            // 上传成功， 处理返回值
            console.log(ret.hash, ret.key, ret.persistentId);       
        } else {
            // 上传失败， 处理返回代码
            console.log(err);
        }
    });
    }
    //调用uploadFile上传
    uploadFile(token, key, filePath);
    2.编辑movie.backup.sh脚本
    cd /tasks
    vi movie.backup.sh
    最后一行加一行代码
    NODE_ENV=$backUpFolder@$backFileName node /home/imooc_manager/tasks/upload.js
    3.来到七牛里面
    对象存储->新建存储空间->imoocdeploydb 私有空间 确定创建
    4.安装七牛模块，在upload.js同层的目录下
    npm install qiniu
    5.安装之后，我们通过命令啊直接调用这个路径下的movie.backup.sh
    cd /tasks
    ./movie.backup.sh
    这时本地的tar包已经是创建了啊，来到七牛上也能够看到已经有了这个文件
    就说明我们的这个数据库呢已经从我们的服务器上传到了七牛的私有云上面
    6.我们在把这个定时任务再来完善一下啊
    crontab -e
    这个任务呢是可以来设置很多个的，每一个呢单独一行
    00 4 * * * sh /home/imooc_manager/tasks/movie.backup.sh
    00 8 * * * sh /home/imooc_manager/tasks/movie.backup.sh
    每天的凌晨四点和八点都来执行一下备份，这个频率可以自己设定，一个小时也可以，十分钟也可以，只要在这里把这些任务都一行行的列了下来，那么它到了这个时间点，
    就会来调用这个脚本，然后再去执行脚本里面的这些命令啊，那么在脚本里面呢，我们不仅是执行了数据库的导出和打包而且把数据库上传到了一个私有云，所以说在你的
    服务器上，包括你的七牛云上，一共有两个备份啊，这样就比较保险一点。另外有一个建议，就是每个应用呢会对应一个数据库，最好是分别建立一个备份脚本，也就是说
    如果你有四个应用对应四个数据库，那么最好是建立四个backup.sh的备份脚本而不是都写到一个脚本里面去，这样的话呢，以免某一个数据库备份失败会导致其他的备份
    呢都出错啊。
    7.除了安装mongodb，还想安装mysql怎么办呢，其实在ubuntu上也特别简单
    sudo apt-get install mysql-server mysql-client
    这样就可以了啊，这样就把mysql给安装完毕了啊
    我们来登陆一下
    mysql -u root -p
    然后输入密码
    这个就登陆成功，进入到mysql的命令行终端里去了
    那么mysql呢就正常安装了啊，关于mysql的导入导出包括备份，可以去搜索一些文档啊，可以参考mongodb的整个流程

向服务器正式部署和发布线上nodejs项目
上传项目代码到线上私有git仓库
    我们已经在服务器上安装好了nginx还有pm2
    nginx的版本是1.4.6
    nginx -v
    pm2的版本是2.4.0
    pm2 -v
    这样的话我们就可以通过nginx的端口映射来把前端的http的请求转发到后端的nodejs上面，那么这个nodejs本身呢，我们会通过pm2来进行维护。
    1.上传项目代码，也就是项目的部署
    我们在部署项目的时候呢，如果说上传这个项目或者说修改项目代码的话，每一次都从本地的代码这边一个字节一个字节上传的话，显然是非常低效的啊。
    那这个时候我们就会用到git仓库了。
    那我们现在要把本地的项目都通过git上传到私有仓库里面，对于私有仓库呢，可以选择付费的github私有仓库，也可以使用开源中国免费的私有仓库。
    2.建好线上私有云仓库
    3.将线上私有云仓库与本地仓库进行关联
        1.进到本地项目的仓库里面
            将id_rsa.pub里面的内容拷贝到私有云的后台，即添加ssh公钥的地方
            现在开始执行关联
                1.先在本地配置全局的git用户名和邮箱
                2.确保我们现在的仓库是一个干净的仓库，如果说这个仓库是一个非常干净的仓库的话，项目目录里面是没有.git这样的文件夹的。
                3.先初始化这个干净的仓库
                git init
                4.添加所有的文件
                git add .
                5.git commit -m "first commit"
                6.git remote add origin git@git.oschina.net:wolf18387/backend-website.git
                这样就通过这个git remote add把我们本地这个仓库将来所要push的地址给关联到了我们私有云的这个仓库里面去
                7.git push -u origin master
                这样就把这个代码给提交上去了啊
                8.如果上述过程失败说明远端有本地没有的代码，这时需要拉取合并远端代码之后再push
                git fetch
                git merge origin/master
                git push -u origin master
            那么这个仓库我们就从本地关联到了线上啊
            现在我们实现了单向的就是从本地到第三方的git仓库啊，那我们还要实现从服务器到第三方的这个仓库
        2.切换到服务器的终端下面
            将id_rsa.pub里面的内容拷贝到私有云的后台，即添加ssh公钥的地方
            这样呢我们的服务器就也有这个权限来获取到码云上面的我们私有仓库代码了
            确保每个项目都可以clone到我们的服务器上
    这样我们就打通这三端了，从我们本地能够随时把代码给更新或者是push到我们的私有仓库里面，然后从我们的服务器上可以随时把我们仓库里面最新的代码给
    拉到我们的服务器里面

配置pm2一键部署线上项目结构
    现在我们已经把本地的项目都推送到了私有仓库，并且呢服务器也能下载到这些私有仓库的代码，那这个时候我们就需要有一个傻瓜式的管理代码更新和服务运行
    的工具帮助我们同步代码更新以及服务的重启这样的工作啊，那这个傻瓜式的工具呢就是pm2，当然了除了pm2，还有很多别的这种运行或者是部署项目相关的工具
    比如说supervisor,mima,forever等等。并且呢也可以基于pm2进行一个深度定制啊。那对于我们来说一个普通的应用，pm2就已经足够了，它不仅可以来守护
    服务器的nodejs服务来实现平滑重启，也可以实现代码的自动更新以及从本地到线上的部署。那么关于部署呢，pm2有非常详细的文档，可以自行的搜索一下啊。
    http://pm2.keymetrics.io 在这个文档里面其实非常的详尽啊，从部署一直到日志啊包括说整个配置文件的各个参数什么的，如果说你打算用pm2的话，建议
    是把这个文档大致的都看一遍啊。知道pm2可以做什么，可以做到什么样的程度。
    1.用pm2把代码部署到我们的服务器上
    我们选择部署的方式呢是通过配置文件的方式，在文档中有一个Deployment，需要在项目里面来建一个ecosystem.json一个json文件啊。官方也提供了这么
    一个案例啊。其实可以直接拷贝过来的
    2.在本地项目里面新建一个json文件ecosystem.json
    在这个里面我们来配置仓库的地址，包括说服务器的ip啊账号啊等等啊。
    {
        "apps": [
            {
                "name": "Website", // 我们需要部署的应用的名字
                "script": "app.js", // 启动的脚本，这个脚本呢就是我们的入口文件app.js
                "env": { // 启动的时候需要传进去的变量
                    "COMMON_VARIABLE": true
                },
                "env_production": { // 生产环境的这个变量
                    "NODE_ENV": "production"
                }
            }
        ],
        // 来配置部署的任务
        "deploy": {
            "production": { , // 任务的名字
                "user": "imooc_manager", // 服务器上我们用来发布应用的这个user
                "host": ["120.26.235.4"], // 主机，如果说我们有好几台服务器的话，那这里可以传进去多个ip
                "port": "39999", // 这个就是我们服务器imooc_manager用户登陆时候的端口号
                "ref": "origin/master", // 分支
                "repo": "git@git.oschina.net:wolf18387/backend-website.git", // 仓库的地址
                "path": "/www/website/production", // 我们需要把这个项目部署到服务器的哪一个目录下面啊
                "ssh_options": "StrictHostKeyChecking=no", // 把它的这个key校验给取消掉
                "env": {
                    "NODE_ENV": "production"
                }
            }
        }
    }
    那这个用来部署和发布的配置文件呢我们就完成了
    3.在本地项目目录里面，从终端里面执行
    pm2 deploy ecosystem.json production setup
    ecosystem.json // 配置文件的名字
    production // 我们配置的任务的名字，这个名字是可以改的，比如说改成aliyun也可以
    这句命令呢就是让我们这个pm2连上我们的服务器，从服务器里面来创建我们需要发布项目的这个所需要的文件夹啊。
    4.再切换到服务器终端上面啊
    首先到我们指定的文件目录下面/www/website/
    这样呢，我们的静态网站的路径就跟我们配置文件里面路径就对上了
    5.再去本地终端执行第三步的命令
    6.此时会报错，我们第一次在部署项目的时候会经常遇到这样的问题，就是权限问题，我们现在呢通过pm2连上我们的服务器，是通过imooc_maneger这个
    用户啊，那么它在跟路径的/www下面是没有新建文件夹的权限的，所以我们需要把website这个文件夹呢它的权限给修改一下
    我们切换到服务器的终端下面
    在/www下面，通过
    sudo chmod 777 website
    来把这个文件夹改成是对于我们的imooc_manager来说是可读可写并且是可执行啊
    7.再跑第三步的命令
    这样就成功了
    8.我们现在来到服务器上来检查一下
    cd /www/website/production
    发现里面多了三个文件夹啊，分别是current,shared,source
    这三个文件夹呢就是pm2 deploy setup的时候呢在production下面新建了三个文件夹
    current呢就是当前的服务所运行的文件夹
    source呢是clone下来的这个源代码
    shared里面就是日志文件啊包括pid之类的这些共享的数据啊

从本地发布上线和更新服务器的nodejs项目
    本地控制远端代码更新还有服务重启的流程
    上一节我们演示了通过pm2来部署项目的一个流程，它的原理呢就是通过本地的pm2这个工具啊在我们本地的命令行上登陆服务器，然后通知服务器从我们的git
    这个私有仓库里面把代码clone到我们的服务器里面，然后呢部署到相应的文件夹中，然后等待我们进一步的操作。那么这个时候呢服务器上的项目就已经是
    ready的状态了，我们就可以进行第一次的发布了，或者说是服务的部署吧。
    1.切换到本地项目目录下
    pm2 deploy ecosystem.json production
    通常呢，我们都会遇到一个报错
    就是在执行post-deploy，就是用pm2来管理nodejs这个脚本的时候呢，这个pm2命令是找不着的，那它的原因呢是因为我们的pm2在服务器上使用的是非交互
    的一个ssh连接方式啊，所以我们需要切换到服务器的终端里面啊。
    来编辑这个脚本，注释掉这几行
    vi .bashrc
    #case $- in
    #    *i*) ;;
    #      *) return;;
    #esac
    这样呢就避免它提前返回
    保存后通过
    source .bashrc
    来加载这个.bashrc
    然后再切换到本地的终端里面啊，重新来发布一次
    pm2 deploy ecosystem.json production
    如果还不成功可能是本地有没提交到私有仓库的提交，提交后再发布就好了
    2.到服务器的终端里面
    pm2 list
    来看一下现在跑的这个应用啊，可以看到上面列出了这个应用
    3.那么截止到这里呢，整个发布流程就走完了啊，就说明是发布成功了，但是发布成功不代表说我们的服务在线上呢就是可以被访问的。我们还有两件事需要做，
    第一件事情呢就是修改我们的域名指向，可以通过域名来访问到这个静态网站所提供的web服务啊，第二件事情呢就是要修改我们的nginx配置文件，让nginx来
    识别这个域名之后呢把请求都转发到我们服务器的3000端口。
    4.我们首先做第一件事情啊
    打开dnspod，登录到dnspod后台，找到我们的域名啊
    添加一个记录
    5.进入到服务器终端里面做第二件事情
    修改nginx的配置文件
    cd /etc/nginx/conf.d
    sudo mv imooc-com-8081.conf www-iblack7-com-3000.conf
    sudo vi www-iblack7-com-3000.conf
    upstream website {
        server 127.0.0.1:3000;
    }
    server {
        listen 80;
        server_name www.iblack7.com;

        location / {
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $http_host;
            proxy_set_header X-Nginx-Proxy true;

            # 配置指令来实现代理，把域名代理到集群的名字上面或者说应用的名字上面
            proxy_pass http://website;
            proxy_redirect off;

        }
    }
    6.来把这个服务重启
    sudo nginx -s reload
    重启之后呢我们就可以从我们本地的浏览器里来访问这个域名了，看看它有没有生效啊
    www.iblack7.com
    这时如果访问不成功，就说明我们服务器上的这个服务啊无论是映射还是nodejs本身啊可能有点问题。我们来排查一下，大家可以来想一下啊，除了服务器的端口
    映射还有nodejs本身，还有什么原因可以导致这个提供web服务出错呢，那就是我们的防火墙。我们现在呢是让nginx来把来自于www.iblack7.com这个域名下
    的请求转发到了服务器上它本地的3000端口，所以说我们的防火墙需要来允许这个3000端口的一个访问啊。
    sudo vi /etc/iptables.up.rules
    找到# mongodb connect，在下面添加两行
    # 静态网站端口访问
    -A INPUT -s 127.0.0.1 -p tcp --destination-port 3000 -m state --state NEW,ESTABLISHED -j ACCEPT
    -A OUTPUT -d 127.0.0.1 -p tcp --source-port 3000 -m state --state ESTABLISHED -j ACCEPT
    重新载入一下防火墙的配置文件
    sudo iptables restore < /etc/iptables.up.rules
    此时在去浏览器刷新后就可以成功访问了，所以单从这一点上来看的话，就能看出防火墙对于一个服务器来说是多么的重要啊，每个端口我们都是严格控制的，不会
    让一个未经我们这个规则所允许的一个请求来访问到我们的端口啊。
    7.那么这样呢，我们就把整个网站就是静态网站从后到前已经是跑通了，那如果说我现在需要对线上的这个网站的内容也好样式也好功能也好进行修改的话，怎么样
    把我们本地的改动给同步到线上呢，这个呢也非常简单，只需要三步。
    第一步，修改本地的项目代码
    第二部，提交我们的代码
    第三步，使用pm2 deploy ecosystem.json production来把我们刚才的改动呢给同步到线上
    这样我们就已经成功部署了一个静态站点

部署发布电影网站并连接线上mongodb
    这一节来部署第二个项目，也就是电影网站的这个项目，这个项目比起第一个项目有两个地方的不同，第一个呢它使用了mongodb数据库，第二个呢它使用到了静态
    资源，比如说本地的css或者是js文件，所以说我们要特别小心的来处理这两个不同之处。
    1.首先呢，我们到dnspod上面把这个域名指向一下啊，我们增加一个域名，这个域名指向就配置好了，我们会通过movie.iblack7.com来访问到我们服务器上的
    电影网站的这个项目
    2.来到本地打开movie-server这个项目
    我们首先需要确保本地的启动文件启动的是3001端口的服务，这样不会跟其他项目的端口有冲突了。
    3.接下来我们来连接这个mongodb数据库啊
    因为呢我们在服务器上已经把mongodb的认证模式开启了，而且专门为这个项目创建了用户名还有密码，所以后端nodejs的代码里面需要调整一下。
    我们首先拿到当前运行这个服务的环境变量啊
    var env = process.env.NODE_ENV || 'development' // 如果这个环境变量没有传的话呢，我们就设置为是开发模式啊
    var dburl = 'mongodb://imooc_movie_runner:F**k9001$@127.0.0.1:19999/imooc-movie' // 默认的话我们连接线上的数据库
    // 线上数据库的地址呢，我们通过mongoose这个模块来连接一个认证开启的某个数据库的话，它的格式是这样的
    // mongodb://这个数据库的用户名:密码@访问mongodb的ip地址:这个数据库的端口号/数据库的名字
    if (env === 'development') { // 如果这个env当前是开发模式的话，我们会来连接本地的数据库
        dburl = 'mongodb://localhost/imooc-movie'
    }
    这样我们就配置好了，如果说是本地的话我们连本地的数据库，如果是到线上的话我们连线上的数据库同时传入用户名还有密码
    4.然后来配置这个发布脚本啊
    我们把之前静态网站的发布脚本，就是ecosystem.json给复制过来，然后放在电影项目里面，我们对它进行修改
    需要修改的地方：
        name
        私有仓库地址
        path部署到线上服务器对应的目录
    还需要增加发布脚本
        "post-deploy": "npm install && grunt build && pm2 startOrRestart ecosystem.json --env production"
        等到我们的项目呢发布到了服务器上之后，我们需要做的第一件事情就是下载这个项目所依赖的npm这些包或者是模块
        grunt build呢就是说在我们的线上对这些样式进行编译，对脚本进行压缩
        pm2 startOrRestart ecosystem.json --env production 启动整个nodejs的服务啊
    我们是在线上进行这个模块的安装包括编译的话，那么整个命令呢都是在"post-deploy"里面定制好的，到线上之后呢等于说是一条龙，从安装到重启就一气呵成
    了，这样的话就比较省心啊。
    {
        "apps": [
            {
                "name": "Movie", // 我们需要部署的应用的名字
                "script": "app.js", // 启动的脚本，这个脚本呢就是我们的入口文件app.js
                "env": { // 启动的时候需要传进去的变量
                    "COMMON_VARIABLE": true
                },
                "env_production": { // 生产环境的这个变量
                    "NODE_ENV": "production"
                }
            }
        ],
        // 来配置部署的任务
        "deploy": {
            "production": { , // 任务的名字
                "user": "imooc_manager", // 服务器上我们用来发布应用的这个user
                "host": ["120.26.235.4"], // 主机，如果说我们有好几台服务器的话，那这里可以传进去多个ip
                "port": "39999", // 这个就是我们服务器imooc_manager用户登陆时候的端口号
                "ref": "origin/master", // 分支
                "repo": "git@git.oschina.net:wolf18387/backend-movie.git", // 仓库的地址
                "path": "/www/movie/production", // 我们需要把这个项目部署到服务器的哪一个目录下面啊
                "ssh_options": "StrictHostKeyChecking=no", // 把它的这个key校验给取消掉
                "post-deploy": "npm install && grunt build && pm2 startOrRestart ecosystem.json --env production",
                "env": {
                    "NODE_ENV": "production"
                }
            }
        }
    }
    5.然后到服务器终端里面啊，修改nginx的配置文件
    cd /etc/nginx/conf.d
    现在这个目录里面只有www-iblack7-com-3000.conf这么一份文件
    我们把这个文件复制一份
    sudo cp www-iblack7-com-3000.conf movie-iblack7-com-3001.conf
    编辑movie-iblack7-com-3001.conf这个文件
    sudo vi movie-iblack7-com-3001.conf
    upstream movie {
        server 127.0.0.1:3001;
    }
    server {
        listen 80;
        server_name movie.iblack7.com;

        location / {
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $http_host;
            proxy_set_header X-Nginx-Proxy true;

            # 配置指令来实现代理，把域名代理到集群的名字上面或者说应用的名字上面
            proxy_pass http://movie;
            proxy_redirect off;

        }

        location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt) {
            root /www/movei/production/current/public;
        }
    }
    那么这样呢就能提供动态的nodejs服务了啊，但是我们这个项目不仅仅是会返回一个页面，还会返回项目内部的静态资源，比如说css或者js或者是图片，所以说
    我们需要增加一个静态资源的访问规则
    location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt) {
        root /www/movei/production/current/public;
    }
    6.切换到本地，对这个项目进行部署
    首先来初始化整个目录的层次
    pm2 deploy ecosystem.json production setup
    提交本地修改到私有仓库里面
    git add .
    git commit -m "fixed"
    git push origin master
    还是这个命令，把setup给删掉，进行第一次的发布
    pm2 deploy ecosystem.json production
    第一次的发布会比较慢，因为它需要安装很多模块，第二次之后就会快很多了，以为它把这些公共的模块都放入到了share的这个文件夹下面，然后通过一个软链接
    来指向过去。
    ok，这样就发布结束了啊。
    7.我们来到线上来看一下
    pm2 list
    来列出当前运行的项目，可以看到这个movie重启了9次，就说明这个movie应该是有错误啊。
    pm2 logs
    我们检查一下这个日志文件，可以看到一直是我们的mongodb连接有错误。
    pm2 stop Movie
    来把这个项目给停止掉，不让它继续写入日志啊
    查看日志，根据提示找到错误，来修复数据库的问题。
    根据pm2 list和pm2 logs可以看到没什么报错了，就已经是可以了。
    那么这个服务呢已经是成功开起来了，我们就把这个nginx重启一下
    sudo nginx -s reload
    8.那我们的防火墙呢也需要来更新一下啊，因为现在这个电影项目的端口是3001，我们需要允许从nginx端口转发的请求能够成功转发到后端的3001端口。
    sudo vi /etc/iptables.up.rules
    # 电影网站端口访问
    -A INPUT -s 127.0.0.1 -p tcp --destination-port 3001 -m state --state NEW,ESTABLISHED -j ACCEPT
    -A OUTPUT -d 127.0.0.1 -p tcp --source-port 3001 -m state --state ESTABLISHED -j ACCEPT
    重新载入防火墙
    sudo iptables-restore < /etc/iptables.up.rules
    重启nginx
    sudo nginx -s reload
    这样呢就把nginx服务重启了。
    9.我们来到浏览器里面来访问一下新的域名啊
    movie.iblack7.com
    这样就访问到了我们原本跑在本地的这个电影的项目啊

部署ReactNative App线上api服务
    1.配置域名
    到dnspod后台添加一个记录
    2.然后到我们的本地
    进入到app的这个后台项目里面
    3.首先把入口文件里面的端口号改一下，改成3002
    将上节的数据库用户名还有密码的这段配置复制过来
    var env = process.env.NODE_ENV || 'development'
    var dburl = 'mongodb://imooc_app_runner:Ack!24$@127.0.0.1:19999/imooc-app'
    if (env === 'development') {
        dburl = 'mongodb://localhost/imooc-movie'
    }
    4.然后呢我们把发布的脚本也给复制过来 
    {
        "apps": [
            {
                "name": "App", // 我们需要部署的应用的名字
                "script": "app.js", // 启动的脚本，这个脚本呢就是我们的入口文件app.js
                "env": { // 启动的时候需要传进去的变量
                    "COMMON_VARIABLE": true
                },
                "env_production": { // 生产环境的这个变量
                    "NODE_ENV": "production"
                }
            }
        ],
        // 来配置部署的任务
        "deploy": {
            "production": { , // 任务的名字
                "user": "imooc_manager", // 服务器上我们用来发布应用的这个user
                "host": ["120.26.235.4"], // 主机，如果说我们有好几台服务器的话，那这里可以传进去多个ip
                "port": "39999", // 这个就是我们服务器imooc_manager用户登陆时候的端口号
                "ref": "origin/master", // 分支
                "repo": "git@git.oschina.net:wolf18387/backend-app.git", // 仓库的地址
                "path": "/www/app/production", // 我们需要把这个项目部署到服务器的哪一个目录下面啊
                "ssh_options": "StrictHostKeyChecking=no", // 把它的这个key校验给取消掉
                "post-deploy": "npm install && pm2 startOrRestart ecosystem.json --env production",
                "env": {
                    "NODE_ENV": "production"
                }
            }
        }
    }  
    这个项目呢因为它不需要用到这个静态资源，所以把grunt build删掉
    5.我们再切换到服务器上
    在服务器的/www目录下再新建一个文件夹
    sudo mkdir app
    然后对它进行授权
    sudo chmod -R 777 app
    6.现在呢进行我们的项目的部署
        1.提交代码
        git add .
        git commit -m "fixed"
        git push origin master
        2.第一次部署
        pm2 deploy ecosystem.json production setup
        3.第一次发布
        pm2 deploy ecosystem.json production
    ok，发布成功
    7.我们到服务器上检查一下
    pm2 list
    pm2 logs
    查看列表和日志可以看到这个服务是启动成功了啊
    8.来编辑我们的nginx配置文件
    cd /etc/nginx/conf.d
    复制一份新的config文件出来
    sudo cp www-iblack7-com-3000.conf app-iblack7-com-3002.conf
    编辑这份文件
    sudo vi app-iblack7-com-3002.conf
    upstream app {
        server 127.0.0.1:3002;
    }
    server {
        listen 80;
        server_name app.iblack7.com;

        location / {
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $http_host;
            proxy_set_header X-Nginx-Proxy true;

            # 配置指令来实现代理，把域名代理到集群的名字上面或者说应用的名字上面
            proxy_pass http://app;
            proxy_redirect off;

        }
    }
    9.然后来编辑这个防火墙
    sudo vi /etc/iptables.up.rules
    # app端口访问
    -A INPUT -s 127.0.0.1 -p tcp --destination-port 3002 -m state --state NEW,ESTABLISHED -j ACCEPT
    -A OUTPUT -d 127.0.0.1 -p tcp --source-port 3002 -m state --state ESTABLISHED -j ACCEPT
    重载iptables
    sudo iptables-restore < /etc/iptables.up.rules
    10.重启nginx的服务
    sudo nginx -s reload
    11.我们到浏览器里面来访问一下啊
    app.iblack7.com/api
    访问成功，就说明呢这个服务器呢已经是能够成功返回了，我们这个狗狗后台的这个api服务器呢已经是建立起来了

部署微信小程序线上api服务

部署配置微信公众号项目后台

选购申请ssl证书的一些建议
    怎么来申请一个ssl证书
    1.申请证书的方式有很多
        收费的，免费的，包括自己动手实现的，或者是通过第三方的平台直接来申请
    2.证书对于对浏览器和操作系统的一个支持的范围。
    3.证书的类型
        1.域名级的证书，也就是dv，这种证书信任等级一般，一般用在个人博客，产品演示，中小企业网站，企业官网宣传等等。这些对信息安全等级要求不太
        高的场景里面可以直接使用啊。
        2.企业级别的证书，简称是ov，这个信任等级就比较高，通常用在一些电商网站，私密社交等等这些涉及到用户资料啊，订单支付这样的场景。
        3.增强型的证书，简称是ev，是目前全球等级最高的ssl证书，安全性是非常高的
    4.证书的维护成本
    有的证书是三个月过期，有的是一年过期，那每一次过期之后呢都需要更新证书或者是重新提交一个申请，那这个就是证书的维护成本。

云平台申请免费证书及nginx配置
    1.申请免费证书
    2.nginx配置
        1.申请成功之后会有连个个key需要上传到服务器上。
        把证书文件传到服务器根目录下
        scp -P 39999 ./2_mini.iblack7.com.key imooc_manager@120.26.235.4:/home/imooc_manager/
        scp -P 39999 ./1_mini.iblack7.com_bundle.crt imooc_manager@120.26.235.4:/home/imooc_manager/
        2.到服务器上检查一下
        可以看到根目录下就有了传上来的这些文件
        把这些文件放到一个目录下
        mkdir ssl
        mv 1_* ./ssl/
        mv 2_* ./ssl/
        放进去之后呢，我们把ssl这个文件夹呢也移动到我们的/www下面
        sudo mv ssl /www/
        3.根据申请证书平台的文档配置我们的nginx
        复制下面这段
            listen 443;
            server_name www.domain.com; #填写绑定证书的域名
            ssl on;
            ssl_certificate 1_www.domain.com_bundle.crt;
            ssl_certificate_key 2_www.domain.com.key;
            ssl_session_timeout 5m;
            ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置
            ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置
            ssl_prefer_server_ciphers on;
        到我们的服务器里面
        cd /etc/nginx/conf.d
        编辑需要配置ssl证书的nginx配置文件
        sudo vi app-iblack7-com-3002.conf
        将上面从文档复制的内容粘贴到nginx配置的server里面，并修改需要更改的内容。
        因为现在过来的请求中呢，可能有的请求本来就是http的协议啊，所以说对于这种请求呢，我们希望把它给转发到https上面去，我们可以把这个server
        给拆出来再放一个server。直接就是http的协议呢，我们这边进行一个重写。
        upstream free {
            server 127.0.0.1:3001;
        }
        server {
            listen 80;
            server_name free.iblack7.com;
            # rewrite ^(.*) https://$host$1 permanent; # 将所有过来的请求呢都重写到https
            return 301 https://free.iblack7.com$request_uri; # 或者用return 301重定向
        }
        server {
            listen 443;
            server_name free.iblack7.com; #填写绑定证书的域名
            ssl on;
            ssl_certificate /www/ssl/1_free.iblack7.com_bundle.crt;
            ssl_certificate_key /www/ssl/2_free.iblack7.com.key;
            ssl_session_timeout 5m;
            ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置
            ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置
            ssl_prefer_server_ciphers on;
            # 如果访问协议是一个空值的话，就是它不是属于这种协议访问的，我们也直接进行rewrite
            if ($ssl_protocol = "") {
                rewrite ^(.*) https://$host$1 permanent;
            }

            location / {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
                proxy_set_header X-Nginx-Proxy true;

                # 配置指令来实现代理，把域名代理到集群的名字上面或者说应用的名字上面
                proxy_pass http://free;
                proxy_redirect off;

            }

        }
        检查nginx配置文件
        sudo nginx -t
        重启nginx
        sudo nginx -s reload
            
课程总结
    本期课程帮大家打通了从本地到线上的发布流程，从开发到生产环境的操作方式，大家可以沿着这个线继续往下挖，无论是2017年还是2018年，nodejs这个
    有点年纪的新技术啊，都会在这个市场上得到更加充分的验证和使用，也对我们有着更多更大的挑战啊，无论是nodejs本身在线上环境的进程守护，进程通信
    ，错误的处理，日志的收集，性能的监控，还是多端口多服务器的集群管理，基于docker的环境部署，nodejs新老版本的交替兼容，还是es新语法的普及和
    使用，前后端的模块的重用，静态资源的打包，和服务器渲染等等这些常见的课题啊都值得我们尝试，多去总结。

##### document load 和 DOMContentLoaded 的区别

load 事件在页面所有资源全部加载完成后（包括 DOM 文档树，css 文件，js 文件，图片资源等）会执行。

DOMContentLoaded 事件在形成 DOM 树后就会触发。

##### new Object() 和 Object.create() 有什么区别

```js
// 1.{}等同于new Object()，原型都是Object.prototype
// 2.Object.create(null)，必须传一个参数，可以是一个对象也可以是null。传入null就是没有原型。传入对象就是指定原型。Object.create()就是创建一个空对象，然后把空对象的原型指定为传入的这个对象上。
  const obj1 = {
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  }
  const obj2 = new Object({
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj3 = new Object(obj1)
  console.log(obj1 === obj3)            // true
  const obj4 = Object.create(null)      // {}，但是没有原型
  const obj5 = new Object()             // {}，有原型
  const obj6 = Object.create({          // {}，原型就是传入的这个对象
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj7 = Object.create(obj1)      // 意思就是说我们通过obj1创建了obj6，通过create方式来创建的。
  console.log(obj6.__proto__ === obj1)  // true
  console.log(obj6 === obj1)            // false
  console.log(obj1 === obj3)            // true 
```

##### 手写字符串 trim 方法，保证浏览器兼容性

```js
String.prototype.trim = function () {
  return this.replace(/(^\s*)|(\s*$)/g, "");
}
```

##### 如何捕获 js 程序中的异常

```js
// 1.手动捕获异常
// 这种方式用的比较常见，觉得哪个地方可能会风险比较高，那就用一个try catch给它包起来，然后有异常就输出
try {
  // todo
} catch (ex) {
  console.error(ex) // 手动捕获catch
} finally {
  // todo
}
// 2.自动捕获异常
// 一种兜底方案，比如说我们想要监听一下前端页面，已经上线了，我们做一个统计监听，我们看一下前端页面有没有什么js错误，一般我们第一种方式就是用上面的方式在该try catch的地方打上try catch，如果catch到我们就发一个统计打点，作为一个记录。第二种方式就是我们不可能每一行都用try catch。这样成本太高。我们只在一个高风险的地方用try catch，其他地方我们用一个window.onerror就可以了。它会自动捕获你程序中的一些问题。
window.onerror = function (message, source, lineNum, colNum, error) {
  // 报错信息 源码 行号 列号 错误栈
  // 第一，对跨域的js，如cdn，会告诉你错误了，但不会有详细的报错信息
  // 第二，对于压缩的js，还要配合sourceMap去反查到为压缩代码的行，列
}
//所以通过这两个方式来集合，你就能监听到页面上绝大部分的错误。
```

##### 获取当前页面 url 参数

```js
// 1.传统方式，查找location.search
function query (name) {
  const search = location.search.substring(1)
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
  const res = search.match(reg)
  if (res == null) {
    return null
  }
  return res[2]
}
// 2.新api，URLSearchParams
function query (name) {
  const search = location.search
  const p = new URLSearchParams(search)
  return p.get(name)
}
```

##### 数组去重

```js
// 1.传统方式，遍历元素挨个比较，去重
function unique (arr) {
  const res = []
  arr.forEach(item => {
    if (res.indexOf(item) < 0) {
      res.push(item)
    }
  })
  return res
}
// 2.使用Set（无序，不能重复）
function unique (arr) {
  const set = new Set(arr)
  return [...set]
}
```

##### 前端性能优化

原则：多使用内存缓存，减少计算，减少网络请求
方向：加载页面要更快，页面渲染要更快，页面操作要更流畅

##### 防抖，节流

```js
// 防抖
function debounce(fn, wait) {
  var timer = null
  return function () {
    var context = this
    var args = arguments
    // 只要timer有就清除它
    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, wait)
  }
}
// 立即执行版
function debounce(func, wait) {
  let timer;
  return function() {
    let context = this
    let args = arguments
    if (timer) {
      clearTimeout(timer)
    }
    let callNow = !timer;
    timer = setTimeout(() => {
      timer = null;
    }, wait)
    if (callNow) func.apply(context, args);
  }
}
// 使用
var fn = function () {
 console.log('boom')
}
document.onclick = debounce(fn, 500)

// 节流
// 定时器版
function throttle(fn, wait) {
  let timer;
  return function() {
    let context = this
    let args = arguments
    // timer没有的时候才执行函数
    if (!timer) {
      timer = setTimeout(() => {
        timer = null
        fn.apply(context, args)
      }, wait)
    }
  }
}
// 时间戳版
function throttle(fn, wait) {
  let previous = 0
  return function() {
    let now = Date.now()
    let context = this
    let args = arguments
    if (now - previous > wait) {
      fn.apply(context, args)
      previous = now
    }
  }
}

// 使用
var fn = function () {
 console.log('boom')
}
document.onclick = throttle(fn, 500)
```

##### vue diff 算法

必要性：lifecycle.js - mountComponent()，组件中可能存在多个 key 的变化，一个组件又只有一个 Watcher ，所以需要知道具体哪里发生了变化，这时就必须要用 diff 算法去比对具体哪里变化。

执行方式：patch.js - patchVnode()，patchVnode 是 diff 发生起始的地方，整体策略：深度优先，同层比较 updateChildren() 递归操作。

diff 算法是虚拟 DOM 技术的必然产物：通过新旧虚拟 DOM 的对比（即diff），将变化的地方更新在真实 DOM 上。diff 高效的对比过程也降低了时间复杂度，提高性能。

Vue 中 diff 执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果 oldVnode 和新的渲染结果 newVnode，此过程称为 patch。

##### vue 模版编译

字符串模版 => 抽象语法树(AST) => 生成 JS 函数。

模板编译的主要目标是将模板 template 转换为渲染函数 render。这个过程是一个字符串模版被转换成 JS 函数。

入口文件 entry-runtime-with-compiler.js 中，如果存在 template 或 el 选项就会执行编译，会执行 compileToFunctions 方法，把模版传进去。通过方法名就可以知道，它可以把字符串模版变成一个函数，它会返回 render 函数。

编译分为三步：解析、优化和生成，src/compiler/index.js。

- 解析 - parse：解析器把模版转换为 AST 对象，抽象语法树，它是对我们将来我们要生成的代码的 JS 对象的描述，将来遍历这棵树，把代码生成。这是底层代码生成器的必要知识。用对象的形式来描述 JS 代码，先把字符串变成对象，这个对象是有格式规定的，能描述将来要生成的代码。解析器内部分了HTML解析器、文本解析器和过滤器解析器。
- 优化 - optimize：在 AST 中标记静态子树，静态子树是界面中永远不变的节点，如两层嵌套以上的纯文本节点。
  - 每次重新渲染，不需要为静态子树创建新节点。
  - 虚拟 DOM 中 patch 时，可以跳过静态子树。
- 代码生成 - generate：把 AST 转换成代码字符串，比如一个字符串形式的函数，然后用 new Function(code) 把字符串函数的代码作为参数传进去就可以得到一个真正的 render 函数。

processIf 用于解析 v-if，genIf 用于生成条件语句相关代码。

processFor 用于解析 v-for 指令，genFor 用于生成相应代码。

v-if，v-for 这些指令只能在编译器阶段处理，如果我们要在 render 函数处理条件或循环只能使用 if 和 for，然后生成VNode。

##### vue 批量异步更新策略

侦听到数据变化，不会把对应的 Watcher 直接更新，而是开启一个队列，存放所有需要变化的组件 Watcher，启动一个微任务 Promise.resolve().then()，在面里遍历队列，一次性的执行所有 Watcher 的更新函数，更新函数把所有的 DOM 更新全部做完之后，浏览器统一的刷新一次，就达到了我们期待的高效方式。

如果一个 key 同时被多次修改，导致 Watcher 被多次触发，只会被推入到队列中一次，避免不必要的计算和 DOM 操作。

异步策略的选择会有优先级，根据当前执行环境的支持情况，会分别使用 Promise.then、MutationObserver、setImmediate、setTimeout，如果使用宏任务做的话，用户体验就不好了，因为它只能到下一个循环才能看到结果了。

##### MVVM 框架三要素

数据响应式：数据变化视图更新。

模版引擎：提供描述视图的模版语法。

渲染：把模版生成真正的 html。

##### let const

let

* let 声明的变量是拥有块级作用域的。
* 用 let 声明的全局变量不能通过 window 的属性去访问。
* var 定义的变量可以重复，let 声明的变量不允许重复定义。
* let 声明的变量不会进行变量提升。

const

* const 具备以上 let 的所有特点
* const 它定义的是常量。既然是常量，也就是说它不能再被修改了。
* const 不允许先声明再赋值，let, var 都可以，就是声明的时候必须做初始化。

##### forEach 实现 break

```js
let arr = [1, 2, 3, 4, 5]
try{
  arr.forEach(item => {
    if (item === 3) {
      throw new Error('出错了')
    } else {
      console.log(item)
    }
  })
} catch(e){
  throw e
}
```

##### Proxy

代理的核心价值是屏蔽原始信息，保证原始信息的安全。

```js
let o = {
  name: 'xiaoming',
  price: 190
}
let d = new Proxy(o, {})
```

* 第一个参数：你要代理谁。

* 第二个参数：代理之后我能干什么。比如劫持构造函数，劫持你的 get, set。但是经常使用的就是读和取。因为我们在写业务的过程中百分之九十九都是在读写数据，对于其他的操作来说基本用不到。

操作传成 {} 就相当于没操作，没操作就等于是透传。

```js
d.revoke() // 撤销代理
```

##### .then() 链式调用的工作原理

* then 传入的函数返回了 promise 实例，那 then 函数返回就是这个 promise 实例；
* then 传入的函数返回的不是 promise 实例，那 then 函数会返回一个全新的 promise 实例并 resolve 这个返回的数据；
* then 传入的函数什么都没返回，那 then 函数也是会返回一个全新的 promise 实例并 resolve undefined。
* then 传入的是非函数，那 then 函数返回的是该 then 前面的那个的 promise 实例。

所以不管怎么样，then() 最终都会返回一个 promise 对象，这样就能保证我们能连续的使用链式调用。

##### Promise.all() & Promise.rase()

```js
// all
const p1 = Promise.resolve(1)
const p2 = Promise.resolve(2)
const p3 = Promise.resolve(3)
Promise.all([p1, p2, p3])
  .then(value => {
    console.log(value) // [1, 2, 3]
  })
// rase
const p1 = () => {
  return new Promise((resolve, reject) => {
    setTimeout(function () {
      resolve(1)
    }, 0)
  })
}
const p2 = () => {
  return new Promise((resolve, reject) => {
    setTimeout(function () {
      resolve(2)
    }, 1000)
  })
}
Promise.race([p1(), p2()])
  .then(value => {
    console.log(value) // 1
  })
```

##### Promise.all 实现

```js
Promise.all = arr => {
  let aResult = [];    // 用于存放每次执行后返回结果
  return new _Promise(function (resolve, reject) {
    let i = 0;
    next();    // 开始逐次执行数组中的函数(重要)
    function next() {
      arr[i].then(function (res) {
        aResult.push(res);    // 存储每次得到的结果
        i++;
        if (i == arr.length) {    // 如果函数数组中的函数都执行完，便resolve
          resolve(aResult);
        } else {
          next();
        }
      })
    }
  })
}
```

##### async/await

用同步的写法来写异步。

* 使用 await，函数必须用 async 标识，这个函数也可以作为一个普通的函数来执行。 
* await 后面必须跟一个 promise 实例，如果不是它会帮你自动处理成一个 promise 对象，await 的返回值就是这个 promise 实例 resolve 或 reject 传出来的结果。

```js
const load = async function () {
  const result1 = await loadImg(src1)
  console.log(result1)
  const result2 = await loadImg(src2)
  console.log(result2)
}
load()
```

async 函数中你返回的不是一个 promise 的时候，它会自动的帮你把返回值变成一个 promise 实例。

```js
async function firstAsync () {
  return 27 // 引擎会自动帮你转成这种效果Promise.resolve(27)
}
```

##### form 的 enctype 属性是声明编码格式，针对 post 的时候主要有两种编码

* url encode 的方式提交文本。
* formdata 是把数据做编码之后提交，这种方式的好处是它可以上传文件。

##### html 语义

语义类标签对开发者更为友好，语义类标签增强了可读性，能够清晰地看出网页的结构，便于团队的开发和维护。

语义类标签也更适合搜索引擎检索（SEO），也可以让搜索引擎爬虫更好地获取到更多有效信息，有效提升网页的搜索量，并且语义类还可以支持读屏软件，根据文章可以自动生成目录等等。

正确使用整体结构类的语义标签，可以让页面对机器更友好。比如，这里一个典型的 body 类似这样：

在 body 下面，有一个 header，header 里面是一个 nav，跟 header 同级的有一个 aside，aside 里面也有一个 nav。接下来是文章的整体，也就是一个一个的 section。section 里面可能还有嵌套，但是我们就不管了，最后是一个 footer，这个 footer 里面可能有 address 这样的内容。

```html
<body>
    <header>
        <nav>
            ……
        </nav>
    </header>
    <aside>
        <nav>
            ……
        </nav>
    </aside>
    <section>……</section>
    <section>……</section>
    <section>……</section>
    <footer>
        <address>……</address>
    </footer>
</body>
```

##### rem  根据根元素的字体大小搞来搞去

```css
html {
  font-size: 62.5%; /* 10÷16=62.5% */
}
@media only screen and (min-width: 481px){
  html {
    font-size: 94%!important; /* 15.04÷16=94% */
  }
}
@media only screen and (min-width: 561px){
  html {
    font-size: 109%!important; /* 17.44÷16=109% */
  }
}
@media only screen and (min-width: 641px){
  html {
    font-size: 125%!important; /* 20÷16=125% */
  }
}
```

##### 禁用手型

```css
div {
	cursor: not-allowed;
}
```

##### 文字超出末尾显示省略号

```css
div {
  width: 200px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
```

##### css 画三角形

![triangle-up](/Users/dxm/tool/images/实战/triangle-up.png)

```css
#triangle-up {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}
```

##### 是否可选择文本

```css
div {
  user-select: none; /* none用户不能选择文本，text用户可以选择文本 */
}
```

##### css reset

https://meyerweb.com/eric/tools/css/reset/

https://yuilibrary.com/yui/docs/cssreset

https://necolas.github.io/normalize.css/

##### height

* height 不会继承，在所有元素都不设置高度的情况下，如果想给某个元素设置 height: 100% 需要从 html 开始，每一层都要设置 height: 100%，才会有效。
* 父级元素的高度会被设置了高度的子元素撑开，高度就为子元素的高度。

##### 字体

指定字体：

```
body {
  font-family: 'PingFang SC', 'Microsoft Yahei', serif;
}
```

自定义字体：

```
@font-face {
  font-family: 'IF';
  src: url('./IndieFlower.ttf');
}
.custom-font {
  font-family: 'IF';
}
```

iconfont: 

既然可以自定义字体，所谓自定义字体原理就是规定每个字长什么样，如果规定每个字是图标的样子，就可以把文字当做图标用了。

##### webpack 和 css

webpack 给 css 提供了相当多的能力和处理方式。

* css-loader 将 css 变成 js
* style-loader 将 js 样式插入 head
* ExtractTextWebpackPlugin 将 css 从 js 中提取出来
* css modules 解决 css 命名冲突的问题
* less-loader sass-loader 等各类预处理器
* postcss-loader postcss 处理
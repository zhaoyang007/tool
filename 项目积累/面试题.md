##### document load 和 DOMContentLoaded 的区别

load 事件在页面所有资源全部加载完成后（包括 DOM 文档树，css 文件，js 文件，图片资源等）会执行。

DOMContentLoaded 事件在形成 DOM 树后就会触发。

##### new Object() 和 Object.create() 有什么区别

```js
// 1.{}等同于new Object()，原型都是Object.prototype
// 2.Object.create(null)，必须传一个参数，可以是一个对象也可以是null。传入null就是没有原型。传入对象就是指定原型。Object.create()就是创建一个空对象，然后把空对象的原型指定为传入的这个对象上。
  const obj1 = {
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  }
  const obj2 = new Object({
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj3 = new Object(obj1)
  console.log(obj1 === obj3)            // true
  const obj4 = Object.create(null)      // {}，但是没有原型
  const obj5 = new Object()             // {}，有原型
  const obj6 = Object.create({          // {}，原型就是传入的这个对象
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj7 = Object.create(obj1)      // 意思就是说我们通过obj1创建了obj6，通过create方式来创建的。
  console.log(obj6.__proto__ === obj1)  // true
  console.log(obj6 === obj1)            // false
  console.log(obj1 === obj3)            // true 
```

##### 手写字符串 trim 方法，保证浏览器兼容性

```js
String.prototype.trim = function () {
  return this.replace(/(^\s*)|(\s*$)/g, "");
}
```

##### 如何捕获 js 程序中的异常

```js
// 1.手动捕获异常
// 这种方式用的比较常见，觉得哪个地方可能会风险比较高，那就用一个try catch给它包起来，然后有异常就输出
try {
  // todo
} catch (ex) {
  console.error(ex) // 手动捕获catch
} finally {
  // todo
}
// 2.自动捕获异常
// 一种兜底方案，比如说我们想要监听一下前端页面，已经上线了，我们做一个统计监听，我们看一下前端页面有没有什么js错误，一般我们第一种方式就是用上面的方式在该try catch的地方打上try catch，如果catch到我们就发一个统计打点，作为一个记录。第二种方式就是我们不可能每一行都用try catch。这样成本太高。我们只在一个高风险的地方用try catch，其他地方我们用一个window.onerror就可以了。它会自动捕获你程序中的一些问题。
window.onerror = function (message, source, lineNum, colNum, error) {
  // 报错信息 源码 行号 列号 错误栈
  // 第一，对跨域的js，如cdn，会告诉你错误了，但不会有详细的报错信息
  // 第二，对于压缩的js，还要配合sourceMap去反查到为压缩代码的行，列
}
//所以通过这两个方式来集合，你就能监听到页面上绝大部分的错误。
```

##### 获取当前页面 url 参数

```js
// 1.传统方式，查找location.search
function query (name) {
  const search = location.search.substring(1)
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
  const res = search.match(reg)
  if (res == null) {
    return null
  }
  return res[2]
}
// 2.新api，URLSearchParams
function query (name) {
  const search = location.search
  const p = new URLSearchParams(search)
  return p.get(name)
}
```

##### 数组去重

```js
// 1.传统方式，遍历元素挨个比较，去重
function unique (arr) {
  const res = []
  arr.forEach(item => {
    if (res.indexOf(item) < 0) {
      res.push(item)
    }
  })
  return res
}
// 2.使用Set（无序，不能重复）
function unique (arr) {
  const set = new Set(arr)
  return [...set]
}
```

##### 前端性能优化

原则：多使用内存缓存，减少计算，减少网络请求
方向：加载页面要更快，页面渲染要更快，页面操作要更流畅

##### 防抖，节流

```js
// 防抖
function debounce(fn, wait) {
  var timer = null
  return function () {
    var context = this
    var args = arguments
    // 只要timer有就清除它
    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, wait)
  }
}
// 立即执行版
function debounce(func, wait) {
  let timer;
  return function() {
    let context = this
    let args = arguments
    if (timer) {
      clearTimeout(timer)
    }
    let callNow = !timer;
    timer = setTimeout(() => {
      timer = null;
    }, wait)
    if (callNow) func.apply(context, args);
  }
}
// 使用
var fn = function () {
 console.log('boom')
}
document.onclick = debounce(fn, 500)

// 节流
// 定时器版
function throttle(fn, wait) {
  let timer;
  return function() {
    let context = this
    let args = arguments
    // timer没有的时候才执行函数
    if (!timer) {
      timer = setTimeout(() => {
        timer = null
        fn.apply(context, args)
      }, wait)
    }
  }
}
// 时间戳版
function throttle(fn, wait) {
  let previous = 0
  return function() {
    let now = Date.now()
    let context = this
    let args = arguments
    if (now - previous > wait) {
      fn.apply(context, args)
      previous = now
    }
  }
}

// 使用
var fn = function () {
 console.log('boom')
}
document.onclick = throttle(fn, 500)
```

##### Promise.all 实现

```js
Promise.all = arr => {
  let aResult = [];    // 用于存放每次执行后返回结果
  return new _Promise(function (resolve, reject) {
    let i = 0;
    next();    // 开始逐次执行数组中的函数(重要)
    function next() {
      arr[i].then(function (res) {
        aResult.push(res);    // 存储每次得到的结果
        i++;
        if (i == arr.length) {    // 如果函数数组中的函数都执行完，便resolve
          resolve(aResult);
        } else {
          next();
        }
      })
    }
  })
}
```

##### vue diff 算法

必要性：lifecycle.js - mountComponent()，组件中可能存在多个 key 的变化，一个组件又只有一个 Watcher ，所以需要知道具体哪里发生了变化，这时就必须要用 diff 算法去比对具体哪里变化。

执行方式：patch.js - patchVnode()，patchVnode 是 diff 发生起始的地方，整体策略：深度优先，同层比较 updateChildren() 递归操作。

diff 算法是虚拟 DOM 技术的必然产物：通过新旧虚拟 DOM 的对比（即diff），将变化的地方更新在真实 DOM 上。diff 高效的对比过程也降低了时间复杂度，提高性能。

Vue 中 diff 执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果 oldVnode 和新的渲染结果 newVnode，此过程称为 patch。

##### vue 模版编译

字符串模版 => 抽象语法树(AST) => 生成 JS 函数。

模板编译的主要目标是将模板 template 转换为渲染函数 render。这个过程是一个字符串模版被转换成 JS 函数。

入口文件 entry-runtime-with-compiler.js 中，如果存在 template 或 el 选项就会执行编译，会执行 compileToFunctions 方法，把模版传进去。通过方法名就可以知道，它可以把字符串模版变成一个函数，它会返回 render 函数。

编译分为三步：解析、优化和生成，src/compiler/index.js。

- 解析 - parse：解析器把模版转换为 AST 对象，抽象语法树，它是对我们将来我们要生成的代码的 JS 对象的描述，将来遍历这棵树，把代码生成。这是底层代码生成器的必要知识。用对象的形式来描述 JS 代码，先把字符串变成对象，这个对象是有格式规定的，能描述将来要生成的代码。解析器内部分了HTML解析器、文本解析器和过滤器解析器。
- 优化 - optimize：在 AST 中标记静态子树，静态子树是界面中永远不变的节点，如两层嵌套以上的纯文本节点。
  - 每次重新渲染，不需要为静态子树创建新节点。
  - 虚拟 DOM 中 patch 时，可以跳过静态子树。
- 代码生成 - generate：把 AST 转换成代码字符串，比如一个字符串形式的函数，然后用 new Function(code) 把字符串函数的代码作为参数传进去就可以得到一个真正的 render 函数。

processIf 用于解析 v-if，genIf 用于生成条件语句相关代码。

processFor 用于解析 v-for 指令，genFor 用于生成相应代码。

v-if，v-for 这些指令只能在编译器阶段处理，如果我们要在 render 函数处理条件或循环只能使用 if 和 for，然后生成VNode。

##### vue 批量异步更新策略

侦听到数据变化，不会把对应的 Watcher 直接更新，而是开启一个队列，存放所有需要变化的组件 Watcher，启动一个微任务 Promise.resolve().then()，在面里遍历队列，一次性的执行所有 Watcher 的更新函数，更新函数把所有的 DOM 更新全部做完之后，浏览器统一的刷新一次，就达到了我们期待的高效方式。

如果一个 key 同时被多次修改，导致 Watcher 被多次触发，只会被推入到队列中一次，避免不必要的计算和 DOM 操作。

异步策略的选择会有优先级，根据当前执行环境的支持情况，会分别使用 Promise.then、MutationObserver、setImmediate、setTimeout，如果使用宏任务做的话，用户体验就不好了，因为它只能到下一个循环才能看到结果了。

##### MVVM 框架三要素

数据响应式：数据变化视图更新。

模版引擎：提供描述视图的模版语法。

渲染：把模版生成真正的 html。

##### let const

let

* let 声明的变量是拥有块级作用域的。
* 用 let 声明的全局变量不能通过 window 的属性去访问。
* var 定义的变量可以重复，let 声明的变量不允许重复定义。
* let 声明的变量不会进行变量提升。

const

* const 具备以上 let 的所有特点
* const 它定义的是常量。既然是常量，也就是说它不能再被修改了。
* const 不允许先声明再赋值，let, var 都可以，就是声明的时候必须做初始化。

##### forEach 实现 break

```js
let arr = [1, 2, 3, 4, 5]
try{
  arr.forEach(item => {
    if (item === 3) {
      throw new Error('出错了')
    } else {
      console.log(item)
    }
  })
} catch(e){
  throw e
}
```


1.http协议
前端 --- http协议 --- 后端
http协议是web开发里面最基础的内容，所有web开发相关的数据传输，内容传输都是通过http协议的。
2.最简单的http例子
  1.输入URL打开网页
  2.AJAX获取数据
  3.img标签加载图片
3.浏览器跟服务器之间怎么进行一个交互，里面有哪些内容可以影响到这个数据加载的速度或者是它的一个传输的效率，http里面怎样的实现逻辑
4.缓存是web服务中对性能提升最大的一环，所以深入理解http缓存对于web开发的同学，不论你是前端还是后端，都非常的重要。
  Cache-Control:
5.当然http协议不止有缓存，每一个http的头都有使用价值。
  比如：
  Content-Type, Content-Encoding等用来约束数据类型
  Cookie用来保持会话信息
  CORS实现跨域并保持安全性限制
  在更合理的地方使用合理的配置能为你的网站带来更高的收益
6.深入tcp层面
  http协议的原理
    三次握手
    https
    长链接
    http2信道复用
7.http协议是目前互联网上使用最频繁的协议。
8.对于后端开发同学，你能够打造性能更好的HTTP服务
  对于前端开发同学，你能够很好的使用HTTP的特性帮助你进行开发，并且也有一些能够提高前端数据和静态资源加载的性能的方案
  对于前后端协作也是有好处的，因为前端和后端主要的沟通就来自于HTTP协议，如果前后端都能够对HTTP协议深入了解，他们之间的沟通效率肯定是更高的
9.一个完整的HTTP过程
  浏览器api里面会有一个performance，这个performance会给我们记录所有的每一个时间点，那么这个时间点就是HTTP协议在每一个时间点都有它
  发挥作用的地方，然后它的一个时间过程的消耗会通过这个api来进行一个记录，那么对于我们开发者来说我们就可以知道哪一个时间点它的耗时特别的
  长，那么我们就可以优化它。
  在最开始我们要去发起一个请求的时候，我们比如说是在浏览器里面输入一个url，然后按一下回车的时候，那最开始它要做一个redirect，那为什么
  一开始就要做redirect呢，因为有可能我们会存在于像301这种请求返回过，浏览器可能记录了你这个地址已经永久跳转成一个新的地址了，所以一开
  始浏览器就要先去判断一下我需不需要redirect以及我要redirect到哪里，所以对于这种请求，它一开始就要进行一个redirect的操作，这是纯客
  户端的行为，所以为什么redirect在第一环，那么我相信大家应该已经清楚了，然后第二步是要去看缓存，因为你请求的这个资源可能已经缓存过了，
  所以我们要去看app-cache里面它的缓存是否有，那么如果没有缓存，那这个时候呢，我们就要去实际的服务器那边去请求资源了，那么因为我们输入
  的是域名，那么域名要对应成ip之后我们才能真正的访问到服务器，所以这个时候呢要先去查找一个域名对应的ip地址，所以这叫dns解析，然后有了
  ip之后，我们就要去创建tcp连接，那么创建连接，我们要经过一个tcp的三次握手之后才能真正的把连接创建起来，而且同时如果我们这一个请求是
  https的，那么要创建一个https的连接，它跟tcp的三次握手又不一样，因为它中间要有一个保证安全的数据传输的过程，那么这个时候连接创建好
  了之后，我们才真正开始发送http请求的数据包，我们请求的数据包发送完成之后，服务器接收到这个数据，它进行一个操作之后返回我们这个请求想
  要的内容，那么它就开始返回数据，返回数据之后，这一个http请求才真正的完成，这也就是从我们打开浏览器输入url之后整一个有关于数据加载的
  过程所会经历的每一个时间点，掌握这些点之后，你就知道哪个点可以去优化可以去做更多的事情，让我们的http服务可以做的更好。
10.5层网络模型介绍
  应用层 传输层 网络层 数据链路层 物理层
  网络协议分层
    维护整个的网络数据传输的过程的。
        1.每一台电脑上和服务器上这些计算机模型都会有这么一个网络的过程。所以你自己的计算机也可以作为一台web服
        务器来提供网络服务的。
        2.我们的http协议是在应用层上面去实现的。但是http协议呢，它要基于我们传输层里面的一个非常重要的一个协议叫tcp ip协议，这
        个协议是现在网络模型当中最最重要的一个协议，在我们应用的过程当中，比如说我们创建一个http的服务，或者是ftp的服务，或者是
        email的服务，那么这些服务它们都是基于tcp ip协议去实现的。tcpip协议它会涉及到像http请求的一个性能或者是它过程的一个消耗
        这些内容都会涉及到tcpip协议相关的东西。
        3.低三层
          下面那三层呢，因为主要做的是web服务，所以基本上不回去碰到相关的一些东西，我们顶多会稍微涉及一些tcpip协议相关的一些内容。
          下面三层主要做的事情
          1.物理层主要作用是定义物理设备如何传输数据，简单来说，物理层就是我们电脑的硬件，我们的网卡端口，网线以及我们网线连出去
          之后要有一条光缆来为我们把数据传输到互联网可能经过好几千公里的这种情况下把数据传输到对面的一个服务器上面。所以这些物理
          的内容是必须要有的，没有物理我们的软件是没办法去使用的。所以物理层就是这些硬件设备相关的东西。
          2.数据链路层是在通信的实体间建立数据链路连接
          就是说我们物理是可以连接在一起的，把两台机器，那么也要有一个软件服务帮我们去通过物理的设备去创建一个电路的连接，也就是说
          这两边可以去传输数据，那么这边数据链路层基本上就是我们最基础的电脑的传输数据，那就是0101之类的一些东西。
          3.网络层是为数据在节点之间的传输创建逻辑链路
          那么逻辑电路它会包含一些比如说我们从我的电脑要去访问百度的服务器，那么我们如何去寻找百度这台服务器它所在的地址，它就是一
          个逻辑关系，那么这个关系是在网络层为我们去创建的。
        那么这三层不是很理解也没有什么关系，因为这些会相对非常的底层，如果有兴趣的话可以自己去学，如果没有什么兴趣，你也不一定要非
        常了解才能做好一个web应用，因为我们基本上是在http协议相关的里面进行一些操作，最多偶尔会学习一些tcp相关的一些东西来提高我
        们使用http协议的时候一些性能相关的一些内容。
        4.传输层
          1.传输层它主要的有两个协议，一个是tcpip协议，一个是udp协议，在更多的情况下，我们使用的基本上是tcpip协议，因为它是一个更可
          靠的一个协议，帮我们去传输数据。
          2.传输层为我们提供了端到端的一个服务，这个服务是什么概念呢，就是我们建立起了从我们自己的电脑到百度的服务器之间的这么一个连接
          之后，它们两端如何去传输一个数据，它的传输数据的方式都是在这一层进行一个定义的。我们传输的数据有可能很小有可能很大，那么如
          果传输的数据大，一次性我们不能把这么大的数据传输过去，那么我们要分包要分片，这些分片之后，数据传输到那边之后又要进行一个组
          装，组装这个过程，就这些它的协议的定义它如何去组装，如何去传输都是在传输层进行一个定义的。
          3.传输层向高层屏蔽了下层数据的通信的细节
          因为我们http协议是实现在tcpip协议基础之上的，我们http协议要传输一个数据，我们只需要非常简单的，比如说在浏览器里面输一个url
          它就会自动去发送相关的一些数据到服务器端，然后服务器端能够解析这些数据返回给我们的浏览器，然后把页面显示出来，那么我们输入url
          这个过程其实涉及到了一系列的数据的拼装以及去传输，那么这个过程我们作为浏览器端我们作为用户或者说我们作为网页的开发者，不需要
          知道的它里面到底是怎么去分片，它怎么去跟服务器创建一个连接的关系，这些内容我们是完全不需要知道的，因为这是传输层它已经帮我们
          封装掉的。还有就是比如我们创建一个ajax请求，那么ajax请求也是一个http的请求，我们使用ajax的post方式去传输一些数据，那么这
          个数据如果比较大的时候，它也是一次性传输不完的，那么它如何去进行一个传输如何能过可靠的把我们想要的信息传输给服务器，服务器返
          回的信息又如何可靠的被我们拿到，那么这个过程都是传输层这边它已经帮我们去实现掉的，所以我们http协议层是不需要关心的，虽然说不
          需要关心，但是如果你能更好的去理解传输层它的一个传输的过程，那这个时候可能对于在某一些细节上面去实现一个性能更高的http协议的
          使用方式可能会是有非常大的帮助的。
        5.应用层
        就是我们最主要的http协议在这个层级上去实现的
        它们为应用软件提供了很多服务，我们写网页的时候，我们使用http协议去发送请求，我们其实是非常方便的，只要去new一个request，然后
        就可以去把一些数据通过比如说post,get的方式去发送到服务端，这就是应用层在http协议上面，它帮我们实现http协议，然后我们只要去使
        用http协议相关的一些工具就可以帮我们去传输一些数据。
        它是构建于tcp协议之上的，所以它的传输的方式最终都是要落实于在tcpip协议上面。
        它屏蔽了网络传输相关的一些细节，那么就跟tcp帮我们屏蔽了http协议它数据如何去发送的这些细节一样，我们在使用http协议的时候，具体
        的网络传输的细节，那么我们也是不需要去深度的理解的。
    这就是我们经典的5层网络传输模型的一个分层方式以及每一层它基本上主要干的一些事情，这些是相对偏理念的东西，先有一个概念，这样的话我们
    在后续使用到我们这边说到的某一些细节的东西，就可以更好的理解它。
11.http协议的发展历史
  1.第一个定稿的http协议是HTTP/0.9版本，在这个版本里面http的协议它的内容非常非常的简单
    1.它只有一个命令GET，对应的就是我们现在经常用到了的get请求post请求，这些统称为http的命令或者叫做方法。
    2.没有header相关的去描述我们数据信息的一些内容，因为那个时候它的请求是非常简单，它需要达到的目的也非常简单，没有那么多不同的
    数据格式之类的东西。
    3.服务器发送完内容之后呢就把tcp连接给关闭了。这里需要明确一点，就是我们这边提到了连接跟我们http请求是不一样的，http请求跟tcp
    连接它不是一个概念，在同一个tcp连接里面我们可以发送很多个http请求，以前的协议版本是不能这么做，但是现在HTTP/1.1里面我们是可
    以这么做了，而且在HTTP2里面是会更大的去优化相关的一些东西来提高我们http协议传输的一个效率以及服务器的性能，所以这边tcp连
    接对应的是多个http请求，而一个http请求它肯定是在某一个tcp连接里面去进行发送的。
  2.第二个版本就是HTTP/1.0版本，这个版本跟我们现在最普遍使用的HTTP/1.1其实已经差不了多少，
    1.在这个版本里面它增加了很多的命令，比如说post,put,header这些命令
    2.增加了像status code和header相关的内容，status code是用来描述服务端它处理我们某一个请求之后它的一个状态的，而header对应
    的就是我们不管是发送还是请求的相关的一些数据，它的描述以及我们对这部分数据如何进行操作的一个方法
    3.其他还增加了，多字符集支持，多部分发送，权限，缓存等，那么这些东西能够更好的有利于我们去使用http请求去实现我们一个web服务。
  3.接下来就到了HTTP/1.1版本，这个版本呢只是在HTTP/1.0上面增加了一些功能来优化整个网络连接的一个过程，在这个版本里面
    1.它支持了持久连接，持久连接是什么意思呢，在HTTP/1.0版本里面呢，我们的一个http请求要去发送，就要在客户端和服务端之间创建一个
    tcp连接，创建这个tcp连接之后，在服务端返回完内容之后，这个tcp连接就关闭掉了，那么这个成本是相对比较高的，因为在建立一个http
    连接的过程当中，我们要进行一个http的三次握手，那么这部分是在tcp协议里面去做掉的，所以我们不需要关心，但是我们要知道在这个创建
    连接的过程当中，它的消耗是比较高的，延迟也会比较高，所以如果我们在建完了一个连接之后它可以不关闭，然后我们以后新的http请求可以
    一直在这个连接里面进行一个发送的话，那么它的性能肯定会高很多，所以这是在HTTP/1.1里面已经给我们去实现了
    2.它增加了pipeline，我们可以在同一个连接里面发送多个请求，但是在HTTP/1.1里面呢，我们发送的请求是可以在同一个连接里面发送多个
    的，但是在服务端我们对于进来的请求我们都是要按照顺序进行一个内容的返回，所以如果我们前一个请求它的等待时间非常的长，而后一个请求
    它处理的也比较快，那这个时候呢，后一个请求它不能先发送，它要等第一个请求数据全部发送完成之后它才能进行发送，所以这部分时间就相当
    于我们一个串行和一个并行它里面的性能的差异就体现出来了，而这个在HTTP2里面就会进行一个优化
    3.增加了其它的一些http的头和命令，其中有一个比较重要的就是host，有了host之后，我们就可以在同一台物理服务器我们可以跑多个不同的
    web服务，比如说一个nodejs的web服务，一个java的web服务，然后通过host这个字段来表示我都是请求到这台物理服务器上面，但是我要请
    求的是里面哪一个我们的软件服务，是node还是我们的java，这就是通过host进行判断的，这个头它增加的好处就是我们在同一个物理服务器或
    者同一个集群里面我们可以部署很多不同的web服务来进行一个使用，这样的话提高我们物理服务的使用效率
  4.最后是HTTP2，HTTP2呢现在还没有普及，但是它肯定是未来，这个毫无疑问的
    1.在HTTP2里面所有数据都是以二进制进行传输的，在HTTP/1.1里面呢，我们大部分的数据传输是通过字符串的，所以它的一个数据的分片方式
    是不太一样的，在HTTP2里面，我们所有的数据都是以贞进行传输的。
    2.而同样是因为有了这一个好处，所以呢我们同一个连接里面发送的请求，它不再需要按照顺序来进行一个返回处理了，它可以同时返回第一个请
    求里面的数据，再同时返回第二个请求里面的数据，这样的话它就是并行的一个效率，能够更大限度的去让整个web应用的传输效率有一个质的提升
    3.头信息压缩以及推送等提高效率的功能，HTTP2其实整体上就是为了解决HTTP/1.1里面它的一些性能底下的问题，头信息压缩是什么概念呢，
    在HTTP/1.1里面我们每一次发送请求和返回请求它的很多http头都是必须要进行一个完整的发送和返回的，但其实这部分头信息呢，里面很多的
    内容，比如说它的header的字段，content-type，accept，catch-control这些字段它是以字符串的形式保存的，所以呢它的栈用的量就是
    我们带宽的量是比较大的，在HTTP2里面呢，我们头信息进行了一个压缩，这个压缩呢就会让我们在头压缩呢就可以有效的减少我们的一个带宽使
    用。推送的功能是什么呢，我们知道http请求是只能够我这边发起了请求然后你响应我的请求返回内容，就是说客户端永远是主动方，服务端它永
    远是被动方，然后在HTTP2里面我们有了推送这个概念，也就是说服务端是可以主动发起一些数据传输的，那它解决了什么问题呢，举一个最简单
    的例子，我们html，我们的web页面，因为现在我们在web页面都会会要求去有一些css和js文件，那么它们都是以连接的方式在html的文本信息
    里面显示着，通过浏览器它解析的里面的内容之后，然后再根据我这个链接里面它包含的这个url地址，我们再去请求对应的css和js文件，那这
    里面就会包含一个顺序的问题，我们需要去先请求到html的文本，然后在浏览器里面运行解析了这个文本之后，我们才能去发送css和js的请求，
    那HTTP2里面有了推送的功能之后，我们在请求这个html的同时我们可以主动把这个html里面所需要引用到的css和js文件推送到我们的客户端
    ，这样的话就是我们的html和css,js它的一个发送顺序是并行的，而不是串行，这样一想大家都能理解就是它整体的一个传输效率和性能肯定是
    要高非常多的。
  这就是我们http协议它进化的一个历史，那么其中当然还包含了https协议，https呢其实是一个安全版本的http，它的实际使用内容跟HTTP/1.1
  其实没有特别大的区别。
12.HTTP的三次握手
  首先要理解一个概念，就是在我们的客户端和我们的服务器之间进行一个http请求的发送和返回的过程当中我们是需要去创建一个叫做tcp connection
  的一个东西，因为http是不存在连接这么一个概念的，它只有请求和响应这么一个概念，那么请求和响应都是数据包，它们之间是要经过一个传输的
  通道的，那么这个传输的通道在哪里呢，就在tcp里面去创建了这么一个从客户端发起和服务端接收的这么一个连接，这个连接呢是可以一直保持在那
  边的，然后呢我们的http请求是在这个连接的基础上面去发送的，那么这里面就有一个概念就是在tcp连接上面是可以发送多个http请求的，在不同
  的版本里面这个模式是不一样的，在HTTP/1.0里面，那么这个连接是在一个http请求创建的时候它就去创建这个tcp连接，然后连接创建完了之后，
  请求发送过去，然后服务器响应了之后呢，这个tcp连接它就关闭了。然后呢，在HTTP/1.1里面，这个连接呢，我们可以通过某种方式去声明，这个
  连接是可以一直保持在那边的，保持在那边是什么意思呢，就是我们这个请求，第一个请求发送完了之后，这个tcp连接没有关，然后第二个有请求进
  来的时候，它还可以在这个连接上面进行一个发送，那么这有什么好处呢，就是因为tcp连接在创建的过程当中，是有三次握手这么一个消耗的，三次
  握手就是代表有三次网络传输，客户端发送过去一次，然后服务端返回一次，然后客户端再发送一次，这个时候才创建了这个tcp连接，然后才能去发
  送http请求，所以如果我们在这个tcp连接把它保持在那边，那么第二个http请求就没有三次握手的开销。然后在HTTP2里面还有一个好处就是HTTP2
  里面tcp连接上面的http请求是可以并发的，这就导致什么呢，就是说我们在同一个用户对同一个服务器发起一个网页请求的时候它只需要一个tcp连
  接，那么具体到底是什么含义呢，我们在后面的课时里面会详细的讲，connection就是长连接的一课时会单独的很详细的讲解。在这节课里面首先要
  清楚的就是tcp连接和http请求他们之间的一个关系。
  1.HTTP的三次握手
  三次握手就是在真正的数据传输之前来用三次握手检查该网络的畅通性，如果三次握手成功，说明网络畅通建立tcp连接，如果三次握手失败则说明网
  络不畅通，服务端关闭tcp连接以减小服务端的开销。
    1.详细过程
        在HTTP的三次握手当中，首先客户端它发起一个我要创建一个连接的这么一个数据包的请求，它发送到服务端，然后这里面呢会有一个标志位，
        是叫做SYN,SYN呢它是一个标志位，就是说我这是一个创建请求的一个数据包，然后后面它会发送一个叫Seq=0，然后呢服务端它接收到了这
        个数据包之后，它知道说我有一个客户它要跟我创建一个连接啦，那么创建这个连接之后呢，它这边就会开启一个tcp的socket的一个端口，
        然后这个端口开启之后呢，它返回给客户端，那返回的客户端数据里面它也是一个SYN第一个标志位，然后呢它会返回这个ACK,ACK呢就等于客
        户端发送过来的Seq+1,然后呢它再发送一个Seq=Y,这个Y=0,这个是服务端的一个Seq,然后客户端拿到之后说服务端已经允许我去创建这个
        tcp连接啦，然后它再去发送它的ACK=Y+1，然后呢它的Seq等于服务端返回的ACK，这就是去创建一个tcp连接的过程，那么为什么我们要去
        进行这样的一个三次握手呢，这是为了防止服务端这边它开启一些无用的连接，因为我们知道网络传输是有延时的，因为我们中间可能隔的非常
        远的距离，要通过一个光纤然后还有各种中间的代理服务器来进行一个传输，那么传输的过程当中，比如说客户端这边它发起了一个SYN创建连
        接的请求，那么如果服务端这边就直接创建了这个连接，然后它返回了这个内容给客户端，但是这个数据包呢因为网络传输的原因它丢失了，它
        丢失了之后那么客户端就一直没有接收到服务器返回的这个东西，然后它(客户端)这边呢它可能有设置了一个超时时间说我关闭了，就是我超过
        了这个时间之后，我这个连接创建就关闭了，那么我可能再发起一个新的创建连接的请求，那这个时候服务端是不知道的，因为它如果我们没有
        第三次握手在这里的话，服务端是根本不知道客户端它到底有没有接收到我返回的信息，并且它没有给我一个确认说要去创建还是要关闭这个请
        求，那么服务端这边的端口就一直开着，就等着客户端来发送实际的请求数据了，那这个时候服务端这个开销就浪费了，因为它不知道这个连接
        已经创建失败了，可能客户端已经去创建别的新的连接去了，所以呢我们需要这个三次握手来确认这个过程，让客户端和服务端能够及时的察觉
        到说我们因为网络原因的一些问题导致数据包没有查到然后这个端口这个连接就已经关闭了，我们不需要一直等在那边这种情况，三次握手主要
        是为了规避这些网络传输当中延时啊导致的一些服务器开销的问题。
    2.http创建连接的三次握手的数据包情况
        13789 -> 80 [SYN] Seq=0
        80 -> 13789 [SYN, ACK] Seq=0 Ack=1  // 这个服务端返回的Ack是客户端请求的Seq+1
        13789 -> 80 [ACK] Seq=1 Ack=1  // 最后一次握手，Seq等于服务端返回的Ack，Ack等于服务端返回的Seq+1
13.URI,URL和URN
  作为我们http协议当中，我们使用的基本上都是URL，那么我们要理解一下什么是URI和URL它们的区别，还有URN又是什么东西
  1.URI是什么呢
    1.URI其实是一个包含URL和URN它们统一的一个定义，它叫做
    Uniform Resource Identifier/统一资源标志符
    因为URL我们知道是用来定位我们一个web网站它的具体的某一个页面，基本上我们现在的使用方式都是这样，但是从http或者从web的角度，
    它的定义其实并不仅仅是如此，这些名词它的定义呢主要是为了去识别我们在互联网上一个固定位置，它的资源所在的地方，用这种方式来标
    志了某一个资源了之后，我们就可以通过一个链接的方式去找到这个资源，因为互联网当中这些http协议或者ftp协议它们主要的目的就是为
    了去找到某一资源，并且通过某种方式去获得这个资源，比如说我们的网页其实就是html的代码，我们通过URL去访问到了这个地址之后然后
    指代的就是我们指定的这个html代码的地方，然后就返回我们这个html代码，并且把页面的内容显示出来，比如说我们通过Http://baidu.com
    我们就可以打开百度的这个页面，但是如果我们任何一个地方打错了一个字，那么它是没有办法打开百度这个页面的，所以只有www.baidu.com
    指代的是百度这个页面，你其它任何东西都指代不了百度这个页面，除非是百度那边设置了另外一个链接它重定向这个页面，它确实是可以访
    问到，但它只是重定向到了，就最终只有Http://www.baidu.com 这么一个资源的地址，它是对应百度这个页面。而URI就是为了去定位某
    一个特定的资源而去设计的
    2.用来标识互联网上的唯一的资源的一个方式，它包含了URL和URN
  2.URL
    Uniform Resource Locator/统一资源定位器
    用来找到这个资源它所在的位置，并且去访问它得到它。
    URL所有的部分就包含这些：
    http://user:pass@host.com:80/path?query=string#hash
      1.http:// 协议名词://
        协议定义我们以怎么样的一个方式怎么样的一个协议去访问这个资源，有很多不同的协议，比如说我们通过ftp也可以去访问互联网上的
        某一些资源，还有想mail2就是我们怎么给一个邮件地址去发送一个邮件，因为这些协议它的服务的实现方式会不一样，我们通过不同的
        协议去访问这个服务，那么它的一个解析的方式就会不一样，所以这就是协议的一个重要性，因为它定义了我们服务以及我们的发送方如
        何去传输数据，然后服务如何去解析数据。
      2.user:pass@
        这个代表我们去访问了这个资源之后，如果这个资源需要有特定的身份才能访问，那么你可以在前面加入user:pass来指定说我就是这个
        用户，并且你的服务可以通过我的用户名跟密码来进行一个认证，来表示我这个用户我是真的是这个用户而不是一个虚假的用户，那么这
        种方式在我们现在的web开发里面基本是不太用到的，因为有更好的方式去做用户的认证，如果你每一次需要用户认证的一个内容都需要
        在url里面去输入这个用户名密码，那么它是一个非常不安全的，而且也是非常麻烦的一个操作。
      3.hostname
        host.com或者ip
        这个是用来定位我们这个资源它所在的服务器在互联网中的一个位置，因为我们知道互联网中我们定位一台机器最基础的那就是它的ip，
        那么hostname它可以是ip，那么它就可以直接通过ip去找到这台机器，或者它可以是域名，那么域名我们要通过dns的一个服务去解析
        成ip，然后才能定位到那台服务，所以host相关的它就是用来找这一台服务器所在的互联网的位置
      4.:80
        这个是一个端口，为什么要有端口呢，因为每一台服务器都有非常非常多的端口，在这台服务器上你可以跑很多的我们软件的就是web服
        务，这个web服务呢它可以监听各种不同的端口，那么如果我们要找的是这台物理服务器上面某一个web服务上面它里面存放的这些资源
        的话呢我们就要指定我们是要找的哪一个web服务，也就是说端口就是用来定位我们host找到的那台服务器就是物理服务器上面它存放的
        许多个web服务当中的某一个web服务，因为整个http协议它其实就是一个用来定位的，所以我们先要找到这台物理服务器，然后再找到
        它的一个web服务器，然后我们才能再根据后面的一些内容去定位到这个web服务器下面存放的内容，其实相当于就是我们的搜索范围从
        大的再往小的一点一点精确精确最终精确到我们真正想要找的这个内容。那么在我们常用的已经正式上线的这些web服务上面呢，我们基
        本上后面是不带端口的，这是为什么呢，因为不带端口的情况下默认它其实是传了一个80端口，就是默认我们不带端口的情况下访问的就
        是80端口，而因为端口这个东西是不方便于我们用户去记忆的，所以呢一般情况下我们正式发布到互联网上的这个服务呢都是不带端口的
        而是直接通过域名进行一个访问，这样的话就方便于记忆，方便于传播。
      5./path
        这个path呢我们一般叫它路由，这个路由是什么意思呢，因为这个web服务里面它可能存放了非常多的内容，我们具体要如何找到这个内
        容，那么我们可以通过路由这个东西来进行一个定位，那么路由其实如果了解一些linux的基础的话，你应该可以很明显的看到它这个写
        法跟我们linux里面文件目录的一个路径其实是很像的，比如说它的/代表的是根目录。我们一般认为/就是根目录，如果你是直接在命令
        行里面输入cd /，那么它会跳到我们整台服务器它的操作系统的根目录，那么很多时候我们会认为/是我们这个web服务所在的这个目录的
        根目录。那后面跟上了一个路径代表什么呢，从http的定义上来讲，我们这个路径应该是直接对应的我们这个web服务它的一个目录结构
        下面的路径，那么很多时候因为现在我们的web应用变得越来越复杂，我们的很多数据都是存在数据库里面的，而不是对应我们某一个磁盘
        上的一个文件它所在的位置，所以呢我们更多时候是直接把它用来辨别我们现在这个url所要请求的数据在程序里面去判断而不是直接对应
        一个目录结构的一个映射关系，这就是路由它的一个定义以及它的一个使用方式。
      6.?query=string
        这是一个搜索参数，就是说我们要请求的这个资源我们如何去进行一个搜索进行一些查找或者一些操作的一个方式，那么我们可以通过这种
        方式，基本上我们现在web服务就是用它来传参。
      7.#hash
        后面跟上一个hash，那么这个hash是干嘛用的呢，哈希其实是在http的定义里面它是代表我们请求的前面整个url它找到了一个文档，但
        如果这个文档它非常的大，比如说有好几兆的内容，然后都是文字的，那这个时候呢我如果一下子返回这么多，我并不需要，我其实只是作
        为用户来讲我只是想看一下它某一个段落，那么用这个hash我们其实从http的定义上来讲应该叫fragment,它就是代表我们这个文档里面
        的某一个片段，就是我要看文档里面的某一个片段，那现在呢我们的web服务我们作为前端页面开发时候，我们经常是用hash来作为一个锚
        点的一个定位的一个工具。
    这就是一整个url它的一个格式，它里面的每一部分都是有它特定的含义的，这些大家一定要清楚，那么这一类的格式我们都叫它url，比如说ftp
    协议的，它整个也是叫url，所以不是仅仅http的请求它才是一个url，有很多不同的协议都可以叫url
  3.URN
    URN这个东西呢，因为现在使用的不多，所以只要了解一下定义就可以了，它是一个
    永久统一资源定位符
    这是什么意思呢，因为我们作为url就是我们http的服务，如果我们某一个资源，它这个链接，我们这个资源呢把它搬了一个位置，那么可能就导
    致这个链接访问的时候，它是请求不到具体的内容的，一般情况下比如说我们现在访问一个不存在的链接都会返回404，但是呢这个url是不会告诉
    你说这个资源被搬到了哪个地方，你怎么样再能去访问到你想要访问的这个东西，那么URN就解决了这个问题，就是很多这方面的专家都在研究如
    何去在出现了这种情况的时候，然后通过URN它可以帮你就是即便你这个内容它搬了一个新的位置，但是它还可以通过URN就是同一个URN去访问到
    这个地方，就是说你只要把这个URN指向了这个资源，即便你搬来搬去，你换了很远的一个地方，它还是能够找到，这就是url它所不具备的一个能
    力，这就是我们刚才说的资源移动之后还能被找到。目前还没有非常成熟的一个使用方案，在业界也没有什么非常好的一个使用场景。所以只要知道
    它解决了什么问题就可以了。
这就是我们URI,URL和URN的一些定义，大家一定要清楚。
14.HTTP报文格式(首行信息)
  http协议它的一个报文的形式
  我们http是请求和响应的这种形式，也就是说发起请求这一方永远是主动的，我们发起了一个请求之后，服务端才会给我们一个响应
  1.它的一个请求报文的格式是这样的：
    1.首先http请求都有一个首行，这个首行呢它并不属于http的headers,headers它是另外区分的，那么首行里面会包含什么呢：
      1.在请求报文里面首行首先它会包含一个method就是我们请求的方法，http的method有很多种，get,post,put,delete，它们有各自的
      语义，一个完成度非常高的web服务会对于不同的请求方法对于同一个url会有不同的操作，这就是请求方法它的一个语义，比如说get它是获
      取这个数据，那么post是我要创建一个数据，put是我要更新这个数据，delete是我要删除这个数据，所以每一个http的method它是有各自
      的语义的，当然这边我要提醒一点，那就是说它这个定义只是一张纸上面写的，就是告诉它应该这么做，但是实际上你完全可以不按照它这个方
      法去实现你的web服务，比如说你如果想通过这个method你去实现一下把这个数据更新掉，完全没有问题，你完全可以这么做，只不过你没有
      遵照http协议它的一个语义化的一个定义去做，那么这有一个什么坏处呢，就是一个不知情的人来访问你的服务的时候，可能一不小心做了一
      个他认为安全的操作，但是你这边呢直接把数据给更新掉了，这就是语义它存在的一个意义，它是希望你规范这个操作，但是你不一点要按照它
      这个操作执行，因为http的协议是没有一个强约束你最终去怎么实现你的这个请求的一个内容的，它只是从定义上面告诉你应该这么去做，但至
      于你真的是不是这么做那么取决于个人的选择。
      2.在请求报文的首行里面呢，第二部分是一个url，就是我要请求的这个资源的地址，一般来说我们这边它只是存放一个路由相关的一些东西，
      而不会包含说像是我们的http协议，因为我们这个报文肯定是http协议的，所以你不需要把协议包含进去，而我们请求的地址是我们在服务
      端发起请求的时候它需要去解析以及创建连接的过程，最终我在发送这个请求的时候，我的连接已经创建完成了，所以我的这个请求报文里面
      没必要把这部分放进去了，我只需要告诉这个服务器，我具体请求的资源是哪个地方就可以
      3.然后首行的第三部分是这个协议的版本，这里就要告诉它这个协议的实现到底是哪一个版本，因为不同的版本可能会有一些不同的操作，比
      如说有一些http的header是没有办法返回的，因为它是没有效果的
    这就是http报文的一个首行
    2.那么首行包含了这些信息，那么header就包含了我传输的这些数据它所包含的一些内容，那么具体http header这一块我们在后面会有很多的
    课为大家讲解每一个header具体有什么用，如何去实现一些功能之类的，我们这一节课主要讲的是首行的一个内容。
  2.然后对应的是我们的响应报文
    1.响应报文也就是response它的一个首行
      1.首先第一部分是http/1.0，也就是一个http的version就是它的版本。
      2.然后第二部分呢是一个code，这个code代表什么意思呢，http协议里面定义了非常多的code，每一个code都有它的一个含义代表我这个请
      求目前是处于一个怎么样的状态，那么200就代表这个状态是OK的，是正常请求而且我可以正常返回你的内容，然后还有像300部分的，就是300
      -399，那么里面有很多的各种定义，然后400-499还有500-599都有它们各自的含义，那么每一个区间它的整体含义是有一个定义，然后每一个
      小的code它又有自己的一个定义，然后对应的是200后面还有一个OK，那么这个OK是什么意思呢，你可以理解为200是code，那么这个OK是这个
      code所代表的含义，用明文的方式来告诉你具体说这个请求是怎么样的，比如说401我们后面跟的这个status那么它就是non authentication
      就是我们没有认证，每一个code会有对应的这么一个字符串来告诉你它具体是什么含义。
  这就是我们一个http请求和响应它的报文的起始行代表的意义，我们可以看到这边有一个格式的问题，就是首行的每一部分之间使用空格进行区分的。
  然后呢在我们解析这个报文的时候呢，我们把首行认为是一个最基础的就是我们首行信息，首行换行之后都是http的header,然后http的header要
  跟http的body进行一个区分的时候是怎么办的呢，这边中间是一个完整的空行，而不仅仅是直接换行就可以了，而是要有一个空行来区分，那么在前
  面的这一部分也就是首行和header读取完成之后读到一个空行，空行之后的内容就全部是http body的内容。所以这就是整的一个http请求报文的
  它的一个格式，大家要注意它的一些定义上面的东西，这节课我们主要是讲的首行的内容和它里面的一些定义。
  3.HTTP的方法
    它是用来定义对资源的操作的，就是我们上节讲到的get对应的是什么，post对应的是什么，put对应的是什么，最常用的就是get,post,put,
    delete，然后还有一些像patch像header这种请求方式也都有，一般我们做web服务的时候是不太会用到这些方法的，而get,post,put,delete
    分别对应就是获取数据，创建数据，修改数据以及删除数据，最简单的我们crud的操作，因为现在web服务更多的就是这些操作，向我们使用restful
    的接口，我们也会使用这些http的方法来定义我们对一个资源的操作，这样的话我们同一个url通过不同的method来进行区分具体的一个操作内容
    ，这样的话我们的整个的api接口的设计就会变得更加的规范，从定义上来讲它们是有各自的语义的，再次声明一下，语义这个东西它是定义上的，
    具体如何实现取决于你自己的一个操作
  4.HTTP code
    1.它定义的是服务器对请求的一个处理结果，这个结果它是处理成功的还是说它需要重定向的还是你发送的请求有问题，比如说你没有做认证，还有
    就是说我处理的时候发现服务器出现了错误，那么这个code它是有各自的含义来代表的。
    2.各个区间的code有各自的语义，比如说：
      1.100-199之间代表你这个操作要持续进行，接下去要再做一些其它的事情，那么我这个请求才能继续返回给你。
      2.200-299那么它代表这个操作是成功的
      3.300-399它代表这个操作你需要去重定向，有别的方式去获取这个数据
      4.400-499是代表你发送的请求有问题，最具有代表性的就是401就代表你发送这个请求的时候你没有做认证，那么你是没有权限去获取你请求的
      资源的内容。
      5.500-599这代表是服务器出现了错误
      6.常见http状态码
        200: 请求成功，所请求的资源发送回客户端
        400: 客户端请求有语法错误，不能被服务器所理解
        403: 禁止访问，服务器收到请求，但是拒绝提供服务
        404: 可以连接服务器，但服务器无法取得所请求的网页，请求资源不存在
        500: 服务器遇到错误，无法完成请求
        502: 网关错误
        503: 由于超载或停机维护，服务器目前无法使用，请求超时，一段时间后可恢复正常
        1**(信息类) 2**(响应成功) 3**(重定向类) 4**(客户端错误类) 5**(服务端错误类)
    3.一个好的http服务是可以通过code来判断这个结果的，就是说你实现了一个非常好的一个http的服务呢，我可以很直观的从你返回给我的http
    code就得知我现在这个请求我处理的结果是怎么样的，我接下去该怎么操作，但是呢现在我们国内很多的做web开发的同学在做服务器的时候呢，在
    他们眼里http code是只有两种，一种是200，一种是500，不管是说我数据请求是正确的还是错误的还是你没有认证，我都会返回你200，然后我
    再返回你一个数据，在这个数据里面再去说明你这个请求到底是正确的还是错误的，那么这种操作方式很明显它不是一个合格的去实现了http语义的
    一个http服务的实现，如果大家接下去以后要去做这些http服务器相关的实现的时候，建议大家是尽量的遵照http它的一个定义，它的一个语义化
    去实现你的一个服务，这样的话你的http服务是更具有通用性的，并且是更符合我们正常的http服务它的一个实现过程
  这就是我们http它的一个首行的信息，以及它每个信息基本上有什么用，在这里进行的一个简单的讲解，那么这些都是语义上面的东西，所以我只是通
  过一个讲解的过程让大家理解这些东西到底是干嘛用的，而且大家也只需要知道就可以了，因为它并没有在我们实现某一个功能的一个规范性上有一定
  的约束力。它只是说定义了这些东西。
15.创建一个最简单的web服务
  server.js
    const http = require('http')
    http.createServer(function (request, response) {
        // request对应就是请求我们这个服务它发送的内容都会封装到这个request对象里面
        // response就是我们要做一些返回的内容的时候我们使用这个对象来进行一个操作就可以返回我们想要返回的东西了
        console.log('request come', request.url)

        // 然后呢我们要做出一个返回，不然的话我们就相当于没有进行一个返回的操作，这样的话我们的页面就直接报错了
        response.end('123')

    }).listen(8888) // 那么我们有了这个服务之后呢，我们需要去监听一个端口，因为我们所有的服务要监听一个端口之后才能进行一个访问
    console.log('server listening on 8888')
    /* 
        那么我们最简单的一个nodejs的http服务就已经写好了，写好了之后呢，我们就可以去启动它，创建成功之后呢我们就可以通过
        localhost:8888来进行一个访问。我们可以看到浏览器页面上有一个内容的显示是我们的123，它显示出来了代表我们服务请求
        成功了，而且它有返回内容了。
        接下去我们要讲的内容都会基于这个服务我们来进行一个演示，让大家能够更好的去理解在http协议当中我们如何去传输数据以及使用数据的。
    */
16.认识http客户端
  接下来我们会讲很多关于http header以及它的一些功能，因为要做一些测试相关的东西，我们可能会用到一些非浏览器的工具，所以这节课先讲解
  一下什么是http的客户端。最简单的http客户端就是我们的浏览器，我们在浏览器里面输入baidu.com，我们的浏览器呢就会给我们发送一个到
  baidu.com的一个http请求，然后得到它的一个返回内容并把它渲染出来，我们打开浏览器的调试工具，然后呢在network这一栏我们可以看到百度
  这个页面呢其实有很多的一个请求，这边呢每一个都以http请求，入口的一个请求就是baidu.com，在这边我们可以看到一些请求相关的内容以及它
  返回的内容，上面的General就是我们上一节讲到的http的http的首行，它并不属于headers里面的相关的内容。所以呢浏览器就是最常用的http
  客户端，它不仅仅是给我们发送http请求并且返回内容的一个工具，它还帮我们处理了返回的内容，我们可以在network的调试端看到它的Response
  ，Response其实是html的代码，就是我们在写一个网站的时候我们肯定会写很多html相关的代码，那么这些代码是浏览器这边请求之后返回的内容，
  返回的内容如何变成我们这边看到的页面呢，就是浏览它又继续做了一个工作，那这并不属于http请求的范畴。这是一个最常用最的http client，还
  有其他很多的http client，你只要是实现了发送一个标准的http请求的报文的一个工具，那么它就是一个http client，那么后续我们要用到的像
  curl,这个工具我们就可以用它来看很多我们想要的http请求和返回的相关的一些内容，curl -v这个参数能够帮我们很详细的展示出一些请求和返回
  的它的header或者它的一些general相关的东西。有时候，我们要使用curl来帮我们去做一些类似于去观察一下我们的http请求它的请求返回的一
  些内容的时候很好的一个工具。http不仅仅是用在http里面，很多时候我们都是不在浏览器里面使用http的，我们的爬虫，那么它就是一个我们自己写
  的代码去发送请求的，然后爬取数据去进行一些分析，这些都是http的client,那么具体要怎么操作都可以按照自己的想法去实现。
17.CORS跨域请求的限制与解决
  今天我们来讲一下浏览器的一个同域的限制，也就是我们做web开发常说到的跨域如何请求资源的一个问题。
  1.cors
    其实不管我们有没有返回'Access-Control-Allow-Origin'这个头，浏览器它都会向我们的服务去发送这个请求，浏览器在发送一个请求的时候
    它并不知道我们这个服务是不是跨域的，所以说它还是会发送请求，并且接收你的返回内容，只不过呢在浏览器接收到它的数据返回的时候，它看到
    里面没有一个'Access-Control-Allow-Origin'这么一个头并且设置为允许的话，那么它会把这个请求返回的内容给它忽略掉并且在你的命令行
    里面给你报这个错，所以这个原理就是请求已经发送了，内容也已经返回了，只不过浏览器在解析了这个返回的内容之后，它发现这是不允许的，所
    以它帮你拦截掉了，这其实是浏览器它提供的一个功能，如果我们在自己的curl里面你随便去发送哪个域名下面的东西，它都没有一个所谓的跨域的
    概念，你任何http请求都是可以发送到的并且都是可以返回内容并且输出的，所以这就是浏览器的跨域的一个限制，就是说你在这一个网页的请求里
    面你发送的任何ajax请求它都是必须在同域里面的，如果跨域那么需要服务器那边同意你跨域你才能够接收到它的一个返回内容。
  2.jsonp 
    因为我们的浏览器它是允许像link标签img标签script标签这些在标签上写路径加载一些内容的时候，它是允许跨域的，它并不在乎你这个服务器它
    是否设置了这个跨域的头，所以jsonp它实现的原理其实就是在script标签里面去加载了一个链接，然后这个链接去访问了服务器的某一个请求并且
    返回了内容，因为服务器返回的内容是可控的，所以我们可以在服务器的返回内容里面写的script标签里面的代码是一段可执行的js代码，然后去调
    用jsonp在发起请求之前它给我们设置的一些内容(这个内容是一个函数定义)，这样的话我们就可以去达到一些我们想要达到的目的，这就是jsonp去
    实现跨域的一个原理。
    它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源。
    客户端
      1.写好<script src='url'></script>标签，可以动态添加并且在url后面写上传给服务端的函数的名字。
      2.定义上面名字的函数用来接收服务端传过来的数据。
    服务端
      1.返回一段可执行的js代码，这段可执行代码就是一个调用客户端请求上面传过来的的函数并且已经将处理好的数据当作函数的参数返回给客户端。
  3.proxy代理
18.CORS跨域限制以及预请求验证
  上一节课中我们讲了使用'Access-Control-Allow-Origin'来允许我们服务之间跨服务的去请求一个数据，那么是否所有情况我们都可以通过设置
  这个头来完成跨域的一个操作呢，并不是如此，所以呢我们这节课就来讲一讲浏览器跨域请求的其他的一些限制。
  1.在cors里面存在的一些其他的限制
    1.首先在跨域的时候我们默认允许的方法只有GET,HEAD,POST，那么其他的方法比如说PUT,DELETE这些方法都是默认不允许的，浏览器要有一个预
      请求的方式去验证的，那么至于预请求做了什么，后面我们会讲，所以首先大家要清楚就是允许的方法在这三个我们使用的时候它是不需要去使用预
      请求去验证过的，但是如果使用其他的方法，都是需要的。
    2.然后还要允许的Content-Type也有限制，一个是text/plain,一个是multipart/form-data,还有一个是application/x-www-from-urlencoded,
      这三个就是我们在html里面使用form表单这个element的时候我们可以设置的三种数据类型，那么除了这三种Content-Type之外的其他的Content-Type
      那么你也需要使用预请求去验证过之后才能进行一个发送。
    3.还有其他的限制，比如说请求头的限制
      1.我们自定义的请求头它就是默认不允许的，它需要去验证过
      2.那么其他还有哪些请求头是不允许的呢，这边有一个网页是官方的一个文档，这上面有说明我们在进行cors的时候哪些默认的头是可以允许使用的，
        除了这些头之外的头它都是需要服务端那边进行过一个预请求的验证的。
        https://fetch.spec.whatwg.org/#cors-safelisted-request-header
      3.XMLHttpRequestUpload对象均没有注册任何监听事件
      4.请求中没有使用ReadableStream对象
  2.cors的预请求
    我们可以在network里看到，我们这边发送了这个请求，而且返回是200 OK，这代表呢就是跟我们上节课讲到过的一样，虽然是它不允许跨域，但呢它
    请求仍然会发送，而且数据呢其实是有返回的，只不过浏览器因为一些安全策略的问题，它把这个请求的返回给忽略掉了并且给你报了这么一个错，那么
    浏览器具体是根据什么来判断这个请求的返回是允不允许的呢，答案就是我们的header跟我们上节课里面一样。如果我们要允许我们自定义的头在请求
    里面发送，那么我们需要返回一个新的头来告诉浏览器我们这个操作是允许的，那么这个头是什么呢，就是
    'Access-Control-Allow-Headers':'我们自定义的头'
    那么这个头允许了之后，是否代表我们刚才那个请求就会成功呢，答案是这个请求就成功了。
    发送成功之后呢，我们会发现这时候多了一个请求，多的这个请求就是我们真正的请求，之前的是预请求，就是它首先发送一个请求，它的request method
    是options，然后其他的东西是跟我们发送的是一摸一样的，只不过它的method是options，我们服务端可以根据不同的method去进行不同的一个操作，
    所以在这边呢，浏览器希望我们做的是什么呢，根据这个options这个method，我们提供的是返回告诉浏览器我们允许你接下去要发的就是我们实际发
    的这个post请求里面的操作的内容是允许的，它是通过这个option请求来获得一个服务端允许的认可，然后再实际发送post请求，所以这就是浏览器的对于
    跨域请求的一个预请求的一个操作，那么既然我们可以通过headers去允许自定义的头，同样的如果我们要我们刚才提到过的那三个方法之外的方法，我们可以
    通过设置'Access-Control-Allow-Methods':'POST,PUT,Delete'来使用，如果这些都是允许的，那么我们发送请求的这边就可以使用这些方法。
    这就是突破跨域限制的几种方法。那么浏览器为什么要提供这些限制呢，因为它希望的是我们在网页里面去进行一些跨域的操作的时候，这个操作是保证
    服务端的一个安全的，它不允许任何随随便便的人都可以进行一个跨域，而且不允许随随便便的一个方法进行跨域，它不希望我们因为一些跨域的请求导致
    我们某一个服务的数据被恶意的串改，所以它提供这些限制之后我们就可以进行一些非常有利的判断来判读我们这个请求到底是否要进行一个响应。
    最后还有一条就是'Access-Control-Max-Age':'1000'代表我们这个请求下面我们允许以这种方式进行跨域的一个请求的最长时间1000秒之内你不需要
    再发送预请求来验证了，直接发起正式的请求就可以了，因为我们的服务在这段时间内已经告诉浏览器说你这个操作是允许的是合规的，你不需要再去验证
    过了。那么这就是我们在浏览器当中要进行跨域的几个限制，根据上一节课的再进行的一些补充，那么这些就是如果你要去做一个跨域的服务，那么就要去
    考虑这些问题，如何进行验证，如何让服务变得更合理，能够保证安全。
19.缓存头Cache-Control的含义和使用
  这节课我们来讲一下关于http协议当中的缓存，也就是Cache-Control，首先Cache-Control有哪些特性呢
    1.可缓存性
      第一个是它的可缓存性，它的可缓存性包括public,private以及no-cache,那么这些都是什么意思呢
      public是指在这个http请求返回的过程当中我在Cache-Control里面设置了public这个值，那么代表这个http请求它返回的内容所经过的任何
      路径当中，包括一些中间的http代理服务器，以及我们发出这个请求的客户端浏览器它都可以进行对我这个返回内容的一个缓存的操作，那么所谓缓存
      大家应该都清楚，就是说我把这份数据存在我本地，然后下一次我可以直接读这个缓存，然后去使用这个数据，而不需要到真正返回这个内容的服务器
      上面去重新进行操作然后返回内容了，那么因为在网络中会有非常多的代理服务器以及我们发起的这个客户端，它们都可以进行一个缓存的操作，而它的
      可缓存性就是用来指定哪些地方可以去执行这个缓存，那么public就是说任何地方这个http经过的任何地方它都可以进行一个缓存，而private就代
      表只有发起请求的这个浏览器，它才可以进行一个缓存，而no-cache那就是任何一个节点，它都不可以进行缓存，这就是Cache-Control的一个可缓
      存性的概念。
    2.到期
      那么到期，就是说这个缓存什么时候到期
      1.那么最常用的max-age=<seconds>,我们可以根据自己的需求去设置我们这一部分的缓存内容它缓存到多少秒之后，它才会过期，过期了
      之后我们的浏览器它才会再次发送请求到我们的服务器端，然后再去请求一个新的内容
      2.s-maxage=<seconds>它会代替max-age，但是呢只有在代理服务器里面它才会生效，也就是说在浏览器端，我们的浏览器它还是会读取
      max-age作为一个缓存的到期时间，但是在代理服务器如果我们设置了max-age和s-maxage这两个，那么它会读取s-maxage，因为这个配
      置项是专门为代理服务器去设置的
      3.max-stale=<seconds>,在我们的max-age过期之后如果我们返回的这部分资源里面有这个max-stale这个设置，max-stale是我们的
      发起请求的这一方它主动去带的一个头，那这个头设置呢是代表即便是我们的缓存已经过期了，但是只要是在max-stale这个时间内，它还可
      以使用过期的缓存，而不需要去原服务器那边去请求一个新的内容，这就是max-stale的一个设置，那么max-stale在浏览器里面是用不到的
      ，因为浏览器我们在发起请求以及我们静态资源请求的过程当中，它并不会主动给我们这只这个头，而这个头呢只有在发起端去设置是有用的，
      在我们服务端返回的内容当中去设置它是没有任何作用的，这就是Cache-Control里面关于到期的一些配置。
    3.重新验证
      1.must-revalidate
        在我们设置了max-age的这个缓存当中，如果它已经过期了，那么我们必须去原服务端去发送这个请求，然后重新获取这部分数据，再来验
        证这个数据到底是否真的过期了，而不能直接使用本地的缓存。
      2.proxy-revalidate
        跟must-revalidate是差不多的意思，只不过呢proxy-revalidate是用在缓存服务器当中的，就是指定缓存服务器在过期的时候，它必
        须要去原服务器上重新请求一遍，而不能直接使用本地的缓存。
    4.其他
      1.no-store
        这边要跟之前的no-cache进行一个区分，no-cache是你可以在本地进行一个缓存，你可以在proxy服务器进行一个缓存，那么每一次你发起
        这个请求的时候都要去服务器那边去验证一下，如果服务器它返回这个请求告诉你，你可以使用本地的缓存，然后你才可以真正的去使用你本地
        这部分缓存，就是说它是要经过服务器端的一个验证的，那么关于如何进行验证我们会在下一节课中讲到，我们只需要知道我们使用no-cache
        它就是代表我们本地可以存缓存，但是呢这个缓存要等服务器验证过之后你才可以去使用。而no-store则是彻底的你本地和代理服务器都是不
        可以去存储这个缓存，就是永远都要去服务器端拿新的body的内容过来才能去使用它，而不能说即便服务器返回告诉你你可以使用缓存，但是
        你本地根本就没有这个缓存，你不能进行一个缓存。
      2.no-transform
        这个也主要是用在proxy服务器那边，因为有一些proxy服务器它比较的有一些想法，它就是说觉得我们返回的这个资源太大了，它帮我们进行
        一些压缩去进行一些格式转换，那么这个是不允许的，就是通过no-transform去配置它告诉我们的代理服务器，你不要去随便改动我返回的一
        个内容。
        那么这些，我又要再提之前我说过的一句非常重要的话，就是这些头它只是一个限制性的声明性的作用，它没有任何强制的约束力，也就是说我
        们这边设置的一些对于代理服务器的它的一些头，我们希望它去按照这个规范去做，但是它完全可以不按照这个规范去做，我们的很多用到代理
        服务器，就比如说我们会用到nginx,我们在正式的环境中很多的线上服务都会用nginx做一层代理，那么用nginx做代理做这个cache是非常
        常见的一种操作，我们之后的有一节课是专门讲nginx如何去做代理服务器的，在那里面我们会更详细的讲到代理服务器它如何去操作一些东西
        ，那么在这里面我们就可以去配置关于我们代理服务器如何去做一些静态资源缓存的一些操作，那么在那里面我们会详细的演示我们这里提到的
        几个关于对代理服务器它的静态资源缓存去操作的一些配置，它如何生效，以及它生效之后会有怎么样的一个效果。
    5.这就是浏览器缓存相关的一些内容，主要就是通过设置Cache-Control以及它的max-age 'Cache-Control': 'max-age=200' 来达到我们
      浏览器长缓存的一个效果，因为Cache-Control可以接受非常多的值所以我们可以在后面使用逗号进行一个区分
      'Cache-Control': 'max-age=200, public',这就是我们设置Cache-Control头的一个效果，那么这些主要就是浏览器缓存相关的，那么
      关于Cache-Control还有很多可以讲的，在后面我们将nginx的服务器代理的时候，我们会深入的再去讲解其他的一些关于一些代理的Cache-Control
      的头，它的属性的一些设置。
20.缓存验证Last-Modified和Etag的使用
  这节课我们来讲我们上节课说到过的，如果我们给我们的Cache-Control设置了no-cache之后，那么每一次浏览器发起对一个已经设置了Cache-Control
  的资源的一个请求的时候，它都会要到服务器端去进行一个资源的验证，验证完了之后如果确定这个资源可以使用缓存，那么它才会读取本地的缓存，
  那么在进入正式的资源验证的课程之前，我们先看一张图：缓存.jpg，能够更好的理解缓存是如何进行一个操作的。
    1.缓存的过程
    首先呢，我们浏览器创建了一个请求，创建了请求之后呢，首先这个请求到达的地方是在本地缓存，当然这是建立在我们有Cache-Control这个头的
    情况下，然后会去本地缓存里面找，如果已经命中了，就是说已经找到了，那么它直接返回给浏览器，浏览器直接显示了，它就不需要经过任何网络的
    一个传输，这也就是在我们network里面看到的from-memory-cache这个展示的一个效果，如果它没有命中呢，它就会往互联网上进行一个发送，
    那么互联网上进行发送的过程当中，有可能就会经过某一层的代理缓存的一个代理服务，那么代理服务里面也会查找相关的一些缓存的设置，以及查看
    这个资源是否有缓存，那么如果命中的话，它就会返回过来，然后经过本地缓存再到浏览器，如果它没有命中，那么它才会真正的最后到我们的原服务
    器，也就是我们自己写的这个webserver里面，然后去获取新的内容，然后再一步步的一个返回，这就是说我们从浏览器发出一个请求到查找缓存的
    一个过程，它是这么样的一个原理，希望大家能够进行更好的理解。
    2.那么我们的数据如何进行一个验证呢，在http协议里面主要的有两个验证的http头
      1.Last-Modified
        Last-Modified它的名字顾名思义就是上次修改时间，也就是说我们给这个资源设置了它上一次是什么时候被修改的，那么它主要配合
        If-Modified-Since或者If-Unmodified-since这两个头进行一个使用，什么意思呢，如果我们请求了一个资源，然后请求这个资
        源上面它返回的header里面有Last-Modified这个头，然后指定了一个时间，那么这个时间在下一次我们浏览器要发起请求的时候它
        就会带上Last-Modified传过来的值，通过If-Modified-Since或者If-Unmodified-Since，那么通常来说浏览器实现的时候都
        是使用If-Modified-Since,那么If-Unmodified-Since有这一个头，但是很少会被用到，然后在这个请求里面就会把它带到我们的
        服务器上，那么我们的服务器就可以通过读取这个header里面的If-Modified-Since带来的这个值，然后呢，对比我们这个资源存在
        的一个地方，然后对比它上次修改的时间，如果发现这两个时间是一样的，那么代表这个资源还没有被重新修改过，那它没有被重新修改
        过，那么服务器就可以告诉浏览器你可以直接使用你缓存的这个，这就是我们去验证我们这个资源能否使用缓存的一个过程。
      2.Etag
        Etag它是一个更加严格的一个验证，Etag的验证呢主要就是通过数据签名，所谓的数据签名是什么呢，就是说我们的一个资源，对它的
        内容会产生唯一的一个签名，也就是说它的这个数据进行了一个修改，它的签名就会变成一个新的，只要有任何修改，它的两个签名就会
        不一样，那么最典型的一个做法就是我们对资源的内容进行一个哈希计算，那么这是最常见的一个，就跟我们在上一节课中讲到的在我们
        的静态资源文件名后面加上一个哈希值是一样的，这个哈希是一样的一个东西，比如说对它内容进行一次计算之后，它会得到一个唯一值
        ，我们用这个签名来标记这个资源，那么下一次我们浏览器发起请求的时候，就会带上If-Match或者If-None-Match这个头，这个头里
        面的值呢就是我们在服务端返回过来的这个Etag的值，然后呢我们对比这两个，服务器拿到了浏览器传过来的这个头之后，我们就可以对
        比我们现在在服务器那边存在的这个资源的签名以及浏览器传过来的签名，如果这两个是相同的，那么它就不需要返回一个新的内容，
    这就是我们关于Etag跟If-Modified-Since的一个讲解。
    http code 304就是Not Modified没有修改的意思，配合缓存验证使用，服务端收到浏览器端的验证信息后，验证服务端资源没有修改告诉
    浏览器可以使用缓存的同时的http code即为304
    Cache-Control里不设置no-cache也不设置no-store,那么浏览器就会在max-age的时间内一直使用缓存；设置no-cache，那么需要去服
    务端进行验证是否能够使用缓存，发送的请求中会带上缓存验证的头；no-store是永远都不使用缓存，发送的请求中也没有需要缓存验证的头。
21.cookie和session
  1.cookie
    1.什么是cookie
      cookie是在服务端返回数据的时候通过Set-Cookie这个header设置到浏览器里面，它保存在浏览器里面的一个内容，那么这个内容我们
      就叫它cookie，浏览器保存了这个cookie之后，它在下一次同域的请求当中，它就会带上这个cookie，通过这个我们就可以实现在这一次
      我们访问用户访问的这个网站的会话当中，我们就可以通过cookie它一直在传输的这个内容来保证我们返回的数据是这个用户的，这就是类
      似于我们后面讲的session这个功能，那么我们设置了cookie之后，浏览器下次请求就会自动带上，cookie是键值对的一个形式来保存的，
      可以设置很多个。
    2.cookie有哪些属性呢
      1.max-age和expires来控制cookie的一个过期时间
      2.Secure这个属性代表这个cookie只有在https的请求的时候它才会带上，在http请求的时候它是不会带上这个的
      3.设置HttpOnly之后就无法通过javascript的document.cookie这个属性通过js去访问cookie的内容，这么做呢有一个原因就是安全性，
        因为互联网上存在着很多各种各样的攻击，比如说有一种非常常用的就是csrf攻击，这种攻击会通过在你的网页里面注入一些脚本，或者是
        通过一个url来引导用户去给攻击者的服务器发送用户自己的，就是我们这个网站设置在用户的浏览器里面的cookie,这样的话攻击者就能拿
        到这个用户的登录状态，然后利用这个cookie来访问我们网站中保存的这个用户的数据，所以禁止重要的一些数据通过js进行访问，是保证
        我们用户数据安全的非常重要的一步
      4.domain
        cookie的一个域名的一个限制的内容
    3.这就是cookie的返回的方式，我们在服务端response内容里面有Set-Cookie这个头，它就会把cookie写到我们的浏览器里面，然后浏览器
      下次请求就会带上。
  2.session
    cookie它不等于session，session也有很多种实现方法，它不一定要使用cookie来做，只不过在我们网站的开发当中，最多的最经常用到的就
    是使用cookie来保存session，那么什么意思呢，我们经常会做的一个方式就是把用户登录之后的一个id或者是它的session的一个key给它设
    置到cookie里面，然后下一次用户请求过来的时候呢，我们就可以读取这个cookie下面的值，那么下次用户再次请求不同的内容的时候，我们可
    以通过读取cookie里面的值拿到这个用户对应的唯一的一个key，然后通过这个key去定位这个用户的信息，然后把这个用户的信息给它拿出来，
    然后去做一些针对这个用户的一些操作，那么这就是一个session的概念，我们只要能够保证定位到这个用户，那么它就是一种session的实现
    方案，我们可以直接把用户的id给它写到cookie里面去，然后下次请求过来的时候，我们根据这个id去搜索用户的信息，但是呢因为用户id也算
    是用户信息的一部分，那么直接保存在客户端，那么相对是不太安全的，那么也有其他的方案就是说我们把这个id相关的一些信息给它转化一下，
    转化成一个对应的唯一key，然后这个用户信息跟这个sessionkey的对应关系就存在服务端的数据库或者缓存里面，然后请求过来的时候我们读
    取这个sessionkey然后再去搜索一下，把这个对应的关系拿出来就可以，这就是session的一个概念，它跟cookie不是一一对应的，它不一定
    要用cookie来实现，我们可以通过js的方式写在header里面那也是可以实现的，所以方式有很多种，那么cookie跟session的关系我们在学习
    http的时候就只要弄清楚cookie不等于session这个概念就可以了。
22.http长连接
  1.这节课中我们将的是http中的connection，在之前的课程当中我们提到过http的请求是在tcp的连接上面进行一个发送的，那么tcp的连接在这边
  就有分为长连接短连接这样的概念，那么什么叫长连接呢，http请求发送的时候要先去创建一个tcp的连接，然后在tcp的连接上面把http请求的内
  容发送，并且接收完返回，在这个时候呢，因为一次http请求已经结束了，浏览器跟服务端就会商量说我们要不要把这个tcp连接给它关闭掉，如果
  不关闭的话呢，这个tcp连接它一直开着，然后会有一定的消耗，但是如果你接下去你还有请求，你可以直接在这个tcp连接上进行一个发送，那么就
  不需要经过三次握手这样的一个连接的创建的一个消耗，而如果直接关闭了之后呢，就代表下次你有请求的时候，又要重新去创建一个连接，那这个时候
  就会有一个网络延迟上面的开销，但是呢它能够提供你的一个好处就是你连接马上就关闭这样的话服务端跟客户端就能减少一个并发的连接数，但是呢
  ，在实际的情况中，因为网站的并发量可能比较大，如果你每次都要重新创建一个连接呢，就会导致创建的这个过程发生的次数太多，而实际导致一个
  开销可能比你保持长连接还要高一点，而且长连接的话是可以设置它的连接的timeout就是过多少时间没有在这个tcp连接上面有新的请求，那么它就
  自动关闭掉，所以呢，一般现在的一个情况，基本上都是保持长连接的。
  2.我们可以来看一下baidu.com，在百度里面我们呢首先打开我们的调试工具，然后点network，记住要把这个disable cache给它钩上，这样的话，
  它就是所有的内容都要去重新加载，然后这个时候我们刷新一下页面，然后在timeline下面这一栏这个地方，你可以右键点一下，选中这个
  Connection ID，这个Connection ID呢就代表是tcp连接的这个id，这样的话我们就可以区分它是否用的是同一个连接，选中之后就会看到这边
  有一栏叫做Connection ID，那么Connection ID点一下之后它会自动排序，然后这个时候我们可以看到百度首页它有非常多的一个请求，在这个
  请求上面我们可以看到，这边有一排上面都是10074，上面的img之类的都在这一个连接上进行发送，而下面有一个新的，因为域名不一样，它要重新
  去创建新的连接，这是没有问题的，但我们可以看到它这边它尽量的去复用了这些连接，但是呢它还是会有很多不同的连接在上面，这是为什么呢，因为
  http/1.1的连接，在tcp连接上面去发送请求它是有先后顺序的，就是说你不可以并发的，你有10个请求，你不能并发的在一个tcp连接上面去发送，
  在这一个tcp连接上面去发送，你只能是一个按着一个，那么我们希望在加载一个首页的时候，我们当然是希望它能够并发，这样的话它的效率会更高
  一点，那这个时候浏览器呢可以允许你产生一个并发的创建tcp连接，像chrome允许的是6个就是一次性的并发，所以呢，一般正常情况我们加载一个
  首页的时候，它肯定会基本上达到6个并发先全部创建完成，但是因为到达了这个6个并发的一个限制之后，那么接下去如果你开始有10个并发，那么
  剩下的4个还是要等前面6个至少有一个完成，然后新的请求再进去，所以呢基本上你可以看到的是再百度首页这边，它会一下子创建很多的连接，但是
  呢之后它就会在这上面进行一个复用，这就是我们去创建一个连接的过程，那么如何让我们的服务去保证它是创建的是长连接而不是短连接呢，我们可
  以看一下它这边的http头里面，Response Headers里面我们可以看到有一条叫做Connection: Keep-Alive，这就代表这个连接是被保持的，那
  么它就不会一下子请求完毕之后就被关闭，而在我们Request Headers里面也有一个Connection: Keep-Alive，因为这是有一个协商的过程，在
  发送请求的时候，浏览器就希望服务端是保持长连接的，但是服务端返回的时候呢，它可以选择是保持还是不保持，如果它选择不保持，那么浏览器端
  还是会关掉。
  3.实验
  所以这就是浏览器的一个tcp连接的并发限制。我们可以看到开始的几张图片它是并发的出来，但是后面要等前面的加载完，它才会再去加载，这就是
  长连接的一个用处，它会复用这里面的tcpip的连接，我们可以看到，默认的情况下我们的Connection都是Keep-Alive。那这个时候如果我把它
  改成close会怎么样，connection在我们的http协议的使用当中基本上只有两个值，一个是keep-alive，还有一个就是close，close代表什么呢，
  一个请求完成之后，这个tcp连接就会关闭掉。那么正常情况下，我们现在开发的http服务都是合理的利用这个'Connection': 'Keep-Alive'的，
  我们可以给这个keep-alive设置自动关闭的一个时间，但是这个呢只是在服务端那边设置操作的，所以跟http协议本身没有什么关系，它并不会在
  http的头上面有什么展示。
  4.然后在http2里面呢，因为它有了一个新的概念，叫信道复用，信道复用是什么意思呢，在tcp连接上面，我们可以并发的去发送http请求，那这
  个时候就代表着什么意思呢，就是我们连接一个网站的时候，我们只需要一个tcp连接，那么相信大家应该知道，这个是什么样的一个好处，我们整一
  个网站，一个用户的一个请求，只需要一个连接，那么对于之前要创建那么多连接的一个开销就降的非常多，我们可以来看一下google的页面，它已经
  都是http2了，我们可以看到这个Connection ID它都是11831，记住是只有同域的情况下才会是同一个，那如果出现不同域的，那么它会创建新的
  连接，但是如果都是在一个域名下面的，那么它都是同一个tcp连接，所以这个时候它的开销就降到最低了，而且它整体的速度会有一个质的提升，那么
  http2服务相关的内容在后期会有单独一节课为大家详细的讲解，如何去实现一个http2的服务，然后它给我们带来的好处以及它还有其他一些功能，
  比如说服务端主动推送的一个功能。
  5.那么这节课我就是告诉大家什么是长连接的一个概念，在理解这一点之前，需要大家去做的呢就是要理解我们之前课里面讲过的http请求是在tcp连
  接上面进行发送的，一个tcp连接可以发送多个http请求，但是在http1.1里面我们的http请求如果要在tcp连接上面进行发送，它是有先后顺序的，
  所以如果为了提高性能，我们还是不得不使用并发tcp连接的一个方式，但是在http2里面呢因为可以在一个tcp连接上面并发的发http请求，所以它
  可以只开一个tcp连接就够了。
23.数据协商
  这节课我们来讲http协议中的数据协商，那么什么叫数据协商呢，所谓的数据协商就是说，在我们客户端发送给服务端一个请求的时候，客户端会声明
  我希望这一个请求我拿到的数据格式以及数据相关的一些限制它都是怎么样的，那么服务端会根据它的一个请求里面表示的它想要拿到怎么样的数据之
  后，然后做出一个判断，服务端可能会有很多不同类型的一个数据的返回，那么服务端可以根据请求端发送过来的这些头信息来进行一个区分，说我到
  底要返回怎么样的一个数据。
  1.分类
    分类中分为请求跟返回这两部分
    1.请求
      1.Accept
        那么请求里面我们通过Accept来进行一个声明我想要怎么样的一个数据，其中最主要的呢是Accept，Accept指定的是我想要的数据类型，那么
        这个数据类型会根据mime type的声明来进行一个限制来告诉服务端我想要怎么样的一个数据类型
      2.Accept-Encoding
        第二个是Accept-Encoding，那么Accept-Encoding呢代表我这个数据是怎么样的一个编码方式来进行一个传输，主要的就是用来限制服务端
        如何进行一个数据的压缩，因为现在数据压缩的算法有很多，gzip,deflate还有br现在新起的一个压缩方式，但是还没有很多服务端支持，
        但是呢以后可能会支持越来越多
      3.Accept-Language
        然后第三个是Accept-Language，在全世界范围来讲，有非常多的不同的语言，那么不同的地方访问一个服务，那么它希望展示的这个语言肯定
        也希望是不同的，比如说国内我们希望是展示的是中文，美国可能它希望展示的是英文，所以呢我们可以根据这个头来判断我们要返回的信息是中
        文还是英文
      4.User-Agent
        然后第四个User-Agent,那么User-Agent是用来表示浏览器的一些相关的信息，就是我们移动端的浏览器跟客户端的跟pc端的浏览器它的
        User-Agent肯定是不一样的，我们可以根据User-Agent来进行一些判断，说我们要返回的是pc端的页面还是移动端的页面，所以它也是一个
        非常重要的头
    2.返回
      1.Content
        Content-Type
        那么与之对应的就是服务端返回的时候，服务端返回的Content,它里面会有Content-Type来对应Accept，Accept里面可以接收好几种不同
        的数据格式，那么Content-Type可以从里面选择一种然后做为它真正返回的数据格式进行一个返回，那么在返回的时候就要声明这个Content-Type
        说我实际返回的是怎样的一个数据格式，因为客户端可能要根据这个来判断然后进行一个怎么样的显示的一个情况
      2.Content-Encoding
        第二个是Content-Encoding，Content-Encoding对应的就是Accept-Encoding，我服务端具体到底是用了gzip还是deflate这种数据
        压缩的方式，那么就会通过Content-Encoding来进行一个声明
      3.Content-Language
        还有就是Content-Language，那么Content-Language对应我是根据你的请求返回了你想要的语言呢还是我没有根据你的请求返回你想要的
        语言，所以都可以通过这个来声明，服务端返回肯定就没有User-Agent了，因为User-Agent是客户端指明我目前是处于哪种浏览器，哪种系
        统环境的一个声明，那么服务端没必要去声明说我服务端是怎么样一个环境，我只要把你想要的数据给你就ok了
  2.我们使用demo分析一下，浏览器请求一个html的时候，它会申请怎么样一个头信息
    1.我们先来看一下我们的请求头里面会有Accept,那么Accept呢它返回的信息我们可以看到，它里面声明的信息我们可以看到有非常多text/html,
    application/xhtml+xml，就这些格式做为浏览器来请求一个页面的时候，它都可以接受，你甚至直接返回一个图片它也是可以接受的，因为浏览
    器认为这些数据格式它都是可以进行一个展示的，它有它自己的一个展示方式，所以它愿意接收这些数据格式，那如果你自己做了一个客户端，你只
    希望接收到html，那么你需要在Accept里面去声明text/html就可以了，又要牵扯到我之前说的那句话，就是你在发送请求的时候，虽然你声明了
    你想要的哪个数据格式，强限制你只希望接收这个格式，但是服务端它不一定会按照你的要求来返回这个数据格式，所以呢很多时候我们做一个http
    的服务的时候，我们就需要考虑我们到底是面向怎么样的一个客户群体，它们用的客户端都是怎么样的，然后你要去选择你可以支持的这些数据格式
    来进行一个使用，ok，这是accept。
    2.然后第二个就是Accept-Encoding,我们可以看到，它这边它声明了三种可以接受的encoding方法，就是现在比较流行的几种，一种是gzip,
    这是用的最多的，然后第二个是deflate，那么第三个br是现在用的相对比较少的，但是它的压缩比会比较高，未来可能会变为一个新的主流
    3.然后第三个是Accept-Language，那么因为我是在中国，然后我的浏览器也是按照中国本地的一个方式进行下载的，所以我安装的过程当中呢，
    其实浏览器它会判断你本系统的一个语言，然后来给你发送，因为这个头是浏览器加的，所以它会给你来发送说我希望接受的语言默认是zh-CN就是
    中文
    4.所以这就是Accept，是浏览器端它自动会给你加的，当然我们在发送ajax请求的时候，我们可以自定义的去设置accept相关的一些东西，那么这些
    你就根据你自己的需求去设置就可以了
    5.User-Agent里面有非常多的一个信息：Mozilla/5.0，本机操作系统版本，浏览器内核，渲染引擎的版本，浏览器版本号，这就是User-Agent
    它里面包含了很多跟系统相关，还有就是浏览器相关的一些信息，那么这些信息你就可以用来判断你想要返回给用户看到的页面是要不要去适应它这个
    浏览器
    6.然后对应的我们可以看到我们返回的只写明了一个Content-Type,因为我们没有进行一个数据压缩。
    7.这就是我们在浏览器里面给我们发送的一些数据协商的一些信息，那么这个时候我们拿到这些信息之后呢，我们就可以在服务端进行一个判断，然后
    返回我们想要的一个信息，返回一个对应的，浏览器想要拿到的一个消息，所以像Content-Type和Accept对应的关系呢，它其实两个就是一个对应
    的一个关系，然后Content-Type它里面声明的值呢有一个定义，叫做mime types，然后在mime types里面有非常多的一个格式来帮助我们去声明
    它,那么它的一个类型就是主类型/sub类型就是分类型，就比如说第一个前面是image，后面可以是png,jpg这些图片的格式，text也可以是plane，
    也可以是html，那么这个mime types大家只需要了解，然后你以后看到能够大致知道它是怎么样一个类型，如果你要做服务端，你要遵照你返回的这
    这么一个类型，那你就要去写这么一个头这种规则就ok啦。
    8.那么关于Content-Type我们有一条必须要讲的是在我们服务端返回的时候，可以返回一个头，叫做'X-Content-Type-Options',基本上我们只
    会用到一个值，叫做'nosniff'，那么这个值是什么意思呢，因为在以前很早的时候，IE浏览器它会主动的，就是你返回的这个Content-Type声明了
    一个数据类型，但是它呢不接受或者是它认为你没有声明对，或者呢还有一种情况就是你根本没有声明这个Content-Type的时候，它会自己去预测你
    返回的这个内容是怎么样的一个类型，然后这样呢会导致一些安全性的问题，比如说别人插入的一些应该是以文本显示的代码，最后它以脚本的方式去
    运行了，导致呢你的安全信息被泄漏了，所以呢，它那个时候设计了一个头就是这个头'X-Content-Type-Options'然后声明它是'nosniff'之后呢
    ，它就不会主动的去预测它了，虽然说这个头呢它基本上用不太到，因为现在的浏览器都不会这么激进的去随便的预测你返回的这个内容，但是如果呢你
    遇到了这种情况，你可以声明这个头来告诉浏览器你不要随意去猜测我返回的一个内容，那么这个大家知道就可以了。
    9.那么接下去我们来讲一下关于Content-Encoding也就是我们Accept-Encoding里面的数据压缩这个问题，那么数据压缩有什么好处呢，我们先来
    看一下我们现在的请求情况，我们可以看到这边有一个size,上面是409B,下面是264B，这个是什么意思呢，409B是我们数据在整个传输的过程中的实
    际大小，那么这个大小呢会包含http的headers和body还有首行的信息，那么这些信息都会包含在这里面，264B是body里面的实际内容的一个大小，
    就是传输信息要比body信息要大，这边显示的这个body信息呢是我们数据拿到之后并且根据我们的这个Content-Encoding解压之后的一个数据，而
    不是说我们传输的里面的body是多少就是多少，如果我们这边显示的是传输的是多少就是多少的话呢，就是上面这个就永远大于下面这个，那么实际情
    况并不是如此，所以我们这边接下去要演示的就是我们使用gzip之后，我们Content-Encoding把它变小之后，我们实际的传输大小是会有变化，但是
    下面的body的大小其实是没有变化的。ok,这就是压缩的一个好处，它能够加快我们网络传输的一个开销。
    10.最后我们再来讲一下关于发送请求的时候的Content-Type,因为我们有时候也会发送一些主动的请求，要发送一些数据，那么这些数据肯定要有
    Content-Type，并且有对应的格式，要声明这个Content-Type,因为如果不声明我们不知道在服务端如何去获取这部分的数据。所以这就是在发送
    请求的不同的Content-Type的一个情况，那么对应的也是需要你在我们的body里面去放上不同的数据格式的，因为我们的服务会根据它的这个请求的
    头信息然后不同的方式去解析它传过去的这个body的数据，所以这就是Content-Type它的一个作用，用来在客户端和服务端之间进行一个数据格式的
    一个协商和声明来告诉你我们要怎么样的方式去接收你传过来的这些数据。
  那么这就是数据协商相关的一些内容。其实在服务端跟客户端之间关于数据的东西还有其他的一些东西不是特别的重要，但是可能也会有用处，但是呢
  在课里面我们就不那么详细的把每一个点都讲到了，因为http headers其实有非常非常多，不是标准的http头，但是在业界也用的比较多，那么我们不
  会每一个都讲，我们只讲最重要的那一部分，然后大家知道了这些东西大概的意思之后，你之后你去学你去看到一个新的东西之后，你会学得非常的快，所
  以这就是我这门课想要达到的一个目的。
24.Redirect
  这节课我们来讲一下关于http的redirect，那么什么是redirect呢，就是我们通过url去访问一个路径的时候，我们去请求这个资源的时候，我们
  发现这个资源呢可能已经不在这个url所指定的位置了，那这个时候呢，服务器要告诉我们的浏览器客户端说你要请求的这个资源它在哪个地方，然后
  浏览器再去重新请求那个地方的，这样的话它就可以拿到这个资源，所以呢如果我们以前在开发服务器的时候，已经指定了某一个资源在某个地方，那
  如果你以后把这个资源搬到别的地方呢，你不应该说立刻就把这个url给它废弃掉，因为你废弃掉之后你可能就直接返回404了，说这个资源不存在，
  那么正常来讲，你要告诉客户端，它应该去哪个地方找到它想要的这个资源，那么这个东西我们怎么做呢，非常的简单，我们只需要在response的
  writeHead()里面我们再写一个它的head是302，然后呢我们要告诉浏览器新的资源在哪里就可以了，那么新的资源在哪里呢，我们这边就把这个代
  码逻辑给它改一下，如果我们访问跟路径，就是request.url === '/'的时候，那么我们直接redirect，redirect的时候呢，我们的内容就不需
  要写啦，然后呢，如果request.url === '/new',我们再把实际的内容给它写进去，实际的内容返回我们把它放到这里，那么这里的时候呢，我们
  的code肯定还是200，那么我们把它redirect到新的路径的时候我们怎么做呢，我们在302的时候就不需要返回内容了，然后呢在header里面去写一
  个叫做'Location'这个头，然后它的地址就等于我们新的这个url,因为是在同域之内跳转，所以呢我们只需要到后面的路由阶段就可以了，不需要、
  指定我们的host跟端口，因为默认情况下，我们不写host跟端口，那就是在同域的一个情况下。ok,那么我们来启动一下服务，访问localhost:8888
  ，我们可以看到这边的路径呢它就直接变成/new了，而且它显示出来了内容。我们用devtool来看一下实际的一个情况是怎么样的，我们可以看到，
  先访问的是302，302 Found，那么302 Found了之后呢，它就会去跳转到我们指定的这个response里面的Location: /new，然后它就跳到了
  /new，就变成了这个了，这就是最基本的redirect的一个操作。那么即便是你在header里面写了这个Location,那如果我返回的是200，那这个
  时候会变成什么样呢，我们来看一下，我们可以看到，就是什么东西都没有，因为只有302的头才代表说它要去进行一个跳转。那么我们返回302的
  情况，我们仍然要服务端这边来指定我们要跳转到哪里，因为302的语义代表呢是临时跳转，就是说你现在访问的这个路径，我临时的跳转到了/new，
  而不是我永久的，所以有可能你下一次访问我跟路径的时候，我跳转的就不是/new了，而是一个/other这么一个路径，所以呢如果你能够确定的说
  你接下去这个/它都是跳转到/new的话，那么我们就可以通过301这个头来指定说我这个/路径已经永久跳转到/new了，那么指定301跟302有什么
  区别呢，我们先来看一下302的一个情况，我们可以看到打印的/跟/new都会出现，就是说每一次我从老的那个路径来访问的时候都要经过服务端的
  一次跳转，然后才能跳转到新的，那么我们使用301的情况，我们来看一下，第一次访问是/跟/new都会出现，第二次之后就只会访问/new，这是为
  什么呢，因为301它指定的呢是你这个/这个路径这个资源它是永久变成了/new，那么这个头就会告诉浏览器说下一次你在浏览器里面去出现了这一
  个路径的访问的时候，你直接在浏览器这边把它变成新的路径就可以了，你不需要经过服务器再去指定一个新的location,因为它是一个永久的变更
  ，这就是301和302它们进行一个redirect的一个不同的区别，大家要清楚你什么时候才能去用对应的http code。那么在这里大家还要注意一点
  就是，301的请求它的Size是from disk cache,就是从缓存里面去读取了，也就是说我们/这个路由的请求已经被放到浏览器的缓存里面了，那么
  因为我们301它的定义就是这个链接已经永久变成一个新的路由了，所以呢浏览器它本身在http协议里面定义并没有说301这个返回是有一个过期时
  间这种限制，所以呢浏览器缓存这个301返回的时候它是尽可能长的时间缓存，也就是说除非是像我们主动去清缓存这些操作之前，那么浏览器都是
  默认都会把这个路由给它跳转，所以说就算我们这边这个301给它取消掉了，我们变成200，然后把Location这个头也给它取消掉，然后我们重启了
  服务器，浏览器这边是根本没有感知的，它还是会主动的跳转到这个新的路由，因为它是从缓存里面去读取的，所以301的返回是要非常的慎重去做的，
  因为301缓存，如果你做了之后，接下去你如果要反悔，那就不是你自己能决定的事情了，而是你的用户使用浏览器的一个情况而定了，如果像我主动
  的清了一下浏览器的缓存，那么ok，新的请求就不会跳转了，但是如果用户一直不清这个缓存，它就一直会进行这个跳转，所以如果你决定给某一个
  链接变成一个永久的跳转到另外一个新的链接的时候，你使用301的时候要非常非常的谨慎，因为你使用了之后就不是你可以控制的一个情况了。
25.CSP
  这节课我们来讲Content-Security-Police，就是内容安全策略，在http协议当中，为了让我们的网站变得更加的安全，那么它具体是做什么的呢。
  1.csp的作用
    1.限制资源获取
      它限制我们网页当中所需要的一系列的资源它的获取的一个情况，它从哪里去获取，然后它的请求发到哪个地方，这些我们都可以通过
      Content-Security-Police来进行一个限制。
    2.报告资源获取越权
      然后我们还可以在我们的网页当中因为获取了一些我们不应该获取的资源的时候给我们的服务进行一个报告，让我们能够知道我们的网页出现了
      我们没有预计到的这些情况，然后我们可以做出一些调整。
  2.服务端通过设置Content-Security-Police这个头来实现一些需求
    1.限制方式
      1.default-src 限制全局
      2.制定资源类型
  3.浏览器搜索栏输入mdn csp来搜索csp更加详细的一个文档内容
  4.那么这就是内容安全策略它的一个作用，让我们可以很好的控制我们的网页中可能会出现的一些不安全的内容引用的时候，我们可以主动的把这些不
    安全的东西屏蔽掉。
  5.这个东西它不仅是可以通过http header来写，它还可以通过在html里面写meta标签来使用
    <meta http-equiv="Content-Security-Police" content="这个头的内容"></meta>
    这个东西它就是一个http协议里面相关的内容，所以呢推荐大家也是通过http的header来进行一个设置，这样的话，它的使用会更合理一点，而且
    更好的去配合服务器的一个开发，就不需要我们去跟html去打交道了。
26.nginx
  nginx的作用：起一个服务，代理到一个服务
  我们访问的地址会先访问nginx起的这个服务，然后再通过nginx代理到一个服务
27.https
28.http2

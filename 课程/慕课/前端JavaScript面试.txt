


2.js-web-api
  1.dom
    题目:
      1.dom属于哪种数据结构
      2.dom操作常用的api
      3.attr和property的区别
      4.一次性插入多个dom节点，考虑性能
        如果这个你不知道，你盲目操作dom，可能会带来一些很麻烦的事情。
    知识点:
      1.dom本质
        dom是浏览器内存里面已经初始化好的树的一个结构。dom的本质是从html文件解析出来的一棵树。
      2.dom节点操作
        这个节点操作就是针对单个节点。
        1.获取dom节点
          document.getElementById('div1') // 元素
          document.getElementsByTagName('div') // 集合
          document.getElementsByClassName('container') // 集合
          document.querySelectorAll('p') // css选择器来获取，集合
        2.attribute
          获取节点之后，我们可以操作它的attribute
          const pList = document.querySelectorAll('p')
          const p = pList[0]
          p.getAttribute('data-name')
          p.setAttribute('data-name', 'imooc')
          p.getAttribute('style')
          p.setAttribute('style', 'font-size: 30px;')
          我们可以通过一个getAttribute和setAttribute这样的api去直接修改这个html的结构。它是能真正作用到dom结构里面去的。它
          是修改的标签的一个属性。
        3.property
          property的意思就是我们能获取dom元素，然后去通过js的属性的方式来操作
          const pList = document.querySelectorAll('p')
          const p = pList[0]
          p.style.width // 获取样式
          p.style.width = '100px' // 修改样式
          p.className // 获取class
          p.className = 'p1' // 修改class
          p.nodeName // 获取nodename
          p.nodeType // 获取nodeType
          也就是说我们说的这个property是通过以js对象属性的形式来去操作它里面的一些东西。所以说property它本身不是一个api的名字。
          它是一种形式，就是用js的属性操作的这么一种形式。我们可以对这个属性进行设置和获取，就是读和写都可以。设置完了之后它真正
          的渲染到了页面上。也就是说，property这种形式它是一种通过修改或获取js的属性的方式来去改变页面样式或页面渲染结构的一种
          形式。
        property修改的是js变量的属性，不会对标签产生影响。attribute它修改的是标签的属性，设置上之后，标签上就会有这个属性。两者
        都有可能引起dom的重新渲染。平常该怎么用它们呢，建议尽量用property去操作。因为property它可能会在js的一些机制中去重复避免
        一些dom的不必要的渲染。attribute你一旦改了这个html结构，它肯定引起这个重新渲染。dom的重新渲染是比较耗费性能的。如果必须
        要修改标签结构的话当然也要用attribute。
      3.dom结构操作
        因为dom是一棵树，对于树的结构操作一般会分为这么几个
        1.新增/插入节点
        2.获取子节点列表，获取父节点
        3.删除子节点
        const div1 = document.getElementsById('div1')
        const p1 = document.createElement('p') // 新增一个节点
        p1.innerHTML = 'this is p1'
        div1.appendChild(p1)                   // 插入节点
        const p2 = document.getElementById('p2')
        div1.appendChild(p2)                   // 移动一个节点
        const child = div1.childNodes          // 获取子节点列表
        const parent = div1.parentNode         // 获取父节点
        div1.removeChild(child[0])             // 删除子节点
      4.dom性能
        dom操作是比较耗时和耗cpu的。
        dom操作可能会导致浏览器的重绘或重排就是重新渲染，所以要避免频繁的dom操作。
        1.对dom查询做一些缓存
          现在电脑的内存都还好，所以我们做一些dom查询的缓存应该会减少我们dom的操作。查出来之后就先存起来，存起来之后就不要再
          查了。为什么浏览器自己不缓存呢，因为我们的js有可能会操作dom，比如每次循环里面我们都对这个p进
          行一些修改，这样的话，浏览器是不是就没办法做到它保存完之后的正确性了。是不是缓存得由我们自己来决定，既然浏览器不能缓存，我们就自己缓存。
          // 不缓存dom查询结果
          for (let i = 0; i < document.getElementsByTagName('p').length; i++) {
            // 每次循环，都会计算length，频繁进行dom查询
          }
          // 缓存dom查询结果
          const pList = document.getElementsByTagName('p')
          const length = pList.length
          for (let i = 0; i < length; i++) {
            // 缓存length，只进行一次dom查询
          }
          如果p的数量多了之后，这个性能的差异还是很大的。
        2.将频繁操作改为一次性操作，就是合并的处理
          有时候我们可能会频繁插入一些东西，这时能不能打个包一块插入进去。这样的话也是避免频繁的dom操作。
          const listNode = document.getElementById('list')
          // 创建一个文档片段，此时还没有插入到dom树中
          const frag = document.createDocumentFragment()
          // 执行插入
          for (let i = 0; i < 10; i++) {
            const li = document.createElement('li')
            li.innerHTML = 'list item ' + i
            frag.appendChild(li)
          }
          // 都完成之后，再插入到dom树中
          listNode.appendChild(frag)
  2.bom
    题目:
      2.分析拆解url的各个部分
    知识点:
      3.location
        地址的一些信息，就是分析url的一些信息
        https://coding.imooc.com/lesson/400.html?a=100&b=200#mid=30309
        location.href        // https://coding.imooc.com/lesson/400.html#mid=30309
        location.protocol    // 'https:'  
        location.host        // 'coding.imooc.com'  
        location.pathname    // '/lesson/400.html'
        location.search      // '?a=100&b=200'
        location.hash        // '#mid=30309'
        我们整个的网址都是通过这些信息拼接出来的。
      4.history
        前进后退这些信息
        history.back()    // 网页后退
        history.forward() // 网页前进
  3.事件
    题目:
      1.编写一个通用的事件监听函数
        function bindEvent (elem, type, fn) {
          elem.addEventListener(type, fn)
        }
        const btn1 = document.getElementById('btn1')
        bindEvent(btn1, 'click', event => {
          console.log(event.target) // 我们触发点击的元素，就是这个btn1这个dom对象
          event.preventDefault() // 阻止浏览器默认行为
          event.stopPropagation() // 阻止事件冒泡
          console.log('clicked')
        })
      2.描述事件冒泡的流程
        事件冒泡是基于dom的树形结构，事件会顺着触发元素往上冒泡。应用场景就是事件代理。代理它是基于事件冒泡这个机制才能够用起来的。
      3.无限下拉的图片列表，如何监听每个图片的点击
        利用事件代理，我们可以通过event.target获取触发元素。用matches来判断是否是我们业务逻辑需要的触发元素是不是这个选择器范
        围之内的。
    知识点:
      1.事件绑定
        事件绑定就是addEventListener
        const btn = document.getElementById('btn1')
        btn.addEventListener('click', event => {
          console.log('clicked')
        })
      2.事件冒泡
        我们的实际事件触发完之后，它是像一种冒泡机制一样，它是顺着这个dom结构往它的上级一层一层的冒，就是说在它当前这个元素中监听
        事件和在它上级或上上级只要是它的上级监听事件，都可以把这个事件给监听到。
      3.事件代理
        事件代理是基于事件冒泡来做的。有了事件冒泡这个机制，我们才能在这个机制的基础上去实现这个代理。所谓代理就是因为数量太多或结
        果比较复杂，不好去挨个都去绑定事件的情况。我们把事件绑到某一个父元素上。事件里我们要去获取它触发的元素做一些判断，是不是我
        们想要的那个元素。然后再去做一些其他的动作。
        1.代码简洁
          事件代理的代码比较简洁，你如果是每一个元素都给它绑一个事件的话，这样代码反而就会麻烦了，至少你还得做个dom查询，还得做个
          循环。
        2.减少浏览器内存使用
          如果需要绑定事件的元素非常多的话，每一个元素都去挂一个事件监听，如果数量过多的话，它是非常耗费内存的。但是利用事件代理只
          在父元素上去挂一个事件，只挂一次事件就没有那么耗费内存。
        3.不要滥用
          只有在一些情况下可以用。就是因为数量太多结果复杂的不好去每一个都去绑定事件的情况下才应该去用。你不要到处都去用这个代理。
          这个代理还是有一定复杂度的。它的代码简洁程度虽然也比较简洁，但是它的简洁是相比于每个元素都做事件监听的情况。比如一个按
          钮的绑定就不至于用代理了。直接把事件绑定到这个按钮上不就完了吗。这样的话才是更简洁的。所以不要滥用，不要为了用代理而用
          代理。要在合适的场景下去使用。
          1.重新写通用事件绑定函数，使其能够适用普通的绑定和事件代理的绑定。
          function bindEvent (elem, type, selector, fn) {
            if (fn == null) {
              fn = selector
              selector = null
            }
            elem.addEventListener(type, event => {
              const target = event.target
              if (selector) {
                // 代理绑定
                if (target.matched(selector)) {
                  fn.call(target, event)
                }
              } else {
                // 普通绑定
                fn.call(target, event)
              }
            })
          }
          const btn1 = document.getElementById('btn1')
          const div3 = document.getElementById('div3')
          bindEvent(btn1, 'click', function (event) {
            event.preventDefault()
            alert(this.innerHTML)
          })
          bindEvent(div3, 'click', 'a', function (event) {
            event.preventDefault()
            alert(this.innerHTML)
          })
  4.ajax
    题目:
      1.手写一个简易的ajax
        1.ajax工作基本过程
          // xhr.readyState等于4的时候才说明ajax的请求成功了，其他需要判断的东西只有xhr.status也就是http状态码了。比如
          // 网络断开的情况下xhr不可能等于4，所以前端的ajax请求的业务逻辑中根本就不用判断类似断网的这种情况
          1.get请求
            const xhr = new XMLHttpRequest()
            xhr.open('GET', '/api', true)
            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  alert(xhr.responseText) // 返回的信息是字符串
                } else {
                  console.log('其他情况')
                }
              }
            }
            xhr.send()
          2.post请求
            const xhr = new XMLHttpRequest()
            xhr.open('POST', '/api', true)
            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  alert(xhr.responseText) // 返回的信息是字符串
                } else {
                  console.log('其他情况')
                }
              }
            }
            const postData = {
              username: 'zhangsan',
              password: 'xxx'
            }
            // 发送的数据也是字符串
            xhr.send(JSON.stringifypost(Data))
        2.简易的ajax，回调函数版
          function ajax (url, method, successFn, errorFn) {
            const xhr = new XMLHttpRequest()
            xhr.open(method, url, true)
            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  successFn(
                    JSON.parse(xhr.responseText)
                  )
                } else if (xhr.status === 404) {
                  errorFn(new Error('404 not found'))
                }
              }
            }
            xhr.send()
          }
        3.简易的ajax，promise版
          function ajax (url, method) {
            const p = new Promise((resolve, reject) => {
              const xhr = new XMLHttpRequest()
              xhr.open(method, url, true)
              xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                  if (xhr.status === 200) {
                    resolve(
                      JSON.parse(xhr.responseText)
                    )
                  } else if (xhr.status === 404) {
                    reject(new Error('404 not found'))
                  }
                }
              }
              xhr.send()
            })
            return p
          }
          const url = '/data/test.json'
          const method = 'GET'
          ajax(url, method)
            .then(res => {
              console.log(res)
            })
            .catch(err => {
              console.log(err)
            })
      2.跨域的常用实现方式
        1.jsonp
        2.cors
    知识点:
      1.XMLHttpRequest
        网页实现ajax最核心的一个api。
      2.状态码
        // xhr.send()之后，这个xhr.readyState才开始从0-4变化
        xhr.readyState
          1.0 - （未初始化）还没有调用send()方法
          2.1 - （载入）已调用send()方法，正在发送请求
          3.2 - （载入完成）send()方法调用完成，已接收到全部响应内容
          4.3 - （交互）正在解析响应内容
          5.4 - （完成）响应内容解析完成，可在客户端调用
        xhr.status  
          status是我们常见的http协议的状态码
          1.2xx - 表示成功处理请求，如200
          2.3xx - 需要重定向，重定向不用我们自己处理，服务器返回之后浏览器会自己去跳转，如301 302 304
          3.4xx - 客户端请求错误，如404 403
          4.5xx - 服务端错误
      3.跨域，跨域解决方案
        1.什么是跨域（同源策略）
          1.同源策略
            ajax请求的时候，浏览器要求当前网页和server必须同源（安全）。在服务端或非浏览器的环境下是可以请求的。这个同源策略是
            浏览器要求的。
          2.同源
            对于一个url来说，前端页面和server端做对比。协议、域名、端口，三者必须一致。
            前端：http://a.com:8080/； server：https://b.com/api/xxx
            这两个是不同源的，而且是协议，域名，端口都不相同的。有一个不一样就是不同源的。  
            为什么同源策略仅限制浏览器呢。我们的搜索引擎，爬虫它不是浏览器上发送的，它是服务端发送的。搜索引擎的爬虫它是服务端去
            做请求去访问各个网站的一些网页。它照样可以把数据拿到。所以说想要去攻击某一个不同源的网站的一些接口是可以发起攻击的。
            server端可以发起攻击，因为server端它并没有像浏览器一样的同源策略，所以可以发起攻击的。怎么预防就是服务端相互较量的
            事情了。但是浏览器必须要做这个同源的要求，因为每个网站都要有每个网站的一个范围，都要有个墙，都要有域的一个限制。你不
            能乱套。如果说这个浏览器同源策略做的不好，那这个浏览器就是不安全的。我们就没法用，没法信任这个浏览器。
          3.加载图片，css，js可无视同源策略
            同源策略第一个条件就是ajax请求。但如果不是ajax请求，比如说图片，css，js可无视同源策略。它们的地址都可以跨域。浏览
            器不会限制。
            <img src="跨域的图片地址" />
            <link href="跨域的css地址" />
            <script src="跨域的js地址"></script>
            应用：
              1.<img/>
                图片可用于统计打点。可能是使用第三方统计服务，比如站长之家，百度统计等，这些也都是外域的嘛，统计打点无非就是发
                一个请求嘛，这个时候如果我们用ajax发的话那就出现跨域，那就不好解决了。所以说我们用图片，我们去初始化一个图片，
                然后把图片的地址写成第三方统计服务的地址，然后在地址里面写上我们各种各样需要的参数，然后这个时候我们通过图片去
                发这个请求，这样的话就不会出现跨域的问题。 
              2.<link /> <script>
                <link /> <script>可以使用cdn，cdn一般都是外域。 
              3.<script>可以实现jsonp
                jsonp是我们一般情况下前端实现跨域一个比较常用的方案。
            所以说图片，css，js可以无视同源策略可以实现跨域，它们都是有一定的功能的。浏览器也是为了它们有一定功能做了一些考虑
            的。所以说并不是说这三个平白无故的就实现了跨域的。
          4.跨域
            1.所有的跨域，都必须经过server端允许和配合
            2.如果未经server端允许就实现的跨域，说明浏览器有漏洞，是一个危险信号。浏览器有漏洞那就非常危险了。因为你现在所有的
            请求都是通过浏览器发出的。浏览器有漏洞那说明这个浏览器不可信，你的一些什么账号啊，密码啊，什么乱七八糟的请求啊，什么
            一些数据啊都有可能被攻击。
        2.Jsonp
          我们先看一个问题。浏览器随便访问一个网址，服务端返回的一定是一个html文件吗。服务端拿到这个网址url之后分析，然后获取这
          个文件的内容，然后把文件内容返回。其实服务端不一定返回一个html文件的内容，服务端可以动态拼接任何的数据内容返回，只要符
          合相应文件的格式要求。
          同理我们script去访问一个js地址的话，就一定是返回一个js静态文件吗。这个也是不一定的。
          jsonp
            1.<script>可以绕过跨域限制
            2.服务端可以拼接任意动态数据返回
            3.所以，我们就可以通过<script>获得跨域的数据，只要服务端愿意返回
            4.jsonp简易demo
              <script>
                window.callback = function (data) {
                  // 这是我们跨域接收的信息
                  console.log(data)
                }
              </script>
              <script src="https://imooc.com/getData.js"></script>
              <!-- 上面的script将返回 callback({x: 100, y: 200}) -->
        3.cors(服务端支持的一种解决跨域的方式)
          cors其实是一个统称，就是服务器端可以设置http header，就是在服务端response返回的时候可以设置header，如下面这些东西。
          response.setHeader('Access-Control-Allow-Origin', 'http://localhost:8081')        // 允许的域名是什么 
          response.setHeader('Access-Control-Allow-Headers', 'X-Requested-With')            // 允许的headers是什么 
          response.setHeader('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS') // 允许的methods是什么 
          response.setHeader('Access-Control-Allow-Credentials', 'true')                    // 接收跨域的cookie，是否允许传cookie
          这种方式就是纯服务器端的操作
  5.存储
    题目:
      1.描述cookie localStorage sessionStorage的区别
        存储一般就是说localStorage和sessionStorage，但是cookie它也掺和到这来。cookie它应该算是http请求的一部分，虽然它
        不是存储这一类的东西，但是它具备存储的这种能力，所以它也能一块来做一个比较。
        1.容量
        2.api易用性
        3.是否跟随http请求发送出去
    知识点:
      1.cookie
        1.cookie它本身是用于浏览器端和server端通讯，也就是http请求的一部分。
        2.它最早是被借用来做本地存储，因为localStorage和sessionStorage这两个它是09年html5之后才提出来的。之前没有localStorage和sessionStorage，所以说我们只能是用cookie来做本地存储。
        3.前端可以用document.cookie = ''这个方式来去修改。后端也可以去修改cookie，因为cookie它本身是一个通讯的一个标准。
        4.cookie的价值不在于本地存储，而在于本地和服务器端进行通讯。cookie的信息中一般是有个人的一些信息标识的。
          cookie是个字符串，中间通过分号分割的形式，每一部分都是key=value的形式。
          怎么加一个cookie：
            document.cookie = 'a=100'
            console.log(document.cookie) // 'a=100'
            document.cookie = 'b=200'
            console.log(document.cookie) // 'a=100; b=200'
            我们每赋值一个就追加一遍。它是一个追加的过程，它不是一个覆盖的过程。所以说这个api看着还比较怪异。
            document.cookie = 'a=300'
            console.log(document.cookie) // 'b=200; a=300'
            同一个key它会覆盖，不同key它会追加
            所以说这种api的计算形式就和我们之前做的js的那种普通的计算形式它就不一样。这就很难让人理解，你不知道的话可能就会掉
            到坑里面去。所以从api这个易用程度来说，这个cookie做本地存储就不合适。
            我们加上了上面的cookie之后，我们访问这个页面的时候，Request Headers里面就带了这个cookie，这个时候我们访问页面，
            后端是能接收到这个cookie的。比如我们这个cookie里面有一个userId=xxx，服务端接收到这个cookie之后就知道这个登录
            用户是谁了。也就是说登录的过程通常用cookie来实现。
        5.它为什么能做本地存储呢，假使我们现在没有localStorage和sessionStorage，其实cookie是可以做本地存储的。我们上面存
          储了一些cookie信息。我们刷新后，还能够查到这些信息，也就是说只要我们的cookie不清除，页面不管怎么刷新，这个cookie
          出来的都是这些信息。也就是我们在前端对cookie进行赋值，然后页面不管怎么刷新，这个赋的值都会在的，就是浏览器会帮我们
          存下来。所以说它能做本地存储。这也是我们在html5规范出来或普及之前唯一的能在页面中做本地存储的一种能力。但是cookie
          当时的设计并不是为了做本地存储，它是为了浏览器和服务端进行通讯。它只是被借用来做本地存储。它本来就不是干这个活的，但
          是干这个活了。所以它肯定会有一些问题。
          cookie的缺点
            1.存储大小，cookie有个限制，最大存4kb，也就是说我们这写了很长很长的cookie，超过了4kb，那就存不下了，为什么存不
              下呢，因为我们在去发送请求的时候，我们是要把cookie带上的。如果你这个cookie内容很多，当时的网速又不快，网速有限。
              你如果每次请求都带上cookie，然后cookie每次都挂上好几kb的数据，那样的话会严重影响每次的请求。
            2.http请求的时候需要发送到服务端，增加请求的数据量，就是你用cookie作为本地的存储，你存什么东西，每次请求都会带到
              服务器上去。这样的话就会让这个请求变得数据量比较大，就会慢一些。
            3.只能用document.cookie = ''这种方式来修改，这种api太过简陋也太不好理解，你每次修改都是追加，这种东西其实和我
              们的js语法本身不是那么的贴近，而且比较费解。
      2.localStorage sessionStorage
        1.这两个是html5专门为存储设计的，最大可存储5M。5M这个空间对于我们前端来说就算是已经很知足了。因为前端存储的信息基本上
          也就存储个字符串啊，存储个数字啊，就是简单的缓存一下，简单的暂存一下。不会存一些很大的数据量，所以说5M绝对是绰绰有余。
          而且这5M是针对每个域名来说的。每个host，每个域我们可以存储5M，所以说它是专门为存春来设计的，空间更大。
        2.api简单易用，是用setItem getItem来做的。这个方式就完全符合于我们自己写一个存储的功能或者缓存的功能。get set这种
          api，很多这种key value的库都是用这种get set api，所以说非常符合我们的使用。
          localStorage.setItem('a', 100)
          localStorage.getItem('a')
          sessionStorage.setItem('b', 200)
          sessionStorage.getItem('b')
        3.不会随着http请求被发送出去，如果是5M都随便发的话那就麻烦了。你如果是自己实现一个类似于存储缓存的一个功能的话。其实
          也是有一个get有一个set就可以了。别的基本上用处不是很大。
        4.localStorage和sessionStorage的区别
          1.localStorage的数据会永久存储，除非代码或手动删除。
          2.sessionStorage的数据只存在于当前会话，当前会话就是当前你和服务端的一个连接，比如说浏览器关闭的时候它会清空。也就
            是sessionStorage类似于我们服务端的一个session。session是和登录和用户验证有关系的。sessionStorage它会存在于
            用户活跃的这段事件，如果用户关闭浏览器走了，不再访问这个网站了，它就会自动清空了。
          3.用的话一般用localStorage会更多一些。
4.运行环境
  前端页面和服务端或者是客户端不一样的地方就是它需要随时去下载网页代码，下载完还要渲染，渲染的过程中还要执行js的一些运算，所以
  它的性能需要比较高的要求。首先要下载快，渲染快，js执行逻辑要比较合理。所以针对它要做一些优化。怎么
  让网页能更快一些。就是保证代码在浏览器中稳定且高效。首先是
  稳定，你不能乱了，你做了高效之后有什么安全问题，这个肯定不行。高效就是让它更快，下载的更快，渲染的更快以及执行的更快，这就是我们
  需要做的一个工作。这个也是比较重要的一部分。
    1.网页加载过程
      我们首先得知道网页是怎么加载的，才能把这个稳定且高效给做好。你连它的加载过程你都不知道，那你就不知道从何入手是不是。
    2.性能优化
      这其实不光是性能，还要有一个体验优化。性能优化有时候可能会表现的更倾向于说让这个事情做的更快一些，更高效一些。但是体验优化呢，
      有时候是让这个事情做的更顺畅一些，就是不卡顿，更顺畅一些。
    3.安全
      就是我们要知道一些在web前端在h5页面一些常见的安全攻击。然后我们要做一些常见的预防。当然安全这个问题肯定不仅仅是前端的一些问
      题。我们只需要做好我们自己的本职工作，至少我们能把这个前端的安全工作给它做好，至少把大家都知道的一些安全的问题给它预防掉。这
      是我们最基本的一个工作。
  1.页面加载过程
    题目:
      1.从输入url到渲染出页面的整个过程
        从下面这些方面去思考
        1.下载资源：各个资源类型，下载过程
        2.渲染页面：结合html css javascript 图片等
        考虑一下这个整个的页面是怎么被渲染出来的
      2.window.onload和DOMContentLoaded的区别
    知识点:
      1.加载资源的形式
        首先我们要知道它加载什么东西
        1.html代码
          最基本的访问页面需要html代码对吧
        2.媒体文件，如图片，视频等
          再一个页面中如果有图片有视频这样的媒体文件。我们需要加载一些文件，加载一些图片视频的媒体文件。所以我们
        3.javascript css
          然后呢就是js和css的这个代码
        一般情况下的页面就基本上三部分。
      2.加载资源的过程
        1.DNS解析：域名 -> IP地址
          我们输入url，第一步的时候它要进行dns解析，dns就是domin name server就是域名服务，域名服务解析，把域名变成ip地址。
          其实域名直接是ip地址也没问题，但由于ip地址很难记，还有就是ip地址在不同区域内，特别是大型网站，像百度，淘宝这种大型
          的网站，ip地址是不一样的，因为它们做了分区域的ip地址的一个均衡或者代理。所以说我们在访问域名的时候，这个域名解析这个
          服务它会根据地域去解析不同的域名，让你的网站会访问的更快一些。比如说你人在北京，你去访问广州的一个机器，ip地址肯定会
          慢对吧。你人在北京，你去访问一个昌平的一个机器，那肯定会快很多。所以基于这两点，我们肯定是要用域名而不是用ip地址。那
          用域名，你就必须用一个域名解析服务。为什么要用域名解析服务呢，我们的手机或电脑去访问一个域名的时候，它真正对应到的还
          是一个ip地址，还是一个ip地址的机器。所以说域名只是一个中间的，方便大家记住，方便统一使用的一个符号，它真正到网络中，
          它还是用ip地址做这个网络访问的。所以说第一步我们要把域名解析成ip地址。
        2.浏览器根据ip地址向服务器发起http请求
          浏览器向ip地址发送请求，其实浏览器只是一个发起方，它真正的核心模块还是操作系统的，操作系统里面有一些能发送网络服务的
          一些系统服务。浏览器调用这个操作系统的系统服务。然后操作系统去把这个事情发送。这里面我们说是http请求，其他它里面还涉
          及到一些http的一些连接，比如说我们常说的三次握手这些。这些有点概念化了。三次握手这个东西在我们实际的应用中，其实我们
          体会不到。我们能体会到的就是ip地址，http请求。我们前端常用的协议就是http协议。这是发起请求。
        3.发起请求后服务器接收请求并处理http请求，并返回给浏览器。返回的东西就是前面讲的加载的资源。看你请求的是什么东西，它就
          给你返回什么东西。
        大体过程就是这样的。
      3.渲染页面的过程
        1.如果我们请求的是一个页面的话，那肯定是返回html代码。然后网页根据html代码生成DOM Tree。
        2.根据css代码生成CSSOM，这个OM跟DOM的OM是一样的，就是object model对象模型。就是css对象模型。这个意思和html生成dom
          树是一样的，html是一个文本代码，浏览器解析完之后呢，它要生成一个结构化的树结构。那css它也是一个文本代码，然后它要生成
          一个css object model的一个可结构化的一个对象。从概念上理解它和dom树是一样的。遇到css的代码出现就会生成一个CSSOM。
        3.DOM Tree和CSSOM整合成一个Render Tree渲染树。为什么要这么做呢，因为只有dom树是没法渲染的。因为有些标签的css属性是
          在CSSOM里面的。DOM树是整个网页的结构框架。然后再在框架上放上一些样式。最终整合成一个框架和样式合并出来的一个结构。我
          们叫做Render Tree。这样的话就可以去渲染了。所谓Render Tree就是我们dom树里面挂了很多css的属性。它也是一个树结构。只
          不过每个节点它挂了一些css的属性。这样的话就可以渲染了。
        4.然后浏览器根据Render Tree渲染页面
          因为有了结构了也有了css属性了，就可以渲染页面了。
        5.如果入到<script>则暂停渲染，优先加载并执行js代码，完成之后再继续。
          我们之前讲js异步的时候说过，js的进程和渲染进程是共用一个线程的。为什么要共用一个线程呢，因为js有可能会改变dom的结构，
          还有可能会改变Render Tree这个结构。这也是为何建议把js放到body最后的原因所在。
        6.直至把Render Tree渲染完成。这个页面就渲染完成了。
        这就是整个的一个渲染过程。
      4.页面加载和渲染示例
        可以通过示例来分析一下加载和渲染过程
        1.示例1
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8">
              <title>Document</title>
            </head>
            <body>
              <p>test</p>
            </body>
          </html>
          我们根据加载过程把页面加载下来，然后根据html生成一个dom树，根据cssOM，然后最后生成render Tree去渲染。
        2.示例2
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8">
              <title>Document</title>
              <link rel="stylesheet" type="text/css" href="test.css">
            </head>
            <body>
              <p>test</p>
            </body>
          </html>
          我们页面加载完之后，我们要先把css代码加载完，因为它是在head里面，加载完之后我们css代码的这个cssOM就已经给它做出来了。
          出来之后我们再根据html这个结构渲染出dom树，然后两个整合成render tree，然后去把这个页面渲染出来。这个是有css的情况。
          思考题：
            1.为何建议把css放在head中
              根据浏览器的渲染过程。如果css放到dom结构下面，那么就会先生成dom树，因为它没有css的信息，所以它就照着默认标签的样式渲染
              到浏览器上，继续向下渲染发现有一个css，把这个css文件加载完成之后，生成一个CSSOM，然后又和当前的这个dom树做一个合并生成
              RenderTree，然后可能会再重新渲染。可能就会是一个重复的过程。有时候这个动作比较慢的话就可能会出现肉眼可见的样式变化的过
              程，感官上不好。所以即使网速很好，电脑也很好的时候，也不建议把css放到下面来写。因为这是一个不好的书写方式。我们之所以把
              css放到上面来写是建议想把css的规则把css的代码在dom树生成完成之前就给它加载完，就把这个css的规则放到这，然后当dom树生
              成完之后直接和所有的css整合生成一个渲染树，生成一个Render Tree，然后一步渲染完成。这样的话就不要再出现重复了。这样的话
              是我们期望的一个过程。所以说我们要把css放到head中。
        3.示例3
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8">
              <title>Document</title>
            </head>
            <body>
              <div id="container">default</div>
              <script src="index.js"></script>
              <p>test</p>
            </body>
          </html>
          根据我们的渲染过程，我们可以这样分析。拿到html之后，我们去分析html，然后生成一个dom树。然后根据dom树进行渲染。
          思考题：
            1.为何建议把js放到body最后
              如果没有放在最后，可能会出现本来渲染了一部分，然后突然卡住了去加载执行js了，然后有进行渲染后面的dom内容。所以说它就会导致
              一个页面渲染的过程比较长。本来我们期望的是这个页面一共的渲染时间是1s钟。我们期望在0.3s或0.5s钟之内让用户看到页面的所有内
              容。然后剩下的0.5s之内我们执行js代码，然后把这个页面渲染完成。这是我们期望的。我们不期望说这个页面渲染一共是1s钟。然后直
              到1s钟的最后一刻我们才让用户看到所有的内容。所以说我们要把js放到最后。就是说我们要把先能出来的东西全部都渲染出来，把html
              渲染完之后，然后在把script继续执行，到时候你该干什么干什么，反正我dom已经渲染完了，你愿意改的话你就改吧。这样是我们比较
              期望的一个结果。
        4.示例4
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8">
              <title>Document</title>
            </head>
            <body>
              <p>test</p>
              <img src="test.png" />
              <p>test</p>
            </body>
          </html>
          生成dom树之后，依次渲染，发现img，我们就要去加载test.png这个文件。但这个过程不会停止渲染，它不像是一个js文件，它不
          像js代码，因为图片这个东西加载完之后直接插进去就行了，它不会改变其他的结果。只不过这个时候这个图片还没过来，所以说我们
          这个位置先空着，然后继续向下渲染，这个时候不会去阻塞这个渲染过程。等什么时候图片加载完，然后我们就把图片塞到这来。有可
          能图片会比较大，或者比较高，可能会把内容向下撑一下，这个就需要重排一下就可以了。
          这就是带img这个情况的一个用处。
            window.addEventListener('load', function () {
              // 网页全部资源加载完才会执行，包括图片，视频等
            })
            window.addEventListener('DOMContentLoaded', function () {
              // dom渲染完即可执行，此时图片，视频可能还没有加载完
            })
            所以说，如果是有图片的话，用DOMContentLoaded这个事件去监听网页加载完成，这样的话就会更快一些。它就不用等到图片加
            载完，因为我们基本上所有的操作都是对dom的操作，图片是不是加载完对我们的一些js的代码中操作的时候可能不是那么的重要。
            所以我们在一般的情况下，像jquery这种代码它都是要监听DOMContentLoaded这个事件来去做一些处理的。只要是监听到这个
            事件，它就认为这个网页它已经加载完了。它不会等到图片加载完再执行，所以说用这个比用load这个事件更加靠谱。
  2.性能优化
    1.性能优化介绍
      1.性能优化是一个综合性的问题，没有标准答案，但要求尽量全面。面试的是想听到尽量全面的方案或比较全面的一个思考。所以我们本着这
        个思路去分析一下应该怎么去回答这个问题。
      2.某些细节问题可能会单独提问：比如手写防抖、手写节流
        防抖和节流它算是一个体验性的优化方案，也算这个性能优化方案之内。
    2.性能优化原则
      1.多使用内存、缓存或其他方法
      2. 减少cpu计算量，减少网络加载耗时
      所以大家要明白，我们到底是多用什么少用什么，所谓性能优化就是让这个网页加载的更快，渲染的更快，运行的更流畅一些。你想要更快
      更流畅，你就需要多使用内存，缓存这种方法。这种方法适用于所有编程的性能优化。都是用空间换时间。算法中的一个时间复杂度的减小
      也是通过空间换时间。这个没有什么神奇的东西，就是通过空间换时间。
    3.从何入手
      性能优化就是让它更快，怎么让它更快呢。
      1.让加载更快
        就是下载的东西更快，别人下载一个页面或所有的文件需要2s钟，那我的代码让人下载完只需要1s钟，这样不就更快了吗。
      2.让渲染更快
        就是我的这个代码逻辑结构更加合理，没有什么重复的多余的渲染操作，没有无用功，没有等待。让渲染更快，至少是在同一时间内，我
        让用户看得更快。
      所以说我们从让加载更快，让渲染更快这个角度来考虑，我们就能直到这个性能优化从何入手。
    4.让加载更快
      1.减少资源体积：压缩代码
        js代码，css代码，包括图片我们也可以压缩。包括服务器端也会进行一些其他的压缩方式，比如说服务器端会进行gzip压缩，这个和
        我们前端没有太多的关系，这是服务器端做的压缩，然后浏览器进行解压。gzip压缩一般能把代码压缩到体积三分之一左右。
      2.减少访问次数：合并代码，ssr服务端渲染，缓存
        1.合并代码
          我们的http请求每次访问都是很耗时的，同样的代码，比如说一共三个代码，每个代码3kb，一共是9kb。如果是你分三次访问，每次
          访问3kb和你这一次访问9kb这个时间是不一样的。我们就选后者，访问次数比较少的那个。js代码，css代码，图片都是可以合并的。
        2.ssr服务端渲染
          服务端渲染为什么能减少访问次数呢，服务端渲染就是说我们服务端把页面以及页面要显示的内容一块给前端显示出来，这样前端拿到
          内容之后就立马去把这个内容展示出来。如果不是服务端渲染的话，是我们把页面拿到之后，我们再通过ajax再去加载资源，加载资源
          之后再去渲染到页面上去。
        3.缓存
          比如说我们这个页面要访问10个资源，如果没有缓存的话，那就是访问10个资源，也就是10次。如果是其中六个都命中的缓存，那我们
          就可以只访问4个资源，那次数就变少了。
      3.使用更快的网络：cdn
        cdn是根据区域来去做服务器的一个处理。也就是说你如果用cdn的一个网络的话，你从北京访问的ip和你从上海访问的ip是不一样的。
        因为它会根据区域来去联系运营商的服务器然后让下载更快一些。
    5.让渲染更快
      1.css放在head里面，js放到body最下面
      2.今早开始执行js，用DOMContentLoaded里面去触发
      3.懒加载（图片懒加载，上滑加载更多）
        上滑的时候加载更多，这个图片呢它是懒加载的。我们看这种新闻的app，图片都是懒加载的。图片没必要说直接加载，我们可以什么时
        候用什么时候加载。这样渲染就会更快一些。
      4.对dom查询进行缓存
      5.频繁dom操作，合并到一起插入dom结构
      6.节流throttle防抖debounce
        你要知道节流防抖它是怎么回事，节流防抖不能说是让渲染更快，而是让渲染更加流畅，它是一个体验性的优化。当然归到让渲染更快，
        渲染优化里面也没问题。
    7.示例
      1.资源合并
        <script src="a.js"></script>
        <script src="b.js"></script>
        <script src="c.js"></script>
        合并后
        <script src="abc.js"></script>
      2.缓存
        bundle.[contenthash].js
        bundle.58jffjq0482nf.js
        1.静态资源加hash后缀，根据文件内容计算hash
        2.文件内容不变，则hash不变，则url不变
        3.url和文件不变，则会自动触发http缓存机制，返回304
          如果我们每次访问一个js的资源，它的url如果不变，并且服务器判断它的文件也不变的话，如果是第一次访问成功之后，第二次再
          去访问，浏览器已经访问过一次了，服务器就会告诉浏览器说这个是304了，304就是说我们的资源根本没有变，所以说你就回去把，
          我就不用给你了。这样直接返回一个304的状态码，那这个内容就非常少了，可能用几个字节就能把这个事情搞定了。就告诉浏览器
          说这个没变，你就用之前的就行了。立马就可以启动这个缓存机制，然后就不用下载了，就可以用之前的缓存的这个文件了。所以这
          个机制不是我们前端去写js实现的，而它是http的缓存机制，浏览器和服务器都会遵从这个机制去做缓存。所以说我们只需要符合
          这个机制去让它尽可能的去命中这个缓存就可以了。
      3.cdn
      4.ssr
        服务端渲染：将网页和数据一起加载，一起渲染
        非ssr：先加载网页，网页的ajax再加载数据，返回后再渲染数据
        所以ssr确实是为了性能考虑来做的。如果是有ssr的话这个性能会提高很多。特别是再网络速度比较慢的情况下会提高很多。所以说
        ssr也是一种减少网络请求的一种思路。
        早先的jsp asp php都属于ssr。ssr是一个比较宽泛的概念。server side render就是服务端渲染。现在的vue react做ssr也
        是借助node的一些能力来做。从服务端渲染这个思路上和jsp asp php也没有什么本质上的区别。只不过它用的更加高级的前端框架
        而已。
      5.懒加载
        比如说一个图片，有时候我们需要图片加载，有时候不需要，比如一个很长的新闻列表，每一个列表项中都有一个图片，这个时候其实
        我们不希望图片一下子全部加载完，我们希望第一屏看到的图片就是在手机屏幕上的图片，我们加载完，比如前五个或前八个让它加载
        完，然后随着用户往上去滑动页面的时候，这个图片慢慢的一个一个加载出来，并不是说我页面下载完之后所有图片立马加载出来。所
        以我们利用懒加载，可以把这个图片默认赋值成一个src="preview.png"就是一个预览的一个图片，这个图片的体积非常小，很容易
        加载，然后我们把真正的图片地址放到data-realsrc="abc.png"里面，放在这里面的话这个图片不会去加载这个地址。当浏览器判
        断到用户往上滑，当这个图片露出这个屏幕的时候我们再去把这个图片地址的data-realsrc赋值给这个图片的src，去加载真正的图
        片地址。这就是懒加载。这个是很常见的，也是性能优化的一个很好的一钟方式。
        <img id="img1" src="preview.png" data-realsrc="abc.png" />
        <script type="text/javascript">
          var img1 = document.getElementById('img1')
          img1.src = img1.getAttribute('data-realsrc')
        </script>
      6.缓存dom查询
      7.多个dom操作合并到一起插入到dom结构
      8.尽早开始js执行
      9.防抖debounce
        1.监听一个输入框，文字变化后触发change事件
        2.直接监听keyup事件，则会频繁触发change事件
        3.防抖：用户在输入结束或暂停的时候，才会触发change事件
        // 防抖简易demo
        const input1 = document.getElementById('input1')
        let timer = null
        input1.addEventListener('keyup', function () {
          if (timer) {
            clearTimeout(timer)
          }
          timer = setTimeout(() => {
            // 模拟触发change事件
            console.log(input1.value)
            // 清空定时器
            timer = null
          }, 500)
        })
        // debounce是对函数的封装，所以它最终返回应该是一个函数
        // 函数的封装就是将大部分逻辑封装起来，使使用的时候更加简单，只写业务逻辑就行了。jq zepto等库和插件都是这个原理。
        function debounce (fn, delay = 500) {
          // 这个timer是在闭包中的，timer这个数据就被隐藏了，不会被外面轻易拿到
          let timer = null

          return function () {
            if (timer) {
              clearTimeout(timer)
            }
            timer = setTimeout(() => {
              // this是为了获取添加事件的dom对象，arguments是为了将事件函数接收到的参数透传给fn
              fn.apply(this, arguments)
              timer = null
            }, delay)
          }
        }
        // 使用
        input1.addEventListener('keyup', debounce(function () {
          console.log(input1.value)
        }, 300))
      10.节流throttle  
        防抖的场景是频繁输入和频繁操作的时候最后的时候才去触发。节流是你在频繁输入频繁操作的时候它会保持一个频率连续触发。
        1.比如拖拽一个元素时，要随时拿到这个元素被拖拽的位置
        2.如果直接用drag事件，则会频繁触发，很容易导致卡顿
        3.这个时候我们需要节流：无论拖拽的速度多快，都会每隔100ms触发一次
        // 防抖简易demo
        const div1 = document.getElementById('div1')
        let timer = null
        div1.addEventListener('drag', function (e) {
          if (timer) {
            return 
          }
          timer = setTimeout(() => {
            console.log(e.offsetX, e.offsetY)
            timer = null
          }, 100)
        })
        // 节流函数封装
        function throttle (fn, delay = 100) {
          let timer = null
          return function () {
            if (timer) {
              return
            }
            timer = setTimeout(() => {
              fn.apply(this, arguments)
              timer = null
            }, delay)
          }
        }
        // 使用
        input1.addEventListener('drag', throttle(function (e) {
          console.log(e.offsetX, e.offsetY)
        }, 200))
  3.安全
    问题:
      1.常见的web前端攻击方式有哪些，怎么预防
        1.XSS跨站请求攻击
          1.一个博客网站，我发表一篇博客，其中嵌入<script>脚本
          2.脚本内容：获取cookie，发送到我的服务器（服务器配合跨域）
          3.发布这篇博客，有人查看它，我轻松收割访问者的cookie
          预防：
          1.替换特殊字符，如把<变为&lt;，把>变为&gt;
          2.这样的话<script>就变为&lt;script&gt;，直接显示，而不会作为脚本被执行。只有html里面有script才会作为脚本被执行
          3.前端要替换，后端也要替换，都做总不会有错
          4.有xss npm工具
        2.XSRF跨站请求伪造
          1.你正在购物，看中了某个商品，商品id是100
          2.付费接口是xxx.com/pay?id=100，但没有任何验证
          3.我是一个攻击者，我看中了一个商品，id是200
          4.我向你发送一个电子邮件，邮件标题很吸引人
          5.但邮件正文隐藏着<img src="xxx.com/pay?id=200" />
          6.你一查看邮件，就购买了id是200的商品
          因为你现在正在购物，肯定登录了这个网站了，你就会有用户信息了，图片的地址去访问的时候，你的用户信息已经带过去了。
          预防：
          1.使用post接口
            使用post接口，你用img攻击是攻击不通的，因为img的src只支持get请求
          2.增加验证，例如密码，短信验证码，指纹等
      
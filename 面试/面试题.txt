1.var和let const的区别
  1.var是es5的语法，let const是es6的语法。var有变量提升
  2.var和let声明的是变量，可修改。const是常量，不可修改
  3.let const有块级作用域，var没有
2.typeof返回哪些类型
  1.undefined string number boolean symbol
  2.object（注意，typeof null === 'object'）
  3.function
3.列举强制类型转换和隐式类型转换
  1.强制：parseInt parseFloat toString等
  2.隐式：if 逻辑运算 == +字符串拼接
4.手写深度比较，模拟lodash isEqual
  // 实现如下效果，属性相等就相等
  const obj1 = {a: 10, b: {x: 100, y: 200}}
  const obj2 = {a: 10, b: {x: 100, y: 200}}
  isEqual(obj1, obj2) // true
  // 判断是否是对象或数组
  function isObject (obj) {
    return typeof obj === 'object' && obj !== null
  }
  // 全相等函数
  function isEqual (obj1, obj2) {
    // 值类型，（注意，参与equal的一般不会是函数）
    if (!isObject(obj1) || !isObject(obj2)) {
      return obj1 === obj2
    }
    if (obj1 === obj2) {
      return true
    }
    // 两个都是对象或数组，而且不相等
    // 1.先取出obj1和obj2的keys，比较个数
    const obj1Keys = Object.keys(obj1)
    const obj2Keys = Object.keys(obj2)
    if (obj1Keys.length !== obj2Keys.length) {
      return false
    }
    // 2.以obj1为基准，和obj2依次递归做比较
    for (let key in obj1) {
      // 比较当前key的val -- 递归！！
      const res = isEqual(obj1[key], obj2[key])
      if (!res) {
        return false
      }
    }
    // 3.全相等
    return true
  }
5.split()和join()的区别
6.数组的pop push unshift shift分别做什么
  针对数组的api
    1.功能是什么
    2.参数是什么
    3.返回值是什么
    4.是否会对原数组造成影响
  1.pop
    const arr = [10, 20, 30, 40]
    const popRes = arr.pop()
    console.log(popRes, arr) // 40 [10, 20, 30]
  2.push
    const arr = [10, 20, 30, 40]
    const pushRes = arr.push(50)
    console.log(pushRes, arr) // 5 [10, 20, 30, 40, 50]
  3.unshift
    const arr = [10, 20, 30, 40]
    const unshiftRes = arr.unshift(50)
    console.log(unshiftRes, arr) // 5 [50, 10, 20, 30, 40]
  4.shift
    const arr = [10, 20, 30, 40]
    const shiftRes = arr.shift()
    console.log(shiftRes, arr) // 10 [20, 30, 40]
  数组的api，有哪些是纯函数
  纯函数：1.不改变原数组（没有副作用） 2.返回一个新数组
  1.concat
    const arr = [10, 20, 30, 40]
    const arr1 = arr.concat([50, 60, 70])
    console.log(arr1, arr) // [10, 20, 30, 40, 50, 60, 70] [10, 20, 30, 40]
  2.map
    const arr = [10, 20, 30, 40]
    const arr1 = arr.map(item => item * 10)
    console.log(arr1, arr) // [100, 200, 300, 400] [10, 20, 30, 40]
  3.filter
    const arr = [10, 20, 30, 40]
    const arr1 = arr.filter(item => item > 25)
    console.log(arr1, arr) // [30, 40] [10, 20, 30, 40]
  4.slice
    const arr = [10, 20, 30, 40]
    const arr1 = arr.slice()
    console.log(arr1, arr) // [10, 20, 30, 40] [10, 20, 30, 40]
  非纯函数数组api
  pop push unshift shift 
  forEach some every
  reduce
7.数组slice和splice的区别 
  1.功能区别
    slice是切片，一片一片的这样切。splice是剪接，剪完之后再给你接上。
  2.参数和返回值
  3.是否是纯函数
  4.演示
    1.slice 纯函数
      const arr = [10, 20, 30, 40, 50]
      const arr1 = arr.slice()     // slice如果不传参数的话，它相当于把这个数组整个的拷贝一份然后复制到一个新的数组中。
      const arr1 = arr.slice(1, 4) // [20, 30, 40]  截取区间
      const arr1 = arr.slice(2)    // [30, 40, 50]  截取到最后
      const arr1 = arr.slice(0, 2) // [10, 20, 30]  截取前几位
      const arr1 = arr.slice(-3)   // [30, 40, 50]  截取后几位
    2.splice 非纯函数
      const arr = [10, 20, 30, 40, 50]
      const spliceRes = arr.splice(1, 2, 'a', 'b', 'c')
      const spliceRes1 = arr.splice(1, 2)
      const spliceRes2 = arr.splice(1, 0, 'a', 'b', 'c')
      const spliceRes3 = arr.splice(1)
      console.log(spliceRes, arr)  // [20, 30] [10, 'a', 'b', 'c', 40, 50]    剪切出来，再添上
      console.log(spliceRes1, arr) // [20, 30] [10, 40, 50]                   只想剪切，不想添
      console.log(spliceRes2, arr) // [] [10, 'a', 'b', 'c', 20, 30, 40, 50]  只想增加，不想剪切
      console.log(spliceRes3, arr) // [20, 30, 40, 50] [10]                   剪切到最后
8.[10, 20, 30].map(parseInt)返回结果是什么
  1.map的参数和返回值
  2.parseInt参数和返回值
  const res = [10, 20, 30].map(parseInt)
  console.log(res) // [10, NaN, NaN]
  // 拆解
  [10, 20, 30].map((item, index) => {
    return parseInt(item, index)
  })
9.ajax请求get和post的区别
  1.get请求一般用于查询操作，post一般用于用户提交操作
    我们在一些项目设计的时候，有一些功能是用get还是post是根据这个方式来去做的。
  2.get请求的参数拼接到url上，post放在请求体内（数据体积可更大）
    所以说我们去上传提交一个什么东西，特别是数据量比较大的一个东西的话，一般是用post请求去提交。我们查询一个东西呢，就是把这
    个查询的参数放到url上，这样是比较方便的。因为url的长度最终是比较受限制的。至少它不适合比如去上传一个文件，一段json这些
    比较大比较麻烦的就比较适合用post请求放到请求体中去往上发送
  3.安全性：post易于防止csrf
10.函数call和apply的区别
  传参方式的不同。call的参数是一个一个拆分的传进去的。apply的参数是一个数组或类数组。其实它们两个可以相互去转换， 但是为了大
  家使用，js的运行时就做了这么两个不同的执行形式，更方便我们去使用。
11.事件代理（委托）是什么
12.闭包是什么，有什么特性特点，有什么负面影响
  1.回顾作用域和自由变量
  2.回顾闭包应用场景：函数作为参数被传入，函数作为返回值被返回
  3.回顾：自由变量的查找，要在函数定义的地方（而非执行的地方）
  4.影响：会让变量常驻内存，得不到释放。闭包不要乱用
    用的太多有可能会影响性能。我们这个地方说一个变量常驻内存，得不到释放。并不一定是内存泄漏。有的人说闭包会造成内存泄漏，这个
    是有可能的，但是不一定啊。所谓内存泄漏是说你的变量也好你的一个数据也好在内存中应该被释放，因为没有用了，但是呢没有被释放，
    也就是说无用的垃圾放在那了，它没有用了，放在那，释放不了。但是闭包有可能的情况是我们的变量也好对象也好在闭包中，它有可能是
    会被用到的。所以说我们判断不了它未来是不是一定会被用到或一定是不用了。我们无非做这个判断，所以我们不去释放它。这并不是说一
    个bug，内存泄漏一般是由bug造成的，就是说我们应该去能识别出来，结果由于什么bug没有识别出来导致的内存泄漏了。闭包是我们没法
    判断这个闭包的变量是不是未来还可用，所以说我们不得不去保存它，就是先不去释放它。
  闭包：1.函数嵌套函数。2.函数内使用的自由变量不能在执行时的父作用域中查找到，要去定义时的父作用域才能查找到的。满足这两点就是
      闭包了。这个自由变量会常驻内存。
13.如何阻止事件冒泡和默认行为
14.查找、添加、删除、移动dom节点的方法
15.如何减少dom操作
16.解释jsonp的原理，为何它不是真正的ajax
  后端没有同源策略，那为什么前端浏览器需要这个同源策略，就是因为一个安全的问题，就是不同域之间你不能有相互的资源访问。那后端没有
  同源策略会不会有安全问题啊，当然也会有安全问题，那就是需要后端去做一些自己的一些预防，因为后端代码是运行到服务器上的，你可以对
  它进行一系列的控制，那前端代码呢是运行到浏览器上的，所以这个控制就需要浏览器自己去做这个同源策略的安全性的控制。如果这个浏览器
  它自己不做同源策略的话，这个浏览器是不能用的。这个浏览器可以被称作是毫无安全底线的浏览器，没有人会用它的。而且你做的网站要对这
  样的浏览器做一个屏蔽的措施，如果识别是这个浏览器的话，告诉用户这个用户不安全，不要用这个浏览器来访问。我们不提供这个浏览器的服
  务。都不用，这个浏览器不就死了吗。
17.document load和ready的区别
18.==和===的区别
19.函数声明和函数表达式的区别
20.new Object()和Object.create()有什么区别
  1.{}等同于new Object()，原型都是Object.prototype
  2.Object.create(null)，必须传一个参数，可以是一个对象也可以是null，如果传的是null就是一个空对象。传入null就是没有原型。
    传入对象就是指定原型。也就是Object.create()是创建一个空对象，然后把空对象的原型指定为传入的这个对象上。
  const obj1 = {
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  }
  const obj2 = new Object({
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj3 = new Object(obj1)
  console.log(obj1 === obj3)            // true
  const obj4 = Object.create(null)      // {}，但是没有原型
  const obj5 = new Object()             // {}，有原型
  const obj6 = Object.create({          // {}，原型就是传入的这个对象
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj7 = Object.create(obj1)      // 意思就是说我们通过obj1创建了obj6，通过create方式来创建的。
  console.log(obj6.__proto__ === obj1)  // true
  console.log(obj6 === obj1)            // false
  console.log(obj1 === obj3)            // true 
21.关于this的场景题
22.关于作用域和自由变量的场景题-1
23.判断字符串以字母开头，后面是字母数字下划线，长度6-30
  正则表达式它不是js特有的一个东西。它是一个脱离了语言和平台的一个标准规范。跟json差不多。一个标准规范。它是在判断字符串是不是
  某一个规则或者说查找字符串的某一个规则的时候是用的比较多的。
  const reg = /^[a-zA-Z]\w{5,29}$/
  常用的正则表达式
  1.
24.关于作用域和自由变量的场景题-2
25.手写字符串trim方法，保证浏览器兼容性
  String.prototype.trim = function () {
    return this.replace(/^s+/, '').replace(/s+$/, '')
  }
26.如何获取多个数字中的最大值
  1.
    function max () {
      const nums = Array.prototype.slice.call(arguments)
      let max = 0
      nums.forEach(n => {
        if (n > max) {
          max = n
        }
      })
      return max
    }
    max(10, 20, 30, 40) // 40 
  2.Math.max(10, 20, 30, 40) // 40
27.如何用js实现继承
  1.class继承
  2.prototype继承
28.如何捕获js程序中的异常
  1.手动捕获异常
    这种方式用的比较常见，觉得哪个地方可能会风险比较高，那就用一个try catch给它包起来，然后有异常就输出
    try {
      // todo
    } catch (ex) {
      console.error(ex) // 手动捕获catch
    } finally {
      // todo
    }
  2.自动捕获异常
    一种兜底方案，比如说我们想要监听一下前端页面，已经上线了，我们做一个统计监听，我们看一下前端页面有没有什么js错误，一般我们
    第一种方式就是用上面的方式在该try catch的地方打上try catch，如果catch到我们就发一个统计打点，作为一个记录。第二种方式
    就是我们不可能每一行都用try catch。这样成本太高。我们只在一个高风险的地方用try catch，其他地方我们用一个window.onerror
    就可以了。它会自动捕获你程序中的一些问题。
    window.onerror = function (message, source, lineNum, colNum, error) {
      // 报错信息 源码 行号 列号 错误栈
      // 第一，对跨域的js，如cdn，会告诉你错误了，但不会有详细的报错信息
      // 第二，对于压缩的js，还要配合sourceMap去反查到为压缩代码的行，列
    }
  所以通过这两个方式来集合，你就能监听到页面上绝大部分的错误。
29.什么是json
  1.json是一种数据格式，本质是一段字符串
  2.json格式和js对象结构一致，所以对js语言更友好一些
    在json格式普及之前，js中的一些数据格式，比如ajax的上传下载包括一些数据的管理都是用xml比较多一些。ajax的核心api的名字
    XMLHttpRequest就是由xml数据格式来引起的一个名字。就一直延用到现在。但是现在json已经全面替代了xml。就是因为json和js
    对象结构比较一致。所以对s语言更友好一些。
  3.window.JSON是一个全局对象：JSON.stringify JSON.parse
    我们会用到这两个函数去转换对象和json字符串，因为json它本质是一个字符串。那我们通过JSON.stringify就能把这个对象转换成
    json字符串。通过JSON.parse就能把json字符串转换成对象。
  4.json格式的特点跟js对象不一样的就是key和字符串的value必须用双引号引起来。不然就会报错。js里面一般是用单引号做字符串。
30.获取当前页面url参数
  1.传统方式，查找location.search
    function query (name) {
      const search = location.search.substr(1)
      const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
      const res = search.match(reg)
      if (res == null) {
        return null
      }
      return res[2]
    }
  2.新api，URLSearchParams
    function query (name) {
      const search = location.search
      const p = new URLSearchParams(search)
      return p.get(name)
    }
31.将url参数解析为js对象
  1.传统方式，利用拆分
    function queryToObj () {
      const res = {}
      const search = location.search.substr(1)
      search.split('&').forEach(item => {
        const arr = item.split('=')
        const key = arr[0]
        const val = arr[1]
        res[key] = val
      })
      return res
    }
  2.使用URLSearchParams
    function queryToObj () {
      const res = {}
      const pList = new URLSearchParams(location.search)
      pList.forEach((val, key) => {
        res[key] = val
      })
      return res
    }
32.手写数组flatern，考虑多层级
  function flat (arr) {
    // 验证arr中，还有没有深层数组 [1, 2, [3, 4], 5]
    const isDeep = arr.some(item => item instanceof Array)
    if (!isDeep) {
      return arr // 已经是flatern [1, 2, 3, 4, 5]
    }
    const res = Array.prototype.concat.apply([], arr)
    return flat(res) // 递归
  }
  const res = flat([1, 2, [3, 4], 5])
  console.log(res)
33.数组去重
  1.传统方式，遍历元素挨个比较，去重
    function unique (arr) {
      const res = []
      arr.forEach(item => {
        if (res.indexOf(item) < 0) {
          res.push(item)
        }
      })
      return res
    }
  2.使用Set（无序，不能重复）
    function unique (arr) {
      const set = new Set(arr)
      return [...set]
    }
  3.考虑计算效率和效率
    Set这种方式比较简单，Set这种数据结构本身是不允许有重复存在的元素的无序结构。这种特点比较适合这种去重的操作，它不需要进行
    遍历。传统方式它要进行一次遍历，遍历里面的indexOf它本质上也是一种遍历，因为数组它是一个有序结构，你要判断数组里有没有你
    想要的那一项，你要从数组的第一项开始一个一个往后找看看有没有满足条件的元素。所以传统方式相当于是遍历了两层，这个算法的效率
    是稍微低一点的。所以能使用Set就使用Set，不要使用传统的方式。这种方式会比较慢。尤其数据量比较大的时候更明显。
34.手写深拷贝
  function deepClone (obj = {}) {
    // obj是null，或者不是对象或数组，直接返回
    if (typeof obj !== 'object' || obj == null) {
      return obj
    }
    // 初始化返回结果，也就是说我们该返回什么东西，我们先初始化一下
    let result
    // 如果传入的这个值是数组类型的，我们返回的这个结果应该是数组格式的。传入的值如果不是数组的话，返回的结果应该是对象格式的
    if (obj instanceof Array) {
      result = []
    } else {
      result = {}
    }
    // 无论是对象还是数组，它都可以用for in去遍历
    for (let key in obj) {
      // 判断每个key是不是这个对象自己拥有的属性，保证key不是原型上的属性
      if (obj.hasOwnProperty(key)) {
        // 递归调用！！！ 递归就是为了防止比较深层次的东西，我们就需要一层层的去递归才能最终给它完全的拷贝出来。
        // 这样的话才能完成深拷贝。我们考察深拷贝的时候，递归是非常看中的东西。
        // obj的每个key的值都要重新深拷贝然后赋值给result[key]
        result[key] = deepClone(obj[key])
      }
    }
    // 最终它要返回一个你拷贝后的对象
    return result
  }
  注意，Object.assign不是深拷贝
35.介绍一下RAF requestAnimationFrame
  这个是做动画用的，这个api大家要知道，算是性能优化体验优化的一部分。
  1.我们要想动画流畅，不管用js还是css，更新频率要达到60帧/s，也就是说我们1s钟动画能动60次，即16.67ms动画更新一次视图，这样
    的话我们人的肉眼就能感觉这个动画非常流畅不卡顿。不管是动画片，电影还是网页上的一些动画，只要能保证这个条件就会让动画非常流
    畅
  2.setTimeout要手动控制频率，而RAF浏览器会自动控制，浏览器它会算好自己的帧率，然后去每隔16.67ms或每秒钟触发60次，这样的话
    它自动就会动起来。
  3.有一些不应该耗费性能的地方，比如后台标签，你的chrome已经切换到后台了已经最小化了，或隐藏的iframe中，这个RAF会暂停的。就
    是浏览器会帮你做更多的事情，这个api提供出来是浏览器专门为了做一些动画动效用的，它会帮你做更多的事情。而setTimeout在这些
    情况下会依然执行，因为setTimeout本身它不是为了做动画用的，它就是为了做一个异步定时器来用的，所以说我们之前用setTimeout
    做动画也算是不得已而为之。但是有了这个新的api之后呢，我们就可以去用新的api去做一些更流畅或性能更好的一些工作。
  示例
    // 3s把宽度从100px变为640px，即增加540px。
    // 60帧/s，3s 180帧，所以每帧变化3px。这样动画的视觉效果就是流畅的。
    1.setTimeout
      const div1 = document.getElementById('div1')
      let curWidth = 100
      const maxWidth = 640
      function animate () {
        curWidth = curWidth + 3
        div1.style.width = curWidth + 'px'
        if (curWidth < maxWidth) {
          setTimeout(animate, 16.67) // 需要自己控制帧率，即时间和每次变化需要自己去评估
        }
      }
      animate()
    2.RAF
      const div1 = document.getElementById('div1')
      let curWidth = 100
      const maxWidth = 640
      function animate () {
        curWidth = curWidth + 3
        div1.style.width = curWidth + 'px'
        if (curWidth < maxWidth) {
          window.requestAnimationFrame(animate) // 时间不用自己控制
        }
      }
      animate()
36.前端性能如何优化，一般从哪几个方面考虑
  原则：多使用内存缓存，减少计算，减少网络请求
  方向：加载页面要更快，页面渲染要更快，页面操作要更流畅
    
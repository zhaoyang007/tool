## 回答问题的套路

* 是什么
* 来由：为什么用这个东西，出现它是为了什么
* 深入的描述它具体是怎么做的这个过程



##### HTML5 有什么变化

##### 语义化的意义是什么

* 开发者容易理解
* 机器容易理解结构（搜索、读屏软件）
* 有助于 SEO

##### 手写深度比较，模拟 lodash isEqual

```js
// 实现如下效果，属性相等就相等
const obj1 = {a: 10, b: {x: 100, y: 200}}
const obj2 = {a: 10, b: {x: 100, y: 200}}
isEqual(obj1, obj2) // true
// 判断是否是对象或数组
function isObject (obj) {
  return typeof obj === 'object' && obj !== null
}
// 全相等函数
function isEqual (obj1, obj2) {
  // 值类型，（注意，参与equal的一般不会是函数）
  if (!isObject(obj1) || !isObject(obj2)) {
    return obj1 === obj2
  }
  if (obj1 === obj2) {
    return true
  }
  // 两个都是对象或数组，而且不相等
  // 1.先取出obj1和obj2的keys，比较个数
  const obj1Keys = Object.keys(obj1)
  const obj2Keys = Object.keys(obj2)
  if (obj1Keys.length !== obj2Keys.length) {
    return false
  }
  // 2.以obj1为基准，和obj2依次递归做比较
  for (let key in obj1) {
    // 比较当前key的val -- 递归！！
    const res = isEqual(obj1[key], obj2[key])
    if (!res) {
      return false
    }
  }
  // 3.全相等
  return true
}
```

##### 数组的 pop push unshift shift 分别做什么

针对数组的 api
1.功能是什么
2.参数是什么
3.返回值是什么
4.是否会对原数组造成影响

```js
// pop
const arr = [10, 20, 30, 40]
const popRes = arr.pop()
console.log(popRes, arr) // 40 [10, 20, 30]
// push
const arr = [10, 20, 30, 40]
const pushRes = arr.push(50)
console.log(pushRes, arr) // 5 [10, 20, 30, 40, 50]
// unshift
const arr = [10, 20, 30, 40]
const unshiftRes = arr.unshift(50)
console.log(unshiftRes, arr) // 5 [50, 10, 20, 30, 40]
// shift
const arr = [10, 20, 30, 40]
const shiftRes = arr.shift()
console.log(shiftRes, arr) // 10 [20, 30, 40]

// 数组的api，有哪些是纯函数
// 纯函数：1.不改变原数组（没有副作用） 2.返回一个新数组

// concat
const arr = [10, 20, 30, 40]
const arr1 = arr.concat([50, 60, 70])
console.log(arr1, arr) // [10, 20, 30, 40, 50, 60, 70] [10, 20, 30, 40]
// map
const arr = [10, 20, 30, 40]
const arr1 = arr.map(item => item * 10)
console.log(arr1, arr) // [100, 200, 300, 400] [10, 20, 30, 40]
// filter
const arr = [10, 20, 30, 40]
const arr1 = arr.filter(item => item > 25)
console.log(arr1, arr) // [30, 40] [10, 20, 30, 40]
// slice
const arr = [10, 20, 30, 40]
const arr1 = arr.slice()
console.log(arr1, arr) // [10, 20, 30, 40] [10, 20, 30, 40]
// 非纯函数数组api：pop push unshift shift forEach some every reduce
// 数组slice和splice的区别 
// 1.功能区别：slice是切片，一片一片的这样切。splice是剪接，剪完之后再给你接上。
// 2.参数和返回值
// 3.是否是纯函数
// 4.演示
// 1.slice 纯函数
const arr = [10, 20, 30, 40, 50]
const arr1 = arr.slice()     // slice如果不传参数的话，它相当于把这个数组整个的拷贝一份然后复制到一个新的数组中。
const arr1 = arr.slice(1, 4) // [20, 30, 40]  截取区间
const arr1 = arr.slice(2)    // [30, 40, 50]  截取到最后
const arr1 = arr.slice(0, 2) // [10, 20, 30]  截取前几位
const arr1 = arr.slice(-3)   // [30, 40, 50]  截取后几位
// 2.splice 非纯函数
const arr = [10, 20, 30, 40, 50]
const spliceRes = arr.splice(1, 2, 'a', 'b', 'c')
const spliceRes1 = arr.splice(1, 2)
const spliceRes2 = arr.splice(1, 0, 'a', 'b', 'c')
const spliceRes3 = arr.splice(1)
console.log(spliceRes, arr)  // [20, 30] [10, 'a', 'b', 'c', 40, 50]    剪切出来，再添上
console.log(spliceRes1, arr) // [20, 30] [10, 40, 50]                   只想剪切，不想添
console.log(spliceRes2, arr) // [] [10, 'a', 'b', 'c', 20, 30, 40, 50]  只想增加，不想剪切
console.log(spliceRes3, arr) // [20, 30, 40, 50] [10]                   剪切到最后
```

##### document load 和 ready 的区别

##### new Object() 和 Object.create() 有什么区别

```js
// 1.{}等同于new Object()，原型都是Object.prototype
// 2.Object.create(null)，必须传一个参数，可以是一个对象也可以是null，如果传的是null就是一个空对象。传入null就是没有原型。传入对象就是指定原型。也就是Object.create()是创建一个空对象，然后把空对象的原型指定为传入的这个对象上。
  const obj1 = {
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  }
  const obj2 = new Object({
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj3 = new Object(obj1)
  console.log(obj1 === obj3)            // true
  const obj4 = Object.create(null)      // {}，但是没有原型
  const obj5 = new Object()             // {}，有原型
  const obj6 = Object.create({          // {}，原型就是传入的这个对象
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj7 = Object.create(obj1)      // 意思就是说我们通过obj1创建了obj6，通过create方式来创建的。
  console.log(obj6.__proto__ === obj1)  // true
  console.log(obj6 === obj1)            // false
  console.log(obj1 === obj3)            // true 
```


##### 手写字符串trim方法，保证浏览器兼容性

```js
String.prototype.trim = function () {
  return this.replace(/^s+/, '').replace(/s+$/, '')
}
```


##### 如何捕获js程序中的异常

```js
// 1.手动捕获异常
这种方式用的比较常见，觉得哪个地方可能会风险比较高，那就用一个try catch给它包起来，然后有异常就输出
try {
  // todo
} catch (ex) {
  console.error(ex) // 手动捕获catch
} finally {
  // todo
}
// 2.自动捕获异常
// 一种兜底方案，比如说我们想要监听一下前端页面，已经上线了，我们做一个统计监听，我们看一下前端页面有没有什么js错误，一般我们第一种方式就是用上面的方式在该try catch的地方打上try catch，如果catch到我们就发一个统计打点，作为一个记录。第二种方式就是我们不可能每一行都用try catch。这样成本太高。我们只在一个高风险的地方用try catch，其他地方我们用一个window.onerror就可以了。它会自动捕获你程序中的一些问题。
window.onerror = function (message, source, lineNum, colNum, error) {
  // 报错信息 源码 行号 列号 错误栈
  // 第一，对跨域的js，如cdn，会告诉你错误了，但不会有详细的报错信息
  // 第二，对于压缩的js，还要配合sourceMap去反查到为压缩代码的行，列
}
//所以通过这两个方式来集合，你就能监听到页面上绝大部分的错误。
```


##### 获取当前页面 url 参数

```js
// 1.传统方式，查找location.search
function query (name) {
  const search = location.search.substr(1)
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
  const res = search.match(reg)
  if (res == null) {
    return null
  }
  return res[2]
}
// 2.新api，URLSearchParams
function query (name) {
  const search = location.search
  const p = new URLSearchParams(search)
  return p.get(name)
}
```


##### 数组去重

```js
// 1.传统方式，遍历元素挨个比较，去重
function unique (arr) {
  const res = []
  arr.forEach(item => {
    if (res.indexOf(item) < 0) {
      res.push(item)
    }
  })
  return res
}
// 2.使用Set（无序，不能重复）
function unique (arr) {
  const set = new Set(arr)
  return [...set]
}
```

##### 前端性能优化

原则：多使用内存缓存，减少计算，减少网络请求
方向：加载页面要更快，页面渲染要更快，页面操作要更流畅

##### 封装组件

##### webpack 配置

##### promise

##### 前端性能优化

##### 优化 if else：switch case，map




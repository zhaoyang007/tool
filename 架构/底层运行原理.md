# babel

babel 插件手册：https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md

babel 核心插件：`@babel/core @babel/parser @babel/traverse @babel/types @babel/generator`

## 1.解析(Parse)

- **词法分析(Lexing)**: Babel 首先接收源代码，然后进行词法分析，将字符串形式的代码转换为令牌流tokens。从左置右逐个字符对源程序进行扫描，产生一个一个单词符号。

- **语法分析(Parsing)**: 接下来，通过语法分析，将令牌流转换为抽象语法树（AST）。AST 是一个深层的对象，以树的形式表示代码中的语法结构，它更详细地表示了程序的语法结构。

  - 在这一步，解析器使用上一步生成的令牌流来构建一个抽象语法树（AST）。

  - AST 是源代码的树形结构表示，其中每个节点代表一个特定的语法结构，如函数声明、变量声明或表达式。

  - 解析器按照 JavaScript 语法规则，使用预先定义的解析逻辑，从令牌流中识别出各种语法结构，并为这些结构创建对应的 AST 节点。

  - 这个过程是递归的。例如，解析一个函数声明时，解析器需要递归地解析函数体内的语句和表达式。

  - Babel 解析器的实现基于以下几个主要原则：

    - **递归下降解析**：Babel 使用递归下降解析技术。这是一种自顶向下的解析方法，其中**每个函数对应于一种语法规则**。
    - **错误恢复**：为了使 Babel 更加鲁棒，并能处理部分无效代码，Babel 的解析器实现了错误恢复机制。当解析器遇到无效代码时，它会尝试跳过该部分并继续解析，同时生成错误消息。
    - **插件系统**：Babel 支持许多 JavaScript 的语法扩展，如 JSX、TypeScript、Flow 以及各种新的 ECMAScript 提案。这些功能不是内置的，而是通过 Babel 的插件系统实现的。解析器可以动态地为这些插件加载额外的解析逻辑。带有syntax的插件，这些插件是解析时，帮助babel理解额外语法特性的插件，而不是转换阶段的插件。

  - 解析器原理简单示例

    ```js
    // 了说明递归下降解析器是如何工作的，我们将使用一个非常简单的算术表达式语法。这个语法将只包括加法、乘法和括号，以及整数。我们的目标是解析这样的表达式，并构建相应的抽象语法树（AST）。
    
    // 首先，我们定义我们的语法规则。对于这个例子，我们的语法可能如下所示：
    
    // 表达式 -> 项 (('+' | '-') 项)* (一个表达式是一个项，后面可以跟零个或多个 '+' 或 '-' 和另一个项)
    // 项 -> 因子 (('*' | '/') 因子)* (一个项是一个因子，后面可以跟零个或多个 '*' 或 '/' 和另一个因子)
    // 因子 -> 数字 | '(' 表达式 ')' (一个因子可以是一个数字或一个括号内的表达式)
    // 现在，我们可以为每个语法规则编写一个解析函数。以下是使用 JavaScript 编写的代码示例：
    function isDigit(ch) {
      return /\d/.test(ch);
    }
    
    function isOperator(ch) {
      return /\+|-|\*|\//.test(ch);
    }
    
    function tokenizer(input) {
      let current = 0;
      let tokens = [];
    
      while (current < input.length) {
        let char = input[current];
    
        if (isDigit(char)) {
          let value = '';
    
          while (isDigit(char)) {
            value += char;
            char = input[++current];
          }
    
          tokens.push({ type: 'number', value });
          continue;
        }
    
        if (isOperator(char)) {
          tokens.push({ type: 'operator', value: char });
          current++;
          continue;
        }
    
        if (char === '(' || char === ')') {
          tokens.push({ type: 'paren', value: char });
          current++;
          continue;
        }
    
        current++;
      }
    
      return tokens;
    }
    
    function parseExpression(tokens) {
      // 解析第一个项
      let firstTerm = parseTerm(tokens);
    
      let body = [firstTerm];
    
      // 当我们有更多的项时（通过 '+' 或 '-' 分隔）
      while (tokens[0] && (tokens[0].value === '+' || tokens[0].value === '-')) {
        let operator = tokens.shift().value;
        let nextTerm = parseTerm(tokens);
        body.push({ type: 'operator', value: operator }, nextTerm);
      }
    
      return { type: 'expression', body };
    }
    
    function parseTerm(tokens) {
      // 解析第一个因子
      let firstFactor = parseFactor(tokens);
    
      let body = [firstFactor];
    
      // 当我们有更多的因子时（通过 '*' 或 '/' 分隔）
      while (tokens[0] && (tokens[0].value === '*' || tokens[0].value === '/')) {
        let operator = tokens.shift().value;
        let nextFactor = parseFactor(tokens);
        body.push({ type: 'operator', value: operator }, nextFactor);
      }
    
      return { type: 'term', body };
    }
    
    function parseFactor(tokens) {
      let token = tokens.shift();
    
      if (token.type === 'number') {
        return { type: 'number', value: token.value };
      } else if (token.value === '(') {
        let expr = parseExpression(tokens);
    
        if (tokens.shift().value !== ')') {
          throw new SyntaxError();
        }
    
        return expr;
      } else {
        throw new SyntaxError();
      }
    }
    
    function parse(input) {
      let tokens = tokenizer(input);
      return parseExpression(tokens);
    }
    
    // 使用解析器
    const ast = parse('3 + (4 * 5)');
    console.log(ast);
    console.log(JSON.stringify(ast, null, 2));
    ```

## 2.转换(Transform)

这一步，Babel接收到AST并进行遍历，在遍历的同时，使用各种插件和预设，修改AST节点，从而转换成成新的AST。

1. **使用插件和预设**:
   - Babel 的转换过程依赖于插件和预设。插件通常是定义如何转换代码的函数。预设是一组插件，允许你用预先设定的设置一次性使用多个插件。
   - 当你使用 Babel 时，你可以在 Babel 配置文件（例如 `.babelrc` 或 `babel.config.js`）中指定要使用的插件和预设。
2. **遍历 AST**:
   - 转换步骤开始于对 AST 的深度优先遍历。Babel 读取之前解析步骤生成的 AST，并遍历所有的节点。
   - 遍历是通过访问者（visitor）模式完成的。每个插件都可以定义访问者，当遍历到特定类型的 AST 节点时，就会调用这些访问者。
3. **应用转换**:
   - 在遍历过程中，当到达由插件定义的特定类型的节点时，插件会应用各种转换。这些转换可能包括添加、更新或删除节点。
   - 例如，一个将 ES6 箭头函数转换为普通函数的插件会在遍历到箭头函数节点时，修改该节点及其子节点，使其符合普通函数的结构。
4. **生成新的 AST**:
   - 在转换过程中，原始的 AST 会根据定义的转换被修改。通常，Babel 会尽量复用 AST 的大部分结构，但在某些情况下，可能会生成全新的节点。
   - 最终结果是一个更新后的 AST，它反映了所有插件应用的转换。
5. **代码生成**:
   - 尽管代码生成通常被认为是编译过程的最后一步，但它实际上是转换过程的一部分。一旦 AST 被转换，Babel 会将它转换回代码，这可能包括源码映射（sourcemaps）的生成，这些映射关联了输出代码和原始代码之间的对应关系。
   - Babel 包含一个代码生成器，它会遍历更新后的 AST，并根据树中的节点创建字符串形式的代码。

## 3.生成(Generate)

- **代码生成(Code Generation)**: 一旦 AST 被转换，Babel 将进入代码生成阶段。在这一步，修改后的 AST 被转换回字符串形式的代码。这个过程可能会生成与原始代码完全不同的代码，特别是当你使用了一些高级转换或语言扩展时。
- **源码映射(Source Maps)**: Babel 还可以生成源码映射（source maps）。这些是特殊的文件，允许开发环境像调试转换前的代码一样调试转换后的代码。

## 4.babel各个阶段的产出

### 1.代码示例

`plugin-transform-arrow-functions` 声明式函数转箭头函数的babel插件

```js
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption;
  api.assertVersion(7);
  const noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : !options.spec;
  return {
    name: "transform-arrow-functions",
    visitor: {
      ArrowFunctionExpression(path) {
        if (!path.isArrowFunctionExpression()) return;
        {
          path.arrowFunctionToExpression({
            allowInsertArrow: false,
            noNewArrows: true,
            specCompliant: !noNewArrows
          });
        }
      }
    }
  };
});
exports.default = _default;

//# sourceMappingURL=index.js.map
```

`转换过程代码示例`

```js
const parser = require("@babel/parser");
const traverse = require("@babel/traverse").default;
const generator = require("@babel/generator").default;
const util = require('util');

// 原始代码
const inputCode = `
const add = (a, b) => a + b;
`;

// 1.解析
// 将输入代码解析为 AST
const ast = parser.parse(inputCode, {
  sourceType: "module",
  tokens: true
});
console.log('词法分析后生成的tokens', util.inspect(ast.tokens, { showHidden: false, depth: null, colors: true }));
console.log('语法分析后生成的ast', util.inspect(ast, { showHidden: false, depth: null, colors: true }));

// 2.转换
// 创建插件实例并传递 api 和 options 参数
const plugin = require("@babel/plugin-transform-arrow-functions").default({
  assertVersion: () => true,
  // assumption: () => null,
}, {
  spec: true  // 这是你想传递给插件的 options 对象
});

// 获取插件实例的 visitor 对象
const { visitor } = plugin;

// 使用 @babel/traverse 遍历和转换 AST
traverse(ast, visitor);

console.log('转换后生成的ast', util.inspect(ast, { showHidden: false, depth: null, colors: true }));

// 3.生成
// 使用 @babel/generator 生成转换后的代码
const output = generator(ast, {}, inputCode);

// 输出转换后的代码
console.log('生成的目标代码', output.code);
```

### 2.词法分析后生成的tokens

```js
[{
  type: [ExportedTokenType], // 令牌类型
  value: const,          // 令牌的文本值
  start: 11,                 // 令牌在源代码中的开始位置
  end: 11,                   // 令牌在源代码中的结束位置
  loc: [SourceLocation]      // 令牌在源文件中位置的信息
}]

[
  Token {
    type: ExportedTokenType {
      label: 'const',
      keyword: 'const',
      beforeExpr: false,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'const',
    start: 1,
    end: 6,
    loc: SourceLocation {
      start: Position { line: 2, column: 0, index: 1 },
      end: Position { line: 2, column: 5, index: 6 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'add',
    start: 7,
    end: 10,
    loc: SourceLocation {
      start: Position { line: 2, column: 6, index: 7 },
      end: Position { line: 2, column: 9, index: 10 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '=',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: true,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: '=',
    start: 11,
    end: 12,
    loc: SourceLocation {
      start: Position { line: 2, column: 10, index: 11 },
      end: Position { line: 2, column: 11, index: 12 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '(',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 13,
    end: 14,
    loc: SourceLocation {
      start: Position { line: 2, column: 12, index: 13 },
      end: Position { line: 2, column: 13, index: 14 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'a',
    start: 14,
    end: 15,
    loc: SourceLocation {
      start: Position { line: 2, column: 13, index: 14 },
      end: Position { line: 2, column: 14, index: 15 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: ',',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 15,
    end: 16,
    loc: SourceLocation {
      start: Position { line: 2, column: 14, index: 15 },
      end: Position { line: 2, column: 15, index: 16 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'b',
    start: 17,
    end: 18,
    loc: SourceLocation {
      start: Position { line: 2, column: 16, index: 17 },
      end: Position { line: 2, column: 17, index: 18 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: ')',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 18,
    end: 19,
    loc: SourceLocation {
      start: Position { line: 2, column: 17, index: 18 },
      end: Position { line: 2, column: 18, index: 19 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '=>',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 20,
    end: 22,
    loc: SourceLocation {
      start: Position { line: 2, column: 19, index: 20 },
      end: Position { line: 2, column: 21, index: 22 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'a',
    start: 23,
    end: 24,
    loc: SourceLocation {
      start: Position { line: 2, column: 22, index: 23 },
      end: Position { line: 2, column: 23, index: 24 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '+/-',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: true,
      postfix: false,
      binop: 9,
      updateContext: null
    },
    value: '+',
    start: 25,
    end: 26,
    loc: SourceLocation {
      start: Position { line: 2, column: 24, index: 25 },
      end: Position { line: 2, column: 25, index: 26 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'b',
    start: 27,
    end: 28,
    loc: SourceLocation {
      start: Position { line: 2, column: 26, index: 27 },
      end: Position { line: 2, column: 27, index: 28 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: ';',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 28,
    end: 29,
    loc: SourceLocation {
      start: Position { line: 2, column: 27, index: 28 },
      end: Position { line: 2, column: 28, index: 29 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'eof',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 30,
    end: 30,
    loc: SourceLocation {
      start: Position { line: 3, column: 0, index: 30 },
      end: Position { line: 3, column: 0, index: 30 },
      filename: undefined,
      identifierName: undefined
    }
  }
]
```

### 3.语法分析后生成的ast

```js
Node {
  type: 'File',
  start: 0,
  end: 30,
  loc: SourceLocation {
    start: Position { line: 1, column: 0, index: 0 },
    end: Position { line: 3, column: 0, index: 30 },
    filename: undefined,
    identifierName: undefined
  },
  errors: [],
  program: Node {
    type: 'Program',
    start: 0,
    end: 30,
    loc: SourceLocation {
      start: Position { line: 1, column: 0, index: 0 },
      end: Position { line: 3, column: 0, index: 30 },
      filename: undefined,
      identifierName: undefined
    },
    sourceType: 'module',
    interpreter: null,
    body: [
      Node {
        type: 'VariableDeclaration',
        start: 1,
        end: 29,
        loc: SourceLocation {
          start: Position { line: 2, column: 0, index: 1 },
          end: Position { line: 2, column: 28, index: 29 },
          filename: undefined,
          identifierName: undefined
        },
        declarations: [
          Node {
            type: 'VariableDeclarator',
            start: 7,
            end: 28,
            loc: SourceLocation {
              start: Position { line: 2, column: 6, index: 7 },
              end: Position { line: 2, column: 27, index: 28 },
              filename: undefined,
              identifierName: undefined
            },
            id: Node {
              type: 'Identifier',
              start: 7,
              end: 10,
              loc: SourceLocation {
                start: Position { line: 2, column: 6, index: 7 },
                end: Position { line: 2, column: 9, index: 10 },
                filename: undefined,
                identifierName: 'add'
              },
              name: 'add'
            },
            init: Node {
              type: 'ArrowFunctionExpression',
              start: 13,
              end: 28,
              loc: SourceLocation {
                start: Position { line: 2, column: 12, index: 13 },
                end: Position { line: 2, column: 27, index: 28 },
                filename: undefined,
                identifierName: undefined
              },
              id: null,
              generator: false,
              async: false,
              params: [
                Node {
                  type: 'Identifier',
                  start: 14,
                  end: 15,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 13, index: 14 },
                    end: Position { line: 2, column: 14, index: 15 },
                    filename: undefined,
                    identifierName: 'a'
                  },
                  name: 'a'
                },
                Node {
                  type: 'Identifier',
                  start: 17,
                  end: 18,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 16, index: 17 },
                    end: Position { line: 2, column: 17, index: 18 },
                    filename: undefined,
                    identifierName: 'b'
                  },
                  name: 'b'
                }
              ],
              body: Node {
                type: 'BinaryExpression',
                start: 23,
                end: 28,
                loc: SourceLocation {
                  start: Position { line: 2, column: 22, index: 23 },
                  end: Position { line: 2, column: 27, index: 28 },
                  filename: undefined,
                  identifierName: undefined
                },
                left: Node {
                  type: 'Identifier',
                  start: 23,
                  end: 24,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 22, index: 23 },
                    end: Position { line: 2, column: 23, index: 24 },
                    filename: undefined,
                    identifierName: 'a'
                  },
                  name: 'a'
                },
                operator: '+',
                right: Node {
                  type: 'Identifier',
                  start: 27,
                  end: 28,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 26, index: 27 },
                    end: Position { line: 2, column: 27, index: 28 },
                    filename: undefined,
                    identifierName: 'b'
                  },
                  name: 'b'
                }
              }
            }
          }
        ],
        kind: 'const'
      }
    ],
    directives: []
  },
  comments: []
}
```

### 4.转换后生成的ast

```js
Node {
  type: 'File',
  start: 0,
  end: 30,
  loc: SourceLocation {
    start: Position { line: 1, column: 0, index: 0 },
    end: Position { line: 3, column: 0, index: 30 },
    filename: undefined,
    identifierName: undefined
  },
  errors: [],
  program: Node {
    type: 'Program',
    start: 0,
    end: 30,
    loc: SourceLocation {
      start: Position { line: 1, column: 0, index: 0 },
      end: Position { line: 3, column: 0, index: 30 },
      filename: undefined,
      identifierName: undefined
    },
    sourceType: 'module',
    interpreter: null,
    body: [
      Node {
        type: 'VariableDeclaration',
        start: 1,
        end: 29,
        loc: SourceLocation {
          start: Position { line: 2, column: 0, index: 1 },
          end: Position { line: 2, column: 28, index: 29 },
          filename: undefined,
          identifierName: undefined
        },
        declarations: [
          Node {
            type: 'VariableDeclarator',
            start: 7,
            end: 28,
            loc: SourceLocation {
              start: Position { line: 2, column: 6, index: 7 },
              end: Position { line: 2, column: 27, index: 28 },
              filename: undefined,
              identifierName: undefined
            },
            id: Node {
              type: 'Identifier',
              start: 7,
              end: 10,
              loc: SourceLocation {
                start: Position { line: 2, column: 6, index: 7 },
                end: Position { line: 2, column: 9, index: 10 },
                filename: undefined,
                identifierName: 'add'
              },
              name: 'add'
            },
            init: Node {
              type: 'FunctionExpression',
              start: 13,
              end: 28,
              loc: SourceLocation {
                start: Position { line: 2, column: 12, index: 13 },
                end: Position { line: 2, column: 27, index: 28 },
                filename: undefined,
                identifierName: undefined
              },
              id: null,
              generator: false,
              async: false,
              params: [
                Node {
                  type: 'Identifier',
                  start: 14,
                  end: 15,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 13, index: 14 },
                    end: Position { line: 2, column: 14, index: 15 },
                    filename: undefined,
                    identifierName: 'a'
                  },
                  name: 'a'
                },
                Node {
                  type: 'Identifier',
                  start: 17,
                  end: 18,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 16, index: 17 },
                    end: Position { line: 2, column: 17, index: 18 },
                    filename: undefined,
                    identifierName: 'b'
                  },
                  name: 'b'
                }
              ],
              body: {
                type: 'BlockStatement',
                body: [
                  {
                    type: 'ReturnStatement',
                    argument: Node {
                      type: 'BinaryExpression',
                      start: 23,
                      end: 28,
                      loc: SourceLocation {
                        start: Position { line: 2, column: 22, index: 23 },
                        end: Position { line: 2, column: 27, index: 28 },
                        filename: undefined,
                        identifierName: undefined
                      },
                      left: Node {
                        type: 'Identifier',
                        start: 23,
                        end: 24,
                        loc: SourceLocation {
                          start: Position { line: 2, column: 22, index: 23 },
                          end: Position { line: 2, column: 23, index: 24 },
                          filename: undefined,
                          identifierName: 'a'
                        },
                        name: 'a'
                      },
                      operator: '+',
                      right: Node {
                        type: 'Identifier',
                        start: 27,
                        end: 28,
                        loc: SourceLocation {
                          start: Position { line: 2, column: 26, index: 27 },
                          end: Position { line: 2, column: 27, index: 28 },
                          filename: undefined,
                          identifierName: 'b'
                        },
                        name: 'b'
                      }
                    }
                  }
                ],
                directives: []
              }
            }
          }
        ],
        kind: 'const'
      }
    ],
    directives: []
  },
  comments: []
}
```

### 5.输出转换后的代码

```js
const add = function (a, b) {
  return a + b;
};
```

## 5.编写babel插件

# webpack

## webpack源码调试：

1. 运行创建webpack项目命令`npx webpack init`
2. 手动创建要打包的资源
3. 运行打包命令 `npx webpack build --config ./webpack.config.js`

## 1.模块加载原理

1. 文件静态分析：
   1. fs读取文件内容
   2. 使用babel将文件内容转换成ast
   3. 使用babel中转换ast的功能，遇到import语法，收集到依赖的模块路径数组
   4. 使用babel将ast转换成代码，并将esm模块转换成commonjs模块
   5. 返回对象，该对象内容包含：文件id 文件名 依赖的路径数组 转换后的文件代码

2. 构建依赖图：
   1. 使用循环递归的方式，将所有文件依次收集到依赖图数组中。
   2. 并记录该文件的依赖的相对路径和id的映射关系

3. 生成打包后代码：
   1. 遍历依赖图，拼接文件id与代码及其依赖的映射关系
   2. 构建自执行函数，传入上一步拼接好的映射
   3. 构建require函数, 从入口文件代码开始执行。require函数中执行文件代码，并传入require module exports保证文件代码正常运行。（[模块封装器](https://www.nodejs.com.cn/api/modules.html#the-module-wrapper)）


代码示例：minipack.js

```js
const fs = require('fs');
const path = require('path');
const babylon = require('babylon');
const traverse = require('babel-traverse').default;
const {transformFromAst} = require('babel-core');

let ID = 0;

// 1.根据文件路径 => 得到该文件的id 文件名 依赖的路径 文件代码
function createAsset(filename) {
  const content = fs.readFileSync(filename, 'utf-8');

  const ast = babylon.parse(content, {
    sourceType: 'module',
  });

  const dependencies = [];

  traverse(ast, {
    ImportDeclaration: ({node}) => {
      dependencies.push(node.source.value);
    },
  });

  const id = ID++;

  const {code} = transformFromAst(ast, null, {
    presets: ['env'],
  });

  return {
    id,
    filename,
    dependencies,
    code,
  };
}

// 2.构建依赖图
function createGraph(entry) {
  const mainAsset = createAsset(entry);

  const queue = [mainAsset];

  for (const asset of queue) {
    asset.mapping = {};

    const dirname = path.dirname(asset.filename);

    asset.dependencies.forEach(relativePath => {
      const absolutePath = path.join(dirname, relativePath);

      const child = createAsset(absolutePath);

      asset.mapping[relativePath] = child.id;

      queue.push(child);
    });
  }

  return queue;
}

// 3.遍历依赖图，生成打包后代码
function bundle(graph) {
  let modules = '';

  graph.forEach(mod => {
    modules += `${mod.id}: [
      function (require, module, exports) {
        ${mod.code}
      },
      ${JSON.stringify(mod.mapping)},
    ],`;
  });

  const result = `
    (function(modules) {
      function require(id) {
        const [fn, mapping] = modules[id];

        function localRequire(name) {
          return require(mapping[name]);
        }

        const module = { exports : {} };

        fn(localRequire, module, module.exports);

        return module.exports;
      }

      require(0);
    })({${modules}})
  `;

  return result;
}

const graph = createGraph('./example/entry.js');
const result = bundle(graph);

console.log(result);
```

## 2.打包运行原理

1. webpack 命令启动过程：
   1. 安装了 webpack 这个包之后，package.json bin 字段里面注册了一个 webpack 命令，npm 会据此在 node_modules/.bin 下会生成一个 webpack 命令。
   2. webpack 命令的作用就是判断用户是否安装了 webpack-cli 这个包，没安装的话会提示安装，然后引入 webpack-cli 这个包并执行。

2. webpack-cli 脚手架：

   将命令行和 webpack.config.js 的配置解析组装成 webpack 可识别的配置，再加载 webpack 并将配置传入，开始编译。

   run() => runWebpack() => createCompiler() => webpack() => loadWebpack() => tryRequireThenImport()

3. webpack 编译和构建流程：

* webpack(options) 
  * create()
    * compiler = createCompiler(webpackOptions)
      * compiler = new Compiler(options) 实例化compiler，传入webpack配置
        * 注册全部Compiler hook
      * **注册用户配置中所有的插件(plugins)**。
      * **根据配置执行 webpack 内部的插件**
        * 其中一个跟编译过程有关的插件WorkerPlugin会执行，WorkerPlugin中又会执行parserPlugin，用于编译过程中的依赖收集。
      * 执行compiler上的一些hooks
  * compiler.run()
    * onCompiled: 编译完成的回调，里面会调用**生成文件资源**的方法
      * compiler.emitAssets(compilation)
        * compiler.hooks.done.callAsync()
          * compiler.hooks.additionalPass.callAsync() 特殊情况需要再进行一次额外的构建时的钩子
            * compiler.compile(onCompiled)
    * compiler.hooks.beforeRun.callAsync()
      * compiler.hooks.run.callAsync()
        * compiler.compile(onCompiled)
          * params = compiler.newCompilationParams()
            * compiler.createNormalModuleFactory() 
              * **依赖解析**：当 Webpack 解析一个具体的文件路径时，例如一个具体的 `import` 或 `require` 语句指向的文件，`NormalModuleFactory` 会被用来处理这个文件。在处理模块时，`NormalModuleFactory` 也会解析模块的依赖关系。这包括分析模块中的 `import` 和 `require` 语句，以确定模块依赖哪些其他模块。
              * **解析文件对应的加载器（loaders）和加载器配置及其路径**：它会应用相应的加载器（**loaders**）来处理文件，并将文件转换为 Webpack 可以进一步处理的模块，**模块信息**包含了模块的路径、解析后的源代码、依赖信息、错误和警告信息、模块的元数据等。这些信息对于后续的编译步骤非常重要。
              * `NormalModuleFactory` 的主要职责是基于请求创建 `NormalModule` 实例。它处理模块的初始化和配置，包括决定哪些加载器（loaders）应该应用于特定的模块。
              * 实际上运行这些加载器（loaders）的过程发生在 `NormalModule` 实例的 `build` 方法中。
            * compiler.createContextModuleFactory() 
              * 当遇到动态依赖时，例如使用变量进行 `require` 调用（如 `require('./locale/' + name + '.json')`），`ContextModuleFactory` 会被使用。
              * 它负责分析这种动态请求的上下文信息，并生成一个上下文模块，该模块包含了所有可能的依赖项。
              * 上下文模块使得 Webpack 能够在打包时包含所有可能的依赖文件，即使它们是在运行时才确定的。
            * 总的来说，这两个工厂类根据不同类型的模块请求来创建相应类型的模块实例。`NormalModuleFactory` 处理静态明确的模块请求，而 `ContextModuleFactory` 处理更复杂的、动态确定的模块请求。通过这种方式，Webpack 能够有效地处理各种类型的模块依赖，无论它们是静态的还是动态的。
          * compiler.hooks.beforeCompile.callAsync(params)
            * compiler.hooks.compile.call(params)
            * 实例化 compilation = compiler.newCompilation(params) 
              * compiler.createCompilation(params)
                * new Compilation(compiler, params)
                  * 注册所有Compilation hook
                  * new AsyncQueue({ processor: this._buildModule.bind(this) }) 该行代码做了如下两件事
                    * new AsyncQueue()
                      * _ensureProcessing() **构建依赖图（递归）**
                        * _startProcessing(entry) 从入口文件开始构建
                          * _processor(entry.item)：entry.item就是NormalModule，\_processor就是processor，也是下面的 \_buildModule 方法。构建的过程中使用loader解析资源。
                    * \_buildModule(module, callback) {} 方法定义
                      * module.build( , , , , callback)：module就是NormalModule，就是上面的entry.item
                        * _doBuild()
                          * runLoaders()：loader-runner 中**运行loader的方法**，构建得到源码内容。
                            * parser.parse(_ast)：再通过NormalModuleFactory中的parser解析依赖，并通过 ParserPlugins 添加依赖，将现有的ast或源代码内容编译生成抽象语法树**ast**或其他相关的解析数据。解析的同时，模块（及其解析结果）被添加到 `compilation` 对象的 `modules` 集合中。
                              * handleBuildDone()
                                * callback()
                                  * compilation.hooks.succeedModule.call(module)
            * compiler.hooks.make.callAsync(compilation)
              * compiler.hooks.finishMake.callAsync(compilation)
                * compilation.finish()
                  * compilation.seal()
                    * 分块（chunk）
                    * 代码优化
                    * 生成哈希
                    * 生成代码资源：codeGeneration()
                      * createModuleAssets()：将 modules 里的代码放到 compilation 对象的 assets 里面去
                    * compiler.hooks.afterCompile.callAsync()
                      * return onCompiled(null, compilation) 产出资源文件到目录

**？？？**每一步产出的资源是什么样子的 **？？？**

**打包运行原理总结**

1. webpack 命令启动过程：用户运行webapck命令，判断用户是否安装 webpack-cli，没安装的话会提示安装，然后引入 webpack-cli 这个包并执行。`node_modules/webpack/bin/webpack.js`
2. webpack-cli 脚手架：将命令行和 webpack.config.js 的配置解析组装成 webpack 可识别的配置，再加载 webpack 并将配置传入，开始编译。`node_modules/webpack-cli/lib/webpack-cli.js`
3. webpack 编译和构建流程：
   1. 接收配置 `node_modules/webpack/lib/webpack.js`
   2. 创建compiler（compiler负责整个构建过程的生命周期和构建流程） `node_modules/webpack/lib/webpack.js`
      * 注册所有compiler hook `node_modules/webpack/lib/Compiler.js`
   3. **执行插件**（给插件传入compiler） `node_modules/webpack/lib/webpack.js`
      1. 根据配置的不同环境，执行webpack内部相应的插件
      2. 执行用户配置中所有的插件（plugins）
      3. 执行webpack内部的一些默认插件
   4. 开始编译 `node_modules/webpack/lib/Compiler.js`
      1. 生成各类模块 `node_modules/webpack/lib/NormalModuleFactory.js`
         1. 解析模块依赖关系
         2. 决定哪些加载器（loaders）应该应用于特定的模块
      2. 编译核心步骤：
         1. 创建compilation（compilation负责单次构建的具体构建工作） `node_modules/webpack/lib/Compiler.js`
            * 注册所有compilation hook  `node_modules/webpack/lib/Compilation.js`
         2. **运行loader**：解析文件，得到源码内容 `node_modules/webpack/lib/NormalModule.js`
         3. **解析AST**：将loader解析后的源码内容编译成ast或其他相关的解析数据 `node_modules/webpack/lib/NormalModule.js`
         4. **构建依赖图**：同时递归构建依赖图 `node_modules/webpack/lib/util/AsyncQueue.js`
         5. **收集模块到compilation.modules**：同时模块（及其解析结果）被添加到compilation对象的modules集合中 `node_modules/webpack/lib/Compilation.js`
   5. 编译结束 `node_modules/webpack/lib/Compilation.js`
      1. 分块（chunk）
      2. 代码优化
      3. 生成哈希
      4. 生成代码资源：将modules里的内容放到compilation.assets上面
   6.  产出文件资源  `node_modules/webpack/lib/Compiler.js`

## webpack vs vite

### Webpack

1. **打包方式**：Webpack 是一个模块打包器（bundler）。它通过递归地构建一个依赖图，包含应用程序中所需的每个模块，然后将所有这些模块打包成一个或多个 bundle（通常是 JavaScript 文件）。
2. **转译过程**：Webpack 使用 loader 来处理非 JavaScript 文件（如 CSS、图片、字体等），并且经常结合 Babel 一起使用以转译 JavaScript 代码（如将 ES6+ 转换为兼容旧浏览器的代码）。
3. **开发模式**：在开发模式下，Webpack 提供了热模块替换（Hot Module Replacement, HMR）等功能，但仍需要打包和服务整个应用，可能导致较慢的启动和热更新速度。
4. **优化和插件**：Webpack 提供了广泛的优化选项和插件系统，可以高度定制打包过程。

### Vite

1. **打包方式**：Vite 在开发模式下不使用传统的打包方法。它利用现代浏览器的原生 ES 模块支持，可以直接在浏览器中加载模块。这意味着启动速度更快，因为 Vite 只需为请求的文件进行转换和加载。
2. **转译过程**：Vite 在开发时使用 [esbuild](https://esbuild.github.io/) 进行 JavaScript 和 TypeScript 的快速转译。esbuild 使用 Go 编写，速度远快于基于 JavaScript 的传统工具。
3. **开发模式**：由于 Vite 在开发时不进行打包，它提供了极快的热更新速度和启动时间。
4. **生产构建**：尽管在开发模式下 Vite 不进行打包，但它在生产构建中使用 Rollup 进行高效的打包。Rollup 作为生产打包器，为最终部署提供了优化的包。
5. **优化和插件**：Vite 同样支持插件系统，但由于其不同的架构，插件的种类和用法可能与 Webpack 不同。

### 总结

- **Webpack** 适合于需要高度定制和优化的复杂项目，其生态系统成熟，提供了广泛的插件和加载器。
- **Vite** 侧重于快速的开发体验和简单的配置，特别适合于现代浏览器优先的项目和快速原型开发。

## webpack 优化

分析工具

* 速度分析：使用 speed-measure-webpack-plugin
* 体积分析：使用 webpack-bundle-analyzer

构建速度优化

* 使用高版本的 webpack 和 Node.js
* 缩小构建目标
* 优化文件查找路径
* 多进程构建
* 多进程压缩代码
* 利用缓存提升二次构建速度

体积优化

* 代码、图片压缩
* Tree Shaking
* Scope Hoisting
* Code Splitting
* 动态 import 加载异步组件
* 使用 cdn 静态资源
* 动态 polyfill

## webpack 热更新理

## webpack 原理

Tapable 为 webpack 插件提供了发布订阅的钩子。每个钩子代表一个关键的事件节点。

webpack 就是基于这种发布订阅的一系列的插件运行的事件流。

在 webpack 内部的 compiler 和 compilation 上面做 hooks 的调用。

插件有个 apply 方法，接收一个 compiler 参数。插件里面做 compiler 和 compilation 上的 hooks 的监听。

* 处理配置参数。
* 执行用户配置中的所有插件。
* 根据配置开启 webpack 内部的插件。
* 使用 loader-runner 运行 loaders 进行编译和分析依赖
* 将所有编译好的 js 代码放到 compilation 对象上的 modules 里面。
* 代码优化
* 将 modules 里的代码放到 compilation 对象的 assets 里面去
* 资源生成

## 手写一个 loader

loader

loader 是一个导出为声明式函数的 javascript 模块，接收资源返回资源：

```js
const loaderUtils = require("loader-utils");
module.exports = function(source) { 
  // 参数获取
  const { name } = loaderUtils.getOptions(this);
  
  // 异常处理
  // 1.throw new Error('Error');
  // 2.this.callback(new Error('Error'), source);
  
  // 返回结果
  // 1.return source;
  // 2.this.callback(null, source, 1, 2); 可以返回多个值
  
  // 异步处理
  const callback = this.async();
  fs.readFile(path.join(__dirname, './demo.txt'), 'utf-8', (err, data) => {
    if (err) {
      callback(err, '');
    }
    callback(null, data);
  });
  
  // 缓存
  // webpack 中默认开启缓存，可以使用以下方法关闭缓存
  // 缓存生效条件：loader 的结果有确定的输出。有依赖的 loader 无法使用缓存。
  this.cacheable(false);
  
  // 文件输出
  const url = loaderUtils.interpolateName(this, "[name].[ext]", source);
  this.emitFile(url, source);
};
```

## 手写一个 plugin

插件是一个类，有一个 apply 方法。

```js
// 将一段代码输出到文件里面就可以用 RawSource
const { RawSource } = require("webpack-sources"); 
class MyPlugin {
  constructor(options) { 
    this.options = options; 
  }
  apply(compiler) {
    // 插件处理逻辑
    
    // 插件的错误处理
    // 1.throw new Error('error');
    // 2.通过 compilation 对象的 warnings 和 errors 接收
    //   compilation.warnings.push("warning");
    //   compilation.errors.push("error");

    // 文件写入
    // webpack 的构建流程的文件生成是在 emit 阶段，所以在插件里监听 compiler emit 这个 hooks。
    // 监听这个 hook 之后我们可以获取到 compilation 对象
    // 然后只需要将最终要输出的内容设置到 compilation.assets 对象上面去就可以了
    // 最终webpack生成文件的时候会触发emit，然后读取compilation.assets上的资源内容并输出到磁盘目录
    const { path } = this.options;
    compiler.hooks.emit.tapAsync("MyPlugin", (compilation, callback) => { 
      compilation.assets[path] = new RawSource("demo"); 
      callback();
    }); 
  } 
}
module.exports = MyPlugin;
```

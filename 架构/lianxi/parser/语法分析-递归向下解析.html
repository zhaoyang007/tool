<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 了说明递归下降解析器是如何工作的，我们将使用一个非常简单的算术表达式语法。这个语法将只包括加法、乘法和括号，以及整数。我们的目标是解析这样的表达式，并构建相应的抽象语法树（AST）。

    // 首先，我们定义我们的语法规则。对于这个例子，我们的语法可能如下所示：

    // 表达式 -> 项 (('+' | '-') 项)* (一个表达式是一个项，后面可以跟零个或多个 '+' 或 '-' 和另一个项)
    // 项 -> 因子 (('*' | '/') 因子)* (一个项是一个因子，后面可以跟零个或多个 '*' 或 '/' 和另一个因子)
    // 因子 -> 数字 | '(' 表达式 ')' (一个因子可以是一个数字或一个括号内的表达式)
    // 现在，我们可以为每个语法规则编写一个解析函数。以下是使用 JavaScript 编写的代码示例：
    // function isDigit(ch) {
    //   return /\d/.test(ch);
    // }

    function isOperator(ch) {
      return /\+|-|\*|\//.test(ch);
    }

    function tokenizer(input) {
      let current = 0;
      let tokens = [];

      while (current < input.length) {
        let char = input[current];

        if (isDigit(char)) {
          let value = '';

          while (isDigit(char)) {
            value += char;
            char = input[++current];
          }

          tokens.push({ type: 'number', value });
          continue;
        }

        if (isOperator(char)) {
          tokens.push({ type: 'operator', value: char });
          current++;
          continue;
        }

        if (char === '(' || char === ')') {
          tokens.push({ type: 'paren', value: char });
          current++;
          continue;
        }

        current++;
      }

      return tokens;
    }

    function parseExpression(tokens) {
      // 解析第一个项
      let firstTerm = parseTerm(tokens);

      let body = [firstTerm];

      // 当我们有更多的项时（通过 '+' 或 '-' 分隔）
      while (tokens[0] && (tokens[0].value === '+' || tokens[0].value === '-')) {
        let operator = tokens.shift().value;
        let nextTerm = parseTerm(tokens);
        body.push({ type: 'operator', value: operator }, nextTerm);
      }

      return { type: 'expression', body };
    }

    function parseTerm(tokens) {
      // 解析第一个因子
      let firstFactor = parseFactor(tokens);

      let body = [firstFactor];

      // 当我们有更多的因子时（通过 '*' 或 '/' 分隔）
      while (tokens[0] && (tokens[0].value === '*' || tokens[0].value === '/')) {
        let operator = tokens.shift().value;
        let nextFactor = parseFactor(tokens);
        body.push({ type: 'operator', value: operator }, nextFactor);
      }

      return { type: 'term', body };
    }

    function parseFactor(tokens) {
      let token = tokens.shift();

      if (token.type === 'number') {
        return { type: 'number', value: token.value };
      } else if (token.value === '(') {
        let expr = parseExpression(tokens);

        if (tokens.shift().value !== ')') {
          throw new SyntaxError();
        }

        return expr;
      } else {
        throw new SyntaxError();
      }
    }

    function parse(input) {
      let tokens = tokenizer(input);
      return parseExpression(tokens);
    }

    // 使用解析器
    const ast = parse('3 + (4 * 5)');
    console.log(ast);
    console.log(JSON.stringify(ast, null, 2));
  </script>
</body>
</html>
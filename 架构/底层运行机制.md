# babel

babel 插件手册：https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md

babel 核心插件：`@babel/core @babel/parser @babel/traverse @babel/types @babel/generator`

## 1. 解析(Parse)

- **词法分析(Lexing)**: Babel 首先接收源代码，然后进行词法分析，将字符串形式的代码转换为令牌流tokens。从左置右逐个字符对源程序进行扫描，产生一个一个单词符号。

- **语法分析(Parsing)**: 接下来，通过语法分析，将令牌流转换为抽象语法树（AST）。AST 是一个深层的对象，以树的形式表示代码中的语法结构，它更详细地表示了程序的语法结构。

  - 在这一步，解析器使用上一步生成的令牌流来构建一个抽象语法树（AST）。

  - AST 是源代码的树形结构表示，其中每个节点代表一个特定的语法结构，如函数声明、变量声明或表达式。

  - 解析器按照 JavaScript 语法规则，使用预先定义的解析逻辑，从令牌流中识别出各种语法结构，并为这些结构创建对应的 AST 节点。

  - 这个过程是递归的。例如，解析一个函数声明时，解析器需要递归地解析函数体内的语句和表达式。

  - Babel 解析器的实现基于以下几个主要原则：

    - **递归下降解析**：Babel 使用递归下降解析技术。这是一种自顶向下的解析方法，其中**每个函数对应于一种语法规则**。
    - **错误恢复**：为了使 Babel 更加鲁棒，并能处理部分无效代码，Babel 的解析器实现了错误恢复机制。当解析器遇到无效代码时，它会尝试跳过该部分并继续解析，同时生成错误消息。
    - **插件系统**：Babel 支持许多 JavaScript 的语法扩展，如 JSX、TypeScript、Flow 以及各种新的 ECMAScript 提案。这些功能不是内置的，而是通过 Babel 的插件系统实现的。解析器可以动态地为这些插件加载额外的解析逻辑。带有syntax的插件，这些插件是解析时，帮助babel理解额外语法特性的插件，而不是转换阶段的插件。

  - 解析器原理简单示例

    ```js
    // 了说明递归下降解析器是如何工作的，我们将使用一个非常简单的算术表达式语法。这个语法将只包括加法、乘法和括号，以及整数。我们的目标是解析这样的表达式，并构建相应的抽象语法树（AST）。
    
    // 首先，我们定义我们的语法规则。对于这个例子，我们的语法可能如下所示：
    
    // 表达式 -> 项 (('+' | '-') 项)* (一个表达式是一个项，后面可以跟零个或多个 '+' 或 '-' 和另一个项)
    // 项 -> 因子 (('*' | '/') 因子)* (一个项是一个因子，后面可以跟零个或多个 '*' 或 '/' 和另一个因子)
    // 因子 -> 数字 | '(' 表达式 ')' (一个因子可以是一个数字或一个括号内的表达式)
    // 现在，我们可以为每个语法规则编写一个解析函数。以下是使用 JavaScript 编写的代码示例：
    function isDigit(ch) {
      return /\d/.test(ch);
    }
    
    function isOperator(ch) {
      return /\+|-|\*|\//.test(ch);
    }
    
    function tokenizer(input) {
      let current = 0;
      let tokens = [];
    
      while (current < input.length) {
        let char = input[current];
    
        if (isDigit(char)) {
          let value = '';
    
          while (isDigit(char)) {
            value += char;
            char = input[++current];
          }
    
          tokens.push({ type: 'number', value });
          continue;
        }
    
        if (isOperator(char)) {
          tokens.push({ type: 'operator', value: char });
          current++;
          continue;
        }
    
        if (char === '(' || char === ')') {
          tokens.push({ type: 'paren', value: char });
          current++;
          continue;
        }
    
        current++;
      }
    
      return tokens;
    }
    
    function parseExpression(tokens) {
      // 解析第一个项
      let firstTerm = parseTerm(tokens);
    
      let body = [firstTerm];
    
      // 当我们有更多的项时（通过 '+' 或 '-' 分隔）
      while (tokens[0] && (tokens[0].value === '+' || tokens[0].value === '-')) {
        let operator = tokens.shift().value;
        let nextTerm = parseTerm(tokens);
        body.push({ type: 'operator', value: operator }, nextTerm);
      }
    
      return { type: 'expression', body };
    }
    
    function parseTerm(tokens) {
      // 解析第一个因子
      let firstFactor = parseFactor(tokens);
    
      let body = [firstFactor];
    
      // 当我们有更多的因子时（通过 '*' 或 '/' 分隔）
      while (tokens[0] && (tokens[0].value === '*' || tokens[0].value === '/')) {
        let operator = tokens.shift().value;
        let nextFactor = parseFactor(tokens);
        body.push({ type: 'operator', value: operator }, nextFactor);
      }
    
      return { type: 'term', body };
    }
    
    function parseFactor(tokens) {
      let token = tokens.shift();
    
      if (token.type === 'number') {
        return { type: 'number', value: token.value };
      } else if (token.value === '(') {
        let expr = parseExpression(tokens);
    
        if (tokens.shift().value !== ')') {
          throw new SyntaxError();
        }
    
        return expr;
      } else {
        throw new SyntaxError();
      }
    }
    
    function parse(input) {
      let tokens = tokenizer(input);
      return parseExpression(tokens);
    }
    
    // 使用解析器
    const ast = parse('3 + (4 * 5)');
    console.log(ast);
    console.log(JSON.stringify(ast, null, 2));
    ```

## 2. 转换(Transform)

这一步，Babel接收到AST并进行遍历，在遍历的同时，使用各种插件和预设，修改AST节点，从而转换成成新的AST。

1. **使用插件和预设**:
   - Babel 的转换过程依赖于插件和预设。插件通常是定义如何转换代码的函数。预设是一组插件，允许你用预先设定的设置一次性使用多个插件。
   - 当你使用 Babel 时，你可以在 Babel 配置文件（例如 `.babelrc` 或 `babel.config.js`）中指定要使用的插件和预设。
2. **遍历 AST**:
   - 转换步骤开始于对 AST 的深度优先遍历。Babel 读取之前解析步骤生成的 AST，并遍历所有的节点。
   - 遍历是通过访问者（visitor）模式完成的。每个插件都可以定义访问者，当遍历到特定类型的 AST 节点时，就会调用这些访问者。
3. **应用转换**:
   - 在遍历过程中，当到达由插件定义的特定类型的节点时，插件会应用各种转换。这些转换可能包括添加、更新或删除节点。
   - 例如，一个将 ES6 箭头函数转换为普通函数的插件会在遍历到箭头函数节点时，修改该节点及其子节点，使其符合普通函数的结构。
4. **生成新的 AST**:
   - 在转换过程中，原始的 AST 会根据定义的转换被修改。通常，Babel 会尽量复用 AST 的大部分结构，但在某些情况下，可能会生成全新的节点。
   - 最终结果是一个更新后的 AST，它反映了所有插件应用的转换。
5. **代码生成**:
   - 尽管代码生成通常被认为是编译过程的最后一步，但它实际上是转换过程的一部分。一旦 AST 被转换，Babel 会将它转换回代码，这可能包括源码映射（sourcemaps）的生成，这些映射关联了输出代码和原始代码之间的对应关系。
   - Babel 包含一个代码生成器，它会遍历更新后的 AST，并根据树中的节点创建字符串形式的代码。

## 3.生成(Generate)

- **代码生成(Code Generation)**: 一旦 AST 被转换，Babel 将进入代码生成阶段。在这一步，修改后的 AST 被转换回字符串形式的代码。这个过程可能会生成与原始代码完全不同的代码，特别是当你使用了一些高级转换或语言扩展时。
- **源码映射(Source Maps)**: Babel 还可以生成源码映射（source maps）。这些是特殊的文件，允许开发环境像调试转换前的代码一样调试转换后的代码。

## 4.babel各个阶段的产出

### 1.代码示例

`plugin-transform-arrow-functions` 声明式函数转箭头函数的babel插件

```js
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption;
  api.assertVersion(7);
  const noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : !options.spec;
  return {
    name: "transform-arrow-functions",
    visitor: {
      ArrowFunctionExpression(path) {
        if (!path.isArrowFunctionExpression()) return;
        {
          path.arrowFunctionToExpression({
            allowInsertArrow: false,
            noNewArrows: true,
            specCompliant: !noNewArrows
          });
        }
      }
    }
  };
});
exports.default = _default;

//# sourceMappingURL=index.js.map
```

`转换过程代码示例`

```js
const parser = require("@babel/parser");
const traverse = require("@babel/traverse").default;
const generator = require("@babel/generator").default;
const util = require('util');

// 原始代码
const inputCode = `
const add = (a, b) => a + b;
`;

// 1.解析
// 将输入代码解析为 AST
const ast = parser.parse(inputCode, {
  sourceType: "module",
  tokens: true
});
console.log('词法分析后生成的tokens', util.inspect(ast.tokens, { showHidden: false, depth: null, colors: true }));
console.log('语法分析后生成的ast', util.inspect(ast, { showHidden: false, depth: null, colors: true }));

// 2.转换
// 创建插件实例并传递 api 和 options 参数
const plugin = require("@babel/plugin-transform-arrow-functions").default({
  assertVersion: () => true,
  // assumption: () => null,
}, {
  spec: true  // 这是你想传递给插件的 options 对象
});

// 获取插件实例的 visitor 对象
const { visitor } = plugin;

// 使用 @babel/traverse 遍历和转换 AST
traverse(ast, visitor);

console.log('转换后生成的ast', util.inspect(ast, { showHidden: false, depth: null, colors: true }));

// 3.生成
// 使用 @babel/generator 生成转换后的代码
const output = generator(ast, {}, inputCode);

// 输出转换后的代码
console.log('生成的目标代码', output.code);
```

### 2.词法分析后生成的tokens

```js
[{
  type: [ExportedTokenType], // 令牌类型
  value: const,          // 令牌的文本值
  start: 11,                 // 令牌在源代码中的开始位置
  end: 11,                   // 令牌在源代码中的结束位置
  loc: [SourceLocation]      // 令牌在源文件中位置的信息
}]

[
  Token {
    type: ExportedTokenType {
      label: 'const',
      keyword: 'const',
      beforeExpr: false,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'const',
    start: 1,
    end: 6,
    loc: SourceLocation {
      start: Position { line: 2, column: 0, index: 1 },
      end: Position { line: 2, column: 5, index: 6 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'add',
    start: 7,
    end: 10,
    loc: SourceLocation {
      start: Position { line: 2, column: 6, index: 7 },
      end: Position { line: 2, column: 9, index: 10 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '=',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: true,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: '=',
    start: 11,
    end: 12,
    loc: SourceLocation {
      start: Position { line: 2, column: 10, index: 11 },
      end: Position { line: 2, column: 11, index: 12 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '(',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 13,
    end: 14,
    loc: SourceLocation {
      start: Position { line: 2, column: 12, index: 13 },
      end: Position { line: 2, column: 13, index: 14 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'a',
    start: 14,
    end: 15,
    loc: SourceLocation {
      start: Position { line: 2, column: 13, index: 14 },
      end: Position { line: 2, column: 14, index: 15 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: ',',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 15,
    end: 16,
    loc: SourceLocation {
      start: Position { line: 2, column: 14, index: 15 },
      end: Position { line: 2, column: 15, index: 16 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'b',
    start: 17,
    end: 18,
    loc: SourceLocation {
      start: Position { line: 2, column: 16, index: 17 },
      end: Position { line: 2, column: 17, index: 18 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: ')',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 18,
    end: 19,
    loc: SourceLocation {
      start: Position { line: 2, column: 17, index: 18 },
      end: Position { line: 2, column: 18, index: 19 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '=>',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 20,
    end: 22,
    loc: SourceLocation {
      start: Position { line: 2, column: 19, index: 20 },
      end: Position { line: 2, column: 21, index: 22 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'a',
    start: 23,
    end: 24,
    loc: SourceLocation {
      start: Position { line: 2, column: 22, index: 23 },
      end: Position { line: 2, column: 23, index: 24 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '+/-',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: true,
      postfix: false,
      binop: 9,
      updateContext: null
    },
    value: '+',
    start: 25,
    end: 26,
    loc: SourceLocation {
      start: Position { line: 2, column: 24, index: 25 },
      end: Position { line: 2, column: 25, index: 26 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'b',
    start: 27,
    end: 28,
    loc: SourceLocation {
      start: Position { line: 2, column: 26, index: 27 },
      end: Position { line: 2, column: 27, index: 28 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: ';',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 28,
    end: 29,
    loc: SourceLocation {
      start: Position { line: 2, column: 27, index: 28 },
      end: Position { line: 2, column: 28, index: 29 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'eof',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 30,
    end: 30,
    loc: SourceLocation {
      start: Position { line: 3, column: 0, index: 30 },
      end: Position { line: 3, column: 0, index: 30 },
      filename: undefined,
      identifierName: undefined
    }
  }
]
```

### 3.语法分析后生成的ast

```js
Node {
  type: 'File',
  start: 0,
  end: 30,
  loc: SourceLocation {
    start: Position { line: 1, column: 0, index: 0 },
    end: Position { line: 3, column: 0, index: 30 },
    filename: undefined,
    identifierName: undefined
  },
  errors: [],
  program: Node {
    type: 'Program',
    start: 0,
    end: 30,
    loc: SourceLocation {
      start: Position { line: 1, column: 0, index: 0 },
      end: Position { line: 3, column: 0, index: 30 },
      filename: undefined,
      identifierName: undefined
    },
    sourceType: 'module',
    interpreter: null,
    body: [
      Node {
        type: 'VariableDeclaration',
        start: 1,
        end: 29,
        loc: SourceLocation {
          start: Position { line: 2, column: 0, index: 1 },
          end: Position { line: 2, column: 28, index: 29 },
          filename: undefined,
          identifierName: undefined
        },
        declarations: [
          Node {
            type: 'VariableDeclarator',
            start: 7,
            end: 28,
            loc: SourceLocation {
              start: Position { line: 2, column: 6, index: 7 },
              end: Position { line: 2, column: 27, index: 28 },
              filename: undefined,
              identifierName: undefined
            },
            id: Node {
              type: 'Identifier',
              start: 7,
              end: 10,
              loc: SourceLocation {
                start: Position { line: 2, column: 6, index: 7 },
                end: Position { line: 2, column: 9, index: 10 },
                filename: undefined,
                identifierName: 'add'
              },
              name: 'add'
            },
            init: Node {
              type: 'ArrowFunctionExpression',
              start: 13,
              end: 28,
              loc: SourceLocation {
                start: Position { line: 2, column: 12, index: 13 },
                end: Position { line: 2, column: 27, index: 28 },
                filename: undefined,
                identifierName: undefined
              },
              id: null,
              generator: false,
              async: false,
              params: [
                Node {
                  type: 'Identifier',
                  start: 14,
                  end: 15,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 13, index: 14 },
                    end: Position { line: 2, column: 14, index: 15 },
                    filename: undefined,
                    identifierName: 'a'
                  },
                  name: 'a'
                },
                Node {
                  type: 'Identifier',
                  start: 17,
                  end: 18,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 16, index: 17 },
                    end: Position { line: 2, column: 17, index: 18 },
                    filename: undefined,
                    identifierName: 'b'
                  },
                  name: 'b'
                }
              ],
              body: Node {
                type: 'BinaryExpression',
                start: 23,
                end: 28,
                loc: SourceLocation {
                  start: Position { line: 2, column: 22, index: 23 },
                  end: Position { line: 2, column: 27, index: 28 },
                  filename: undefined,
                  identifierName: undefined
                },
                left: Node {
                  type: 'Identifier',
                  start: 23,
                  end: 24,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 22, index: 23 },
                    end: Position { line: 2, column: 23, index: 24 },
                    filename: undefined,
                    identifierName: 'a'
                  },
                  name: 'a'
                },
                operator: '+',
                right: Node {
                  type: 'Identifier',
                  start: 27,
                  end: 28,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 26, index: 27 },
                    end: Position { line: 2, column: 27, index: 28 },
                    filename: undefined,
                    identifierName: 'b'
                  },
                  name: 'b'
                }
              }
            }
          }
        ],
        kind: 'const'
      }
    ],
    directives: []
  },
  comments: []
}
```

### 4.转换后生成的ast

```js
Node {
  type: 'File',
  start: 0,
  end: 30,
  loc: SourceLocation {
    start: Position { line: 1, column: 0, index: 0 },
    end: Position { line: 3, column: 0, index: 30 },
    filename: undefined,
    identifierName: undefined
  },
  errors: [],
  program: Node {
    type: 'Program',
    start: 0,
    end: 30,
    loc: SourceLocation {
      start: Position { line: 1, column: 0, index: 0 },
      end: Position { line: 3, column: 0, index: 30 },
      filename: undefined,
      identifierName: undefined
    },
    sourceType: 'module',
    interpreter: null,
    body: [
      Node {
        type: 'VariableDeclaration',
        start: 1,
        end: 29,
        loc: SourceLocation {
          start: Position { line: 2, column: 0, index: 1 },
          end: Position { line: 2, column: 28, index: 29 },
          filename: undefined,
          identifierName: undefined
        },
        declarations: [
          Node {
            type: 'VariableDeclarator',
            start: 7,
            end: 28,
            loc: SourceLocation {
              start: Position { line: 2, column: 6, index: 7 },
              end: Position { line: 2, column: 27, index: 28 },
              filename: undefined,
              identifierName: undefined
            },
            id: Node {
              type: 'Identifier',
              start: 7,
              end: 10,
              loc: SourceLocation {
                start: Position { line: 2, column: 6, index: 7 },
                end: Position { line: 2, column: 9, index: 10 },
                filename: undefined,
                identifierName: 'add'
              },
              name: 'add'
            },
            init: Node {
              type: 'FunctionExpression',
              start: 13,
              end: 28,
              loc: SourceLocation {
                start: Position { line: 2, column: 12, index: 13 },
                end: Position { line: 2, column: 27, index: 28 },
                filename: undefined,
                identifierName: undefined
              },
              id: null,
              generator: false,
              async: false,
              params: [
                Node {
                  type: 'Identifier',
                  start: 14,
                  end: 15,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 13, index: 14 },
                    end: Position { line: 2, column: 14, index: 15 },
                    filename: undefined,
                    identifierName: 'a'
                  },
                  name: 'a'
                },
                Node {
                  type: 'Identifier',
                  start: 17,
                  end: 18,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 16, index: 17 },
                    end: Position { line: 2, column: 17, index: 18 },
                    filename: undefined,
                    identifierName: 'b'
                  },
                  name: 'b'
                }
              ],
              body: {
                type: 'BlockStatement',
                body: [
                  {
                    type: 'ReturnStatement',
                    argument: Node {
                      type: 'BinaryExpression',
                      start: 23,
                      end: 28,
                      loc: SourceLocation {
                        start: Position { line: 2, column: 22, index: 23 },
                        end: Position { line: 2, column: 27, index: 28 },
                        filename: undefined,
                        identifierName: undefined
                      },
                      left: Node {
                        type: 'Identifier',
                        start: 23,
                        end: 24,
                        loc: SourceLocation {
                          start: Position { line: 2, column: 22, index: 23 },
                          end: Position { line: 2, column: 23, index: 24 },
                          filename: undefined,
                          identifierName: 'a'
                        },
                        name: 'a'
                      },
                      operator: '+',
                      right: Node {
                        type: 'Identifier',
                        start: 27,
                        end: 28,
                        loc: SourceLocation {
                          start: Position { line: 2, column: 26, index: 27 },
                          end: Position { line: 2, column: 27, index: 28 },
                          filename: undefined,
                          identifierName: 'b'
                        },
                        name: 'b'
                      }
                    }
                  }
                ],
                directives: []
              }
            }
          }
        ],
        kind: 'const'
      }
    ],
    directives: []
  },
  comments: []
}
```

### 5.输出转换后的代码

```js
const add = function (a, b) {
  return a + b;
};
```

## 5.编写babel插件

# webpack

## 1.模块加载原理

1. 文件静态分析：
   1. fs读取文件内容
   2. 使用babel将文件内容转换成ast
   3. 使用babel中转换ast的功能，遇到import语法，收集到依赖的模块路径数组
   4. 使用babel将ast转换成代码，并将esm模块转换成commonjs模块
   5. 返回对象，该对象内容包含：文件id 文件名 依赖的路径数组 转换后的文件代码

2. 构建依赖图：
   1. 使用循环递归的方式，将所有文件依次收集到依赖图数组中。
   2. 并记录该文件的依赖的相对路径和id的映射关系

3. 生成打包后代码：
   1. 遍历依赖图，拼接文件id与代码及其依赖的映射关系
   2. 构建自执行函数，传入上一步拼接好的映射
   3. 构建require函数, 从入口文件代码开始执行。require函数中执行文件代码，并闯入require module exports保证文件代码正常运行。


代码示例：minipack.js

```js
const fs = require('fs');
const path = require('path');
const babylon = require('babylon');
const traverse = require('babel-traverse').default;
const {transformFromAst} = require('babel-core');

let ID = 0;

// 1.根据文件路径 => 得到该文件的id 文件名 依赖的路径 文件代码
function createAsset(filename) {
  const content = fs.readFileSync(filename, 'utf-8');

  const ast = babylon.parse(content, {
    sourceType: 'module',
  });

  const dependencies = [];

  traverse(ast, {
    ImportDeclaration: ({node}) => {
      dependencies.push(node.source.value);
    },
  });

  const id = ID++;

  const {code} = transformFromAst(ast, null, {
    presets: ['env'],
  });

  return {
    id,
    filename,
    dependencies,
    code,
  };
}

// 2.构建依赖图
function createGraph(entry) {
  const mainAsset = createAsset(entry);

  const queue = [mainAsset];

  for (const asset of queue) {
    asset.mapping = {};

    const dirname = path.dirname(asset.filename);

    asset.dependencies.forEach(relativePath => {
      const absolutePath = path.join(dirname, relativePath);

      const child = createAsset(absolutePath);

      asset.mapping[relativePath] = child.id;

      queue.push(child);
    });
  }

  return queue;
}

// 3.遍历依赖图，生成打包后代码
function bundle(graph) {
  let modules = '';

  graph.forEach(mod => {
    modules += `${mod.id}: [
      function (require, module, exports) {
        ${mod.code}
      },
      ${JSON.stringify(mod.mapping)},
    ],`;
  });

  const result = `
    (function(modules) {
      function require(id) {
        const [fn, mapping] = modules[id];

        function localRequire(name) {
          return require(mapping[name]);
        }

        const module = { exports : {} };

        fn(localRequire, module, module.exports);

        return module.exports;
      }

      require(0);
    })({${modules}})
  `;

  return result;
}

const graph = createGraph('./example/entry.js');
const result = bundle(graph);

console.log(result);
```

## 2.打包运行原理

1. webpack 命令启动过程：
   1. 安装了 webpack 这个包之后，package.json bin 字段里面注册了一个 webpack 命令，npm 会据此在 node_modules/.bin 下会生成一个 webpack 命令。
   2. webpack 命令的作用就是判断用户是否安装了 webpack-cli 这个包，没安装的话会提示安装，然后引入 webpack-cli 这个包并执行。

2. webpack-cli 脚手架：

   将命令行和 webpack.config.js 的配置解析组装成 webpack 可识别的配置，再加载 webpack 并将配置传入，开始编译。

   run() => runWebpack() => createCompiler() => webpack() => loadWebpack() => tryRequireThenImport()

3. webpack 编译和构建流程：

* webpack(options) 
  * create()
    * compiler = createCompiler(webpackOptions)
      * compiler = new Compiler(options) 实例化compiler，传入webpack配置，注册全部Compiler hook，并调用一些 hook。
      * **注册用户配置中所有的插件(plugins)**。
      * **根据配置执行 webpack 内部的插件**。
  * compiler.run()
    * onCompiled: 编译完成的回调，里面会调用**文件生成**的方法
      * compiler.emitAssets(compilation)
        * compiler.hooks.done.callAsync()
          * compiler.hooks.additionalPass.callAsync() 特殊情况需要再进行一次额外的构建时的钩子
            * compiler.compile(onCompiled)
    * compiler.hooks.beforeRun.callAsync()
      * compiler.hooks.run.callAsync()
        * compiler.compile(onCompiled)
          * params = compiler.newCompilationParams()
            * compiler.createNormalModuleFactory() 
              * **依赖解析**：当 Webpack 解析一个具体的文件路径时，例如一个具体的 `import` 或 `require` 语句指向的文件，`NormalModuleFactory` 会被用来处理这个文件。在处理模块时，`NormalModuleFactory` 也会解析模块的依赖关系。这包括分析模块中的 `import` 和 `require` 语句，以确定模块依赖哪些其他模块。
              * **解析文件对应的加载器（loaders）和加载器配置及其路径**：它会应用相应的加载器（**loaders**）来处理文件，并将文件转换为 Webpack 可以进一步处理的模块，**模块信息**包含了模块的路径、解析后的源代码、依赖信息、错误和警告信息、模块的元数据等。这些信息对于后续的编译步骤非常重要。
              * `NormalModuleFactory` 的主要职责是基于请求创建 `NormalModule` 实例。它处理模块的初始化和配置，包括决定哪些加载器（loaders）应该应用于特定的模块。
              * 实际上运行这些加载器（loaders）的过程发生在 `NormalModule` 实例的 `build` 方法中。
            * compiler.createContextModuleFactory() 
              * 当遇到动态依赖时，例如使用变量进行 `require` 调用（如 `require('./locale/' + name + '.json')`），`ContextModuleFactory` 会被使用。
              * 它负责分析这种动态请求的上下文信息，并生成一个上下文模块，该模块包含了所有可能的依赖项。
              * 上下文模块使得 Webpack 能够在打包时包含所有可能的依赖文件，即使它们是在运行时才确定的。
            * 总的来说，这两个工厂类根据不同类型的模块请求来创建相应类型的模块实例。`NormalModuleFactory` 处理静态明确的模块请求，而 `ContextModuleFactory` 处理更复杂的、动态确定的模块请求。通过这种方式，Webpack 能够有效地处理各种类型的模块依赖，无论它们是静态的还是动态的。
          * compiler.hooks.beforeCompile.callAsync(params)
            * compiler.hooks.compile.call(params)
            * 实例化 compilation = compiler.newCompilation(params) 
              * compiler.createCompilation(params)
                * new Compilation(compiler, params)
                  * 注册所有Compilation hook
                  * new AsyncQueue({ processor: this._buildModule.bind(this) }) 该行代码做了如下两件事
                    * new AsyncQueue()
                      * _ensureProcessing() **构建依赖图**
                        * _startProcessing(entry) 从入口文件开始构建
                          * _processor(entry.item)：entry.item就是NormalModule，\_processor就是processor，也是下面的 \_buildModule 方法。构建的过程中使用loader解析资源。
                    * \_buildModule(module, callback) {} 方法定义
                      * module.build()：module就是NormalModule，就是上面的entry.item
                        * _doBuild()
                          * runLoaders()：loader-runner 中**运行loader的方法**，构建得到一个 js 代码
                            * 再将代码进行编译，**生成 ast**
                              * 在通过NormalModuleFactory中的parser将ast编译成最终的js代码，然后将这些代码放到compilation对象上的mudules中。
            *  compiler.hooks.make.callAsync(compilation)
              * compiler.hooks.finishMake.callAsync(compilation)
                * compilation.finish()
                  * compilation.seal()
                    * compiler.hooks.afterCompile.callAsync()
                      * return onCompiled(null, compilation)

* run：开始构建。

* complie：构建

  * 使用 loader-runner 运行 loaders，解析构建得到一个 js 代码，再将这个代码进行编译，生成 AST。
  * 然后通过 parser 解析依赖(acorn)，通过 ParserPlugins 添加依赖，将所有编译好的 js 代码放到 compilation 对象上的 modules 里面。

* 代码优化

  将 modules 里的代码放到 compilation 对象的 assets 里面去

* 资源生成

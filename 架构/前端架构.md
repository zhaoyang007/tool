##### 数据 mock

开发时，当后端的接口还未完成，前端为了不影响工作效率，手动模拟后端接口。在已有接口文档的情况下，我们可以直接按照接口文档来开发，将相应的字段写好，在接口完成 之后，只需要改变url地址即可。

本地 mock 的问题是需要了解 node，还有就是接口代码太多了。

线上 easy-mock：诸如 easy-mock 这类线上 mock 工具优点是使用简单，mock 工具库也比较强大，还能根据 swagger 规范生成接口。

方案一：使用开发服务器配置 before 选项，可以编写接口，提供模拟数据。

```js
// vue.config.js
module.exports = {
  devServer:{
    before(app) {
      // app是一个express的实例
      // 这里就可以在express实例的上面添加一些你想要模拟的接口
      app.get('/api/courses', (req, res) => {
        // 做一个json的返回，这里如果想做一些网络延迟的模拟，可以做个定时器。
        res.json([{ name: 'web全栈', price: 8999 }, { name: 'web高级', price:8999 }]);
      });
    }
  }
}
// 调用
import axios from 'axios';
export function getCourses() {
  return axios.get('/api/courses').then(res => res.data);
}
```

方案二：json-server

方案三：koa + mockjs 起本地 mock 服务器

1. 我们可以使用json文件来模拟后台数据，但比较局限，无法模拟数据的增删改查。

2. 使用json-server模拟，但不能随机生成所需数据

3. 使用 mockjs 模拟后端接口，可随机生成所需数据，可模拟对数据的增删改查。

##### 权限控制

页面权限：就是根据是否登录和用户角色信息来动态设置相应路由。

按钮权限。

导航菜单生成：导航菜单是根据路由信息并结合权限判断而动态生成的。它需要对应路由的多级嵌套，所以要用到递归组件。组件里面还使用了自己。

递归：自己里面调用自己，有条件跳出。

##### 请求封装

对 axios 做一次封装，统一处理配置，请求和响应拦截。

封装请求：src/utils/request.js

```js
import Axios from "axios";
import { MessageBox, Message } from "element-ui";
import store from "@/store";

// 创建axios实例
const axios = Axios.create({
  baseURL: process.env.VUE_APP_BASE_API, // url基础地址，解决不同数据源url变化问题。vue-cli3里提供了一个模式的东西，可以利用模式配置一批环境变量，它可以根据当前环境的动态的切换，解决我们请求时的url的变化的问题，在根目录下创建一个叫.env.development的文件，这个文件就是模式，默认有三种模式development,production,test 分别对应在package.json里面的dev,build,test这三个命令，可以在这个模式文件中定义环境变量。也可以在打包命令中使用--mode xxx结合.env.xxx模式文件，就可以使用该文件中的配置了，它就是一个环境变量的参数。
  // withCredentials: true, // 跨域时若要发送cookies需设置该选项
  timeout: 5000 // 超时
});

// 请求拦截，对请求头做一些处理，令牌的追加等
axios.interceptors.request.use(
  config => {
    // do something
    const token = localStorage.getItem('token')
    if (token) {
      // 设置令牌请求头
      config.headers["Authorization"] = 'Bearer ' + token;
    }
    return config;
  },
  error => {
    // 请求错误预处理
    //console.log(error) // for debug
    return Promise.reject(error);
  }
);

// 响应拦截，做一些错误处理
// 1.通过响应的状态判断请求成功与否，比如400,500
// 2.不管对错服务端都是以状态200返回，根据返回的code值判断请求是否成功
axios.interceptors.response.use(
  // 通过自定义code判定响应状态，也可以通过HTTP状态码判定
  response => {
    // 仅返回数据部分
    const res = response.data;

    // code不为1则判定为一个错误
    if (res.code !== 1) {
      Message({
        message: res.message || "Error",
        type: "error",
        duration: 5 * 1000
      });

      // 假设：10008-非法令牌; 10012-其他客户端已登录; 10014-令牌过期;
      if (res.code === 10008 || res.code === 10012 || res.code === 10014) {
        // 重新登录
        MessageBox.confirm(
          "登录状态异常，请重新登录",
          "确认登录信息",
          {
            confirmButtonText: "重新登录",
            cancelButtonText: "取消",
            type: "warning"
          }
        ).then(() => {
          store.dispatch("user/resetToken").then(() => {
            location.reload();
          });
        });
      }
      return Promise.reject(new Error(res.message || "Error"));
    } else {
      return res;
    }
  },
  error => {
    //console.log("err" + error); // for debug
    Message({
      message: error.message,
      type: "error",
      duration: 5 * 1000
    });
    return Promise.reject(error);
  }
);

export default axios;
```

设置环境变量：.env.development

```
# axios base api
VUE_APP_BASE_API = '/dev-api'
```

请求列表：@/api/user.js

```js
import axios from '@/utils/request'

export function login(data) {
  return axios.post('/user/login', data)
}

export function getInfo() {
  return axios.get('/user/info')
}
```

使用请求：src/store/user.js

```js
import {login, getInfo} from '@/api/user';

const actions = {
  // 模拟用户登录
  login({ commit }, userInfo) {
    return login(userInfo).then(res => {
      commit('login', res)
    });
  },
  getInfo({ commit, state }) {
    return getInfo(state.token).then(({data: roles}) => {
      
    })
  }
};

export default {
  namespaced: true,
  state,
  mutations,
  actions
};
```

##### 项目配置

Vue 社区的最佳实践项目：vue-element-admin。

在项目的根目录创建 vue.config.js，这里的代码是 nodejs 代码，最终导出一个配置对象，会被 vue-cli 去解析，在这里可以和 webpack、devServer 去打交道。因为 vue-cli3 中不能直接接触到 webpack。

1.项目本身的基础配置：指定应用上下文、开发服务器等。

```js
const port = 7070;

module.exports = { 
  publicPath: '/best-practice', // 部署时的上下文路径，基本URL
  devServer: { 
    port,
  } 
};
```

2.基础的 webpack 配置： configureWebpack

底层是用了 webpack-merge 把我们在 configureWebpack 里的配置解析成 webpack 的配置项并且跟 vue-cli 原有的配置合并起来。所有的 webpack 的配置项在这里都是可以配置的。

```js
const title = "vue项目最佳实践"; 

module.exports = { 
  configureWebpack: { 
    name: title, // 向index.html注入标题
  } 
};
```

最终使用的是 lodash template 的插值语法，./public/index.html，webpack 打包的时候，会把我们设置的这些值动态的添加到这里。我们想要一些配置的环境变量就可以用这种方式做。

```html
<title><%= webpackConfig.name %></title>
```

3.高级的链式 webpack 配置：chainWebpack

webpack-chain 称为链式操作，可以更细粒度控制 webpack 内部配置。可以修改已经存在的配置，也可以添加新的配置。

查看当前 webpack 配置：vue inspect 输出全部配置，vue inspect --rule 输出所有 rule，vue inspect --rule svg 查看 svg 规则的具体配置。

```js
const path = require('path')

function resolve(dir) {
  return path.join(__dirname, dir)
}

chainWebpack(config) {
  // 修改当前项目默认的svg配置：排除icons目录
  config.module.rule('svg')
    .exclude.add(resolve('./src/icons'))
	// 新增一个rule：用svg-sprite-loader处理icons里面的svg
  config.module.rule('icons')
    .test(/\.svg$/)
    .include.add(resolve('./src/icons')).end()
    .use('svg-sprite-loader')
    	.loader('svg-sprite-loader')
    	.options({ symbolId: 'icon-[name]' })

}
```

4.何时使用 public 文件夹：

关于 public 里面存放素材的选择。

将来静态的资源会放到 public 里头，因为 public 会作为开发服务器的静态路径。这里的资源 webpack 是不会处理的，原封不动，位置和名字都不会变。

通过 webpack 的处理（相对路径）并获得如下好处：

* 脚本和样式表会被压缩且打包在一起，从而避免额外的网络请求。
* 文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误。
* 最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本。

如下情况考虑使用 public 文件夹：

* 你需要在构建输出中指定一个固定的文件名字。
* 你有上千个图片，需要动态引用它们的路径。
* 有些库可能和 webpack 不兼容，除了将其用一个独立的 <script> 标签引入没有别的选择。

使用 public 文件夹的注意事项：

一般情况下，没有特别需要的话，别用这个 public，它会增添很多繁琐的使用。

* 如果你的应用没有部署在域名的根部，那么你需要为你的 URL 配置 publicPath 前缀

  ```js
  // vue.config.js 
  module.exports = { 
    publicPath: process.env.NODE_ENV === 'production' 
    	? '/cart/' 
    	: '/' 
  }
  ```

* 在 public/index.html 等通过 html-webpack-plugin 用作模板的 HTML 文件中，你需要通过 <%= BASE_URL %> 设置链接前缀：

  ```html
  <link rel="icon" href="<%= BASE_URL %>favicon.ico">
  ```

* 在模板中，先向组件传入 BASE_URL：

  ```js
  data () { 
  	return { 
  		publicPath: process.env.BASE_URL 
  	} 
  }
  ```

  然后：

  ```vue
  <img :src="`${publicPath}my-image.png`">
  ```

5.处理资源路径:

当你在 JavaScript、CSS 或 *.vue 文件中使用相对路径 (必须以 . 开头) 引用一个静态资源时，该资源模块将被 webpack 处理，需要打包，给它起个合适的名字放到一个合适的地方去。

转换规则：

* 如果 URL 是一个绝对路径 (例如 /images/foo.png )，它将会被保留不变。

  ```vue
  <img alt="Vue logo" src="/assets/logo.png"> 
  <img alt="Vue logo" src="http://image.xx.com/logo.png">
  ```

* 如果 URL 以 . 开头会作为一个相对模块请求被解释并基于文件系统相对路径。

  ```vue
  <img alt="Vue logo" src="./assets/logo.png">
  ```

* 如果 URL 以 ~ 开头会作为一个模块请求被解析。这意味着你甚至可以引用 Node 模块中的资源：

  ```vue
  <img src="~some-npm-package/foo.png">
  ```

* 如果 URL 以 @ 开头会作为一个模块请求被解析。Vue CLI 默认会设置一个指向 src 的别名 @ 。

  ```js
  import Hello from '@/components/Hello.vue'
  ```

##### 环境变量

##### 代码规范

##### 告警

##### 优化

##### 发布和部署

vue 线上打包:

根据环境变量来区分开发环境的请求地址还是线上的请求地址

可以在打包后，通过修改配置文件来更换线上请求地址，修改完配置文件后刷新页面即可。https://www.cnblogs.com/webhmy/p/9517680.html

vue-cli工程详解:

https://www.cnblogs.com/zhaowy/p/9542369.html

https://www.jianshu.com/p/7006a663fb9f

##### 项目测试

单元测试

e2e 测试

组件测试
##### 数据 mock

json-server

koa + mockjs 起本地 mock 服务器

1. 我们可以使用 json 文件来模拟后台数据，但比较局限，无法模拟数据的增删改查。

2. 使用 json-server 模拟，但不能随机生成所需数据。

3. 使用 mockjs 模拟后端接口，可随机生成所需数据，可模拟对数据的增删改查。

##### 权限控制

页面权限：AuthComponent

按钮权限：v-access 指令，收集 menuList 中所有的权限信息（menuType为1的url）

导航菜单：有单独的一个菜单接口 menuList

```js
[
  {
    children: [ // 子导航或该页面下的所有按钮权限
      {
        url: '/index/list/1',
        menuName: "首页列表1",
        menuType: 0,
        order: 1,
        children: [
					{
            children: [],
            url: '/api/index/check',
            menuName: "查看",
            menuType: 1,
            order: 1,
          },
          {
            children: [],
            url: '/api/index/edit',
            menuName: "编辑",
            menuType: 1,
            order: 2,
          },
        ]
      },
      {
        children: [],
        url: '/index/list/2',
        menuName: "首页列表2",
        menuType: 0,
        order: 2,
      },
    ],
		url: '/index/list', // 页面路由或权限按钮调用的接口的url
    menuName: "首页列表", // 导航名称
		menuType: 0, // 是否页面还是按钮权限
    order: 1, // 顺序
  }
]
```

导航菜单是根据路由信息并结合权限判断而动态生成的。

##### 请求封装

对 axios 做一次封装，统一处理配置，请求和响应拦截。

封装请求：src/utils/request.js

```js
import Axios from "axios";
import { MessageBox, Message } from "element-ui";
import store from "@/store";

// 创建axios实例
const axios = Axios.create({
  baseURL: process.env.VUE_APP_BASE_API, // url基础地址，解决不同数据源url变化问题。vue-cli3里提供了一个模式的东西，可以利用模式配置一批环境变量，它可以根据当前环境的动态的切换，解决我们请求时的url的变化的问题，在根目录下创建一个叫.env.development的文件，这个文件就是模式，默认有三种模式development,production,test 分别对应在package.json里面的dev,build,test这三个命令，可以在这个模式文件中定义环境变量。也可以在打包命令中使用--mode xxx结合.env.xxx模式文件，就可以使用该文件中的配置了，它就是一个环境变量的参数。
  // withCredentials: true, // 跨域时若要发送cookies需设置该选项
  timeout: 5000 // 超时
});

// 请求拦截，对请求头做一些处理，令牌的追加等
axios.interceptors.request.use(
  config => {
    // do something
    const token = localStorage.getItem('token')
    if (token) {
      // 设置令牌请求头
      config.headers["Authorization"] = 'Bearer ' + token;
    }
    return config;
  },
  error => {
    // 请求错误预处理
    //console.log(error) // for debug
    return Promise.reject(error);
  }
);

// 响应拦截，做一些错误处理
// 1.通过响应的状态判断请求成功与否，比如400,500
// 2.不管对错服务端都是以状态200返回，根据返回的code值判断请求是否成功
axios.interceptors.response.use(
  // 通过自定义code判定响应状态，也可以通过HTTP状态码判定
  response => {
    // 仅返回数据部分
    const res = response.data;

    // code不为1则判定为一个错误
    if (res.code !== 1) {
      Message({
        message: res.message || "Error",
        type: "error",
        duration: 5 * 1000
      });

      // 假设：10008-非法令牌; 10012-其他客户端已登录; 10014-令牌过期;
      if (res.code === 10008 || res.code === 10012 || res.code === 10014) {
        // 重新登录
        MessageBox.confirm(
          "登录状态异常，请重新登录",
          "确认登录信息",
          {
            confirmButtonText: "重新登录",
            cancelButtonText: "取消",
            type: "warning"
          }
        ).then(() => {
          store.dispatch("user/resetToken").then(() => {
            location.reload();
          });
        });
      }
      return Promise.reject(new Error(res.message || "Error"));
    } else {
      return res;
    }
  },
  error => {
    //console.log("err" + error); // for debug
    Message({
      message: error.message,
      type: "error",
      duration: 5 * 1000
    });
    return Promise.reject(error);
  }
);

export default axios;
```

设置环境变量：.env.development

```
# axios base api
VUE_APP_BASE_API = '/dev-api'
```

请求列表：@/api/user.js

```js
import axios from '@/utils/request'

export function login(data) {
  return axios.post('/user/login', data)
}

export function getInfo() {
  return axios.get('/user/info')
}
```

使用请求：src/store/user.js

```js
import {login, getInfo} from '@/api/user';

const actions = {
  // 模拟用户登录
  login({ commit }, userInfo) {
    return login(userInfo).then(res => {
      commit('login', res)
    });
  },
  getInfo({ commit, state }) {
    return getInfo(state.token).then(({data: roles}) => {
      
    })
  }
};

export default {
  namespaced: true,
  state,
  mutations,
  actions
};
```

##### 最佳项目配置

1.项目本身的基础配置：指定应用上下文、开发服务器等。

```js
const port = 7070;

module.exports = { 
  publicPath: '/best-practice', // 部署时的上下文路径，基本URL
  devServer: { 
    port,
  } 
};
```

2.基础的 webpack 配置： configureWebpack

底层是用了 webpack-merge 把我们在 configureWebpack 里的配置解析成 webpack 的配置项并且跟 vue-cli 原有的配置合并起来。所有的 webpack 的配置项在这里都是可以配置的。

```js
const title = "vue项目最佳实践"; 

module.exports = { 
  configureWebpack: { 
    name: title, // 向index.html注入标题
  } 
};
```

最终使用的是 lodash template 的插值语法，./public/index.html，webpack 打包的时候，会把我们设置的这些值动态的添加到这里。我们想要一些配置的环境变量就可以用这种方式做。

```html
<title><%= webpackConfig.name %></title>
```

3.高级的链式 webpack 配置：chainWebpack

4.何时使用 public 文件夹：

关于 public 里面存放素材的选择。

将来静态的资源会放到 public 里头，因为 public 会作为开发服务器的静态路径。这里的资源 webpack 是不会处理的，原封不动，位置和名字都不会变。

通过 webpack 的处理（相对路径）并获得如下好处：

* 脚本和样式表会被压缩且打包在一起，从而避免额外的网络请求。
* 文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误。
* 最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本。

如下情况考虑使用 public 文件夹：

* 你需要在构建输出中指定一个固定的文件名字。
* 你有上千个图片，需要动态引用它们的路径。
* 有些库可能和 webpack 不兼容，除了将其用一个独立的 <script> 标签引入没有别的选择。

使用 public 文件夹的注意事项：

一般情况下，没有特别需要的话，别用这个 public，它会增添很多繁琐的使用。

* 如果你的应用没有部署在域名的根部，那么你需要为你的 URL 配置 publicPath 前缀

  ```js
  // vue.config.js 
  module.exports = { 
    publicPath: process.env.NODE_ENV === 'production' 
    	? '/cart/' 
    	: '/' 
  }
  ```

* 在 public/index.html 等通过 html-webpack-plugin 用作模板的 HTML 文件中，你需要通过 <%= BASE_URL %> 设置链接前缀：

  ```html
  <link rel="icon" href="<%= BASE_URL %>favicon.ico">
  ```

* 在模板中，先向组件传入 BASE_URL：

  ```js
  data () { 
  	return { 
  		publicPath: process.env.BASE_URL 
  	} 
  }
  ```

  然后：

  ```vue
  <img :src="`${publicPath}my-image.png`">
  ```

##### 发布和部署

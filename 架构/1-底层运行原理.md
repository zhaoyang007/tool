# babel

babel 插件手册：https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md

babel 核心插件：`@babel/core @babel/parser @babel/traverse @babel/types @babel/generator`

## 1.解析(Parse)

- **词法分析(Lexing)**: Babel 首先接收源代码，然后进行词法分析，将字符串形式的代码转换为令牌流tokens。从左置右逐个字符对源程序进行扫描，产生一个一个单词符号。

- **语法分析(Parsing)**: 接下来，通过语法分析，将令牌流转换为抽象语法树（AST）。AST 是一个深层的对象，以树的形式表示代码中的语法结构，它更详细地表示了程序的语法结构。

  - 在这一步，解析器使用上一步生成的令牌流来构建一个抽象语法树（AST）。

  - AST 是源代码的树形结构表示，其中每个节点代表一个特定的语法结构，如函数声明、变量声明或表达式。

  - 解析器按照 JavaScript 语法规则，使用预先定义的解析逻辑，从令牌流中识别出各种语法结构，并为这些结构创建对应的 AST 节点。

  - 这个过程是递归的。例如，解析一个函数声明时，解析器需要递归地解析函数体内的语句和表达式。

  - Babel 解析器的实现基于以下几个主要原则：

    - **递归下降解析**：Babel 使用递归下降解析技术。这是一种自顶向下的解析方法，其中**每个函数对应于一种语法规则**。
    - **错误恢复**：为了使 Babel 更加鲁棒，并能处理部分无效代码，Babel 的解析器实现了错误恢复机制。当解析器遇到无效代码时，它会尝试跳过该部分并继续解析，同时生成错误消息。
    - **插件系统**：Babel 支持许多 JavaScript 的语法扩展，如 JSX、TypeScript、Flow 以及各种新的 ECMAScript 提案。这些功能不是内置的，而是通过 Babel 的插件系统实现的。解析器可以动态地为这些插件加载额外的解析逻辑。带有syntax的插件，这些插件是解析时，帮助babel理解额外语法特性的插件，而不是转换阶段的插件。

  - 解析器原理简单示例

    ```js
    // 了说明递归下降解析器是如何工作的，我们将使用一个非常简单的算术表达式语法。这个语法将只包括加法、乘法和括号，以及整数。我们的目标是解析这样的表达式，并构建相应的抽象语法树（AST）。
    
    // 首先，我们定义我们的语法规则。对于这个例子，我们的语法可能如下所示：
    
    // 表达式 -> 项 (('+' | '-') 项)* (一个表达式是一个项，后面可以跟零个或多个 '+' 或 '-' 和另一个项)
    // 项 -> 因子 (('*' | '/') 因子)* (一个项是一个因子，后面可以跟零个或多个 '*' 或 '/' 和另一个因子)
    // 因子 -> 数字 | '(' 表达式 ')' (一个因子可以是一个数字或一个括号内的表达式)
    // 现在，我们可以为每个语法规则编写一个解析函数。以下是使用 JavaScript 编写的代码示例：
    function isDigit(ch) {
      return /\d/.test(ch);
    }
    
    function isOperator(ch) {
      return /\+|-|\*|\//.test(ch);
    }
    
    function tokenizer(input) {
      let current = 0;
      let tokens = [];
    
      while (current < input.length) {
        let char = input[current];
    
        if (isDigit(char)) {
          let value = '';
    
          while (isDigit(char)) {
            value += char;
            char = input[++current];
          }
    
          tokens.push({ type: 'number', value });
          continue;
        }
    
        if (isOperator(char)) {
          tokens.push({ type: 'operator', value: char });
          current++;
          continue;
        }
    
        if (char === '(' || char === ')') {
          tokens.push({ type: 'paren', value: char });
          current++;
          continue;
        }
    
        current++;
      }
    
      return tokens;
    }
    
    function parseExpression(tokens) {
      // 解析第一个项
      let firstTerm = parseTerm(tokens);
    
      let body = [firstTerm];
    
      // 当我们有更多的项时（通过 '+' 或 '-' 分隔）
      while (tokens[0] && (tokens[0].value === '+' || tokens[0].value === '-')) {
        let operator = tokens.shift().value;
        let nextTerm = parseTerm(tokens);
        body.push({ type: 'operator', value: operator }, nextTerm);
      }
    
      return { type: 'expression', body };
    }
    
    function parseTerm(tokens) {
      // 解析第一个因子
      let firstFactor = parseFactor(tokens);
    
      let body = [firstFactor];
    
      // 当我们有更多的因子时（通过 '*' 或 '/' 分隔）
      while (tokens[0] && (tokens[0].value === '*' || tokens[0].value === '/')) {
        let operator = tokens.shift().value;
        let nextFactor = parseFactor(tokens);
        body.push({ type: 'operator', value: operator }, nextFactor);
      }
    
      return { type: 'term', body };
    }
    
    function parseFactor(tokens) {
      let token = tokens.shift();
    
      if (token.type === 'number') {
        return { type: 'number', value: token.value };
      } else if (token.value === '(') {
        let expr = parseExpression(tokens);
    
        if (tokens.shift().value !== ')') {
          throw new SyntaxError();
        }
    
        return expr;
      } else {
        throw new SyntaxError();
      }
    }
    
    function parse(input) {
      let tokens = tokenizer(input);
      return parseExpression(tokens);
    }
    
    // 使用解析器
    const ast = parse('3 + (4 * 5)');
    console.log(ast);
    console.log(JSON.stringify(ast, null, 2));
    ```

## 2.转换(Transform)

这一步，Babel接收到AST并进行遍历，在遍历的同时，使用各种插件和预设，修改AST节点，从而转换成成新的AST。

1. **使用插件和预设**:
   - Babel 的转换过程依赖于插件和预设。插件通常是定义如何转换代码的函数。预设是一组插件，允许你用预先设定的设置一次性使用多个插件。
   - 当你使用 Babel 时，你可以在 Babel 配置文件（例如 `.babelrc` 或 `babel.config.js`）中指定要使用的插件和预设。
2. **遍历 AST**:
   - 转换步骤开始于对 AST 的深度优先遍历。Babel 读取之前解析步骤生成的 AST，并遍历所有的节点。
   - 遍历是通过访问者（visitor）模式完成的。每个插件都可以定义访问者，当遍历到特定类型的 AST 节点时，就会调用这些访问者。
3. **应用转换**:
   - 在遍历过程中，当到达由插件定义的特定类型的节点时，插件会应用各种转换。这些转换可能包括添加、更新或删除节点。
   - 例如，一个将 ES6 箭头函数转换为普通函数的插件会在遍历到箭头函数节点时，修改该节点及其子节点，使其符合普通函数的结构。
4. **生成新的 AST**:
   - 在转换过程中，原始的 AST 会根据定义的转换被修改。通常，Babel 会尽量复用 AST 的大部分结构，但在某些情况下，可能会生成全新的节点。
   - 最终结果是一个更新后的 AST，它反映了所有插件应用的转换。
5. **代码生成**:
   - 尽管代码生成通常被认为是编译过程的最后一步，但它实际上是转换过程的一部分。一旦 AST 被转换，Babel 会将它转换回代码，这可能包括源码映射（sourcemaps）的生成，这些映射关联了输出代码和原始代码之间的对应关系。
   - Babel 包含一个代码生成器，它会遍历更新后的 AST，并根据树中的节点创建字符串形式的代码。

## 3.生成(Generate)

- **代码生成(Code Generation)**: 一旦 AST 被转换，Babel 将进入代码生成阶段。在这一步，修改后的 AST 被转换回字符串形式的代码。这个过程可能会生成与原始代码完全不同的代码，特别是当你使用了一些高级转换或语言扩展时。
- **源码映射(Source Maps)**: Babel 还可以生成源码映射（source maps）。这些是特殊的文件，允许开发环境像调试转换前的代码一样调试转换后的代码。

## 4.babel各个阶段的产出

### 1.代码示例

`plugin-transform-arrow-functions` 声明式函数转箭头函数的babel插件

```js
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption;
  api.assertVersion(7);
  const noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : !options.spec;
  return {
    name: "transform-arrow-functions",
    visitor: {
      ArrowFunctionExpression(path) {
        if (!path.isArrowFunctionExpression()) return;
        {
          path.arrowFunctionToExpression({
            allowInsertArrow: false,
            noNewArrows: true,
            specCompliant: !noNewArrows
          });
        }
      }
    }
  };
});
exports.default = _default;

//# sourceMappingURL=index.js.map
```

`转换过程代码示例`

```js
const parser = require("@babel/parser");
const traverse = require("@babel/traverse").default;
const generator = require("@babel/generator").default;
const util = require('util');

// 原始代码
const inputCode = `
const add = (a, b) => a + b;
`;

// 1.解析
// 将输入代码解析为 AST
const ast = parser.parse(inputCode, {
  sourceType: "module",
  tokens: true
});
console.log('词法分析后生成的tokens', util.inspect(ast.tokens, { showHidden: false, depth: null, colors: true }));
console.log('语法分析后生成的ast', util.inspect(ast, { showHidden: false, depth: null, colors: true }));

// 2.转换
// 创建插件实例并传递 api 和 options 参数
const plugin = require("@babel/plugin-transform-arrow-functions").default({
  assertVersion: () => true,
  // assumption: () => null,
}, {
  spec: true  // 这是你想传递给插件的 options 对象
});

// 获取插件实例的 visitor 对象
const { visitor } = plugin;

// 使用 @babel/traverse 遍历和转换 AST
traverse(ast, visitor);

console.log('转换后生成的ast', util.inspect(ast, { showHidden: false, depth: null, colors: true }));

// 3.生成
// 使用 @babel/generator 生成转换后的代码
const output = generator(ast, {}, inputCode);

// 输出转换后的代码
console.log('生成的目标代码', output.code);
```

### 2.词法分析后生成的tokens

```js
[{
  type: [ExportedTokenType], // 令牌类型
  value: const,          // 令牌的文本值
  start: 11,                 // 令牌在源代码中的开始位置
  end: 11,                   // 令牌在源代码中的结束位置
  loc: [SourceLocation]      // 令牌在源文件中位置的信息
}]

[
  Token {
    type: ExportedTokenType {
      label: 'const',
      keyword: 'const',
      beforeExpr: false,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'const',
    start: 1,
    end: 6,
    loc: SourceLocation {
      start: Position { line: 2, column: 0, index: 1 },
      end: Position { line: 2, column: 5, index: 6 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'add',
    start: 7,
    end: 10,
    loc: SourceLocation {
      start: Position { line: 2, column: 6, index: 7 },
      end: Position { line: 2, column: 9, index: 10 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '=',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: true,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: '=',
    start: 11,
    end: 12,
    loc: SourceLocation {
      start: Position { line: 2, column: 10, index: 11 },
      end: Position { line: 2, column: 11, index: 12 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '(',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 13,
    end: 14,
    loc: SourceLocation {
      start: Position { line: 2, column: 12, index: 13 },
      end: Position { line: 2, column: 13, index: 14 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'a',
    start: 14,
    end: 15,
    loc: SourceLocation {
      start: Position { line: 2, column: 13, index: 14 },
      end: Position { line: 2, column: 14, index: 15 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: ',',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 15,
    end: 16,
    loc: SourceLocation {
      start: Position { line: 2, column: 14, index: 15 },
      end: Position { line: 2, column: 15, index: 16 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'b',
    start: 17,
    end: 18,
    loc: SourceLocation {
      start: Position { line: 2, column: 16, index: 17 },
      end: Position { line: 2, column: 17, index: 18 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: ')',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 18,
    end: 19,
    loc: SourceLocation {
      start: Position { line: 2, column: 17, index: 18 },
      end: Position { line: 2, column: 18, index: 19 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '=>',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 20,
    end: 22,
    loc: SourceLocation {
      start: Position { line: 2, column: 19, index: 20 },
      end: Position { line: 2, column: 21, index: 22 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'a',
    start: 23,
    end: 24,
    loc: SourceLocation {
      start: Position { line: 2, column: 22, index: 23 },
      end: Position { line: 2, column: 23, index: 24 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: '+/-',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: true,
      postfix: false,
      binop: 9,
      updateContext: null
    },
    value: '+',
    start: 25,
    end: 26,
    loc: SourceLocation {
      start: Position { line: 2, column: 24, index: 25 },
      end: Position { line: 2, column: 25, index: 26 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'name',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: true,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: 'b',
    start: 27,
    end: 28,
    loc: SourceLocation {
      start: Position { line: 2, column: 26, index: 27 },
      end: Position { line: 2, column: 27, index: 28 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: ';',
      keyword: undefined,
      beforeExpr: true,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 28,
    end: 29,
    loc: SourceLocation {
      start: Position { line: 2, column: 27, index: 28 },
      end: Position { line: 2, column: 28, index: 29 },
      filename: undefined,
      identifierName: undefined
    }
  },
  Token {
    type: ExportedTokenType {
      label: 'eof',
      keyword: undefined,
      beforeExpr: false,
      startsExpr: false,
      rightAssociative: false,
      isLoop: false,
      isAssign: false,
      prefix: false,
      postfix: false,
      binop: null,
      updateContext: null
    },
    value: undefined,
    start: 30,
    end: 30,
    loc: SourceLocation {
      start: Position { line: 3, column: 0, index: 30 },
      end: Position { line: 3, column: 0, index: 30 },
      filename: undefined,
      identifierName: undefined
    }
  }
]
```

### 3.语法分析后生成的ast

```js
Node {
  type: 'File',
  start: 0,
  end: 30,
  loc: SourceLocation {
    start: Position { line: 1, column: 0, index: 0 },
    end: Position { line: 3, column: 0, index: 30 },
    filename: undefined,
    identifierName: undefined
  },
  errors: [],
  program: Node {
    type: 'Program',
    start: 0,
    end: 30,
    loc: SourceLocation {
      start: Position { line: 1, column: 0, index: 0 },
      end: Position { line: 3, column: 0, index: 30 },
      filename: undefined,
      identifierName: undefined
    },
    sourceType: 'module',
    interpreter: null,
    body: [
      Node {
        type: 'VariableDeclaration',
        start: 1,
        end: 29,
        loc: SourceLocation {
          start: Position { line: 2, column: 0, index: 1 },
          end: Position { line: 2, column: 28, index: 29 },
          filename: undefined,
          identifierName: undefined
        },
        declarations: [
          Node {
            type: 'VariableDeclarator',
            start: 7,
            end: 28,
            loc: SourceLocation {
              start: Position { line: 2, column: 6, index: 7 },
              end: Position { line: 2, column: 27, index: 28 },
              filename: undefined,
              identifierName: undefined
            },
            id: Node {
              type: 'Identifier',
              start: 7,
              end: 10,
              loc: SourceLocation {
                start: Position { line: 2, column: 6, index: 7 },
                end: Position { line: 2, column: 9, index: 10 },
                filename: undefined,
                identifierName: 'add'
              },
              name: 'add'
            },
            init: Node {
              type: 'ArrowFunctionExpression',
              start: 13,
              end: 28,
              loc: SourceLocation {
                start: Position { line: 2, column: 12, index: 13 },
                end: Position { line: 2, column: 27, index: 28 },
                filename: undefined,
                identifierName: undefined
              },
              id: null,
              generator: false,
              async: false,
              params: [
                Node {
                  type: 'Identifier',
                  start: 14,
                  end: 15,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 13, index: 14 },
                    end: Position { line: 2, column: 14, index: 15 },
                    filename: undefined,
                    identifierName: 'a'
                  },
                  name: 'a'
                },
                Node {
                  type: 'Identifier',
                  start: 17,
                  end: 18,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 16, index: 17 },
                    end: Position { line: 2, column: 17, index: 18 },
                    filename: undefined,
                    identifierName: 'b'
                  },
                  name: 'b'
                }
              ],
              body: Node {
                type: 'BinaryExpression',
                start: 23,
                end: 28,
                loc: SourceLocation {
                  start: Position { line: 2, column: 22, index: 23 },
                  end: Position { line: 2, column: 27, index: 28 },
                  filename: undefined,
                  identifierName: undefined
                },
                left: Node {
                  type: 'Identifier',
                  start: 23,
                  end: 24,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 22, index: 23 },
                    end: Position { line: 2, column: 23, index: 24 },
                    filename: undefined,
                    identifierName: 'a'
                  },
                  name: 'a'
                },
                operator: '+',
                right: Node {
                  type: 'Identifier',
                  start: 27,
                  end: 28,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 26, index: 27 },
                    end: Position { line: 2, column: 27, index: 28 },
                    filename: undefined,
                    identifierName: 'b'
                  },
                  name: 'b'
                }
              }
            }
          }
        ],
        kind: 'const'
      }
    ],
    directives: []
  },
  comments: []
}
```

### 4.转换后生成的ast

```js
Node {
  type: 'File',
  start: 0,
  end: 30,
  loc: SourceLocation {
    start: Position { line: 1, column: 0, index: 0 },
    end: Position { line: 3, column: 0, index: 30 },
    filename: undefined,
    identifierName: undefined
  },
  errors: [],
  program: Node {
    type: 'Program',
    start: 0,
    end: 30,
    loc: SourceLocation {
      start: Position { line: 1, column: 0, index: 0 },
      end: Position { line: 3, column: 0, index: 30 },
      filename: undefined,
      identifierName: undefined
    },
    sourceType: 'module',
    interpreter: null,
    body: [
      Node {
        type: 'VariableDeclaration',
        start: 1,
        end: 29,
        loc: SourceLocation {
          start: Position { line: 2, column: 0, index: 1 },
          end: Position { line: 2, column: 28, index: 29 },
          filename: undefined,
          identifierName: undefined
        },
        declarations: [
          Node {
            type: 'VariableDeclarator',
            start: 7,
            end: 28,
            loc: SourceLocation {
              start: Position { line: 2, column: 6, index: 7 },
              end: Position { line: 2, column: 27, index: 28 },
              filename: undefined,
              identifierName: undefined
            },
            id: Node {
              type: 'Identifier',
              start: 7,
              end: 10,
              loc: SourceLocation {
                start: Position { line: 2, column: 6, index: 7 },
                end: Position { line: 2, column: 9, index: 10 },
                filename: undefined,
                identifierName: 'add'
              },
              name: 'add'
            },
            init: Node {
              type: 'FunctionExpression',
              start: 13,
              end: 28,
              loc: SourceLocation {
                start: Position { line: 2, column: 12, index: 13 },
                end: Position { line: 2, column: 27, index: 28 },
                filename: undefined,
                identifierName: undefined
              },
              id: null,
              generator: false,
              async: false,
              params: [
                Node {
                  type: 'Identifier',
                  start: 14,
                  end: 15,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 13, index: 14 },
                    end: Position { line: 2, column: 14, index: 15 },
                    filename: undefined,
                    identifierName: 'a'
                  },
                  name: 'a'
                },
                Node {
                  type: 'Identifier',
                  start: 17,
                  end: 18,
                  loc: SourceLocation {
                    start: Position { line: 2, column: 16, index: 17 },
                    end: Position { line: 2, column: 17, index: 18 },
                    filename: undefined,
                    identifierName: 'b'
                  },
                  name: 'b'
                }
              ],
              body: {
                type: 'BlockStatement',
                body: [
                  {
                    type: 'ReturnStatement',
                    argument: Node {
                      type: 'BinaryExpression',
                      start: 23,
                      end: 28,
                      loc: SourceLocation {
                        start: Position { line: 2, column: 22, index: 23 },
                        end: Position { line: 2, column: 27, index: 28 },
                        filename: undefined,
                        identifierName: undefined
                      },
                      left: Node {
                        type: 'Identifier',
                        start: 23,
                        end: 24,
                        loc: SourceLocation {
                          start: Position { line: 2, column: 22, index: 23 },
                          end: Position { line: 2, column: 23, index: 24 },
                          filename: undefined,
                          identifierName: 'a'
                        },
                        name: 'a'
                      },
                      operator: '+',
                      right: Node {
                        type: 'Identifier',
                        start: 27,
                        end: 28,
                        loc: SourceLocation {
                          start: Position { line: 2, column: 26, index: 27 },
                          end: Position { line: 2, column: 27, index: 28 },
                          filename: undefined,
                          identifierName: 'b'
                        },
                        name: 'b'
                      }
                    }
                  }
                ],
                directives: []
              }
            }
          }
        ],
        kind: 'const'
      }
    ],
    directives: []
  },
  comments: []
}
```

### 5.输出转换后的代码

```js
const add = function (a, b) {
  return a + b;
};
```

## 5.babel插件

**概念**

Babel 插件可以让你自定义 JavaScript 代码转换的方式。Babel 插件是模块化的，每个插件都代表一个转换步骤。babel插件作用于babel的转换阶段。

Babel 插件通过遍历 AST，并应用访问者模式来转换特定类型的节点，实现代码的转换。

Babel 插件是一个简单的 JavaScript 文件，它导出了一个对象，该对象定义了一个或多个访问者方法，用于转换 AST 中的节点。

**编写插件**

下面是一个简单的 Babel 插件示例，它搜索所有的变量声明，并将 `let` 和 `const` 转换为 `var`：

```js
module.exports = function ({ types: t }) {
  return {
    visitor: {
      VariableDeclaration(path) {
        if (['let', 'const'].includes(path.node.kind)) {
          path.node.kind = 'var';
        }
      }
    }
  };
};
```

在这个插件中，导出了一个函数，它接收 Babel 的 `types` 模块作为参数。这个函数返回一个对象，该对象包含了我们想要访问的 AST 节点类型及其对应的处理函数。在这个例子中，我们访问 `VariableDeclaration` 节点，并修改其 `kind` 属性。

在 Babel 插件中，`types`和 `path` 是两个关键概念，它们都与 AST（抽象语法树）节点的操作有关。

1. `types`（或 `t`）

- `types` 是 Babel 的一个模块，主要用于 AST 节点的创建和验证。
- 节点创建：这对于你想要生成新代码或修改现有 AST 结构时非常有用。
  - 例如，使用 `types.identifier('name')` 创建一个新的标识符（变量名）节点。
  - 例如，使用`types.stringLiteral("hello")` 创建一个表示字符串字面量的 AST 节点。
- 节点验证： `types` 提供了一系列的 `is*` 函数，用于验证一个节点是否为特定类型。这在你需要根据节点类型进行条件处理时非常有用。
  - 例如，使用 `types.isIdentifier(node)` 来检查一个节点是否是标识符节点。
- 不直接修改 AST：尽管 `types` 可以创建新的 AST 节点，但它本身并不修改现有的 AST。创建的节点需要通过其他手段（如 `path` 对象）插入到 AST 中。

2. `path`

- 当 Babel 遍历 AST 时，它创建了一个称为 `path` 的对象，这个对象代表了对 AST 中特定位置的引用。可以认为 `path` 是指向 AST 中某个特定节点的“链接”。

- `path` 不仅包含了指向节点本身的引用（通过 `path.node` 访问），还包含了关于该节点在 AST 中位置的信息，以及如何与该节点的父节点和子节点进行交互、上下文信息和操作节点的方法的复合对象

  - 节点操作: `path` 提供了修改其引用的 AST 节点的方法，如 `path.replaceWith(newNode)` 可以用新节点替换当前节点，`path.remove()` 可以删除当前节点、以及在当前节点前后插入节点等。

  - 遍历和上下文: `path` 还包含关于节点位置的信息（例如它的父节点是什么），并允许你遍历 AST（例如 `path.findParent((path) => /* ... */)`）。

  - 节点信息: 通过 `path`，你可以访问节点的详细信息，例如它的类型、它的子节点等。

- 在 Babel 插件中，大部分的工作都是通过操作 `path` 来完成的。
- 直接修改 AST：与 `types` 不同，`path` 对象可以直接修改 AST。当你调用 `path` 的方法时，AST 会立即反映这些更改。

总的来说，`types` 用于创建和验证 AST 节点，而 `path` 则用于在 AST 中定位和操作这些节点。在编写 Babel 插件时，理解和利用这两个概念是非常重要的。

总之，`types` 更多的是一个“构造器”和“验证器”，用于创建和检验节点，但它并不直接涉及 AST 的修改。而 `path` 是一个“操作者”，它直接作用于 AST，允许你改变 AST 的结构。在实际的 Babel 插件开发中，这两者通常会一起使用，`types` 用于生成新的节点或验证节点类型，而 `path` 用于实际的 AST 操作和修改。

**插件分类**

* helper-xxx：通常是Babel内部工具函数，用于帮助Babel进行语法转换、生成代码等内部任务，并不是独立的插件。
* plugin-proposal-xxx
  - 这类插件通常用于提出新的 ECMAScript（JavaScript的规范）特性或语法提案。
  - 这些提案可能还没有被正式纳入 ECMAScript 规范，但由于其创新性或实用性，被 Babel 社区开发的插件用于在项目中使用这些提案。
* plugin-syntax-xxx
  - 这类插件通常用于添加新的语法，但不会进行语法转换。它们只是告诉 Babel 解析器如何理解某些新的语法结构，而不会对其进行转换。
  - 例如，`plugin-syntax-jsx` 允许 Babel 解析 JSX 语法，但不会将其转换为普通的 JavaScript。
* plugin-transform-xxx
  - 这类插件用于对代码进行转换，将一种语法或结构转换为另一种。
  - 例如，`plugin-transform-arrow-functions` 可能会将箭头函数的语法转换为普通的函数表达式。
* plugin-bugfix-xxx
  - 这类插件通常用于修复 Babel 编译过程中的一些问题或错误，或者为已有的特性提供修复。
  - 这类插件的使用可能会随着 Babel 版本的更新而变化，以解决特定版本的问题。

要使用这些插件，需要在你的 Babel 配置文件（例如 `.babelrc` 或 `babel.config.js`）中将它们添加到 `plugins` 数组中。

如果想在解析阶段支持更多的语言特性，你应该使用类似于 `@babel/plugin-syntax-dynamic-import` 或 `@babel/plugin-syntax-jsx` 这样的语法插件。（使用babel进行底层编译时会用到）

```js
const ast = parser.parse(code, {
  sourceType: "module",
  plugins: ["jsx"] // 这里的 "jsx" 是解析器插件的简写形式
});
```

拓展：提案分为几个阶段，从0到4

- 阶段 0 - 草案（strawman）: 这是一个新想法的最初阶段，还没有正式的提案。
- 阶段 1 - 建议（proposal）: 这个阶段的特性是值得进一步探究和讨论的正式提案，但细节可能会发生变化。
- 阶段 2 - 初稿（draft）: 这个阶段的提案已经更加成熟，初步规范已经完成，但仍可能会有较大的变化。
- 阶段 3 - 候选（candidate）: 提案已经接近最终形式，只进行微小的调整，除非发现重大问题。
- 阶段 4 - 完成（finished）: 提案已经准备好被包含在 ECMAScript 标准的下一个版本中。

# webpack

## 源码调试步骤

1. 运行创建webpack项目命令`npx webpack init`
2. 手动创建要打包的资源
3. 运行打包命令 `npx webpack build --config ./webpack.config.js`
4. 断点调试分析

## 模块加载原理

1. 文件静态分析：
   1. fs读取文件内容
   2. 使用babel将文件内容转换成ast
   3. 使用babel中转换ast的功能，遇到import语法，收集到依赖的模块路径数组
   4. 使用babel将ast转换成代码，并将esm模块转换成commonjs模块
   5. 返回对象，该对象内容包含：文件id 文件名 依赖的路径数组 转换后的文件代码

2. 构建依赖图：
   1. 使用循环递归的方式，将所有文件依次收集到依赖图数组中。
   2. 并记录该文件的依赖的相对路径和id的映射关系

3. 生成打包后代码：
   1. 遍历依赖图，拼接文件id与代码及其依赖的映射关系
   2. 构建自执行函数，传入上一步拼接好的映射
   3. 构建require函数, 从入口文件代码开始执行。require函数中执行文件代码，并传入require module exports保证文件代码正常运行。（[模块封装器](https://www.nodejs.com.cn/api/modules.html#the-module-wrapper)）


代码示例：minipack.js

```js
const fs = require('fs');
const path = require('path');
const babylon = require('babylon');
const traverse = require('babel-traverse').default;
const {transformFromAst} = require('babel-core');

let ID = 0;

// 1.根据文件路径 => 得到该文件的id 文件名 依赖的路径 文件代码
function createAsset(filename) {
  const content = fs.readFileSync(filename, 'utf-8');

  const ast = babylon.parse(content, {
    sourceType: 'module',
  });

  const dependencies = [];

  traverse(ast, {
    ImportDeclaration: ({node}) => {
      dependencies.push(node.source.value);
    },
  });

  const id = ID++;

  const {code} = transformFromAst(ast, null, {
    presets: ['env'],
  });

  return {
    id,
    filename,
    dependencies,
    code,
  };
}

// 2.构建依赖图
function createGraph(entry) {
  const mainAsset = createAsset(entry);

  const queue = [mainAsset];

  for (const asset of queue) {
    asset.mapping = {};

    const dirname = path.dirname(asset.filename);

    asset.dependencies.forEach(relativePath => {
      const absolutePath = path.join(dirname, relativePath);

      const child = createAsset(absolutePath);

      asset.mapping[relativePath] = child.id;

      queue.push(child);
    });
  }

  return queue;
}

// 3.遍历依赖图，生成打包后代码
function bundle(graph) {
  let modules = '';

  graph.forEach(mod => {
    modules += `${mod.id}: [
      function (require, module, exports) {
        ${mod.code}
      },
      ${JSON.stringify(mod.mapping)},
    ],`;
  });

  const result = `
    (function(modules) {
      function require(id) {
        const [fn, mapping] = modules[id];

        function localRequire(name) {
          return require(mapping[name]);
        }

        const module = { exports : {} };

        fn(localRequire, module, module.exports);

        return module.exports;
      }

      require(0);
    })({${modules}})
  `;

  return result;
}

const graph = createGraph('./example/entry.js');
const result = bundle(graph);

console.log(result);
```

## 打包运行原理

1. webpack 命令启动过程：
   1. 安装了 webpack 这个包之后，package.json bin 字段里面注册了一个 webpack 命令，npm 会据此在 node_modules/.bin 下会生成一个 webpack 命令。
   2. webpack 命令的作用就是判断用户是否安装了 webpack-cli 这个包，没安装的话会提示安装，然后引入 webpack-cli 这个包并执行。

2. webpack-cli 脚手架：

   将命令行和 webpack.config.js 的配置解析组装成 webpack 可识别的配置，再加载 webpack 并将配置传入，开始编译。

   run() => runWebpack() => createCompiler() => webpack() => loadWebpack() => tryRequireThenImport()

3. webpack 编译和构建流程：

* webpack(options) 
  * create()
    * compiler = createCompiler(webpackOptions)
      * compiler = new Compiler(options) 实例化compiler，传入webpack配置
        * 注册全部Compiler hook
      * **注册用户配置中所有的插件(plugins)**。
      * **根据配置执行 webpack 内部的插件**
        * 其中一个跟编译过程有关的插件WorkerPlugin会执行，WorkerPlugin中又会执行parserPlugin，用于编译过程中的依赖收集。
      * 执行compiler上的一些hooks
  * compiler.run()
    * onCompiled: 编译完成的回调，里面会调用**生成文件资源**的方法
      * compiler.emitAssets(compilation)
        * compiler.hooks.done.callAsync()
          * compiler.hooks.additionalPass.callAsync() 特殊情况需要再进行一次额外的构建时的钩子
            * compiler.compile(onCompiled)
    * compiler.hooks.beforeRun.callAsync()
      * compiler.hooks.run.callAsync()
        * compiler.compile(onCompiled)
          * params = compiler.newCompilationParams()
            * compiler.createNormalModuleFactory() 
              * **依赖解析**：当 Webpack 解析一个具体的文件路径时，例如一个具体的 `import` 或 `require` 语句指向的文件，`NormalModuleFactory` 会被用来处理这个文件。在处理模块时，`NormalModuleFactory` 也会解析模块的依赖关系。这包括分析模块中的 `import` 和 `require` 语句，以确定模块依赖哪些其他模块。
              * **解析文件对应的加载器（loaders）和加载器配置及其路径**：它会应用相应的加载器（**loaders**）来处理文件，并将文件转换为 Webpack 可以进一步处理的模块，**模块信息**包含了模块的路径、解析后的源代码、依赖信息、错误和警告信息、模块的元数据等。这些信息对于后续的编译步骤非常重要。
              * `NormalModuleFactory` 的主要职责是基于请求创建 `NormalModule` 实例。它处理模块的初始化和配置，包括决定哪些加载器（loaders）应该应用于特定的模块。
              * 实际上运行这些加载器（loaders）的过程发生在 `NormalModule` 实例的 `build` 方法中。
            * compiler.createContextModuleFactory() 
              * 当遇到动态依赖时，例如使用变量进行 `require` 调用（如 `require('./locale/' + name + '.json')`），`ContextModuleFactory` 会被使用。
              * 它负责分析这种动态请求的上下文信息，并生成一个上下文模块，该模块包含了所有可能的依赖项。
              * 上下文模块使得 Webpack 能够在打包时包含所有可能的依赖文件，即使它们是在运行时才确定的。
            * 总的来说，这两个工厂类根据不同类型的模块请求来创建相应类型的模块实例。`NormalModuleFactory` 处理静态明确的模块请求，而 `ContextModuleFactory` 处理更复杂的、动态确定的模块请求。通过这种方式，Webpack 能够有效地处理各种类型的模块依赖，无论它们是静态的还是动态的。
          * compiler.hooks.beforeCompile.callAsync(params)
            * compiler.hooks.compile.call(params)
            * 实例化 compilation = compiler.newCompilation(params) 
              * compiler.createCompilation(params)
                * new Compilation(compiler, params)
                  * 注册所有Compilation hook
                  * new AsyncQueue({ processor: this._buildModule.bind(this) }) 该行代码做了如下两件事
                    * new AsyncQueue()
                      * _ensureProcessing() **构建依赖图（递归）**
                        * _startProcessing(entry) 从入口文件开始构建
                          * _processor(entry.item)：entry.item就是NormalModule，\_processor就是processor，也是下面的 \_buildModule 方法。构建的过程中使用loader解析资源。
                    * \_buildModule(module, callback) {} 方法定义
                      * module.build( , , , , callback)：module就是NormalModule，就是上面的entry.item
                        * _doBuild()
                          * runLoaders()：loader-runner 中**运行loader的方法**，构建得到源码内容。
                            * parser.parse(_ast)：再通过NormalModuleFactory中的parser解析依赖，并通过 ParserPlugins 添加依赖，将现有的ast或源代码内容编译生成抽象语法树**ast**或其他相关的解析数据。解析的同时，模块（及其解析结果）被添加到 `compilation` 对象的 `modules` 集合中。
                              * handleBuildDone()
                                * callback()
                                  * compilation.hooks.succeedModule.call(module)
            * compiler.hooks.make.callAsync(compilation)
              * compiler.hooks.finishMake.callAsync(compilation)
                * compilation.finish()
                  * compilation.seal()
                    * 分块（chunk）
                    * 代码优化
                    * 生成哈希
                    * 生成代码资源：codeGeneration()
                      * createModuleAssets()：将 modules 里的代码放到 compilation 对象的 assets 里面去
                    * compiler.hooks.afterCompile.callAsync()
                      * return onCompiled(null, compilation) 产出资源文件到目录

**？？？**每一步产出的资源是什么样子的 **？？？**

**打包运行原理总结**

Tapable 为 webpack 插件提供了发布订阅的钩子。每个钩子代表一个关键的事件节点。

webpack 就是基于这种发布订阅的一系列的插件运行的事件流。

在 webpack 内部的 compiler 和 compilation 上面做 hooks 的调用。

插件有个 apply 方法，接收一个 compiler 参数。插件里面做 compiler 和 compilation 上的 hooks 的监听。

1. webpack 命令启动过程：用户运行webapck命令，判断用户是否安装 webpack-cli，没安装的话会提示安装，然后引入 webpack-cli 这个包并执行。`node_modules/webpack/bin/webpack.js`
2. webpack-cli 脚手架：将命令行和 webpack.config.js 的配置解析组装成 webpack 可识别的配置，再加载 webpack 并将配置传入，开始编译。`node_modules/webpack-cli/lib/webpack-cli.js`
3. webpack 编译和构建流程：
   1. 接收配置 `node_modules/webpack/lib/webpack.js`
   2. 创建compiler（compiler负责整个构建过程的生命周期和构建流程） `node_modules/webpack/lib/webpack.js`
      * 注册所有compiler hook `node_modules/webpack/lib/Compiler.js`
   3. **执行插件**（给插件传入compiler） `node_modules/webpack/lib/webpack.js`
      1. 根据配置的不同环境，执行webpack内部相应的插件
      2. 执行用户配置中所有的插件（plugins）
      3. 执行webpack内部的一些默认插件
   4. 开始编译 `node_modules/webpack/lib/Compiler.js`
      1. 生成各类模块 `node_modules/webpack/lib/NormalModuleFactory.js`
         1. 解析模块依赖关系
         2. 决定哪些加载器（loaders）应该应用于特定的模块
      2. 编译核心步骤：
         1. 创建compilation（compilation负责单次构建的具体构建工作） `node_modules/webpack/lib/Compiler.js`
            * 注册所有compilation hook  `node_modules/webpack/lib/Compilation.js`
         2. **运行loader**：解析文件，得到源码内容 `node_modules/webpack/lib/NormalModule.js`
         3. **解析AST**：将loader解析后的源码内容编译成ast或其他相关的解析数据 `node_modules/webpack/lib/NormalModule.js`
         4. **构建依赖图**：同时递归构建依赖图 `node_modules/webpack/lib/util/AsyncQueue.js`
         5. **收集模块到compilation.modules**：同时模块（及其解析结果）被添加到compilation对象的modules集合中 `node_modules/webpack/lib/Compilation.js`
   5. 编译结束 `node_modules/webpack/lib/Compilation.js`
      1. 分块（chunk）
      2. 代码优化
      3. 生成哈希
      4. 生成代码资源：将modules里的内容放到compilation.assets上面
   6.  产出文件资源  `node_modules/webpack/lib/Compiler.js`

**Tapable 插件架构与 Hooks 设计**

Tapable 为 webpack 插件提供了发布订阅的钩子。每个钩子代表一个关键的事件节点。

webpack 就是基于这种发布订阅的一系列的插件运行的事件流。

compiler 和 compilation 都是继承自 Tapable。compiler负责整个构建过程的生命周期和构建流程，compilation负责单次构建的具体构建工作。

compiler 和 compilation 上面做 hooks 的调用。

插件有个 apply 方法，接收一个 compiler 参数。

插件里面做 compiler 和 compilation 的 hooks 的监听。

Tapable hooks 类型：

```js
const {
  SyncHook,                   // 同步钩子
  SyncBailHook,               // 同步熔断钩子，遇到return直接返回
  SyncWaterfallHook,          // 同步流水钩子，执行结果可以传递给下一个插件
  SyncLoopHook,               // 同步循环钩子
  AsyncParallelHook,          // 异步并发钩子
  AsyncParallelBailHook,      // 异步并发熔断钩子
  AsyncSeriesHook,            // 异步串行钩子 
  AsyncSeriesBailHook,        // 异步串行熔断钩子
  AsyncSeriesWaterfallHook,   // 异步串行流水钩子
} = require("tapable")
```

Tapable 钩子绑定事件和执行事件对应的方法：

​                         Async*                           Sync*          

绑定：tapAsync/tapPromise/tap         tap

执行：     callAsync/promise                 call

Tapable hook 基本用法：

```js
// 创建一个同步的钩子
// class 接受数组参数 options，非必传。类方法会根据传参，接收同样数量的参数。
const hook1 = new SyncHook(['arg1', 'arg2', 'arg3']);
// 绑定事件
hook1.tap('hook1', (arg1, arg2, arg3) => {console.log(arg1, arg2, arg3)});
// 执行绑定的事件
hook1.call(1, 2, 3);
```

## 热更新原理

![热更新原理](images/webpack/热更新原理.png)

## 编写loader

**概念**

loader 的作用是用来处理各种各样的静态资源。

loader 是一个导出为声明式函数的 javascript 模块，接收资源返回资源：

```js
const loaderUtils = require("loader-utils");
module.exports = function(source) { 
  // 参数获取
  const { name } = loaderUtils.getOptions(this);
  
  // 异常处理
  // 1.throw new Error('error');
  // 2.this.callback(new Error('error'), source);
  
  // 返回结果
  // 1.return source;
  // 2.this.callback(null, source, 1, 2); 可以返回多个值
  
  // 异步处理
  const callback = this.async();
  fs.readFile(path.join(__dirname, './demo.txt'), 'utf-8', (err, data) => {
    if (err) {
      callback(err, '');
    }
    callback(null, data);
  });
  
  // 缓存
  // webpack 中默认开启缓存，可以使用以下方法关闭缓存
  // 缓存生效条件：loader 的结果有确定的输出。有依赖的 loader 无法使用缓存。
  this.cacheable(false);
  
  // 文件写入
  const url = loaderUtils.interpolateName(this, "[name].[ext]", source);
  this.emitFile(url, source);
};
```

**loader-runner**

```js
import { runLoaders } from "loader-runner"; 
runLoaders({ 
  resource: “/abs/path/to/file.txt?query”, // String: 资源的绝对路径(可以增加查询字符串) 
  loaders: [“/abs/path/to/loader.js?query”], // String[]: loader 的绝对路径(可以增加查询字符串) 
  context: { minimize: true }, // 基础上下文之外的额外 loader 上下文 
  readResource: fs.readFile.bind(fs) // 读取资源的函数 
}, function(err, result) { 
  // err: Error? 
  // result.result: Buffer | String 
})
```

**raw-loader**

raw-loader 的功能是将一个文件的内容转换成一个 string。

```js
module.exports = function(source) { 
  const json = JSON.stringify(source)
  	.replace(/\u2028/g, '\\u2028') // 为了安全起见, ES6模板字符串的问题 
    .replace(/\u2029/g, '\\u2029');
  return `export default ${json}`; 
};
```

**自动合成雪碧图的 loader**

支持的语法：

background: url('a.png?__sprite')

​                                           						           -----》						background: url('sprite.png')

background: url('b.png?__sprite')

准备知识：如何将两张图片合成一张图片？

使用 spritesmith (https://www.npmjs.com/package/spritesmith) 

验证 spritesmith 功能是不是正常的 test.js:

```js
const path = require('path')
const fs = require('fs')
const Spritesmith = require('spritesmith')

const sprites = ['./loaders/image/1.jpg', './loaders/image/2.jpg']

// 合成图片
Spritesmith.run({src: sprites}, (err, result) => {
  console.log(result.image)
  console.log(result.coordinates)
  console.log(result.properties)
  // 把合成后的图片内容输出到磁盘
  fs.writeFileSync(path.join(__dirname, 'dist/sprite.jpg'), result.image)
})
```

开发 sprite-loader

run-loader.js:

```js
const fs = require("fs"); 
const path = require("path"); 
const { runLoaders } = require("loader-runner"); 

runLoaders( 
  { 
    resource: "./loaders/index.css", 
    loaders: [path.resolve(__dirname, "./loaders/sprite-loader")], 
    readResource: fs.readFile.bind(fs), 
	}, 
  (err, result) => (err ? console.error(err) : null) 
);
```

index.css:

```css
.img1 {
	background: url(./images/1.jpg?__sprite);
}
.img2 {
	background: url(./images/2.jpg?__sprite);
}
```

sprite-loader.js:

```js
const path = require('path')
const fs = require('fs')
const Spritesmith = require('spritesmith')

module.exports = function (source) {
  const callback = this.async()
  const imgs = source.match(/url\((\S*)\?__sprite/g)
  const matchedImgs = []
  
  for (let i = 0; i < imgs.length; i++) {
   	const img = imgs[i].match(/url\((\S*)\?__sprite/)[1]
    matchedImgs.push(path.join(__dirname, img))
  }
  
  Spritesmith.run({
    src: matchedImgs
  }, (err, result) => {
    // 正常开发是使用this.emitFile输出文件，但是loader-runner没有这个方法，所以这里用fs代替
    fs.writeFileSync(path.join(process.cwd(), 'dist/sprite.jpg'), result.image)
    source = source.replace(/url\((\S*)\?__sprite/g, match => {
      return `url("dist/sprite.jpg")`
    })
    fs.writeFileSync(path.join(process.cwd(), 'dist/index.css'), source)
    callback(null, source)
  })
}
```

## 编写plugin

**概念**

插件是伴随着 webpack 从初始化到最终的资源生成的过程的。

插件是一个类，有一个 apply 方法。

webpack 执行插件的时候会运行每一个插件上的 apply 方法，同时把 webpack 的 compiler 对象传进去，这样插件就具备监听 compiler hooks 的能力，通过 compiler.hooks 在不同的阶段可以做相应的事情。compiler里面又可以接收到complition。

```js
// 将一段代码输出到文件里面就可以用 RawSource
const { RawSource } = require("webpack-sources"); 
class MyPlugin {
  constructor(options) { 
    this.options = options; 
  }
  apply(compiler) {
    // 插件处理逻辑
    
    // 插件的错误处理
    // 1.throw new Error('error');
    // 2.通过 compilation 对象的 warnings 和 errors 接收
    //   compilation.warnings.push("warning");
    //   compilation.errors.push("error");

    // 文件写入
    // webpack 的构建流程的文件生成是在 emit 阶段，所以在插件里监听 compiler emit 这个 hooks。
    // 监听这个 hook 之后我们可以获取到 compilation 对象
    // 然后只需要将最终要输出的内容设置到 compilation.assets 对象上面去就可以了
    // 最终webpack生成文件的时候会触发emit，然后读取compilation.assets上的资源内容并输出到磁盘目录
    const { path } = this.options;
    compiler.hooks.emit.tapAsync("MyPlugin", (compilation, callback) => { 
      compilation.assets[path] = new RawSource("demo"); 
      callback();
    }); 
  } 
}
module.exports = MyPlugin;
```

**插件的插件**

webpack 的插件是特别的强大的，除了通过插件来扩展 webpack 的能力，插件自身也可以通过暴露 hooks 的方式进行自身扩展。

以 html-webpack-plugin 为例，它暴露出来的 hooks： 

* html-webpack-plugin-alter-chunks (Sync) 
* html-webpack-plugin-before-html-generation (Async) 
* html-webpack-plugin-alter-asset-tags (Async) 
* html-webpack-plugin-after-html-processing (Async) 
* html-webpack-plugin-after-emit (Async)

**压缩构建资源为 zip 包的插件**

Node.js 里面将文件压缩为 zip 包：使用 jszip (https://www.npmjs.com/package/jszip)

jszip 使用示例

```js
var zip = new JSZip(); 

zip.file("Hello.txt", "Hello World\n"); 

var img = zip.folder("images"); 
img.file("smile.gif", imgData, {base64: true}); 

zip.generateAsync({type:"blob"}).then(function(content) { 
	// see FileSaver.js 
	saveAs(content, "example.zip"); 
});
```

zip-plugin.js:

```js
const JSZip = require('jszip');
const path = require('path');
const RawSource = require('webpack-sources').RawSource;

const zip = new JSZip();

module.exports = class ZipPlugin {
  constructor(options) {
    this.options = options;
  }
  apply(compiler) {
    compiler.hooks.emit.tapAsync('ZipPlugin', (compilation, callback) => {
      const folder = zip.folder(this.options.filename);
      for (let filename in compilation.assets) {
        const source = compilation.assets[filename].source();
        folder.file(filename, source);
      }

      zip.generateAsync({
        type: 'nodebuffer'
      }).then((content) => {
        const outputPath = path.join(
          compilation.options.output.path, 
          this.options.filename + '.zip'
        );

        const outputRelativePath = path.relative(
          compilation.options.output.path,
          outputPath
        );
        compilation.assets[outputRelativePath] = new RawSource(content);
        callback();
      });
    });
  }
}
```

## 基础使用

**配置分类**

* 基础配置（webpack.base.js）
  * 资源解析
    * 解析 es6
    * 解析 react
    * 解析 css
    * 解析 less
    * 解析图片
    * 解析字体
  * 样式增强
    * 前缀补齐
    * px 转 rem
  * 清理目录
  * 多页面打包
  * 命令行信息显示优化
  * 错误捕获和处理
  * css 提取成单独的文件
* 开发环境配置（webpack.dev.js）
  * 代码热更新
    * js 热更新
    * css 热更新
  * sourcemap
* 生产环境配置（webpack.prod.js）
  * 代码压缩
  * 文件指纹
  * Tree Shaking
  * Scope Hoisting
  * 速度优化（基础包 CDN）
  * 体积优化（代码分割）
* SSR 配置（webpack.ssr.js）
  * Output 的 libiraryTarget 的设置
  * Css 解析 ignore

**webpack**

进入入口文件 index.js，webpack 会借助 babel 来分析页面里面的内容，哪些是依赖，哪些是语句，然后把代码处理成浏览器能够正确执行的 js。递归地找出⼊⼝⽂件的所有依赖，不断的处理编译，将⼊⼝和其所有的依赖打包到⼀个单独的⽂件中，最终形成一个代码块。    

chunk 是代码块的，bundle 是打包构建生成的资源文件，一个 chunk 对应一个 bundle。nodejs 里，万物皆模块，就是文件。

**webpack 配置组成**

```js
module.exports = { 
  context: process.cwd() // 上下文，项目打包的相对路径，必须是绝对路径
	entry: './src/index.js', 
  output: './dist/main.js',
  mode: 'production',
	module: {
    rules: [	
    	{ 
        test: /\.txt$/, 
        use: 'raw-loader' 
      }
    ]
  },
  plugins: [
  	new HtmlwebpackPlugin({ 
      template: './src/index.html’
  	})
  ]
}
```

entry：

单入口

```js
module.exports = {
	entry: './src/index.js'
  // entry: ['./src/index.js', './src/index2.js']
}
```

多入口

```js
module.exports = {
  entry: {
    // main: './src/index.js', // 默认值就是main，等价于上面字符串的写法
    app: './src/app.js',
    adminApp: './src/adminApp.js'
  }
}
```

output：

单入口

```js
module.exports = {
  output: {
    path: path.join(__dirname, 'dist'),
    filename: 'bundle.js'
  }
}
```

多入口

```js
module.exports = {
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name].js' // 多出口不可以指定名称
  }
}
```

**babel**

要解析 es6 需要安装 @babel/core，es6 的预设插件 @babel/preset-env，通过 babel-loader 去解析它们。

```bash
npm i @babel/core @babel/preset-env babel-loader -D
```

使用 babel-loader

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader'
      }
    ]
  }
}
```

babel 配置文件：.babelrc

babel 在执⾏编译的过程中，会从项⽬根⽬录下的 .babelrc JSON ⽂件中读取配置。没有该⽂件会从 loader 的 options 地⽅读取配置。

babel 两个比较重要的概念，presets 和 plugins。plugins 可以理解成一个 plugin 对应一个功能，presets 是一系列 babel plugin 的集合。要解析es6，使用 es6 的预设 @babel/preset-env 就可以了。 

```json
{
  "presets": [
    "@babel/preset-env"
  ]
}
```

解析 react jsx：

安装 react 相关

```bash
npm i react react-dom @babel/preset-react -D
```

增加 react 的 babel 预设，就可以解析 react 相关的语法了。

```json
{
  "presets": [
    "@babel/preset-react"
  ]
}
```

**解析 css**

css-loader 作用是加载 .css 模块的内容，转成 commonjs 对象，插入到 js 模块中去。

然后通过 style-loader 将样式通过 \<style\> 标签插入到 head 中，这样样式才能显示出来。

```bash
npm i css-loader style-loader -D
```

配置 css-loader style-loader

有一点需要注意，loader 的调用顺序是从右到左的，因此需要先写 style-loader，再写 css-loader，实际执行的时候会先去使用 css-loader 去解析 css，然后再将解析好的 css 传递给 style-loader。

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader'
        ]
      }
    ]
  }
}
```

使用 .vue 文件进行开发，应该使用 vue-style-loader 而不是 style-loader，这样 .vue 文件的样式也有热重载的功能了，.vue 文件和样式文件的样式都适用。

**解析 less 和 sass**

```bash
npm i less less-loader -D
```

配置 less

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [
          'style-loader',
          'css-loader',
          'less-loader'
        ]
      }
    ]
  }
}
```

**解析图片**

file-loader 用于处理文件

```bash
npm i file-loader -D
```

配置图片解析 file-loader

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: 'file-loader'
      }
    ]
  }
}
```

**解析字体**

在 webpack 里解析字体和解析图片做法是一样的，因为图片和字体都不是代码文件。图片和字体的解析都可以用file-loader 处理。

配置字体解析 file-loader

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/,
        use: 'file-loader'
      }
    ]
  }
}
```

**图片和字体解析的其他方式**

url-loader 包含了 file-loader 的全部功能，只不过 url-loader 相比 file-loader，还可以做小图片或小字体，自动的做一个 base64 的转换，url-loader 内部也使用了 file-loader。

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: [{
          loader: 'url-loader',
          options: {
            limit: 10240 // 单位是字节 1024=1kb
          }
        }]
      }
    ]
  }
}
```

**webpack 中的⽂件监听**

⽂件监听是在发现源码发⽣变化时，⾃动重新构建出新的输出⽂件。

webpack 开启监听模式，有两种方式：

启动 webpack 命令时，带上 --watch 参数

```json
"scripts": {
  "watch": "webpack --watch"
}
```

在配置 webpack.config.js 中设置 watch: true

```js
module.exports = {
  // 默认false，也就是不开启
  watch: true,
  // 只有开启监听模式时，watchOptions才有意义
  watchOptions: {
    // 不监听的文件或文件夹，支持正则匹配，默认为空
    ignored: /node_modules/,
    // 监听到变化后会等300ms再去执行，默认300ms
    aggregateTimeout: 300,
    // 判断文件是否发生变化是通过不停轮询系统指定文件有没有变化实现的，默认每秒询问1000次
    poll: 1000
  }
}
```

缺陷：每次需要⼿动刷新浏览器。

文件监听的原理分析：

轮询判断⽂件的最后编辑时间是否变化。

某个⽂件发⽣了变化，并不会⽴刻告诉监听者，⽽是先缓存起来，等 aggregateTimeout，这个时间内如果有其他文件也发生了变化，它会把这些变化的文件列表一起去构建。

**webpack-dev-server**

基于 express 启动了一个小型服务。

WDS 会自动刷新浏览器。

WDS 输出的文件不放入磁盘里面，没有磁盘的 IO 操作，它输出的文件是放在内存里面，而不像 watch 这种方式是放在本地的磁盘文件里面。所以它的构建速度会有更大的优势。

```js
module.exports = {
  mode: 'development',
  // 配置devServer
  devServer: {
    // wds 服务的基础的目录
    contentBase: './dist',
    // 代理
    proxy: {
      '/api': {
				target: 'http://localhost:9092'
      }
    },
    // 防止我们没有使用vue-router的api进行跳转，比如在地址栏直接输入我们的路由，这时就会请求到我们本地服务器，由于这个路由是前端路由，服务器是不认识这个路径的，所以会返回找不到页面。加了这个配置就可以在这种情况下，让服务器去找我们htmlPlugin生成的index.html，这样就可以进到我们前端的页面来了。只要进到我们前端的页面，那么路由就由我们前端来掌控了，就不会有问题了。
    historyApiFallback: { 
			index: '/public/index.html' // 这个index它的写法跟我们在webpack.config.base.js中output里的publicPath是有关系是对应的，这个publicPath就是作为historyApiFallback里index的基路径。如果你不这么写它是找不到的。
		}
    // mock数据，跟wds中间件机制有关。wds中间件给我们提供了两个钩子，加载中间件之前和之后的概念。
    before(app, server) {
      // 就相当于在这里做服务器接口的工作
			app.get("/api/mock.json", (req, res) => {
        res.json({
          hello: "express",
        })
      })
    },
    after() {
      
    }
  }
}
```

```json
"scripts": {
  "dev": "webpack-dev-server --open"
}
```

**webpack-dev-middleware**

自己写本地服务的情况。

WDM 将 webpack 输出的⽂件传输给服务器。

适⽤于灵活的定制场景，可以对 webpack 的配置控制的更多。

```js
const express = require('express')
const webpack = require('webpack')
const webpackDevMiddleWare = require('webpack-dev-middleware')

const app = express()
const config = require('./webpack.config.js')
const compiler = webpack(config)

app.use(webpackDevMiddleWare(compiler, {
  publicPath: config.output.publicPath
}))

app.listen(3000, function() {
  console.log('Example app listening on port 3000')
})
```

**热更新**

借助 webpack-dev-server，每次代码修改，自动构建，通过热更新的方式让浏览器的内容自动的变化。

启动 HMR 后，css 抽离会不⽣效，还有不⽀持 contenthash，chunkhash。

```js
const webpack = require('webpack')

module.exports = {
  mode: 'development',
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ],
  devServer: {
    hot: true
  }
}
```

**文件指纹策略**

常见的文件指纹有哪几种：

* hash：每次打包后整个项目的 hash 值，每构建一次就会有一个新的 hash 值。
* chunkhash：和 webpack 打包的 chunk 有关，不同的 entry 会⽣成不同的 chunkhash 值，根据不同入口 entry 进行依赖解析，构建对应的 chunk，生成相应的 hash，只要组成 entry 的模块没有内容改动，则对应的 hash 不变， 对于 js 文件的指纹，一般采用 chunkhash。
* contenthash：根据⽂件内容来定义 hash ，⽂件内容不变，则 contenthash 不变。 一个页面既有 js 资源也有 css 资源，如果 css 资源也使用 chunkhash 的话，会有一个问题，就是我们修改了 js，但是 css 并没有变，由于 css 也使用了 chunkhash，就会导致 css 内容没有变，但是发布上去的文件指纹发生了变化。因此对于 css ，通常根据内容进行文件指纹的生成，采用 contenthash。

JS 的⽂件指纹设置：

设置 output 的 filename，使⽤ [chunkhash]。

chunkhash是没办法和热更新的HotModuleReplacementPlugin一起使用的，所以只需设置在生产环境。

```js
module.exports = {
  output: {
    filename: '[name].[chunkhash:8].js',
    path: __dirname + '/dist'
  }
}
```

CSS 的⽂件指纹设置和 css 文件抽离：

使用 style-loader 和 css-loader 的话，那么这个 css 会由这个 style-loader 将这个 css 插入到 style 里面并且放到 head 头部。这时并没有独立的一个 css 文件，因此我们通常会采用插件把 css 提取成一个独立的文件。

css/sass/less 等 css 相关文件经过对应的 loader 处理之后，最终处理必须为 style-loader 将 css 样式放到 style 标签中或者使用文件提取的插件将 css 单独提取成独立 css 文件。两者必须存在一个，这样样式才能有效。两者同时存在时，style-loader 在前，生成独立 css 文件，style-loader 失效；提取文件的插件 loader 在前，编译过不了。

css 文件指纹也只需设置在生产环境。

webpack4：

使用 MiniCssExtractPlugin 插件的 loader。

设置 MiniCssExtractPlugin 的 filename，使⽤ [contenthash]。

```js
const MiniCssExtractPlugin = require('mini-css-extract-plugin')

module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader'
        ]
      },
      {
        test: /\.less$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'less-loader'
        ]
      }
    ]
  },
	plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash:8].css'
    })
  ]
}
```

webpack3：

使用 extract-text-webpack-plugin 把非 js 的代码，单独打包成一个静态资源文件。比如把css文件拎出来打包成一个单独的文件。

使用 ExtractTextPlugin 的 loader。

设置 ExtractTextPlugin 的 filename，使⽤ [contenthash]。

```js
const ExtractTextPlugin = require('extract-text-webpack-plugin')

module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          ExtractTextPlugin.extract({
            fallback: 'style-loader',
            use: 'css-loader'
          })
        ]
      },
      {
        test: /\.less/,
        use: [
          ExtractTextPlugin.extract({
            fallback: 'style-loader',
            use: [
              'css-loader',
              'less-loader'
            ]
          })
        ]
      }
    ]
  },
	plugins: [
    new ExtractTextPlugin('styles.[contentHash:8].css')
  ]
}
```

图片或字体的文件指纹设置：

设置 file-loader 或 url-loader 的 name，使⽤ [hash]。

这里的 hash 也是指文件内容的 hash，这个 hash 是采用 md5 生成的。

```js
module.exports = {
	module: {
    rules: [
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: {
          loader: 'file-loader',
          options: {
            name: 'img/[name].[hash:8].[ext]'
          }
        }
      }
    ]
  }
}
```

**html-webpack-plugin**

html-webpack-plugin 默认支持 ejs 模版语法。

开发环境中的作用：

启动了 webpack-dev-server 后，它会在项目根目录中生成一个隐形的 index.html，如果 output 中配置了 publicPath，会生成在项目跟目录的 publicPath 中。webpack-dev-server 会自动在根目录下寻找这个 index.html，但是根目录里根本没有 index.html。所以访问页面出现的是项目目录结构，在 webpack-dev-server 中配置 historyApiFallback 就可以直接访问到 index.html。

生产环境打包中的作用：

生产环境打包，会生成一个 index.html 来包含我们打包好的 js 和 css 文件。

**自动清理构建目录**

每次构建的时候不会清理⽬录，造成构建的输出⽬录 output ⽂件越来越多

通过 npm scripts 清理构建⽬录：

rm -rf ./dist && webpack

rimraf ./dist && webpack

⾃动清理构建⽬录：

使⽤ clean-webpack-plugin。它会默认删除 output 指定的输出⽬录。

```js
const { CleanWebpackPlugin } = require('clean-webpack-plugin')

module.exports = {
  plugins: [
    new CleanWebpackPlugin()
  ]
}
```

**PostCSS 插件 autoprefixer**

autoprefixer 插件通常是和 postcss-loader 一起使用。postcss-loader 的功能是比较强大的，除了做 css 样式补全之外，它还可以做支持 css module，style lint 等。

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [
          'style-loader',
          'css-loader',
          'less-loader',
          {
            loader: 'postcss-loader',
            options: {
              plugins: () => [
                require('autoprefixer')({
                  overrideBrowserslist: ["last 2 version", ">1%", "IOS 7"] // 指定autoprefixer所需要兼容的浏览器的版本
                })
              ]
            }
          }
        ]
      }
    ]
  }
}
```

**移动端 CSS px ⾃动转换成 rem**

使用手淘比较成熟的方案 [lib-flexible ](https://github.com/amfe/lib-flexible) 库计算实际的设备分辨率根元素的 font-size 大小。

页面打开的时候就需要马上的计算这个值，所以它的位置需要前置放在前面的位置。

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [
          'style-loader',
          'css-loader',
          'less-loader',
          {
            loader: 'px2rem-loader',
            options: {
              remUnit: 75, // rem相对于px的转换的单位，75代表1rem=75px，这个比较适合750的设计稿，750个像素对应着10个rem。
              remPrecision: 8 // px转成rem，后面小数点的位数。
            }
          }
        ]
      }
    ]
  }
}
```

**静态资源内联**

资源内联的意义：

代码层面：

* ⻚⾯框架的初始化脚本：如上节中 rem 计算的 js 库，要在打开页面的时候就要去计算。

* 上报相关打点：page start，css 初始化，css 加载完成，js 初始化和 js 加载完成等代码，这些都是需要内联到 html 里面去，而不能直接放到最终打包的 js 脚本中去。

* css 内联避免⻚⾯闪动

请求层⾯：

* 减少 HTTP ⽹络请求数

⼩图⽚或者字体内联使用 url-loader：

html 和 js 的内联：

raw-loader 的功能是读取一个文件，把这个文件的内容返回成一个 string，把这个 string 插入到对应的位置。

raw-loader 内联 html

```html
 <%= require('raw-loader!./meta.html') %>
```

raw-loader 内联 js

```html
<script>
  <%= require('raw-loader!babel-loader!../../node_modules/lib-flexible/flexible.js') %></script>
```

css 内联：

方案一：借助 style-loader

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [
          {
            loader: 'style-loader',
            options: {
              insertAt: 'top', // 样式插入到 <head>
              singleton: true, // 将所有的style标签合并成一个
            }
          },
          "css-loader",
          "less-loader"
        ]
      }
    ]
  }
}
```

方案二：html-inline-css-webpack-plugin

它针对打包好的 css chunk 的代码，把它内联到 html 的 head 中。

```js
const HTMLInlineCSSWebpackPlugin = require("html-inline-css-webpack-plugin").default;

module.exports = {
  plugins: [
    new HTMLInlineCSSWebpackPlugin(),
  ]
}
```

**多页面应用打包通用方案**

多页面优势

​	1.每个页面之间是解偶的

​	2.对 seo 更友好

多页面打包基本思路：

每个页面对应一个 entry，一个 html-webpack-plugin。

缺点：每次新增或删除页面需要手动修改 webpack 配置构建脚本。

多⻚⾯打包通⽤⽅案：

动态获取 entry 和设置 html-webpack-plugin 数量。

通过程序的思维动态获取某个目录下面指定的入口文件，需要有一个约定，把所有的页面都放在 src 的目录下面，每个页面的入口文件都约定为 index.js，这样我们就可以通过 js 脚本去获取src里面所有的目录，就可以知道入口文件的数量，打包的时候动态的设置 html-webpack-plugin。相比于自己写这个脚本，webpack 里面有一个更通用的做法是通过 glob 这个库，glob 的原理类似 linux 操作系统下面文件通配匹配的概念，根据匹配信息返回匹配到的目录内容，我们根据这个目录内容进行操作就可以了。

```js
const setMPA = () => {
  const entry = {}
  const htmlWebpackPlugins = []
  const entryFiles = glob.sync(path.join(__dirname, './src/*/index.js'))
  Object.keys(entryFiles)
    .map(index => {
    const entryFile = entryFiles[index];
    const match = entryFile.match(/src\/(.*)\/index\.js/);
    const pageName = match && match[1];
    entry[pageName] = entryFile;
    htmlWebpackPlugins.push(new HtmlWebpackPlugin({
      template: path.join(__dirname, `./src/${pageName}/index.html`),
      filename: `${pageName}.html`,
      chunks: [pageName],
      inject: true,
      minify: {
        html5: true,
        collapseWhitespace: true,
        perserveLineBreaks: false,
        minifyCSS: true,
        minifyJS: true,
        removeComments: false
      }
    }));
  });
  return {
    entry,
    htmlWebpackPlugins
  }
}
const {entry, htmlWebpackPlugins} = setMPA()
```

**webpack 打包组件和基础库**

实现⼀个⼤整数加法库的打包：

需要打包压缩版和⾮压缩版本。

⽀持 AMD/CJS/ESM 模块引⼊，也支持script标签方式引入。

库的目录结构：

dist
    large-number.js
    large-number.min.js
webpack.config.js
package.json
index.js
src
    index.js

支持ES module：

```js
import * as largeNumber from 'large-number'
largeNumber.add('999', '1')
```

支持CJS：

```js
const largeNumber = require('large-number')
largeNumber.add('999', '1')
```

支持AMD：

```js
require(['large-number'], function(large-number) {
  largeNumber.add('999', '1')
})
```

直接通过script引入，脚本发布到cdn上去：

```html
<script src="https://unpkg.com/large-numer"></script>
<script>
  largeNumber.add('999', '1')
</script>
```

如何将库暴露出去：

```js
module.exports = {
  mode: 'production',
  entry: {
    'large-number': './src/index.js',
    'large-number.min': './src/index.js'
  },
  output: {
    filename: '[name].js',   
    library: 'largeNumber',   // 指定库它暴露出去的库的名称，同时也可以通过全局变量的方式去引入到它。
    libraryTarget: 'umd',     // 支持库引入的方式，设置成umd就可以支持上述四种方式的引用。
    libraryExport: 'default'  // 如果不设置成default，要通过largeNumber.default使用，不是很方便。
  }
}
```

如何只对 .min 压缩：

通过 include 设置只压缩 min.js 结尾的⽂件

```js
const TerserWebpackPlugin = require('terser-webpack-plugin')

module.exports = {
	optimization: {
    minimize: true,
    minimizer: [
      // 压缩js，遇到se6不会报错
      new TerserWebpackPlugin({
        include: /\.min\.js$/
      })
    ]
  }
}
```

设置⼊⼝⽂件：

package.json 的 main 字段为 index.js

index.js

```js
if (process.env.NODE_ENV === "production") {
	module.exports = require("./dist/large-number.min.js");
} else {
	module.exports = require("./dist/large-number.js");
}
```

发布到npm上面去：

增加npm script钩子，每次npm publish的时候会执行一下打包

```json
"scripts": {
	"prepublish": "webpack"
}
```

登陆npm账号

```bash
npm login
```

发布

```bash
npm publish
```

**source map**

源代码与打包后的代码的映射关系，通过 source map 定位到源代码，方便我们调试代码，内部借助了 sourcemap-loader 来实现的。

在 webpack.dev.js devtool 中设置。

开发环境默认开启，线上环境关闭

* 如果线上不关闭，会把我们的业务逻辑暴露出来，线上排查问题的时候可以将 sourcemap 上传到错误监控系统。

配置推荐：

```js
devtool: "cheap-module-eval-source-map", // 开发环境
devtool: "cheap-module-source-map", // 生产环境
```

source map 关键字：

eval: 使⽤ eval 包裹模块代码

source map: 产⽣ .map ⽂件

cheap: 不包含列信息，只包含行信息

inline: 将 .map 作为 DataURI 嵌⼊，不单独⽣成 .map ⽂件

module:包含 loader 的 sourcemap

source map类型：

可以根据前面的关键字排列组合得到。

**ESLint**

方案一：与CI/CD系统集成

把代码检查放在 CI/CD 的 pipeline build 里面去。

安装 husky：

它自动会在本地项目的 .git 目录下面去生成一个 hook，它会读取 package.json 里的一些内容，比如说我们的precommit。

注意：安装 husky 之前项目要 git init 初始化好，如果连 git 目录都没有，它安装的过程中生成的 git hook 就没法放进去。

```bash
npm i husky -D
```

本地开发阶段增加 precommit 钩⼦：

git 进行代码提交的时候，可以使用 precommit 的 git 钩子。在调用 git commit 的时候，触发 precommit 钩子，先运行 precommit 命令，"precommit": "npm run lint-fix"，自动帮我们去检测代码，如果代码不通过 eslint。没有办法提交代码。

增加 npm script，通过 lint-staged 增量检查修改的⽂件：

```json
"scripts": {
	"precommit": "lint-staged"
},
"lint-staged": {
  "linters": {
  	"*.{js,scss}": ["eslint --fix", "git add"]
  }
}
```

方案二：与webpack等构建工具集成

webpack 构建的时候，遇见 eslint 的语法问题，直接中断构建，语法修改正确后才能构建成功。 

比较适合新的，一开始就使用 eslint 的项目。不适合老的项目去接入，因为这种方案，webpack 构建的时候它会默认把所有的文件都会进行检查。

eslint 基础解析包

```bash
npm i eslint eslint-loader -D
```

比较好且流行的eslint书写规范，我们自己就不定义这个规范了。

```bash
npm i eslint-config-standard -D
```

上面官方推荐我们安装的，它的校验规则要依赖于这些plugin进行验证。

```bash
npm i eslint-plugin-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node -D
```

因为.vue文件类似于html的格式，不是标准的javascript文件。eslint没法直接识别.vue文件里面的javascript代码，这个插件够让 eslint 识别一个文件里 script 标签下面的javascript。所以就用这个工具去解析我们的.vue文件就可以了。官方的推荐也是这么去做。

```bash
npm i eslint-plugin-html -D
```

兼容 babel 和 eslint

```bash
npm i babel-eslint -D
```

配置文件 .eslintrc

```json
{
  "extends": "standard",    // 使用哪个eslint规范。
  "plugins": ["html"],      // eslint检查.vue文件不报错。
  "parser": "babel-eslint"  // 代码都是要经过babel去处理过的，会有一些语法对eslint不是特别支持，可能就会出现一些问题，所以一般使用webpack和babel开发的项目都会指定它的parser是babel-eslint。 
}
```

使⽤ eslint-loader，构建时检查 JS 规范。

开发的过程中，每次修改代码，自动进行 eslint 检查。

```js
module.exports = {
	module: {
    rules: [
      {
				test: /\.(vue|js|jsx)$/,
				loader: 'eslint-loader',
				exclude: /node_modules/,
				enforce: 'pre'
			}
    ]
  }
}

```

使用 package.json scripts 手动检查代码规范

```json
{
	"scripts": {
    "lint": "eslint --ext .js --ext .jsx --ext .vue src/", // 检查代码是否符合规则
    "lint-fix": "eslint --fix --ext .js --ext .jsx --ext .vue src/" // 修复代码
  }
}
```

**优化构建时命令行的显示日志**

构建的过程，命令行里面会有一大堆的信息打印出来，很多不需要开发者关注，开发者更加关注的是，构建是否成功，构建报错的信息，构建 warning 的信息。对于构建成功的详细的信息，比如 loader 里输出的日志，插件的处理日志等并不是太需要关注的。

统计信息stats：

统计信息，可以分析构建速度或构建体积，也可以分析一些其他的数据出来。

![stats统计信息](/Users/zhaoyang/tool/images/前端知识体系/前端工程实践/webpack/stats统计信息.png)

命令行更加明显的提示信息：

使用 friendly-errors-webpack-plugin，对于构建成功，警告，错误都有很明显的信息提示。

stats 设置成 errors-only，生产环境直接设置。开发环境如果用的是 webpack-dev-server，就设置到这里。

```js
const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin')

module.exports = {
  plugins: [
  	new FriendlyErrorsWebpackPlugin()
  ],
  stats: 'errors-only'
};
```

使⽤效果：

success：构建成功的日志提示

warning：构建警告的日志提示

error：构建报错的日志提示

**构建异常和中断处理**

在 webpack 里面怎么做错误的捕获和异常的处理。

如何判断构建是否成功：

构建完之后，接下来要部署或一些其他的操作，像 CI/CD 的系统或者发布系统它怎么知道这次构建是否成功呢。

每次构建完之后输入一个 echo $? 获取错误码。如果错误码不为 0 的话，说明这次构建是失败的。也可以获取到error 的信息。

构建异常和中断处理：

webpack4 之前的版本构建失败不会抛出错误码 (error code)。

webpack4 给我们抛出了错误码，但是我们想针对异常的情况需要加额外的处理怎么做呢？

通过 node.js 中的 process.exit 规范去把错误码抛出来。这个规范也是尊从命令行里面的 error

* 0 表示成功完成，回调函数中，err 为 null

* 非 0 表示执行失败，回调函数中，err 不为 null，err.code 就是传给 exit 的数字

如何主动捕获并处理构建错误：

compiler 在每次构建结束后会触发 done 这个 hook，我们只要监听 done 这个 hook，就可以对它进行额外的一些操作。比如数据上报相关的信息。错误信息可以通过 stats 获取到。

process.exit 主动处理构建报错。

```js
module.exports = {
	plugins: [
    function() {
      this.hooks.done.tap('done', stats => {
        if (
          stats.compilation.errors && 
          stats.compilation.errors.length && 
          process.argv.indexOf('--watch') === -1
        ) {
          console.log('build error')
          process.exit(1)
        }
      })
    }
  ]
}
```

# vue-cli

## 原理

![vue-cli](images/vue-cli.png)

## 使用

**chainWebpack**

**public**

关于 public 里面存放素材的选择。

将来静态的资源会放到 public 里头，因为 public 会作为开发服务器的静态路径。这里的资源 webpack 是不会处理的，原封不动，位置和名字都不会变。

通过 webpack 的处理（相对路径）并获得如下好处：

* 脚本和样式表会被压缩且打包在一起，从而避免额外的网络请求。
* 文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误。
* 最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本。

如下情况考虑使用 public 文件夹：

* 你需要在构建输出中指定一个固定的文件名字。
* 你有上千个图片，需要动态引用它们的路径。
* 有些库可能和 webpack 不兼容，除了将其用一个独立的 <script> 标签引入没有别的选择。

使用 public 文件夹的注意事项：

一般情况下，没有特别需要的话，别用这个 public，它会增添很多繁琐的使用。

* 如果你的应用没有部署在域名的根部，那么你需要为你的 URL 配置 publicPath 前缀

  ```js
  // vue.config.js 
  module.exports = { 
    publicPath: process.env.NODE_ENV === 'production' 
    	? '/cart/' 
    	: '/' 
  }
  ```

* 在 public/index.html 等通过 html-webpack-plugin 用作模板的 HTML 文件中，你需要通过 <%= BASE_URL %> 设置链接前缀：

  ```html
  <link rel="icon" href="<%= BASE_URL %>favicon.ico">
  ```

* 在模板中，先向组件传入 BASE_URL：

  ```js
  data () { 
  	return { 
  		publicPath: process.env.BASE_URL 
  	} 
  }
  ```

  然后：

  ```vue
  <img :src="`${publicPath}my-image.png`">
  ```

**vuecli默认配置**

配置插件base：

设置环境为development、打包入口、output输出路径、pnp插件、vue相关模块noParse、js已经被cli-plugin-babel处理、vue文件应用cache-loader vue-loader、静态资源（images/svg/media/fonts）使用url-loader和file-loader处理、pug模版引擎、DefinePlugin插件、friendly-errors插件、terser-webpack-plugin压缩js插件

配置插件css：

postcss autoprefixer、生产环境使用`mini-css-extract-plugin`插件的loader提取css、开发环境使用`vue-style-loader`注入js生成内联样式、css-loader、生产环境且不提取css时需开启postcss-loader cssnano压缩css、sass-loader、less-loader、stylus-loader、生产环境使用`mini-css-extract-plugin`插件提取css并压缩css。

配置插件prod：

设置环境为production、使用webpack/lib/HashedModuleIdsPlugin插件保证没有变化的文件的hash值稳定、如果是测试环境禁用Webpack的优化，以提高构建速度

配置插件app：

output输出路径、非测试环境开启code splitting、HTML plugin（处理 `html-webpack-plugin` 默认排序问题 、配置模板参数、处理indexPath、模板压缩、保证异步代码块一致性hash、处理单页/多页应用（同时使用PreloadPlugin插件处理预加载资源））、将`public` 目录静态资源复制到输出目录（通常是 `dist` 目录）、处理link script跨域资源共享（CORS）和子资源完整性的设置

默认配置：

* loader
  * vue：vue-loader catch-loader
  * 图片：file-loader url-loader
  * 媒体资源：file-loader url-loader
  * 字体：file-loader url-loader
  * pug：pug-plain-loader raw-loader
  * css：`vue-style-loader` `css-loader` `postcss-loader` `sass-loader` `less-loader` `stylus-loader` `mini-css-extract-plugin` `autoprefixer`
  * js：`babel-loader` `eslint-loader` `thread-loader` ` catch-loader`内部使用cli-plugin-babel和cli-plugin-eslint
* optimization
  * splitChunks：code spliting
  * minimizer：js压缩混淆，内部采用TerserPlugin
* plugins
  * VueLoaderPlugin：解析和转换 Vue 单文件组件的 webpack 插件
  * DefinePlugin：设置环境变量
  * MiniCssExtractPlugin：css提取
  * OptimizeCssnanoPlugin：优化和压缩 CSS 的工具
  * HashedModuleIdsPlugin：文件指纹
  * ScriptExtHtmlWebpackPlugin：向 HTML 文件中自动注入标签，实现一些脚本的管理和控制
  * NamedChunksPlugin：生成的代码块（chunks）提供有意义的名称而不是使用数字标识符
  * HtmlWebpackPlugin：构建过程中生成一个 HTML 文件
  * PreloadPlugin：资源预加载preload prefetch
  * CaseSensitivePathsPlugin：处理由于不同系统区不区分大小写产生的问题
  * FriendlyErrorsWebpackPlugin：在终端中友好显示 Webpack 构建错误和警告
  * CopyPlugin：将public目录内容完整复制到dist目录

**最佳实践**

```js
module.exports = {
  // 1.webpack基础配置
	publicPath: '/',
  outputDir: 'dist',
  assetsDir: 'static',
  lintOnSave: process.env.NODE_ENV === 'development',
  productionSourceMap: false,
  
  // 2.devServer
  devServer: {
    // 端口
    port: port,
    // open: true,
    overlay: {
      warnings: false,
      errors: true
    },
    // 代理
    proxy: {
      '/api': {
        target: 'http://heimahr.itheima.net/',
        changeOrigin: true,
      }
    }
  },
  // 3.configurewebpack
  configureWebpack: {
    // 项目名称
    name: name,
    // cdn外链
    externals: externals,
    resolve: {
      // 设置别名
      alias: {
        '@': resolve('src')
      }
    }
  },
  // 4.chainWebpack
  chainWebpack(config) {
		// svg-sprite-loader
    // 优化
  }
}
```

## 构建速度优化

**速度分析：使用 speed-measure-webpack-plugin**

可以看到每个 loader 和插件执行耗时，重点的关注耗时较长的 loader 或插件，针对这些做优化。

```js
const SpeedMeatureWebpackPlugin = require('speed-measure-webpack-plugin');
const smp = new SpeedMeatureWebpackPlugin();
// 包裹webpack配置
const webpackConfig = smp.wrap({
  plugins: [
    new MyPlugin(),
    new MyOtherPlugin()
  ]
});
module.exports = webpackConfig;
```

**优化项**

1. 尽可能使用高版本的 webpack 和 Node.js
2. 缩小构建目标babel-loader排除node_modules
3. 优化文件查找路径（vuecli默认已经配置，使用webpack resolve）
   * 设置vue别名
   * 设置指定node_modules目录位置，减少模块所有层级
   * 缩小文件后缀查找范围
4. 多进程构建和代码压缩（vuecli默认已经配置生产环境开启）
5. 利用缓存提升二次构建速度（vuecli默认已经配置开启，使用cache-loader）

**使用高版本的 webpack 和 Node.js**

**缩小构建目标**

loader 是一个消耗性能的大户，官方不建议我们使用过多的 loader。

所以缩小构建范围主要是优化 loader 配置，缩小 loader 的查找范围。

test include exclude 三个配置项来缩⼩ loader 的处理范围，推荐 include。

比如 babel-loader 不解析 node_modules。

```js
module.exports = {
	module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader',
        exclude: 'node_modules'
      }
    ]
  }
}
```

**优化文件查找路径**

```js
module.exports = {
    // 子模块的查找策略
    resolve: {
      // 别名
      alias: {
        'react': path.join(__dirname, './node_modules/react/umd/react.production.min.js'),
        'react-dom': path.join(__dirname, './node_modules/react-dom/umd/react-dom.production.min.js')
      },
      // 减少模块搜索层级
      modules: [path.join(__dirname, 'node_modules')],
      // 缩小文件后缀的查找的范围，只设置查找.js，其他文件使用时写全文件后缀
      extensions: ['.js']
    }
  }
```

**多进程构建**

thread-loader

```js
module.exports = {
	module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'thread-loader',
            options: {
              workers: 3
            }
          },
          'babel-loader'
        ]
      }
    ]
  }
}
```

**多进程压缩代码**

terser-webpack-plugin 开启 parallel 参数，支持 es6 代码的压缩。

```js
const TerserPlugin = require('terser-webpack-plugin')
module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin({
        parallel: true
      })
    ]
  }
}
```

**利用缓存提升二次构建速度**

有缓存的话 node_modules 下面会有一个 .cache 目录。

babel-loader 开启缓存：

```js
module.exports = {
	module: {
    rules: [
      {
        test: /\.js$/,
        use: [{
          loader: 'babel-loader',
          options: {
            cacheDirectory: true
          }
        }]
      }
    ]
  }
}
```

terser-webpack-plugin 开启代码压缩缓存：

```js
const TerserPlugin = require('terser-webpack-plugin')

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        cache: true
      })
    ]
  }
}
```

使用 cache-loader 针对某个模块开启缓存：

```js
module.exports = {
	module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'cache-loader',
            options: {
              cacheDirectory: '/Users/dxm/project/ris-processmanager-fe/node_modules/.cache/babel-loader',
              cacheIdentifier: '2a366bb7'
            }
          },
          'babel-loader'
        ]
      }
    ]
  }
}
```

## 体积优化

### 体积分析

方式一：使用webpack-bundle-analyzer它可以把项目打包出来的文件体积直观的展示出来。我们可以重点关注体积大的文件进行优化。

```js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
  
 module.exports = {
   plugins: [
     new BundleAnalyzerPlugin()
   ]
 }
```

方式二：vuecli项目可以使用`"report": "vue-cli-service build --report"`命令

### vuecli打包后资源类型

* runtime.xxx.js：webpack runtime 运行时用于模块加载和解析的代码
* chunk-vendor.xxx.js：第三方包代码
  * 根据chunks的配置的同步异步的不同，会生成多个vendor。（比如：如果设置的vendor是同步的，通过异步引入的模块中包含需要垫片的内容。就会单独成成一个vendor）（vendor配置为同步，代码中的异步里的同步会单独抽离成一个vendor）
  * chunks配置: 'all/async/initial'，默认值async，全局chunks和某个模块chunks都会生效。针对的是该包在代码中是同步还是异步加载。基本都是使用all或initial
* chunk-common.xxx.js：源码公共模块
* app.xxx.js：源码
* chunk-xxx.xxx.js：路由懒加载组件代码

### runtime优化

优化策略：该部分代码量偏少，可以将其内联在html中，以减少网络请求，加快响应速度。

```js
module.exports = {
	chainWebpack(config) {
    // 1.将runtime单独生成一个文件
    config.optimization.runtimeChunk('single')
    // 2.内联在html中
    config
      .plugin('ScriptExtHtmlWebpackPlugin')
      .after('html')
      .use('script-ext-html-webpack-plugin', [{
        // `runtime` must same as runtimeChunk name. default is `runtime`
        inline: /runtime\..*\.js$/
      }])
      .end()
    // 内联后，排除runtime的preload
    config.plugin('preload').tap(() => [
      {
        rel: 'preload',
        // to ignore runtime.js
        // https://github.com/vuejs/vue-cli/blob/dev/packages/@vue/cli-service/lib/config/app.js#L171
        fileBlacklist: [/\.map$/, /hot-update\.js$/, /runtime\..*\.js$/],
        include: 'initial'
      }
    ])
  }
}
```

### 按需导入

**element**

**echarts** 

效果：减少565k

```js
// 完整引入
// import * as echarts from "echarts";

// 按需导入echearts
// 1.引入echarts核心包
import * as echarts from "echarts/core";
// 2.引入图表类型（折线图）
import { LineChart } from "echarts/charts";
// 3.引入使用到的组件（直角坐标系组件）
import { GridComponent } from "echarts/components";
// 4.引入渲染器（canvas渲染器）
import { CanvasRenderer } from "echarts/renderers";
// 5.注册所有的引入
echarts.use([LineChart, GridComponent, CanvasRenderer]);
```

### 预加载资源优化

概念：针对css/js资源使用preload或prefetch进行预加载，vuecli项目默认配置。

preload/prefetch概念：`preload` 适用于当前页面所需的关键资源（立即下载资源），而 `prefetch` 则适用于未来可能导航到的页面所需的资源（空闲时下载资源）。

优化策略：去除默认的prefetch

* 项目中通过路由懒加载的页面过多，就会导致页面已进入产生大量通过prefetch预加载的css、js资源导致首屏渲染时间长，所以该场景去除prefetch的注入。

  ```js
  config.plugins.delete('prefetch')
  ```

### code spliting

* 默认vuecli只在splitChunks中设置了initial（初始化加载的同步模块）的vendor和common，以分离/node_modules/中的包。分离后整体大小不变，只会将第三方包从app.xxx.js中分离出来。
* 优化原因：
  * 如果用到的包体积较大，可以单独拆分开来，以避免所有第三方包都在vendor中，如果某一个包发生变化，整个vendor会发生变化，从而失去缓存优化。
  * 将一个很大的包才分成多个小包，能够充分利用浏览器并发请求的优势，加快页面响应速度。

* 优化策略：

  ```js
  module.exports = {
  	chainWebpack(config) {
      config
        .optimization.splitChunks({
        	chunks: 'all',
          cacheGroups: {
            echarts: {
              name: 'chunk-echarts', // split elementUI into a single package
              priority: 20, // the weight needs to be larger than libs and app or it will be packaged into libs or app
              test: /[\\/]node_modules[\\/]_?echarts(.*)/ // in order to adapt to cnpm
            },
            elementUI: {
              name: 'chunk-elementUI', // split elementUI into a single package
              priority: 20, // the weight needs to be larger than libs and app or it will be packaged into libs or app
              test: /[\\/]node_modules[\\/]_?element-ui(.*)/ // in order to adapt to cnpm
            }
          }
      	})
  	}
  }
  ```

### tree shaking

默认情况下webpack中的js tree shaking是通过`optimization.usedExports`开启的，无需做额外工作。

我们要处理的是css tree shaking：将css从269k压缩到96k。

1. 安装

   ```bash
   npm i glob-all purify-css purifycss-webpack -D
   ```

2. 使用

   ```js
   // vue.config.js
   const path = require('path')
   const glob = require('glob-all')
   const PurifyCSSPlugin = require('purifycss-webpack')
   module.exports = {
   	chainWebpack(config) {
       config.plugin('purify-css').use(PurifyCSSPlugin, [
         {
           paths: glob.sync([path.resolve(__dirname, './src/**/*.vue')])  // 根据你的项目结构配置
         }
       ])
     }
   }
   ```

### cdn外链

`vue.config.js`

```js
let externals = {}
let cdn = { css: [], js: [] }
if (process.env.NODE_ENV === 'production') {
  externals = {
    // 包名: 引入的 js 脚本文件中的名称
    vue: 'Vue',
    'element-ui': 'ELEMENT',
    xlsx: 'XLSX'
  }
  cdn = {
    css: [
      'https://unpkg.com/element-ui/lib/theme-chalk/index.css' // element-ui css 样式表
    ],
    js: [
    	// vue must at first!
      'https://unpkg.com/vue@2.6.12/dist/vue.js',
      'https://unpkg.com/element-ui@2.15.3/lib/index.js',
      'https://cdn.jsdelivr.net/npm/xlsx@0.16.6/dist/xlsx.full.min.js'
    ]
  }
}

module.exports = {
  configureWebpack: {
    externals: externals
  }
}
```

`index.html`

```html
<!DOCTYPE html>
<html>
  <head>
    <!-- 引入样式 -->
    <% for(var css of htmlWebpackPlugin.options.cdn.css) { %>
      <link rel="stylesheet" href="<%=css%>">
    <% } %>
  </head>
  <body>
    <div id="app"></div>
    <!-- built files will be auto injected -->
    <!-- 引入 JS -->
    <% for(var js of htmlWebpackPlugin.options.cdn.js) { %>
      <script src="<%=js%>"></script>
    <% } %>
  </body>
</html>
```

### scope hoisting

默认生产环境已开启。

作⽤域提升（Scope Hoisting）是指 webpack 通过 ES6 语法的静态分析，分析出模块之间的依赖关系，尽可能地把模块放到同⼀个函数中。

没有开启 Scope Hoisting 的现象：

构建之后的代码存在大量的闭包代码。对于每一个模块打包出来都会有一个函数的包裹。

会导致的问题：

* 大量函数的闭包包裹代码，会导致打包出来的 bundle 文件体积增大（模块越多越明显）。

* 通过函数闭包的形式包裹代码，运行代码时创建的函数作用域变多，内存开销变大。

模块转换分析：

被 webpack 转换后的模块会带上⼀层包裹。

import 会被转换成 __webpack_require，export 也会做相应的转换。

进⼀步分析 webpack 的模块机制：

打包出来的是⼀个 IIFE (匿名闭包)

modules 是⼀个数组，每⼀项是⼀个模块初始化函数

__webpack_require ⽤来加载模块，返回 module.exports

通过 WEBPACK_REQUIRE_METHOD(0) 启动程序

scope hoisting 原理：

原理：将所有模块的代码按照引⽤顺序放在⼀个函数作⽤域⾥，然后适当的重命名⼀些变量以防⽌变量名冲突。

对⽐：通过 scope hoisting 可以减少函数声明代码和内存开销。

scope hoisting 使⽤：

必须是 ES6 语法，CJS 不⽀持。

webpack3 需要手动开启。

```js
module.exports = {
  plugins: [
    new webpack.optimize.ModuleConcatenationPlugin()
  ]
}
```

webpack4 mode 为 production 默认开启。webpack4 mode 为 development 时，可以使用 optimization.concatenateModules 开启 Scope Hoisting。

```js
module.exports = {
  optimization: {
    concatenateModules: true
  }
}
```

### 代码压缩

vuecli默认对js、css、html都做了代码压缩。

js 文件的压缩：

webpack4 里，内置了uglifyjs-webpack-plugin 插件，所以默认打包出来的 js 文件就已经压缩过了。不需要再做其他的操作。当然也可以手动的安装这个插件，给它设置一些额外的参数，比如默认开启它的并行压缩。

css ⽂件的压缩：

webpack3 的时候我们可以通过 css-loader 去设置一个 minify 参数来压缩 css，但是 css-loader 在 1.0 的版本之后去掉了这个参数，所以现在是没办法直接通过 css-loader 设置参数的方式做 css 的压缩。

现在需要使用 optimize-css-assets-webpack-plugin 插件，同时使用 css 的预处理器 cssnano，匹配到所有的 css文件，再用这个 css 处理器进行 css 的压缩。

```js
const OptimizeCssAssetsWebpackgin = require('optimize-css-assets-webpack-plugin')

module.exports = {
	plugins: [
    new OptimizeCssAssetsWebpackgin({
      assectNameRegExp: /\.css$/g,
      cssProcessor: require('cssnano') // 它是postcss的依赖，不用单独安装
    })
  ]
}
```

html ⽂件的压缩：

修改 html-webpack-plugin，设置压缩参数 minify。

```js
const path = require('path')

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: path.join(__dirname, './src/index.html'), // HtmlWebpackPlugin它的html模版所在的位置
      filename: 'index.html', // 指定打包出来的html的文件名称
      chunks: ['index'], // 指定生成的这个html它要使用哪些chunk
      inject: true, // 打包出来的chunk的js css会自动的注入到html中来。
      minify: {
        html5: true,
        collapseWhitespace: true,
        perserveLineBreaks: false,
        minifyCSS: true,
        minifyJS: true,
        removeComments: false
      }
    })
  ]
}
```

### 图片压缩

图片资源相对是较大的，我们可以通过在线工具手动进行图片的批量压缩。构建工具一部分职责就是将平时手动完成的事做成自动化。

方式一：image-webpack-loader

成果：9张图片由396k压缩到147k。

```js
module.exports = {
	chainWebpack(config) {
		config.module
      .rule('images')
      // .test(/\.(png|jpe?g|gif|webp|svg)(\?.*)?$/)
      .use('image-webpack-loader')
      .loader('image-webpack-loader')
      .options({
        // bypassOnDebug: true, // webpack@1.x
        // disable: true, // webpack@2.x and newer
        mozjpeg: {
          progressive: true,
          quality: 90 // 登录页背景图默认值虚化严重，调整该参数为90。该参数下：204k到78k，且不影响图片显示效果
        },
        // optipng.enabled: false will disable optipng
        optipng: {
          enabled: false,
        },
        pngquant: {
          quality: [0.65, 0.90],
          speed: 4
        },
        gifsicle: {
          interlaced: false,
        },
        // the webp option will enable WEBP
        webp: {
          quality: 75
        }
      })
      .end();
  }
}
```

方式二：imagemin-webpack-plugin

方式三：node imagemin

imagemin的优点分析

* 有很多定制选项 

* 可以引入更多第三方优化插件，例如pngquant 

* 可以处理多种图片格式

imagemin的压缩原理

* pngquant: 是一款 PNG 压缩器，通过将图像转换为具有 alpha 通道（通常比 24/32 位 PNG 文件小 60-80％）的更高效的 8 位 PNG 格式，可显著减小文件大小。 

* pngcrush: 其主要目的是通过尝试不同的压缩级别和 PNG 过滤方法来降低 PNG IDAT 数据流的大小。 

* optipng: 其设计灵感来自于 pngcrush。optipng 可将图像文件重新压缩为更小尺寸，而不会丢失任何信息。 

* tinypng: 也是将 24 位 png 文件转化为更小有索引的 8 位图片，同时所有非必要的 metadata 也会被剥离掉。

### 动态polyfill服务

Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign、Array.from）都不会转码。如果想让这个方法运行，必须使用 babel-polyfill。  

Polyfill 方案：

![babel-polyfill方案](images/webpack/babel-polyfill方案.png)

方法一：@babel/polyfill

以全局变量的⽅式注⼊进来的。windows.Promise，它会造成全局对象的污染。

```bash
npm install --save @babel/polyfill
```

```js
// index.js 顶部
import "@babel/polyfill"
```

babel-polyfill 打包后体积：88.49k，占比 29.6%。

按需加载，减少冗余：

会发现打包的体积⼤了很多，这是因为 polyfill 默认会把所有特性注⼊进来，假如我想我⽤到的 es6+，才会注⼊，没⽤到的不注⼊，从⽽减少打包的体积，可不可以呢，当然可以。

```json
{
  "presets": [
  	[
    	"@babel/preset-env",
     	{
        targets: {
          edge: "17",
          firefox: "60",
          chrome: "67",
          safari: "11.1"
        },
        corejs: 2, // 新版本需要指定核⼼库版本
        useBuiltIns: "usage" //按需注⼊
      }
    ]
	]
}
```

useBuiltIns 选项是 babel 7 的新功能，这个选项告诉babel如何配置@babel/polyfill。 它有三个参数可以使⽤： ①entry: 需要在webpack的⼊⼝⽂件⾥import "@babel/polyfill"⼀次。babel会根据你的使⽤情况导⼊垫⽚，没有使⽤的功能不会被导⼊相应的垫⽚。 ②usage: 不需要import，全⾃动检测，但是要安装@babel/polyfill。（试验阶段） ③false: 如果你import "@babel/polyfill"，它不会排除掉没有使⽤的垫⽚，程序体积会庞⼤。(不推荐)

请注意 usage 的⾏为类似 babel-transform-runtime，不会造成全局污染，因此也会不会对类似 Array.prototype.includes() 进⾏polyfifill。

方法二：@babel/plugin-transform-runtime

当我们开发的是组件库，⼯具库这些场景的时候，polyfill 就不适合了，因为 polyfifill 是注⼊到全局变量，window下的，会污染全局环境，所以推荐闭包⽅式：@babel/plugin-transform-runtime，它不会造成全局污染。

```bash
npm install --save-dev @babel/plugin-transform-runtime
npm install --save @babel/runtime
```

```json
{
  "presets": [
		"@babel/preset-env",
 	],
	"plugins": [
  	[
			"@babel/plugin-transform-runtime",
     	{
        "absoluteRuntime": false,
        "corejs": false,
        "helpers": true,
        "regenerator": true,
        "useESModules": false
       }
 		]
 	]
}
```

方法三：构建体积优化，动态 polyfill

Polyfill Service 原理：

识别 User Agent，下发不同的 Polyfill。

如何使用动态 Polyfill service：

polyfill.io 官方提供的服务

https://polyfill.io/v3/polyfill.min.js

# vite

**Webpack**

1. 打包方式：Webpack 是一个模块打包器（bundler）。它通过递归地构建一个依赖图，包含应用程序中所需的每个模块，然后将所有这些模块打包成一个或多个 bundle（通常是 JavaScript 文件）。
2. 转译过程：Webpack 使用 loader 来处理非 JavaScript 文件（如 CSS、图片、字体等），并且经常结合 Babel 一起使用以转译 JavaScript 代码（如将 ES6+ 转换为兼容旧浏览器的代码）。
3. 开发模式：在开发模式下，Webpack 提供了热模块替换（Hot Module Replacement, HMR）等功能，但仍需要打包和服务整个应用，可能导致较慢的启动和热更新速度。
4. 优化和插件：Webpack 提供了广泛的优化选项和插件系统，可以高度定制打包过程。

**Vite**

1. 打包方式：Vite 在开发模式下不使用传统的打包方法。它利用现代浏览器的原生 ES 模块支持，可以直接在浏览器中加载模块。这意味着启动速度更快，因为 Vite 只需为请求的文件进行转换和加载。
2. 转译过程：Vite 在开发时使用 [esbuild](https://esbuild.github.io/) 进行 JavaScript 和 TypeScript 的快速转译。esbuild 使用 Go 编写，速度远快于基于 JavaScript 的传统工具。以及对js或ts进行优化、压缩、Tree Shaking。
3. 开发模式：由于 Vite 在开发时不进行打包，它提供了极快的热更新速度和启动时间。
4. 生产构建：尽管在开发模式下 Vite 不进行打包，但它在生产构建中使用 Rollup 进行高效的打包。Rollup 作为生产打包器，为最终部署提供了优化的包。
5. 优化和插件：Vite 同样支持插件系统，但由于其不同的架构，插件的种类和用法可能与 Webpack 不同。

**总结**

- Webpack适合于需要高度定制和优化的复杂项目，其生态系统成熟，提供了广泛的插件和加载器。
- Vite侧重于快速的开发体验和简单的配置，特别适合于现代浏览器优先的项目和快速原型开发。

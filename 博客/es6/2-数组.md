1. ES5中数组有多少种遍历的方法？
    1. for循环
    2. forEach </br>
      forEach跟for做对比，forEach的写法更加简洁，但是它也带来了问题，它不支持break和continue，也就是说当
      你选用forEach对数组进行遍历的时候，你要知道break和continue已经失效了，它所遍历的就是从头到尾，每个元
      素必须遍历到。这是它的用法。
    3. every
        ```
          const arr = [1, 2, 3, 4, 5]
          arr.every(function (item) {
            console.log(item) // 1
            // return true
          })
        ```
        every去遍历一个数组的时候，它能不能继续向下遍历取决于这个函数体的返回值，而上面这个函数的返回值默认是false，
        也就是说不要继续往下遍历，这是它的默认值，如果你想改变它的默认行为，你要在这个函数体后面加一句，return true，
        也就是说这个时候已经能遍历所有的元素。既然这个时候它和forEach的行为很像了，那为什么要新增every的api，因为
        forEach它有弊端，它是有应用场景的局限性的，它不支持break和continue。但every可以，因为every能不能向下遍
        历取决于你这个函数的返回值，这样就受你程序的控制了。这是它们两个本质的区别。every返回值是布尔值，每个函数体
        都返回true，every的返回值为true，否则为false。
    4. forEach和every虽然不能直接写break和continue，但是可以实现一样的效果。
        1. forEach
            1. continue
              可以使用条件判断的方式实现
            2. break
                1. try catch throw
                    ```
                      let arr = [1, 2, 3, 4, 5]
                      try{
                        arr.forEach(item => {
                          if (item === 3) {
                            throw new Error('出错了')
                          } else {
                            console.log(item)
                          }
                        })
                      } catch(e){
                        throw e
                      }
                    ```
                2. 空跑循环 </br>
                  在外层加一个标识。这种会影响性能，因为效果是实现了，但是循环并没有停止，会一直遍历到最后。
                    ```
                      let breakFlag = false
                      let arr = [1,2,3,4,5]
                      arr.forEach(item => {
                        if (breakFlag === true) {
                          return
                        }
                        if (item===3) {
                          breakFlag = true
                          return
                        }
                        console.log(item)
                      })
                    ```
        2. every可以使用条件判断的方式实现continue。使用条件判断的加上return false的方式实现break。
    5. for in
      for in是为object来做遍历来设计的，不是为数组设计的。它确实能遍历数组，但是会有问题。
        ```
          const arr = [1, 2, 3, 4, 5]
          for (let index in arr) {
            console.log(index, arr[index]) // 0 1, 1 2, 2 3, 3 4, 4 5
          }
        ```
      之所以for in能遍历数组，有两个因素。第一数组也是对象的一种，第二，数组是可遍历的。在ES6中，关于一个对象是不
      是可遍历的，会有另一种定义，特别强调，一个对象是不是可遍历不是你理解的像数组那样它就是，比如说你觉得对象是可
      遍历的，数组是可遍历的，除了这两种结构之外，都是不可遍历的。如果你用这个方式去判断一个对象是不是可遍历的，那
      就大错特错。数组既然是对象，我是不是就能往这个对象上挂一些属性，比如说arr.a = 8，按照我们刚才讲的，这个自定
      义属性应该不是数组中的一个元素，我们这个数组中的元素是12345。这个时候我增加了一个属性，看看遍历出来的是什么。
      不仅把12345遍历出来了，还把a和8遍历出来了，这个就有点怪异了，数组里面的索引怎么可能是a呢，这个时候你发现它是
      达不到预期的，我的索引0到4，这个时候a按照常规的理解，它不应该是索引，我们说数组的索引一般都是数字，它不应该是
      一个字符串，那么在这里a很明显它就是个字符串。这就是for in遍历数组的瑕疵。因为for in它是为对象设计的，很明显
      数组它也是一个对象，数组的索引，大家认为它就是数字，其实不是的，它也可以是字符串的。但是要注意for in遍历出数
      组的索引index是字符串，for遍历的index是数字。那么for in能不能做break和continue呢，因为这个是遍历的时候
      非常重要的控制元素，for in它是支持break和continue的。
2. ES6中它们是怎么做遍历的？  
    1. for of 
      你要判断一个对象是不是可遍历的不能用常规的思维说它是不是个数组或者是不是一个object，你如果这么判断那就大错特
      错，既然不能用这个思维去判断一个对象是不是可遍历的，那意味着很多对象它跟数组或object不一样，但是还能被遍历，
      是不是可以这样理解。像every,forEach,for循环，它都是专门针对数组的遍历。而for in它是专门为object设计的遍
      历。也就是说这几种方法就是为数组和object设计的，那除了数组和object之外可遍历的对象拿什么遍历呢，那就是我们
      今天要讲的for of。在es6之前，你要认为只有数组和object可以遍历，没什么问题，因为大家平时的遍历接触的无非就
      是object和数组，那么这两种情况的遍历就用我们上面讲的for,forEach,every,for in这四种方法足够用了，但是到
      了es6的时候不是这样了，es6允许你自定义数据结构，这个数据结构不是数组也不是object，什么样的数据结构都可以，
      什么样的类型都可以，你可以随意组装一个数据结构，组装出来它既不是数组也不是object，但是只要你按照es6的这个标
      准，是可以把它构造成一个可遍历的，但是这个可遍历的对象不能用for,forEach,every,for in去遍历。那怎么办呢，
      就用我们接下来讲的for of。for of它也可以遍历数组，只是它的功能比遍历数组更强大而已。
3. 数组的转换功能
    1. 伪数组
      函数的arguments和dom中的nodelist就是伪数组，它和数组非常相似，在理解的时候你通常会认为集合就等于数组，然而
      在编程的时候你发现集合它调用不了数组的api，比如我们刚才说的arguments，如果你直接用arguments.slice()会发现
      报错，说明arguments不具备slice的方法，这个是伪数组的概念。伪数组具备数组的一些特性，比如它们都具备长度都能遍
      历，但是它不能直接调用数组的方法。既然它在特性上像数组，但是又不能直接调用数组的方法，那我们比如说想遍历想查找，
      我们该怎么做呢，首先你要把它转换成数组。因为它是可转换的。
      伪数组具备两个特征：
          1. 这个对象是按照索引方式存储数据的
          2. 它具备一个length属性 </br>
          {0: 'a', 1: 'b', length: 2}这个对象就叫伪数组
    2. es5中将伪数组转换成数组
        1. [].slice.call(arguments) // 把arguments转换成数组
        2. [].slice.call(document.querySelectorAll('img')) // 把NodeList转换成数组
    3. es6的做法
        1. Array.from // 这个from就是用来转换伪数组到数组的 </br>
          let args = Array.from(arguments) </br>
          let img = Array.from(document.querySelectorAll('img'))
        2. from除了能把伪数组转换成数组这个功能之外，它还具备其他的功能吗
            1. from参数 </br>
              Array.from(arrayLike, mapFn, thisArg)
                1. arrayLike  伪数组
                2. mapFn  遍历函数，说明from还具备map也就是遍历的功能
                3. thisArg  mapFn中的this指向
            2. 初始化数组长度为5，每项为1
                1. es5
                    ```
                      let array = Array(5)
                      for (let i = 0, len = array.length; i < len; i++) {
                        array[i] = 1
                      }
                    ```
                    这里用forEach不行
                2. es6 
                    ```
                    let array = Array.from({length: 5}, function () {return 1})
                    ```
4. 如何创建一个新数组
    1. es5生成新数组
        1. let array = Array(5)
        2. let array = []
    2. es6
        1. 上节讲的Arrar.from也是新生成数组的一种方式
        2. Array.of </br>
          快速的把n个元素放到一个数组里面去，这个方法就是array.of
            1. es5使用生成一个新数组，然后往里面push的方法
            2. es6
              let array = Array.of(1, 2, 3, 4, 5)
        3. Array.prototype.fill
            1. let array = Array(5).fill(1)  // 生成一个长度为5每一项为1的数组
            2. Array().fill(value, start, end)
              value 填充的值
              start 填充指定范围的起始位置，默认值是0
              end 填充指定范围的截止位置，默认值是数组的最后一个元素
            3. 不用来生成新数组，也可以用做对已有数组的填充，就是替换数组的某一块区域的值 </br>
                // 将数组的第三项第四项更换为8
                ```
                  let array = [1, 2, 3, 4, 5]
                  console.log(array.fill(8, 2, 4)) // [1, 2, 8, 8, 5]
                  console.log(array) // [1, 2, 8, 8, 5]
                ```
    3. 所以以后在业务场景中再生成新数组，不要只知道加一个字面量或用Array的构造函数去做，你有很多种方法，es6至少提
      供给你了三种方法，from,of,fill
5. 如何查找数组
    1. 在遍历的过程中去找都可以，只要是遍历都能找到这个元素
    2. 关于查找分几个概念
      1.查找的目的是为了验证某个元素在这个数组当中
      2.还有个查找的维度是我要把满足每个条件的筛出来
    3. es5
        1. filter
          ```
            let array = [1, 2, 3, 4, 5]
            let find = array.filter(function (item) {
              return item === 3 // return item === 6
            })
            console.log(find) // [3]
            console.log(find) // []
          ```
          我们在用es5的filter做查找的时候，如果找到，那返回的这个数组一定是不为空的，也就是数组的长度一定是不为0，找
          到与没找到它都会返回一个数组，你要去判断这个数组的长度来确定元素有或者没有，这是判断有无。filter去查找的时
          候，它会把所有满足条件的元素都给筛出来。所以查找的两个filter都能够达到维度。filter功能上很全面，但是它有缺
          点。如果数组长度非常大，数据非常大，我就想知道这个数组中有没有这个元素，我不关心它有多少个，出现多少次，我要
          确保性能，它虽然能实现这个东西，但它不是最高效的。那么在es6中新增加了一个方法验证查找的，就是来弥补这个缺陷
          的。这个方法叫find。
  4.es6
      1. Array.prototype.find
          ```  
            let array = [1, 2, 3, 4, 5]
            let find = array.find(function (item) {
              return item === 2
            })
            console.log(find) // 2
          ```
          它不关注返回的所有的值，我找到了2我就返回2这个数据，没有就返回undefined，它跟filter的返回值完全不一样。
          filter关注的是满足你条件的所有值。而find关注的是满足你条件的第一个值。找到了满足你条件的第一个值，我就返
          回，不再往下找了。它关注的是有和没有而不是所有。这是它的优点也是它的缺点。这就是find和filter的区别。
      2. Array.prototype.findIndex <br/>
        它跟find是一对。原理和特点都是一样的。唯独的区别就是find找符合的元素，findIndex找符合元素的下标。
6. 数组总结</br>
  其实关于数组在es6这一部分新增的功能主要围绕了几个方面。因为我们用数组无非就是这几个吗。遍历转换生成吗。
    1. 遍历
    2. 转换
      在转换这个过程中，指的是伪数组到数组的转换。
    3. 生成
      我们想初始化的时候。那么es6提供了很多的数组生成的方法。非常快捷高效。
    4. 查找
      最后一个是，只要你用数组基本上都要用查找。为什么要用数组呢，不就是为了找吗。你不能说我生成了一个数据结构，就把
      数据存那，我不用啦，封存啦。不会的。你存这个数据结构就是为了读取查找。
      
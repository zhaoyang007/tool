当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。

宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。

单线程 - 只有一个线程，同一时间只能做一件事情

### 原因 - 避免dom渲染的冲突
1. 浏览器需要渲染dom
2. js可以修改dom结构

所以说js在浏览器中应用必须是单线程的。而且呢还要和浏览器的渲染的线程共用一个线程。

### 解决方案 - 异步

  针对js单线程的机制。我们的解决方案是异步。因为遇到一些需要等待的事情我们不可能等地它做完我们再往下走，不然这个等待的时
  间里页面就是卡死的状态，这显然是不合理的。所以我们将这些需要等待的事情让它们成为异步，就是遇到这样的事我们先不管它，先
  让其他的js代码运行。不要让这个等待影响我们后面的事情。然后等这个异步等待结束后我们再处理这个异步。就是我们先把该执行
  的执行完了，异步最后再说。这是异步的一个核心逻辑。

### 异步解决方案的问题

异步是js单线程的一个唯一解决方案，现在来看也是一个非常合适非常高效的解决方案，但是呢它还是有一些问题的。

1. 没有按照书写的顺序来执行，可读性差
2. callback中不容易模块化<br>
  因为异步它要回过头来执行这么一个模式，所以它要传一个callback函数。callback中不容易模块化，callback是传一个函数过
  去的，你不可能把这个函数写的特别复杂，因为它本来就没有按照书写顺序来执行，你又把callback写的特别复杂，就容易出现耦
  合度不高的问题，以后有问题就不好排查。所以之后的Promise, async/await就是为了解决这两个问题来服务的。

### event loop - 异步的实现方式
1. 事件轮询，js实现异步的具体解决方案。js的异步就是通过这种方式来实现的。
2. 实例分析

    ```
    setTimeout(function () {
      console.log(1)
    }, 100)
    setTimeout(function () {
      console.log(2)
    })
    console.log(3)
    // 主进程
    console.log(3)
    // 异步队列
    // 立刻被放入
    function () {
      console.log(2)
    }
    // 100ms之后被放入
    function () {
      console.log(1)
    }
    ```

    第一步同步代码直接扔进主进程中执行，第二步异步函数要放在异步队列中，第三步等着同步代码执行完成之后，再去异步队列中看，有
    的话就拿到主进程中来执行。只要主进程的代码都执行完后，就去监视异步队列中有没有异步函数，有的话就立刻拿到主进程中去执行。
    这就是事件轮询的机制。事件轮询机制就是异步的实现原理和本质。

### 宏任务 微任务
在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。

一个宏任务在执行的过程中，是可以添加一些微任务的。

在当前的微任务没有执行完成时，是不会执行下一个宏任务的。

所有会进入的异步都是指的事件回调中的那部分代码也就是说new Promise在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的。

#### 任务分类
  * 宏任务：同步代码 I/O setTimeout setInterval requestAnimationFrame
  * 微任务：Promise MutationObserver

#### 任务的优先级
执行一个宏任务(先执行同步代码) --> 执行所有微任务 --> UI render --> 执行下一个宏任务 --> 执行所有微任务 --> UI render --> ......

根据HTML Standard，一轮事件循环执行结束之后，下轮事件循环执行之前开始进行UI render。即：macro-task任务执行完毕，接着执行完所有的micro-task任务后，此时本轮循环结束，开始执行UI render。UI render完毕之后接着下一轮循环。但是UI render不一定会执行，因为需要考虑ui渲染消耗的性能已经有没有ui变动。

微任务比宏任务执行的更早，每一次 call stack 结束，都会触发 DOM 渲染
  * 宏任务：DOM 渲染后再触发
  * 微任务：DOM 渲染前会触发

#### async/await函数
因为，async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种。所以在使用await关键字与Promise.then效果类似：

```
setTimeout(_ => console.log(4))
async function main() {
  console.log(1)
  await Promise.resolve()
  console.log(3)
}
main()
console.log(2)
```

async函数在await之前的代码都是同步执行的，可以理解为await之前的代码属于new Promise时传入的代码，await之后的所有代
码都是在Promise.then中的回调。
  
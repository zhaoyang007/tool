## 闭包
主流的编程语言是基于 lambda 演算的函数式编程语言，所以这个最初的闭包定义，使用了大量的函数式术语。一个不太精确的描述是“带有一系列信息的λ表达式”。对函数式语言而言，λ表达式其实就是函数。

我们可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。

至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。

总之它函数定义的地方和函数执行的地方它是不一样的。自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在函数执行的地方。

### 一般情况下引起的形式有两种
  1. 函数作为参数被传递

      也就是函数在这个地方定义好之后，传递到另一个地方去执行。

      ```
      function print (fn) {
        let a = 200
        fn()
      }
      let a = 100
      function fn () {
        console.log(a)
      }
      print(fn) // 100
      ```
  2. 函数做为返回值被返回

      函数在这个地方定义好之后，它会被返回到另一个地方去执行。

      ```
      function create () {
        let a = 100
        return function () {
          console.log(a)
        }
      }
      let fn = create()
      let a = 200
      fn() // 100
      ```

### 作用域，自由变量，变量的生命周期
1. 作用域：作用域就是查找变量，对象，函数的的地方

2. 作用域链：自由变量查找的顺序

3. 自由变量：当前作用域没有定义，但是使用了的变量

4. 变量的生命周期

    在javascript中声明一个变量是使用var来声明的。一个变量的声明意味着就是我们在内存当中申请了一个空间用来存储。这个内存也就是
    我们电脑的运行内存，如果我们一直的声明变量，不释放的话。会占用很大的内存。在c/c++当中是需要程序员在合适的地方手动的去释放变
    量内存，而javascript和java拥有垃圾回收机制，他们会自己回收。但有的时候我们需要让局部变量的生命周期长一点，这个时候在js当
    中就有了闭包，他能够很好的解决这个问题。

    JavaScript执行过程中内存分配：

      1. 为变量对象分配需要的内存
      2. 在分配到的内存中进行读/写操作
      3. 不再使用时将其销毁，释放内存

    内存管理不善，会出现内存泄露，造成浏览器内存占用过多，页面卡顿等问题。

    垃圾回收机制：

      JavaScript中有自动垃圾回收机制，会通过标记清除的算法识别哪些变量对象不再使用，对其进行销毁，释放其内存。也就是说，执行环
      境会负责管理代码执行过程中使用的内存。开发者也可在代码中手动设置变量值为null（a = null）进行标记清除，让其失去引用，以便
      下一次垃圾回收时进行有效回收。

      局部环境中，函数执行完成后，函数局部环境声明的变量不再需要时，就会被垃圾回收销毁（理想的情况下，闭包会阻止这一过程）。

      全局环境只有页面退出时才会出栈，解除变量引用。所以开发者应尽量避免在全局环境中创建全局变量，如需使用，也要在不需要时手动标
      记清除，将其内存释放掉。
      
### 闭包应用
  1. 由于js作用域链的存在，只能内部环境访问外部环境，不能从外部访问内部

      ```
      function a() {
        var i=0;
        function b() {
          alert(++i)
        }
        return b
      }
      var c = a()
      c()
      ```
  2. 由于js变量生命周期的存在，变量无法常驻内存

      ```
      // 创建10个'<a>'标签，点击的时候弹出对应的序号
      let i, a
      for (i = 0; i < 10; i++) {
        a = document.createElement('a')
        a.innerHTML = i + '<br>'
        a.addEventListener('click', function (e) {
          e.preventDefault()
          alert(i)
        })
        document.body.appendChild(a)
      }
      // 上面的写法，点击每个a标签弹出来的都是10
      // 因为事件绑定的函数定义时里面的i是找的全局作用域i，当遍历结束后，这个全局i已经变成10了。这时点击触发函数里面的i就会
        向上找到全局变量i，所以都会弹出10。
      let a
      for (let i = 0; i < 10; i++) {
        a = document.createElement('a')
        a.innerHTML = i + '<br>'
        a.addEventListener('click', function (e) {
          e.preventDefault()
          alert(i)
        })
        document.body.appendChild(a)
      }
      // 上面的写法，i就变成了块级作用域中的变量，每次for循环执行的时候都会形成一个新的块，这时配合事件绑定的函数就形成了一
        个闭包，所以每次循环的变量i都会保存下来。这时点击触发函数里面的i就会向上找到块级作用域里的变量i，所以就会弹出对应的i。
      let i, a
      for (i = 0; i < 10; i++) {
        a = document.createElement('a')
        a.innerHTML = i + '<br>'
        a.addEventListener('click', (function (i) {
          return function (e) {
            e.preventDefault()
            alert(i)
          }
        })(i))
        document.body.appendChild(a)
      }
      // 第三种写法跟第二种的目的和解释是一样的，只是写法不同。
      这种情况是针对不会立即执行的函数中存在自由变量的取值的情况可能会被外面作用域里面的数据的改变所影响。解决的办法就是让这个
      自由变量存在在闭包中，这时它就能常驻内存了。
      ```
  3. 闭包内的局部变量不会影响到闭包外的同名变量，即可用闭包形成一个块级作用域
    可以通过立即执行函数，来达到隐藏细节的目的

      ```
      var myModule = (function () {
        var var1 = 1
        var var2 = 2
        function fn1 () {

        }
        function fn2 () {

        }
        return {
            fn1: fn1,
            fn2: fn2
        }
      })()
      ```
      这样在模块外部无法修改我们没有暴露出来的变量、函数，来做js模块化。
  4. 隐藏数据

      我们通过闭包把一些数据隐藏起来，然后不让外边去改变。比如我们做一个简单的缓存工具。
    
      ```
      // 闭包隐藏数据，只提供api。缓存的小插件，小工具
      function createCache () {
        const data = {} // 闭包中的数据，被隐藏，不被外界访问
        return {
          get (key) {
            return data[key]
          },
          set (key, value) {
            data[key] = value
          }
        }
      }
      const c = createCache()
      c.set('a', 100)
      console.log(c.get('a'))
      ```
      为什么说它可以隐藏数据呢，比如我们现在想去不通过set,get直接去改data值怎么改呢，没有办法改。因为这个data是在这个
      createCache的这个作用域里面的。它不会被外界所访问到。也就是它的合法作用域只是createCache这个函数里面，如果你在
      这个函数外界直接去data.a赋值成200，这个是会报错的。data在这个作用域里没有定义，作用域的自由变量的查找顺序它不会
      找到createCache函数里面来。这样我们通过return get set返回函数的闭包的一种形式，执行这个函数的时候，因为这个函
      数是在这个createCache作用域里面的，所以说它能找到这个data，对它做一些修改。所以说这种方式是非常常见的，不管是缓
      存也好，还是其他的数据也好。比如说jquery的事件绑定和自定义事件，它都是通过这种方式来去隐藏的，就是一个函数里面，我
      们去把这个数据隐藏，然后只提供一些api在外面，然后去用api，然后这个数据我自己去管理着。所以说这是闭包的一个非常常见
      和常用的一种方。

## 执行上下文：执行的基础设施
相比普通函数，JavaScript 函数的主要复杂性来自于它携带的“环境部分”。

JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。

执行上下文在 ES3 中，包含三个部分。
  * scope：作用域，也常常被叫做作用域链。
  * variable object：变量对象，用于存储变量的对象。
  * this value：this 值。

在 ES5 中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。
  * lexical environment：词法环境，当获取变量时使用。
  * variable environment：变量环境，当声明变量时使用。
  * this value：this 值。

### this 关键字的行为
this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同，我们看一个例子：

  ```
  function showThis(){
      console.log(this);
  }
  var o = {
      showThis: showThis
  }
  showThis(); // global
  o.showThis(); // o
  ```

普通函数的 this 值由“调用它所使用的引用”决定，其中奥秘就在于：我们获取函数的表达式，它实际上返回的并非函数本身，而是一个Reference 类型。

Reference 类型由两部分组成：一个对象和一个属性值。不难理解 o.showThis 产生的 Reference 类型，即由对象 o 和属性“showThis”构成。

在这个例子中，Reference 类型中的对象被当作 this 值，传入了执行函数时的上下文当中。

如果，我们把这个例子稍作修改，换成箭头函数，结果就不一样了：

  ```
  const showThis = () => {
      console.log(this);
  }
  var o = {
      showThis: showThis
  }
  showThis(); // global
  o.showThis(); // global
  ```
### this 关键字的机制
在 JavaScript 标准中，为函数规定了用来保存定义时上下文的私有属性 [[Environment]]。

当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的
    [[Environment]]。

JavaScript 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。

当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。
  
而 this 则是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]] 私有属性。

[[thisMode]] 私有属性有三个取值
  * lexical：表示从上下文中找 this，这对应了箭头函数。
  * global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。
  * strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。

### 操作 this 的内置函数
  1. Function.prototype.call 和 Function.prototype.apply 可以指定函数调用时传入的 this 值，这里 call 和 apply 作用是一样的，只是传参方式有区别。
  2. 此外，还有 Function.prototype.bind 它可以生成一个绑定过的函数，这个函数的 this 值固定了参数

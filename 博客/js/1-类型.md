## 值类型，引用类型，栈堆的内存存储形式
  我们在计算机变量存储的时候，栈和堆是同时存在的。在内存存储中，栈是从上往下累加，堆是从下往上累加。它们两个之间会不会重合呢，异
  常情况下可能会重合，但是我们的操作系统一般分配的内存是够我们的程序使用的。值类型是在栈中存储的，我们的堆就不一样了，比如说我们
  把a赋值成一个对象，它会在堆中申请一个内存地址，然后把这个对象放到这个堆里，然后这个变量a指向这个内存地址。也就是说变量a里面存
  储的并不是这个对象，而是存的这个内存地址，这个内存地址指向这个对象。这就是从js引擎去解析或定义变量的这个内存模型或堆栈模型。
## 为什么值类型和引用类型是这样的存储方式
  原因还是考虑到性能或者存储的问题。因为值类型它的占用空间是比较少的。引用类型可能存储占用的空间太大，不好管理。再一个就是我们在
  复制的时候直接复制值会导致复制过程非常的慢。所以说计算机所有的程序，代码，语言都是采用这种方式。就是值类型和引用类型严格的分离
  出来。它们的存储机制，它们的赋值机制，它们的拷贝机制也是严格的分离出来。它是基于这个内存的空间和cpu的计算的耗时来去做的这么一
  个区分，它并不是故意这么做，故意为难你，它是不得以而为之的。
## typeof
  * undefined, number, string, boolean, symbol, function, object

  * 应用 

    `if( typeof str === undefined )`
    
## 运行时的 JavaScript 的类型系统，根据最新的语言标准，这 7 种语言类型是：
  1.Undefined；
  2.Null；
  3.Boolean；
  4.String；
  5.Number；
  6.Symbol；
  7.Object。

## 类型转换
### ==
JavaScript 中的“ == ”运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。== 的规则，它属于设计失误，并非语言中有价值
的部分，很多实践中推荐禁止使用“ ==”，而要求程序员进行显式地类型转换后，用 === 比较。==会发生隐式类型转换，除了==null之外，其他一
律用===。==null这种规则是jquery和zipto等源码都在使用的，而且eslint检测也是支持这种规则的。
``` 
// 判断对象中有没有这个属性
const obj = {x: 100}
if (obj.a == null) {}
// 相当于：
if (obj.a === null || obj.a === undefined) {}
```
### 其它运算
算数运算，关系运算，逻辑运算，如加减乘除大于小于与或非，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示：

类型转换规则.jpg

#### if语句和逻辑运算

  truly变量和falsely变量这两个概念对我们的if语句和逻辑运算是非常有用的，它们判断的就是truly变量和falsely变量，
  它不是必须要判断true和false

  > truly变量：!!a === true的变量，就是经过两步非运算如果得出true那就是truly变量； <br>
  flasely变量：!!a === flase的变量，就是经过两步非运算如果得出flase那就是flasely变量。

  ```
  // 以下是falsely变量。除此之外都是truly变量
  !!0 === false
  !!NaN === false
  !!'' === false
  !!null === false
  !!undefined === false
  !!false === false
  // 逻辑运算与或非
  console.log(10 && 0) // 0
  console.log('' || 'abc') // 'abc'
  console.log(!window.abc) // true
  ```
### 上述运算中较为复杂的类型转换
在这个里面，较为复杂的部分是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。我们来看一看这几种转换的规则
#### StringToNumber
字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制。

此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示。

需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。

  1. parseInt

      在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。

      在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都
        建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。

      parseInt()函数：它是全局函数，不从属于任何类的方法，且只解析整数。如果字符串前缀是"0x"或者"0X"，则parseInt()将
        其解释为十六进制数。它解析时会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容，如果第一个非空格字符
        是非数字字符，则返回NaN。

      parseInt()还可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2~36

  2. parseFloat

      parseFloat()函数：它也是全局函数，不从属于任何类的方法，它可以解析整数和浮点数。它不能识别十六进制前缀"0x"或"0X"。
      它解析时也会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容，如果第一个非空格字符是非数字字符，则返
      回NaN。

  3. Number  

      通过Number()转换函数传入一个字符串，它会试图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制进行转换，并且字
      符串中不能出现非数字的字符，否则将返回NaN。

>多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。
#### NumberToString
在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学
计数法表示的。

  1. Number类定义的toString()方法：这个方法可以接收表示转换基数（radix，范围在2~36之间）的可选参数，如果不指定此参数，
    转换规则将是基于十进制。

  2. Number类定义的toFixed()方法：这个方法可以指定小数点后的位数。

  3. Number类定义的toExponential()方法：这个方法使用指数记数法将数字转换为指数形式的字符串，其中小数点前只有一位，小数
    点后的位数则由参数指定。

  4. Number类定义的toPrecision()方法：这个方法根据指定的有效数字位数将数字转换成字符串。如果有效数字的位数少于数字整数
    部分的位数，则转换成指数形式。

#### 装箱转换
每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象。
#### 拆箱转换
在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。

对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型
  转换为对应的 String 或者 Number。

拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或
  者没有返回基本类型，则会产生类型错误。

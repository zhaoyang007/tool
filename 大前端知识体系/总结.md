前端面试题汇总：

https://juejin.cn/post/7004638318843412493#heading-21

https://juejin.cn/post/6968713283884974088

https://hub.fastgit.org/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB

https://www.yuque.com/cuggz/interview

https://github.com/lgwebdream/FE-Interview/issues?page=1&q=is%3Aissue+is%3Aopen

前端大班车公众号

大厂面试题（牛客...）

## css

##### 隐藏页面的方式

`opacity: 0`：占据空间，可以交互。

`visibility: hidden`：占据空间，不可交互。

`display: none`：不占据空间，不可交互。

`transform: scale(0, 0)`：占据空间，不可交互。

##### 水平垂直居中

水平居中：

```html
<div class="parent">
	<div class="child"> 啦啦啦 </div>
</div>

<style>
/* 方案一：inline-block + text-align */
.parent { text-align: center; }
.child { display: inline-block; }
/* 方案二：block + margin */
.child { 
  width: 100px; /* 需要设置宽度 */
  display: block; /* 设置成table可以不设置宽度 */
  margin: 0 auto;
}
/* 方案三：absolute + transform/margin */
.parent { position: relative; }
.child {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}
</style>
```

垂直居中：

```html
<div class="parent">
	<div class="child"> 啦啦啦 </div>
</div>

<style>
/* 方案一：table-cell + vertical-align */
.parent {
	display: table-cell; /* 单元格的内容是可以设置水平垂直对齐的 */
  vertical-align: middle; /* 用于设置文本内容的垂直方向对齐方式 */
}
/* 方案二：absolute + transform/margin */
.parent { position: relative; }
.child {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
</style>
```

##### BFC（块级格式化上下文）

BFC 是指一块独立的区域，与外部的元素不互相产生影响。

BFC 触发条件：

* position: fixed/absolute
* float 不是 none
* display: flex/inline-block/table-cell/table-caption
* overflow 不为 visible

BFC 应用：

1. 清除浮动
2. 防止同一 BFC 容器中的相邻元素间的外边距重叠问题

##### 清除浮动

1.父级添加 overflow 属性

通过触发 BFC 方式（就是负责接管自己的宽高），实现清除浮动。

```css
.fahter {
  overflow: hidden; /* auto 也可以 */
}
```

2.额外标签 clear: both;

在最后一个浮动标签后，新加一个标签，给其设置 clear: both; 

3.使用 after 伪元素清除浮动

```css
.clearfix::after {
  display: block; /* 伪元素默认是 inline 的，inline 元素无法帮我们做清除浮动的事情。 */
  content: " ";
  clear: both;
  height: 0;
  visibility: hidden;
  overflow：hidden;
}
```

4.万能清除法

```css
.clearfix::before, .clearfix::after {
  display: block;
  content: " ";
}
.clearfix::after {
  clear: both;
}
```

##### css 怎么开启硬件加速(GPU 加速)

- transform: translate3d(0, 0, 0) （当 3D 变换的样式出现时会使用 GPU 加速）
- opacity
- filter

再使用 will-change 设置上面属性。

##### 对 requestAnimationFrame 的理解

请求动画的 API

## Javascript

##### 数据类型

typeof：

值类型：'undefined', 'number', 'string', 'boolean', 'symbol'

引用类型：'function', 'object'(对象，数组，null)

Object.prototype.toString.call(obj)： 

'[object Undefined]', '[object Number]', '[object String]', '[object Boolean]', '[object Symbol]', '[object Function]', '[object Object]', '[object Array]', '[object Null]'

获取数据类型：

```js
function getType(value) {
  if (value === null) return value + "";
  if (typeof value === "object") {
    let valueClass = Object.prototype.toString.call(value),
    type = valueClass.split(" ")[1].split("");
    type.pop();
    return type.join("").toLowerCase();
  } else {
    return typeof value;
  }
}
```

##### 作用域

作用域：作用域就是变量，函数能够使用的范围。

作用域链：自由变量的查找是在函数定义的地方向上级作用域查找，不是在函数执行的地方。

自由变量：当前作用域中使用了却没有声明的变量。

##### 闭包

闭包是一个绑定了执行环境的函数。

* 函数的词法环境
* 函数中用到的未声明的变量
* 函数体

有两个函数，内部函数定义在外部函数中，并且内部函数使用了外部函数环境中定义的变量，当内部函数执行的时候，外部函数就形成了一个闭包。

```js
(function () {
  var a = 1;
  function add() {
    var b = 2;
    var sum = b + a;
    console.log(sum) // 3
  }
  add();
})();
```

闭包作用：

1.私有化数据。

函数中的 data 只能通过 get 和 set 访问，外部无法访问，相当于将变量私有化。

```js
function createPrivate() {
  const data = {};
  return {
    get(key) {
      return data[key];
    },
    set(key, value) {
      data[key] = value;
    }
  }
}
```

2.使局部变量常驻内存

```js
// 打印 10个10
for (var i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
// 闭包
for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
for (var i = 0; i< 10; i++){
  (function(i) {
    setTimeout(() => {
      console.log(i);
    }, 1000);
  })(i);
}
```

3.节流/防抖函数里都用到了闭包

##### 单线程和异步

单线程：只有一个线程，同一时间只能做一件事情。

单线程原因：避免 dom 渲染的冲突。

异步：在单线程的环境下，针对耗时很长的任务会阻塞后面代码的执行，造成页面卡死状态，所以要将这些任务变成异步来处理。

异步写法：

* 回调函数
* jquery deferred
* Promise
* async/await
* generator

##### event-loop

事件循环是浏览器对异步的实现方式。

整体的 js 代码这个宏任务先执行，同步代码执行完后有微任务执行微任务，没有微任务执行下一个宏任务，如此往复循环至结束。

宏任务之间会触发页面渲染。

```js
// 修改DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
  .append($p1)
  .append($p2)
  .append($p3);
// 微任务：DOM 渲染之前执行
Promise.resolve().then(() => {
  const length = $('#container').children().length;
  alert(`micro task ${length}`);
});
// 宏任务：DOM 渲染之后执行
setTimeout(() => {    
  const length = $('#container').children().length;
  alert(`macro task ${length}`);
});
```

##### 原型和原型链

原型：

* 每个 class 都有显示原型 prototype

* 每个实例都有隐式原型 \_\_proto\_\_

* 实例的隐式原型 \_\_proto\_\_ 指向对应 class 的显示原型 prototype

* prototype 中有一个 constructor 属性，用来引用它的构造函数，Person.prototype.constructor === Person，这是一种循环引用。

原型链：我们把由 \_\_proto\_\_ 串起来的直到 Object.prototype.\_\_proto\_\_ 为 null 的链叫做原型链。

```js
Object.__proto__ === Function.prototype 
Function.__proto__ === Function.prototype 
Function.prototype.__proto__ === Object.prototype 
Object.prototype.__proto__ === null // 原型链顶端

Object instanceof Function; // true
Function instanceof Object; // true
```

##### 继承

对象冒充继承：

```js
function Person(name) {
  this.name = name;
}
function Student(name) {
  this.fn = Person;
  this.fn(name);
  delete this.fn;
}
```

call,apply,bind

call 和 apply 可以实现多重继承，一个子类能够继承多个父类，F1 可以同时从 F2, F3 ... 继承。

原型链继承：

对象继承类

```js
o.__proto__ = F.prototype;
```

类继承类

```js
Student.prototype.__proto__ = Person.prototype;
```

混合方式继承：

```js
function Person(name) {
  this.name = name;
}
Person.prototype.sayName = function() {
  console.log(this.name);
}
function Student(name, age) {
  Person.call(this, name);
  this.age = age;
}
Student.prototype.__proto__ = Person.prototype;
```

class 继承：

```js
class Person {};
class Student extends Person {
  super();
};
```

new 继承：

构造函数创建实例的过程本身就是一种继承，new 的内部其实是做了继承里面的合体工作。

```js
Student.prototype = new Person();
```

##### 模块化

https://juejin.cn/post/6866973719634542606

es module 

commonjs

amd

cmd

前端发展模块化历程及js模块化原理:

1.函数封装

我们在讲函数的时候提到，函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里面编写几个相关函数就是最开始的模块了。

```js
function fn1 () {
  statement
}
function fn2 () {
  statement
}
```

这样在需要的时候加载函数所在文件，调用函数就可以了。

这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。

2.对象

为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中。

```js
var myModule = {
  var1: 1,
  var2: 2,
  fn1: function () {

  },
  fn2: function () {

  }
}
```

这样我们在希望调用模块的时候引用对应文件，然后

myModule.fn2()

这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系

看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员

myModel.var1 = 100;

这样就会产生意外的安全问题

3.立即执行函数

可以通过立即执行函数，来达到隐藏细节的目的

```js
var myModule = (function () {
  var var1 = 1;
  var var2 = 2;
  function fn1 () {

  }
  function fn2 () {

  }
  return {
    fn1: fn1,
    fn2: fn2
  }
})()
```

这样在模块外部无法修改我们没有暴露出来的变量、函数

4.放大模式(扩展模块本身)

如果一个模块很大，必须分成几个部分

```js
var module1 = (function (mod){
  mod.m3 = function () {
    //...
  };
  return mod;
})(module1 || {});
```

上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。

5.输入全局变量(依赖其他模块)

独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。

为了在模块内部调用全局变量，必须显式地将其他变量输入模块。

```js
var module1 = (function ($, YAHOO) {
  //...
})(jQuery, YAHOO);
```

上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。

这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。

Javascript模块规范：CommonJS，AMD，CMD：

require.js实现AMD规范

sea.js实现CMD规范

定义模块(利用的就是模块化的原理，使用自执行函数)，导出模块；引入模块，使用模块

模块化博客：

Javascript模块化编程（一）：模块的写法    

http://www.ruanyifeng.com/blog/2012/10/javascript_module.html  

Javascript模块化编程（二）：AMD规范

http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html

Javascript模块化编程（三）：require.js的用法

http://www.ruanyifeng.com/blog/2012/11/require_js.htmls

模块化使用：

函数定义中调用引入的模块中的函数，始终是这样的两层结构。这个函数还可以作为模块被其他函数引用并且调用。调用时形成多层结构。一层一层的调用和传参。vuex 中的接口和 actions 的结合就能很好的体现这一点。

函数定义的时候是从外层到里层，调用的时候也是从外层到里层。

## Javascript API 实现

##### 实现 let

```js
// 1
{
  let a = 1;
  console.log(a); // 1
}
console.log(a);
// 相当于
(function () {
  var a = 1;
  console.log(a); // 1
})();
console.log(a); // a is not defined

// 2
var fns = [];
for (let i = 0; i < 10; i++) {
  fns[i] = function() {
    console.log(i);
  };
}
fns[0](); // 0
// 相当于
var fns = [];
for (var i = 0; i < 10; i++) {
  (function(i) {
    fns[i] = function() {
      console.log(i);
    };
  })(i);
}
fns[0](); // 0
```

##### 实现 const

```js
function _const(key, value) {
  window.key = value;
  Object.defineProperty(window, key, {
    enumerable: false,
    configurable: false,
    get() {
      return value;
    },
    set(newVal) {
      throw new TypeError('不能重复定义');
			// if(newVal !== value){
      //     throw new TypeError('不能重复定义');
      // } else {
      //     return value;
      // }
    }
  });
}
```

##### 实现数组 push

```js
Array.prototype.push = function(...args) {
  for (let i = 0; i < args.length; i++) {
    this[this.length] = args[i];
  }
  return this.length;
}
```

##### 实现数组 filter

```js
Array.prototype.filter = function(fn) {
  if (typeof fn !== 'function') throw TypeError('参数必须是一个函数');
  const res = [];
  for (let i = 0; i < this.length; i++) {
    if (fn(this[i], i)) res.push(this[i]); 
  }
  return res;
}
```

##### 实现数组 map

```js
Array.prototype.map = function(fn) {
  if (typeof fn !== 'function') throw TypeError('参数必须是一个函数');
  const res = [];
  for (let i = 0; i < this.length; i++) {
    res.push(fn(this[i], i));
  }
  return res;
}
```

##### 实现数组 flat

```js
// 1 reduce + 递归
function flat(arr, depth = 1) {
  if(!Array.isArray(arr) || depth <= 0) return arr;
  return arr.reduce((acc, cur) => {
    return Array.isArray(cur) ？ acc.concat(flat(cur, depth - 1)) : acc.concat(cur);
  }, []);
}
// 2 迭代
function flat(arr) {
  const res = [];
  const arrs = [...arr];
  while(arrs.length) {
    const tmp = arrs.shift();
    Array.isArray(tmp) ? arrs.unshift(...tmp) : res.push(tmp);
  }
  return res;
}
// 3 递归
function flat(arr, depth = 1) {
  if(!Array.isArray(arr) || depth <= 0) return arr;
  const res = [];
  arr.forEach(item => {
    Array.isArray(item) ? res.push(...flat(item, depth - 1)) : res.push(item);
  })
  return res;
}
```

##### 实现字符串 trim

```js
String.prototype.trim = function() {
  return this.replace(/(^\s*)|(\s*$)/g, '');
}
```

##### 实现字符串 repeat

```js
// 1
String.prototype.repeat = function(n) {
	return (new Array(n + 1)).join(this);
}
// 2 递归
String.prototype.repeat = function(n) {
  return n > 0 ? this.repeat(n - 1) + this : '';
}
```

##### 实现 Object.create

```js
Object.create = function(obj) {
  function F() {};
  F.prototype = obj;
  return new F();
}
```

##### 实现 Object.is

```js
Object.is = function (x, y) {
  // 全等情况下，只有 +0 -0 返回 false
  if (x === y) {
    // 1/+0 === Infinity 1/-0 === -Infinity
    return x !== 0 || 1 / x === 1 / y;
  }
	// 不全等情况下，只有 NaN NaN 返回 true
  return x !== x && y !== y;
};
```

##### 实现 Object.assign

```js
Object.assign = function(target, ...sources) {
    if (target == null) throw new TypeError('Cannot convert undefined or null to object');
  	const res = Object(target);
    sources.forEach(source => {
      for (let key in source) {
        if (source.hasOwnProperty(key)) res[key] = source[key];
      }
    });
    return res;
}
```

##### 实现 instanceof

```js
function Instanceof(left, right) {
  while (true) {
    if (left == null) return false;
    if (left.__proto__ === right.prototype) return true;
    left = left.__proto__;
  }
}
```

##### 实现 JSON.parse

```js
// 1 eval
JSON.parse = function(jsonStr) {
  return eval(`(${jsonStr})`);
}
// 2 new Function()
JSON.parse = function(jsonStr) {
	return (new Function(`return ${jsonStr}`))();
}
```

##### 实现 new

```js
function New(fn, ...args) {
  const obj = Object.create(fn.prototype);
  const res = fn.call(obj, ...args);
  if (res && (typeof res === 'object' || typeof res === 'function')) return res;
  return obj;
}
```

##### 实现 call apply bind

call

```js
Function.prototype.call = function (obj, ...args) {
  obj = obj == null ? window : Object(obj);
  obj.fn = this;
  const res = obj.fn(...args);
  delete obj.fn;
  return res;
}
```

apply   

```js
Function.prototype.apply = function (obj, args) {
  obj = obj == null ? window : Object(obj);
  obj.fn = this;
  const res = args ? obj.fn(...args) : obj.fn();
  delete obj.fn;
  return res;
}
```

bind

```js
Function.prototype.bind = function(obj, ...args) {
  obj = obj == null ? window : Object(obj);
  const fn  = this;
  const bound = function(...innerArgs) {
    if (this instanceof bound) {
      return new fn(...args, ...innerArgs);
    } else {
      // return fn.call(obj, ...args, ...innerArgs);
      obj.fn = fn;
      const res = obj.fn(...args, ...innerArgs);
      delete obj.fn;
      return res;
    }
  }
  return bound;
}
```

##### 实现 Promise

```js
class Promise {
  constructor(fn) {
    this.status = 'pending';
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];
    // 更改成功后的状态
    const resolve = value => {
      if (this.status === 'pending') {
        this.status = 'fulfilled';
        this.onFulfilledCallbacks.forEach(fn => fn(value));
      }
    }
    // 更改失败后的状态
    const reject = err => {
      if (this.status === 'pending') {
        this.status = 'rejected';
        this.onRejectedCallbacks.forEach(fn => fn(err));
      }
    }
    try {
      fn(resolve, reject)
    } catch(err) {
      reject(err)
    }
  }
  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
    onRejected = typeof onRejected === 'function' ? onRejected : err => {throw err};
    // 为了链式调用，这里直接返回一个 Promise
    return new Promise((resolve, reject) => {
      const fulfilledMicrotask = value =>  {
        queueMicrotask(() => {
          try {
            const res = onFulfilled(value);
            res instanceof Promise ? res.then(resolve, reject) : resolve(res);
          } catch(err) {
            reject(err);
          } 
        })  
      }
      const rejectedMicrotask = value => { 
        queueMicrotask(() => {
          try {
            const res = onRejected(value);
            res instanceof Promise ? res.then(resolve, reject) : reject(res);
          } catch(err) {
            reject(err);
          } 
        }) 
      }
      this.onFulfilledCallbacks.push(fulfilledMicrotask);
      this.onRejectedCallbacks.push(rejectedMicrotask);
    });
  }
  static resolve(value) {
    if (value instanceof Promise) {
      return value;
    }
    return new Promise(resolve =>  {
      resolve(value);
    });
  }
  static reject(err) {
    return new Promise((resolve, reject) => {
      reject(err);
    });
  }
}
```

##### 实现 Promise.all

```js
Promise.all = function(promises) {
  return new Promise((resolve, reject) => {
    const result = [];
  	let count = 0;
    if (promises.length === 0) {
      resolve(result);
    } else {
      for (let i = 0; i < promises.length; i++) {
        Promise.resolve(promises[i]).then(res => {
          result[i] = res;
          count++;
          if (count === promises.length) {
            resolve(result);
          }
        }, err => {
          reject(err);
        });
      }
    }
  });
}
```

##### 实现 Promise.race

```js
Promise.race = function(promises) {
  return new Promise((resolve, reject) => {
    for (let i = 0; i < promises.length; i++) {
      Promise.resolve(promises[i]).then(res => {
        resolve(res);
      }, err => {
        reject(err);
      });
    }
  });
}
```

##### 实现 Promise.prototype.finally

```js
Promise.prototype.finally = function(cb) {
  return this.then(res => {
    return Promise.resolve(cb()).then(() => res);
  }, err => {
    return Promise.resolve(cb()).then(() => { throw err });
  });
}
```

##### 实现取消 promise

```js
function cancel(promise) {
  const obj = {};
  const p = new Promise((resolve, reject) => {
    obj.resolve = resolve;
    obj.reject = reject;
  });
  obj.promise = Promise.race([p, promise]);
  return obj;
}
// 使用
const testPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(123);
  }, 1000);
});
const cancelPromise = cancel(testPromise);
cancelPromise.promise.then(res => {
  console.log(res);
}); 
// 取消
cancelPromise.resolve("取消");
```

## Javascript 手写题

##### 数组去重

```js
// 1.传统方式，遍历元素挨个比较，去重
function uniqueArr(arr) {
  const res = [];
  const map = new Map();
  for (let item of arr) {
  	if (!map.has(item)) {
			res.push(item);
      map.set(item, 1);
    }
  }
  return res;
}
// 2.使用Set（无序，不能重复）
function uniqueArr(arr) {
  return [...new Set(arr)];
}
```

##### 浅拷贝

```js
// Object.assign
let a = {a: 1, b: 2};
let b = Object.assign({}, a);
// ...
let a = {a: 1, b: 2};
let b = {...a};
// slice
let a = [1, {a: 1}];
let b = a.slice();
// concat
let a = [1, {a: 1}];
let b = [].concat(a);
```

##### 深拷贝

```js
// 1 
// 1.如果obj里面存在时间对象,JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。
// 2.如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象。
// 3.如果obj里有函数，undefined，则序列化的结果会把函数，undefined丢失。
// 4.如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。
// 5.JSON.stringify()只能序列化对象的可枚举的自有属性。如果obj中的对象是有构造函数生成的，则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的构造函数constructor，即无法继续使用构造函数原型上的属性。
// 6.如果对象中存在循环引用的情况也无法正确实现深拷贝。
const o = JSON.parse(JSON.stringify(obj));

// 2
function isObject(val) {
  return typeof val === "object" && val !== null;
}
function deepClone(obj, hash = new WeakMap()) {
  if (!isObject(obj)) return obj;
  if (hash.has(obj)) return hash.get(obj);
  const res = Array.isArray(obj) ? [] : {};
  hash.set(obj, res);
  // Reflect.ownKeys(obj)=Object.getOwnPropertyNames(obj)+Object.getOwnPropertySymbols(obj)
  [
    ...Object.getOwnPropertyNames(obj),
    ...Object.getOwnPropertySymbols(obj),
  ].forEach(key => {
    res[key] = deepClone(obj[key], hash);
  });
  return res;
}
```

##### 节流

节流是频繁操作的时候保持一个频率触发。比如拖拽一个元素时，要随时拿到这个元素被拖拽的位置。

```js
// 定时器版
function throttle(fn, delay = 100) {
  let flag = true;
  return function(...args) {
		if (!flag) return;
    flag = false;
    setTimeout(() => {
      fn.call(this, ...args);
      flag = true;
    }, delay);
  }
}
// 时间戳版
function throttle(fn, delay = 100) {
  let prev = 0;
  return function(...args) {
    const now = Date.now();
    if (now - prev > delay) {
      fn.call(this, ...args);
      prev = now;
    }
  }
}
// 使用
div.addEventListener('drag', throttle(function(e) {
  console.log(e.offsetX, e.offsetY);
}, 300));
```

##### 防抖

防抖是频繁操作的最后时刻触发。比如输入停止后一段时间没有再输入才会请求接口。

```js
// 定时器版
function debounce (fn, delay = 100) {
  let timer = null;
  return function(...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.call(this, ...args);
      timer = null;
    }, delay)
  }
}
// 使用
input.addEventListener('keyup', debounce(function() {
  console.log(input.value);
}, 300));
```

##### 发布订阅

```js
class EventEmitter {
  constructor() {
    this.events = {};
  }
  on(name, handler){
    this.events[name] = this.events[name] || [];
    this.events[name].push(handler);
  }
  emit(name, ...args) {
    if (!this.events[name]) throw new Error('该事件未注册');
    this.events[name].forEach(fn => fn.call(this, ...args));
  }
  off(name, handler) {
    if (!this.events[name]) throw new Error('该事件未注册');
    if (!handler) {
			delete this.events[name];
    } else {
      this.events[name] = this.events[name].filter(fn => fn !== handler);
    }
  }
  once(name, handler) {
    function fn(...args) {
      handler.call(this, ...args);
      this.off(name, fn);
    }
    this.on(name, fn);
  }
}
```

##### sleep 函数

```js
function sleep(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}
// 使用
sleep(1000).then(()=>{
  console.log(1);
})
async function output() {
  let out = await sleep(1000);
  console.log(1);
}
output();
```

##### 通用事件封装

```js
function bindEvent (elem, type, selector, fn) {
  if (fn == null) {
    fn = selector;
    selector = null;
  }
  elem.addEventListener(type, event => {
    const target = event.target;
    if (selector) {
      // 代理绑定
      if (selector.contains(target)) {
        fn.call(target, event);
      }
    } else {
      // 普通绑定
      fn.call(target, event);
    }
  })
}
```

##### ajax 封装

```js
function ajax (url, method, postData) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open(method, url);
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(JSON.parse(xhr.responseText));
        } else {
          reject(new Error(xhr.responseText));
        }
      }
    }
    method === 'GET' ? xhr.send() : xhr.send(JSON.stringify(postData));
  });
}
```

##### setTimeout 实现 setInterval

```js
function setInterval(fn, time) {
	function interval() {
    fn();
    setTimeout(interval, time);
  }
  return setTimeout(interval, time);
}
```

##### setInterval 实现 setTimeout

```js
const setTimeout = (fn, time) => {
  const timer = setInterval(() => {
    fn();
    clearInterval(timer);
  }, time);
  return timer;
}
```

##### Jsonp 封装

```js
// 发送请求
function createScript(src) {
  const script = document.createElement('script');
  script.src = src;
  script.type = "text/javascript";
  document.body.appendChild(script);
}
createScript("http://xxx.xxx.com/xxx.js?callback=handleResponse");
// 接收数据
function handleResponse(res) {
  console.log(res);
}
// 接口返回一个携带数据的函数调用的js
handleResponse({a: 1, b: 2});
```

##### 解析 URL Params

```js
// 1.传统方式，查找location.search
function query(name) {
  const search = location.search.substring(1);
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i');
  const res = search.match(reg);
  return res ? res[2] : null;
}
// 2.新api，URLSearchParams
function query(name) {
  const p = new URLSearchParams(location.search);
  return p.get(name);
}
```

##### 对象扁平化

```js
function isObject(val) {
  return typeof val === "object" && val !== null;
}
function flatten(obj) {
  if (!isObject(obj)) return obj;
  const res = {};
  function dfs(cur, prefix) {
    if (isObject(cur)) {
      if (Array.isArray(cur)) {
        cur.forEach((item, index) => {
          dfs(item, `${prefix}[${index}]`);
        });
      } else {
        for (let key in cur) {
          dfs(cur[key], `${prefix}${prefix ? "." : ""}${key}`);
        }
      }
    } else {
      res[prefix] = cur;
    }
  };
  dfs(obj, '');
  return res;
}
// 测试
const obj = {
  a: {
    b: 1,
    c: 2,
    d: {e: 5}
  },
  b: [1, 3, {a: 2, b: 3}],
  c: 3
};
flatten(obj);
```

##### 函数柯里化

柯里化（currying）是把接受多个参数的函数变换成接受一个参数的函数，并且返回接受剩余参数且返回结果的新函数的技术。

柯里化后的函数接收参数的数量与原函数的形参数量相等时，执行原函数；当接收的参数数量小于原函数形参数量时，返回一个用于接收剩余参数的函数。

```js
// 1 只能传被柯里化函数形参的个数，多少都不行
function currying(fn, ...args) {
    const length = fn.length;
    return function(...newArgs) {
        const allArgs = [...args, ...newArgs];
        if (allArgs.length < length) {
            return currying.call(this, fn, ...allArgs);
        } else {
            return fn.apply(this, allArgs);
        }
    }
}
const add = (a, b, c) => a + b + c;
const addCurrying = currying(add);
console.log(addCurrying(1)(2)(3));
console.log(addCurrying(1,2)(3));
console.log(addCurrying(1)(2,3));
console.log(addCurrying(1,2,3));

// 2 参数长度不固定，最后需要手动调用一次
function currying(fn, ...args) {
    let allArgs = [...args];
    return function temp(...newArgs) {
        if (newArgs.length) {
            allArgs = [...allArgs, ...newArgs];
            return temp;
        } else {
            const res = fn.apply(this, allArgs);
            allArgs = [...args];
            return res;
        }
    }
}
const add = (...args) => args.reduce((a, b) => a + b);
const addCurrying = currying(add);
console.log(addCurrying(1)(2)(3)(4,5)());
console.log(addCurrying(1)(2)(3,4,5)());
console.log(addCurrying(1)(2,3,4,5)());
```

柯里化用途

```js
// 1 校验规则
// 原函数
function checkByRegExp(regExp, string) {
    return regExp.test(string);  
}
// 普通使用
checkByRegExp(/^1\d{10}$/, '18642838455'); // 校验电话号码
checkByRegExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'test@163.com'); // 校验邮箱
// 柯里化后使用
let check = currying(checkByRegExp);
let checkCellPhone = check(/^1\d{10}$/);
let checkEmail = check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);
checkCellPhone('18642838455'); // 校验电话号码
checkCellPhone('13109840560'); // 校验电话号码
checkCellPhone('13204061212'); // 校验电话号码
checkEmail('test@163.com'); // 校验邮箱
checkEmail('test@qq.com'); // 校验邮箱
checkEmail('test@gmail.com'); // 校验邮箱
// 2 提取对象数组的某一属性
const list = [
    {name:'lucy'},
    {name:'jack'}
];
// 普通使用
const names = list.map(item => item.name);
// 柯里化使用
const prop = currying((key, obj) => obj[key]);
const names = list.map(prop('name'));
```

##### compose

```js
function compose(...fns) {
    if (!fns.length) return v => v;
    if (fns.length === 1) return fns[0];
    return fns.reduce((pre, cur) => (...args) => pre(cur(...args)));
}
function compose(...fns) {
    if (!fns.length) return v => v;
    if (fns.length === 1) return fns[0];
    return fns.reduce((pre, cur) => {
        return (...args) => {
            return pre(cur(...args));
        }
    });
}
// 使用
function fn1(x) {
  return x + 1;
}
function fn2(x) {
  return x + 2;
}
function fn3(x) {
  return x + 3;
}
function fn4(x) {
  return x + 4;
}
const a = compose(fn1, fn2, fn3, fn4); // a = (...args) => fn1(fn2(fn3(fn4(...args))))
console.log(a(1)); // 1+4+3+2+1=11
```

##### LazyMan

```js
class LazyManClass {
  constructor(name) {
    this.tasks = [];
    const task = () => {
      console.log(`Hi! This is ${name}`);
      this.next();
    };
    this.tasks.push(task);
    setTimeout(() => {
      // 所有任务添加完之后开始初始化执行任务队列的任务。
      this.next();
    }, 0);
  }
  next() {
    // 取第一个任务执行
    const task = this.tasks.shift();
    task && task();
  }
  sleep(time) {
    this.sleepWrapper(time, false);
    return this;
  }
  sleepFirst(time) {
    this.sleepWrapper(time, true);
    return this;
  }
  sleepWrapper(time, isFirst) {
    const task = () => {
      setTimeout(() => {
        console.log(`等待${time}秒`);
        this.next();
      }, time * 1000);
    };
    if (isFirst) {
      this.tasks.unshift(task);
    } else {
      this.tasks.push(task);
    }
  }
  eat(name) {
    const task = () => {
      console.log(`eat ${name}`);
      this.next();
    };
    this.tasks.push(task);
    return this;
  }
}
function LazyMan(name) {
  return new LazyManClass(name);
}
LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(4).eat('junk food');
```

##### 对象反扁平化

```js
function unflatten(data) {
  if (!isObject(data) || Array.isArray(data)) return data;
  const regex = /\.?([^.\[\]]+)|\[(\d+)\]/g;
  const resultholder = {};
  for (let p in data) {
    let cur = resultholder;
    let prop = "";
    let m;
    while(m = regex.exec(p)) {
      cur = cur[prop] || (cur[prop] = (m[2] ? [] : {}));
      prop = m[2] || m[1];
    }
    cur[prop] = data[p];
  }
  return resultholder[""] || resultholder;
}
```

##### 循环打印红黄绿

红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次。如何让3个灯不断交替重复亮灯？

```js
function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}
// callback
const task = (timer, light, callback) => {
    setTimeout(() => {
        if (light === 'red') {
            red()
        }
        else if (light === 'green') {
            green()
        }
        else if (light === 'yellow') {
            yellow()
        }
        callback()
    }, timer)
}
const step = () => {
    task(3000, 'red', () => {
        task(2000, 'green', () => {
            task(1000, 'yellow', step)
        })
    })
}
step()

// promise
const task = (timer, light) => 
    new Promise((resolve, reject) => {
        setTimeout(() => {
            if (light === 'red') {
                red()
            }
            else if (light === 'green') {
                green()
            }
            else if (light === 'yellow') {
                yellow()
            }
            resolve()
        }, timer)
    })
const step = () => {
    task(3000, 'red')
        .then(() => task(2000, 'green'))
        .then(() => task(2100, 'yellow'))
        .then(step)
}
step()

// async/await
const taskRunner =  async () => {
    await task(3000, 'red')
    await task(2000, 'green')
    await task(2100, 'yellow')
    taskRunner()
}
taskRunner()
```

##### 每隔一秒打印 1,2,3,4

```js
// 使用闭包实现
for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  })(i);
}
// 使用 let 块级作用域
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
```

##### 分片思想解决大数据量渲染问题

```js
let ul = document.getElementById("container");
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total / once;
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal, curIndex) {
  if (curTotal <= 0) {
    return false;
  }
  //每页多少条
  let pageCount = Math.min(curTotal, once);
  window.requestAnimationFrame(function () {
    for (let i = 0; i < pageCount; i++) {
      let li = document.createElement("li");
      li.innerText = curIndex + i + " : " + ~~(Math.random() * total);
      ul.appendChild(li);
    }
    loop(curTotal - pageCount, curIndex + pageCount);
  });
}
loop(total, index);
```

##### 将虚拟 Dom 转化为真实 Dom

```js
{
  tag: 'DIV',
  attrs:{
  id:'app'
  },
  children: [
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] }
      ]
    },
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] },
        { tag: 'A', children: [] }
      ]
    }
  ]
}
// 把上诉虚拟Dom转化成下方真实Dom
<div id="app">
  <span>
    <a></a>
  </span>
  <span>
    <a></a>
    <a></a>
  </span>
</div>

// 真正的渲染函数
function _render(vnode) {
  // 如果是数字类型转化为字符串
  if (typeof vnode === "number") {
    vnode = String(vnode);
  }
  // 字符串类型直接就是文本节点
  if (typeof vnode === "string") {
    return document.createTextNode(vnode);
  }
  // 普通DOM
  const dom = document.createElement(vnode.tag);
  if (vnode.attrs) {
    // 遍历属性
    Object.keys(vnode.attrs).forEach((key) => {
      const value = vnode.attrs[key];
      dom.setAttribute(key, value);
    });
  }
  // 子数组进行递归操作
  vnode.children.forEach((child) => dom.appendChild(_render(child)));
  return dom;
}
```

##### DOM2JSON

```js
<div>
  <span>
    <a></a>
  </span>
  <span>
    <a></a>
    <a></a>
  </span>
</div>

把上诉dom结构转成下面的JSON格式

{
  tag: 'DIV',
  children: [
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] }
      ]
    },
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] },
        { tag: 'A', children: [] }
      ]
    }
  ]
}

function dom2Json(domtree) {
  let obj = {};
  obj.name = domtree.tagName;
  obj.children = [];
  domtree.childNodes.forEach((child) => obj.children.push(dom2Json(child)));
  return obj;
}
```

##### 程序把 entry 转换成如下对象

```js
var entry = {
a: {
b: {
  c: {
    dd: 'abcdd'
  }
},
d: {
  xx: 'adxx'
},
e: 'ae'
}
}

// 要求转换成如下对象
var output = {
'a.b.c.dd': 'abcdd',
'a.d.xx': 'adxx',
'a.e': 'ae'
}

```

##### 把 entry 转换成如下对象

```js
var entry = {
'a.b.c.dd': 'abcdd',
'a.d.xx': 'adxx',
'a.e': 'ae'
}

// 要求转换成如下对象
var output = {
a: {
b: {
  c: {
    dd: 'abcdd'
  }
},
d: {
  xx: 'adxx'
},
e: 'ae'
}
}

```

##### 列表转成树形结构

```js
[
    {
        id: 1,
        text: '节点1',
        parentId: 0 //这里用0表示为顶级节点
    },
    {
        id: 2,
        text: '节点1_1',
        parentId: 1 //通过这个字段来确定子父级
    }
    ...
]

转成
[
    {
        id: 1,
        text: '节点1',
        parentId: 0,
        children: [
            {
                id:2,
                text: '节点1_1',
                parentId:1
            }
        ]
    }
]
// 1
function listToTree(data) {
  let temp = {};
  let treeData = [];
  for (let i = 0; i < data.length; i++) {
    temp[data[i].id] = data[i];
  }
  for (let i in temp) {
    if (+temp[i].parentId != 0) {
      if (!temp[temp[i].parentId].children) {
        temp[temp[i].parentId].children = [];
      }
      temp[temp[i].parentId].children.push(temp[i]);
    } else {
      treeData.push(temp[i]);
    }
  }
  return treeData;
}

// 2
function convert(list) {
	const res = []
	const map = list.reduce((res, v) => (res[v.id] = v, res), {})
	for (const item of list) {
		if (item.parentId === 0) {
			res.push(item)
			continue
		}
		if (item.parentId in map) {
			const parent = map[item.parentId]
			parent.children = parent.children || []
			parent.children.push(item)
		}
	}
	return res
}
// 3
const convert = list => {
  let map = new Map();
  let result = []
  list.forEach(el => {
    map.set(el.id, el);
  });
  list.forEach(el => {
		let parent = map.get(el.parentId);
		if (!parent) {
			// parentId === 0
			el.children = []
			return 
		}
    if (parent.hasOwnProperty('children')) {
      parent.children.push(el);
    } else {
      parent['children'] = [];
      parent.children.push(el);
    }
	});
	for (let i = 0; i < list.length; i++) {
		const el = list[i];
		if (el.parentId === 0) {
			result.push(el)
		}
	}
	return result
};
let list = [
  { id: 1, name: '部门A', parentId: 0 },
  { id: 2, name: '部门B', parentId: 0 },
  { id: 3, name: '部门C', parentId: 1 },
  { id: 4, name: '部门D', parentId: 1 },
  { id: 5, name: '部门E', parentId: 2 },
  { id: 6, name: '部门F', parentId: 3 },
  { id: 7, name: '部门G', parentId: 2 },
  { id: 8, name: '部门H', parentId: 4 }
];
convert(list)

```

##### 树形结构转成列表

```js
[
    {
        id: 1,
        text: '节点1',
        parentId: 0,
        children: [
            {
                id:2,
                text: '节点1_1',
                parentId:1
            }
        ]
    }
]
转成
[
    {
        id: 1,
        text: '节点1',
        parentId: 0 //这里用0表示为顶级节点
    },
    {
        id: 2,
        text: '节点1_1',
        parentId: 1 //通过这个字段来确定子父级
    }
    ...
]

function treeToList(data) {
  let res = [];
  const dfs = (tree) => {
    tree.forEach((item) => {
      if (item.children) {
        dfs(item.children);
        delete item.children;
      }
      res.push(item);
    });
  };
  dfs(data);
  return res;
}
```

##### jsonToTree

```js
// 方法1
var treeList = [
    {
        title: '系统管理',
        parentName: '',
        parentId: 0,
        id: 1,
    },
    {
        title: '菜单管理',
        parentName: '系统管理',
        parentId: 1,
        id: 11,
    },
    {
        title: '菜单新增',
        parentName: '菜单管理',
        parentId: 11,
        id: 111,
    },
    {
        title: '菜单编辑',
        parentName: '菜单管理',
        parentId: 11,
        id: 112,
    },
    {
        title: '菜单删除',
        parentName: '菜单管理',
        parentId: 11,
        id: 113,
    },
    {
        title: '角色管理',
        parentName: '系统管理',
        parentId: 1,
        id: 22,
    },
    {
        title: '角色新增',
        parentName: '角色管理',
        parentId: 22,
        id: 221,
    },
    {
        title: '角色编辑',
        parentName: '角色管理',
        parentId: 22,
        id: 222,
    },
    {
        title: '角色删除',
        parentName: '角色管理',
        parentId: 22,
        id: 223,
    },
    {
        title: '用户管理',
        parentName: '系统管理',
        parentId: 1,
        id: 33,
    },
    {
        title: '用户新增',
        parentName: '用户管理',
        parentId: 33,
        id: 331,
    },
    {
        title: '用户编辑',
        parentName: '用户管理',
        parentId: 33,
        id: 332,
    },
    {
        title: '用户删除',
        parentName: '用户管理',
        parentId: 33,
        id: 333,
    }
]
function jsonToTree(lists, id, parentId) {
    var idList = {},
        treeList = [];
    for (var i = 0, len = lists.length; i < len; i++) {
        //生成一个以id为键的对象
        idList[lists[i][id]] = lists[i]
    }
    for (var j = 0, len1 = lists.length; j < len1; j++) {
        var aVal = lists[j];
        var aValParent = idList[aVal[parentId]];
        //如果aValParent存在；就说明当前的aVal是aValParent的孩子
        if (aValParent) {
            if ('chindren' in aValParent) {
                aValParent['children'].push(aVal)
            } else {
                aValParent['children'] = [];
                aValParent['children'].push(aVal)
            }
        } else {
            treeList.push(aVal)
        }
    }
    return treeList
}
// 方法2
var data=[
  { id: 40, parentId: 31, note: "的萨达是" }, 
  { id: 20, parentId: 11, note: "的萨达是" },
  { id: 22, parentId: 20, note: "dsadas" },
  { id: 12, parentId: null, note: "dsadasad萨达s" }, 
  { id: 11, parentId: undefined, note: "dqwds" }, 
  { id: 24, parentId: 22, note: "搜索" },
  { id: 34, parentId: 22, note: "搜索" }
]
function fnSetTreeData(data) {
  var data = [...data];
  var tree = data.filter((father) => {
    var branchArr = data.filter((child) => {
      if (father.id == child.parentId) child._hasParent = true;
      return father.id == child.parentId;

      // MARK 为什么这样写就报错 ? 
      // if (father.id == child.parentId) child._hasParent = true;
      // return child._hasParent
    });
    if (branchArr.length > 0) father.children = branchArr;
    return !father._hasParent;
  });
  // MARK 为什么在这里还得加一个过滤
  tree = tree.filter((item) => {
    return !item._hasParent;
  })
  return tree
}
console.log(JSON.stringify(fnSetTreeData(data), null, 2))
// 方法3
var data = [
  { id: 40, parentId: 31, note: "的萨达是" }, 
  { id: 20, parentId: 11, note: "的萨达是" },
  { id: 22, parentId: 20, note: "dsadas" },
  { id: 12, parentId: null, note: "dsadasad萨达s" }, 
  { id: 11, parentId: undefined, note: "dqwds" }, 
  { id: 24, parentId: 22, note: "搜索" },
  { id: 34, parentId: 22, note: "搜索" }
]
function listToTree(data) {
  let arr = JSON.parse(JSON.stringify(data))
  const listChildren = (obj, filter) => {
    [arr, obj.children] = arr.reduce((res, val) => {
      if (filter(val))
        res[1].push(val)
      else
        res[0].push(val)
      return res
    }, [[],[]])
    obj.children.forEach(val => {
      if (arr.length)
      listChildren(val, obj => obj.parentId === val.id)
    })
  }

  const tree = {}
  listChildren(tree, val => arr.findIndex(i => i.id === val.parentId) === -1)
  return tree.children
}
// 方法4
var aaa= [{name:'wwb',id:111},{name:'aaa',id:0,pid:"mei"},{name:'a',id:1,pid:"mei"},{name:'b',id:2,pid:1},{name:'c',id:3,pid:1},{name:'d',id:4,pid:2},{name:'e',id:5,pid:2}];

function test(ary,data){

    var data=data?data:(function(ary){
      var tempAry=[];
      var idList=[];
      ary.forEach(function(item){idList.push(item.id)});
     function deb(id,idList){
         var flag=true;
        for(var ida in idList){
            if(id==idList[ida]){
                flag=false;
            }       
        }
         return flag;
     }

      for(var i=0,len=ary.length;i<len;i++){
        if(ary[i].pid==undefined||(ary[i].pid!=undefined&&deb(ary[i].pid,idList))){
          var obj={name:ary[i].name,id:ary[i].id};
          tempAry.push(obj);
        }
       }
        return tempAry; 
    }(ary));

    var temp=0;
   if(data.constructor==Array){
     for(var i=0,len=data.length;i<len;i++){
        for(var j=0,lenA=ary.length;j<lenA;j++){
           if(ary[j].pid==data[i].id){
           var obj={name:ary[j].name,id:ary[j].id};
           data[i].child=data[i].child||[];
           data[i].child.push(obj);
           temp++;
       }
     }
    }
   }

   if(temp>0){
     if(data.constructor==Array){
      for(var n=0,lenB=data.length;n<lenB;n++){
        data[n].child=test(ary,data[n].child?data[n].child:[]);
        if(data[n].child.length==0){
            delete data[n].child;
        }
          delete data[n].id;
      } 
    }
   }else{
       for(var n=0,lenB=data.length;n<lenB;n++){
          delete data[n].id;
       } 

   }
    return data;

}
var a=test(aaa);
sconsole.log(a)
```

##### 实现模板字符串解析

```js
let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';
let data = {
  name: '姓名',
  age: 18
}
render(template, data); // 我是姓名，年龄18，性别undefined
```

##### 找出 element 元素的全部 input 元素

```js
function findAllInputElement(element) {
  const rec = function (element, arr) {
    if (element.nodeName.toUpperCase() === "INPUT") {
      arr.push(element)
    }
    let children = element.childNodes
    children.forEach(element => {
      rec(element, arr)
    });
    return arr
  }
  return rec(element, [])
}
```

##### 判读对象是否存在循环引用

```js
const isCycleObject = (obj,parent) => {
    const parentArr = parent || [obj];
    for(let i in obj) {
        if(typeof obj[i] === 'object') {
            let flag = false;
            parentArr.forEach((pObj) => {
                if(pObj === obj[i]){
                    flag = true;
                }
            })
            if(flag) return true;
            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);
            if(flag) return true;
        }
    }
    return false;
}


const a = 1;
const b = {a};
const c = {b};
const o = {d:{a:3},c}
o.c.b.aa = a;

console.log(isCycleObject(o))
```

##### 根据以下要求，写一个数组去重函数

1. 如传入的数组元素为`[123, "meili", "123", "mogu", 123]`，则输出：`[123, "meili", "123", "mogu"]`
2. 如传入的数组元素为`[123, [1, 2, 3], [1, "2", 3], [1, 2, 3], "meili"]`，则输出：`[123, [1, 2, 3], [1, "2", 3], "meili"]`
3. 如传入的数组元素为`[123, {a: 1}, {a: {b: 1}}, {a: "1"}, {a: {b: 1}}, "meili"]`，则输出：`[123, {a: 1}, {a: {b: 1}}, {a: "1"}, "meili"]`

## 浏览器

##### 前端存储方式

cookie：大小只有4k，设置后自动加入请求头浪费流量，每个 domain 限制 20 个。api 怪异，使用需要自行封装。

localStorage：大小 5M，操作方便，永久性存储。

sessionStorage：只存在于当前页面，不能在窗口之间共享，页面关闭后就会被清理。

Web SQL：关系型数据库。2010 年被废弃。

IndexedDB：NoSQL 非关系型数据库，用键值对进行存储，读取速度快，javascript 操作方便。

##### 跨域

同源策略：针对 ajax 请求，浏览器要求当前网页和请求的服务必须同源，即协议、域名、端口三者一致。

image，css，js，form 表单提交也不受跨域限制：

1.\<img/>

图片可用于统计打点。统计可能是使用第三方统计服务，比如站长之家，百度统计等，这些都是外域的，统计打点无非就是发一个请求，如果用 ajax 发的话就会出现跨域。所以说我们用图片，初始化一个图片，把图片的地址写成第三方统计服务的地址，通过图片去发这个请求就可以了。

2.\<link> \<script>

\<link /> \<script> 可以使用 cdn，cdn 一般都是外域。

跨域解决方案：

所有的跨域解决方案都必须经过 server 端允许和配合。

1.Jsonp

\<script> 可以绕过跨域限制。

只能用 GET 请求，并且要求返回 JavaScript。

2.cors

服务端支持的一种解决跨域的方式，是纯服务器端的操作。

```js
response.setHeader('Access-Control-Allow-Origin', 'http://localhost:8081') // 允许的域名是什么 
response.setHeader('Access-Control-Allow-Headers', 'X-Requested-With')     // 允许的headers是什么 
response.setHeader('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS') // 允许的methods是什么 
response.setHeader('Access-Control-Allow-Credentials', 'true') // 接收跨域的cookie，是否允许传cookie
```

3.设置反向代理

##### Html 文档中各种资源的解析规则

html 在接收到一部分之后就开始解析。

css 下载和解析不会阻塞 dom 的解析。

js 的下载和解析都会阻塞 dom 的解析。

js 的解析需要等待 cssom 全部解析完。

页面渲染需要 dom 和 cssom 全部解析完。

##### script 标签中 defer 和 async 的区别

`<script src="script.js"></script>`

按照顺序来加载并执行脚本，在脚本加载及执行过程中，会阻塞后续 html 文档的解析。

`<script defer src="script.js"></script>`

加载过程不会影响 html 文档解析，并且在 html 文档解析成功后，DOMContentLoaded 事件触发之前执行脚本。

`<script async src="script.js"></script>`

加载过程不会影响 html 文档解析，加载成功后会立即执行脚本内容，这个过程会阻塞后续 html 文档的解析。

##### link 标签中 preload, prefetch, preconnect, dns-prefetch 的区别

`<link rel="preload" href="/main.js" as="script">`

浏览器会在遇到如上 link 标签时，立刻开始下载 main.js(异步加载)，并放在内存中，但不会执行。只有当遇到 script 标签加载的也是 main.js 的时候，浏览器才会将预先加载的 JS 执行掉。如果这个时候 JS 仍然没有下载完，浏览器不会重新发请求，而是等待此文件的加载。字体和图片等资源也可以用这个属性，要用 as 属性标明资源类型，否则这个设置会失效。

`<link rel="prefetch" href="main.js" as="script">`

与 preload 类似。区别是浏览器会在空闲的时候下载，在还没下载完的时候就用到了该资源，会再次发起请求。所以在当前页面马上就要用的资源用 preload，不是马上用的资源用 prefetch。

`<link rel="preconnect" href="https://cdn.bootcss.com">`

提前建立 tcp 链接。

`<link rel="dns-prefetch" href="https://cdn.bootcss.com">`

提前查找 dns 解析域名。

##### 输入地址按下回车的整个流程

1. 查找缓存：有缓存，返回缓存副本，并直接结束请求。没有缓存，发起网络请求过程。
2. 准备 IP 地址：先查找浏览器中的 DNS 数据缓存，没有缓存浏览器会请求 DNS 返回域名对应的 IP。
3. 等待 TCP 队列：Chrome 同一个域名同时最多只能建立 6 个 TCP 连接。
4. 建立 TCP 连接：排队等待结束之后，浏览器通过 TCP 与服务器建立连接。
5. 发送 HTTP 请求：一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。浏览器会向服务器发送请求行，请求头，请求体信息。
6. 服务器处理请求。
7. 服务器返回请求。
8. 断开 TCP 连接：一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。如果浏览器或者服务器在其头信息中加入了 Connection: Keep-Alive，TCP 会一直保持连接。
9. 重定向：返回的状态码是 301，告诉浏览器要重定向到另外一个网址，重定向的网址包含在响应头 Location 字段中，浏览器使用该地址重新导航。
10. 构建 DOM 树：由 HTML 解析器将 html 文件解析成树状结构的 DOM。
11. 样式计算：计算出 DOM 节点中每个元素的具体样式。
12. 布局：根据 DOM 和 ComputedStyle 生成一棵只包含可见元素的布局树，并计算出布局树节点的具体坐标位置。
13. 分层：将页面分成很多图层。
14. 绘制：为每个图层生成绘制命令列表。
15. 栅格化：将图层分成图块，并将图块利用 GPU 转换成位图。
16. 合成和显示：浏览器根据绘制命令将页面内容绘制到内存，将渲染好的页面显示到显示器上。停止标签图标上的加载动画。


重排会走整个渲染流程，重绘会走绘制之后的渲染流程，合成会走栅格化之后的渲染流程（如使用 transform）

## 网络

##### 网络五层模型

* 物理层

* 数据链路层

* 网络层

  IP 协议

* 传输层

  TCP/UDP 协议

* 应用层

  TELNET/SSH/HTTP/SMTP/POP/SSL/TLS/FTP/MIME/HTML

##### IP

IP 是非常底层的协议，只负责把数据包送达目的主机。

交给对方电脑中的具体哪个应用，就需要 UDP 或 TCP 协议了。

##### UDP

应用于在线视频、互动游戏等关注速度、不要求数据完整性的应用。

* 数据传输不可靠：传输过程中出错的数据包会丢失。
* 速度快。

##### TCP

应用于浏览器请求，邮件等要求数据传输可靠性的应用。

* 重传机制：对于传输过程中丢失的数据包，提供重传机制。
* 排序机制：用来保证把乱序的数据包组合成一个完整的文件。
* 速度慢。

##### HTTP 协议格式

```bash
curl -v http://www.baidu.com
```

请求部分：

* 请求行 request line

  * 请求方法：表示此次 HTTP 请求希望执行的操作类型。只是语义上的约定，并没有强约束。

    GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, TRACE。

    浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法。

    HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起。

    PUT 和 DELETE 分别表示添加资源和删除资源。

    CONNECT 现在多用于 HTTPS 和 WebSocket。

    OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。预检请求的 method 也是 OPTIONS。

  * 请求路径

  * 协议和版本

* 请求头 request header

  HTTP 头也是一种数据，可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一些特殊的 HTTP 头。

  * Accept：告诉服务端想要的数据类型。
  * Accept-Charset：想要接收数据的字符集。
  * Accept-Encoding：数据编码方式，用来限制服务端如何进行数据压缩。
  * Accept-Language：语言。
  * Connection：连接方式，如果是 keep-alive，且服务端支持，则会复用连接。
  * Cookie：客户端存储的 cookie 字符串。
  * User-Agent：浏览器的一些相关的信息。操作系统及版本/cpu/浏览器及版本/浏览器渲染引擎/浏览器语言/浏览器插件。
  * If-Modified-Since：上次访问时服务端返回的 Last-Modified。
  * If-None-Match：上次访问时服务端返回的 ETag。
  
* 请求体：请求体可能包含文件或者表单数据

  HTTP 请求的 body 主要用于提交表单场景。一些常见的 body 格式是：

  * application/json
  * application/x-www-form-urlencoded
  * multipart/form-data：既有文本数据，又有文件等二进制数据。所有的传输数据类型都会在编码里面去体现。
  * text/xml


响应部分：

* 响应行 response line

  * 协议和版本
  * 状态码
    * 1xx：临时回应，表示客户端请继续。对前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 HTTP 库直接处理掉了，不会让上层应用知晓。
    * 2xx：请求成功。
      * 200：请求成功。
    * 3xx: 表示请求的目标有变化，希望客户端进一步处理。
      * 301&302：永久性与临时性跳转。表示当前资源已经被转移。
      * 304：跟客户端缓存没有更新。
    * 4xx：客户端请求错误。
      * 400：请求参数有语法错误，不能被服务器理解。
      * 401：没登录，鉴权失败。
      * 403：无权限。禁止访问，服务器收到请求，但是拒绝提供服务。
      * 404：表示请求的资源不存在。
    * 5xx：服务端请求错误。
      * 500：服务端错误。
      * 502：网关错误。
      * 503：由于超载，请求超时或停机维护，服务器目前无法使用，一段时间后可恢复正常，服务端暂时性错误，可以一会再试。
  * 状态文本
* 响应头 response header

  * Content-Type：对应 Accept，Accept 里面可以接收好几种不同的数据格式，那么 Content-Type 可以从里面选择一种然后做为它真正返回的数据格式进行一个返回，客户端根据这个来进行一个怎么样的显示。
  * Content-Encoding：对应的是 Accept-Encoding，服务端具体使用的数据压缩方式。
  * Content-Language：语言。
  * Content-Length：内容长度，有利于浏览器判断内容是否已经结束。
  * Connection：连接方式，keep-alive 表示复用连接。
  * Keep-Alive：保持连接不断时需要的一些信息，如 timeout=5, max=100。
  * Location：告诉客户端重定向的地址。
  * Set-Cookie：设置 cookie，可以存在多个。
  * Cache-Control：缓存控制，用于通知各级缓存保存的时间，例如 max-age=0，表示不要缓存。
  * Expires：过期时间，用于判断下次请求是否需要到服务端取回页面。
  * Last-Modified：页面上次修改的时间。
  * ETag：页面信息摘要，用于判断是否需要重新到服务端取回页面。
  * Access-Control-Allow-Origin：允许的跨域的源，如：'http://localhost:3000'
  * Access-Control-Allow-Headers：允许跨域的请求头，如：'X-Token,Content-Type'
  * Access-Control-Allow-Method：允许跨域的方法，如：'PUT,OPTIONS'
  * Access-Control-Allow-Credentials: true。跨域时默认是不记录 cookie 认证信息的。加上这个让它能够记录，从而能够使用 cookie。
* 响应体：头之后，以一个空行为分隔，响应体则是 HTML 代码。

预检请求：使用了非正常的请求报头或使用非 get/post 的请求会触发预检请求。

##### HTTP 缓存

命中强缓存后不会发送请求，没有命中强缓存后走协商缓存。

强缓存：

cache-control 优先级高于 expires

* expires：它的值为一个绝对时间的 GMT 格式的时间字符串。发送请求的时间在 expires 之前，本地缓存始终有效，强缓存命中。
* cache-control：max-age=number，它是一个相对值，根据资源第一次的请求时间和这个相对值，计算出一个资源过期时间，之后的请求时间在过期时间之前，就能命中缓存。该头可以存在多个。
  * no-cache：不使用强缓存，需要使用缓存协商。
  * no-store：禁止使用强缓存和协商缓存等任何缓存行为。
  * public：可以被所有的用户缓存，包括终端和 CDN 等中间代理服务器。
  * private：只能被终端的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。

协商缓存：

协商缓存由两对 http 头组成。

服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified。

* Last-Modified/If-Modified-Since：

  这两个值是 GMT 格式的时间字符串。

  * 浏览器在第一次请求一个资源，在 respone 的 header 加上 Last-Modified 的 header，表示这个资源在服务器上的最后修改时间。
  * 浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值。服务器根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容和 Last-Modified；如果有变化，就正常返回资源内容和新的 Last-Modified。
  
* Etag/If-None-Match

  这个值是由服务器生成的资源的唯一标识字符串，只要资源有变化这个值就会改变。

  过程与 Last-Modified/If-Modified-Since 类似。不同的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。

* 优缺点

  * Last-Modified
    * 一些文件会周期性的修改时间，但内容并没有改变，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；
    * 某些文件修改非常频繁，比如在秒以下的时间内进行修改，If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
    * 某些服务器不能精确的得到文件的最后修改时间。
  * Etag
    * Etag 能很好的解决上面 Last-Modified 遇到的问题，但由于要生成 hash，会消耗性能。

用户行为对缓存的影响：

![用户行为对缓存的影响](../架构/用户行为对缓存的影响.png)

##### cdn

内容分发网络。加快用户访问速度，减轻源服务器的访问压力。

##### https

HTTP + SSL(TLS) = HTTPS

通常情况下，HTTP 会先直接和 TCP 进行通信。在使用 SSL 的 HTTPS 后，则会先演变为和 SSL 进行通信，然后再由 SSL 和 TCP 进行通信。

做到以下三点才能保证信息的安全：

* 信息的保密性
  * 对称加密
  * 非对称加密
* 信息的完整性
  * 摘要算法
* 身份识别
  * 数字证书

##### http2.0

- 二进制分帧传输
- 多路复用
- 头部压缩
- 服务器推送

## 性能优化

##### 标准

长任务：https://www.w3.org/TR/2017/WD-longtasks-1-20170907/

性能：https://www.w3.org/TR/navigation-timing-2/

1.使用PerformanceNavigationTiming界面获取与文档导航相关的准确计时数据·

```js
<script>
function showNavigationDetails() {
  // Get the first entry
  const [entry] = performance.getEntriesByType("navigation");
  // Show it in a nice table in the developer console
  console.table(entry.toJSON());
}
</script>
<body onload="showNavigationDetails()">
```



##### 谷歌官方学习网站

https://web.dev/

##### 慢的影响

如果网站太慢会影响用户的体验，会造成客诉或资损。

- 57%的用户更在乎网页在3秒内是否完成加载。
- 52%的在线用户认为网页打开速度影响到他们对网站的忠实度。
- 每慢1秒造成页面 PV 降低11%，用户满意度也随之降低降低16%。
- 近半数移动用户因为在10秒内仍未打开页面从而放弃。

##### 性能指标

https://juejin.cn/post/6850037270729359367

* FP（First Paint）：首次绘制。
* FCP（First Contentful Paint）：首次内容绘制。2s 内优秀。
* 白屏时间：输入网址回车后的时间到 FCP 的时间。
* LCP（Largest Contentful Paint）：最大内容绘制（2.5s - 4.0s）
* FMP（First Meaningful Paint）：首次有意义绘制。
* DCL（DOMContentLoaded Event）：dom 渲染完成事件。
* L（Loaded Event）：全部元素渲染完成事件。
* 首屏时间：输入网址回车后的时间到全部页面展示出来的时间。
* TTI（Time to Interactive）：首次可交互时间
  * 从 FCP 指标后开始计算
  * 持续 5 秒内无长任务（执行时间超过 50 ms）且无两个以上正在进行中的 GET 请求
  * 往前回溯至 5 秒前的最后一个长任务结束的时间
* FID（First Input Delay）：首次输入延迟，在 FCP 和 TTI 之间，用户首次与页面交互到 TTI 的时间。用户交互事件触发到页面响应中间耗时多少，如果其中有长任务发生的话那么势必会造成响应时间变长（100ms - 300ms）。
* TBT（Total Blocking Time）：阻塞总时间，记录在 FCP 到 TTI 之间所有长任务的阻塞时间总和。每个长任务的阻塞时间就等于它所执行的总时间减去 50ms。执行时间大于 50ms就是长任务，否则是短任务。（200ms - 600ms）

* CLS（Cumulative Layout Shift）：累计位移偏移。位移距离 / 位移影响的面积（0.1 - 0.25）
* 除了这些指标以外，我们还需要获取网络、文件传输、DOM等信息丰富指标内容。

##### 获取指标

* web-vitals-extension

* web-vitals 库

* Lighthouse

  ```js
  import {getCLS, getFID, getLCP} from 'web-vitals';
  
  getCLS(console.log);
  getFID(console.log);
  getLCP(console.log);
  ```

* Chrome DevTools - Performance

  https://zhuanlan.zhihu.com/p/163474573

* Performance API

  mdn：https://developer.mozilla.org/zh-CN/docs/Web/API/Performance

##### 性能优化

* 优化 FP、FCP、LCP、FMP 指标（白屏、首屏时间）
  * 资源优化
    * 图片优化
      * 使用合适的图片格式
      * 小图标使用字体图标
      * 小图使用 base64
      * 图片懒加载
      * 图片渐进式加载
    * 文件压缩：服务端配置 Gzip 压缩文件体积
    * 代码压缩
    * 异步组件，按需加载
    * Code Splitting
    * 动态 polyfill
    * Tree shaking
    * Scope Hoisting
    * 单页应用改为多页应用
  * 网络优化
    * 缓存文件，对首屏数据做离线缓存
    * 服务端渲染
    * 使用 CDN 加载资源
    * 首屏不需要使用的 CSS 文件不加载
    * 内联关键的 CSS 代码
    * 资源预加载
    * 使用 dns-prefetch 预解析 IP 地址
    * 使用 preconnect，提前建立 TCP 连接
    * 使用 HTTP2.0 协议、TLS 1.3 协议或者直接拥抱 QUIC 协议
* 优化 TTI、FID、TBT 指标（优化耗时任务）
  * 使用 Web Worker 将耗时任务丢到子线程中，这样能让主线程在不卡顿的情况下处理 JS 任务
  * 调度任务 + 时间切片，这块技术在 React 16 中有使用到。简单来说就是给不同的任务分配优先级，然后将一段长任务切片，这样能尽量保证任务只在浏览器的空闲时间中执行而不卡顿主线程
* 优化 CLS 指标
  * 使用骨架屏给用户一个预期的内容框架，突兀的显示内容体验不会很好
  * 图片切勿不设置长宽，而是使用占位图给用户一个图片位置的预期
  * 不要在现有的内容中间插入内容，起码给出一个预留位置

* 代码优化
  * css 放在 head 里面：尽早的使 css 加载完成并执行完成。
  * js 放到 body 最下面：防止 js 阻塞 dom 解析。
  * 对 dom 查询进行缓存
  * 使用 DOMFragment 批量 DOM 操作。
  * css 选择器避免使用过多层级，避免使用标签选择器。
  * 频繁回流重绘的节点设置为单独的图层。使用 will-change。
  * 尽早执行 js：window.DOMContentLoaded：dom 渲染完即可执行，此时图片，视频可能还没有加载完。
  * 编写一些时间复杂度比较低的代码。

  * 节流防抖
  * 合理的加一些 loading

##### 优化实战

https://juejin.cn/post/6919295789630455815

https://github.com/KieSun/per-moniteur

## vue

##### 对 mvvm 的理解

* 模版引擎：提供描述视图的模版语法。
* 数据响应式：数据变化视图更新。
* 渲染：把模版转换成 render 函数，render 函数生成 vdom，最后将 vdom 转换成真实 dom。

##### vue 组件间通信

* props
* 自定义事件
* eventbus
* Vuex
* $parent/$root
* $children
* $refs
* provide/inject

##### vue 父子组件生命周期钩子执行顺序

1. 加载渲染过程
   `父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted`
2. 子组件更新过程
   `父beforeUpdate->子beforeUpdate->子updated->父updated`
3. 父组件更新过程
   `父beforeUpdate->父updated`
4. 销毁过程
   `父beforeDestroy->子beforeDestroy->子destroyed->父destroyed`

##### vue 双向绑定实现原理

数据响应式 + 事件发布订阅

##### vue-router 实现原理

监听地址变化，改变响应式数据 current，这个 current 就是路由表的 path，从路由表中获取到最新的 component，把它渲染到 router-view 里。

vue-router.js 

```js
import Link from './router-link';
import View from './router-view';

// 保存构造函数引用，避免import
let Vue;
class VueRouter {
  constructor(options) {
    this.$options = options;
    // 需要创建响应式的current属性
    // 变成响应式的好处是，在任何组件的template或render函数中用到current就会把它收集起来，将来只要我变了，就会通知用到的组件做更新，重新render
    Vue.util.defineReactive(this, 'current', '/');
    // 还可以使用这种方式实现current的响应式
    // this.app = new Vue({
    //   data() {
    //     return {
    //       current: '/'
    //     }
    //   }
    // })
    
    // 监控url变化
    window.addEventListener('hashchange', this.onHashChange.bind(this));
    window.addEventListener('load', this.onHashChange.bind(this));

    // 创建路由映射表
    this.routeMap = {};
    options.routes.forEach(route => {
      this.routeMap[route.path] = route;
    });
  }
  onHashChange() {
    this.current = window.location.hash.slice(1);
  }
}

// 1.实现一个插件
// 一个插件只是个普通对象，并实现 install 方法。
VueRouter.install = function (_Vue) {
  // 保存构造函数，在VueRouter里面使用
  Vue = _Vue;
  // 挂载$router
  Vue.mixin({
    beforeCreate() {
      // 根实例的时候才执行
      if (this.$options.router) {
        Vue.prototype.$router = this.$options.router;
      }
    }
  });
  // 注册全局组件router-link和router-view
  Vue.component('router-link', Link);
  Vue.component('router-view', View);
}

export default VueRouter;
```

router-link.js 

```js
export default {
  props: {
    to: {
      type: String,
      required: true
    },
  },
  render(h) {
    // <a href="#/about">abc</a>
    // <router-link to="/about">xxx</router-link>
    // h(tag, data, children)
    console.log(this.$slots);
    return h('a', { attrs: { href: '#' + this.to } }, this.$slots.default);
    // jsx
    // return <a href={'#' + this.to}>{this.$slots.default}</a>;
  }
}
```

router-view.js

```js
export default {  
  render(h) {    
    // 获取path对应的component    
    const { routeMap, current } = this.$router; 
    const component = routeMap[current].component || null;  
    return h(component);
  }
}
```

##### vuex 实现原理

vuex.js

```js
// 保存构造函数引用，避免import
let Vue;
class Store {
  constructor(options) {
    // this.$options = options;
    // 保存mutations、actions、getters选项
    this._mutations = options.mutations;
    this._actions = options.actions;
    this._getters = options.getters;
    // 定义computed选项
    const computed = {};
    // 给用户暴露一个getters
    this.getters = {};
    const store = this;
    Object.keys(this._getters).forEach(key => {
      // 获取用户定义的getters
      const fn = store._getters[key];
      // 转换为computed使用的无参数的形式，做一个高阶封装
      computed[key] = function() {
        return fn(store.state);
      }
      // 将getters设置为只读属性
      Object.defineProperty(store.getters, key, {
				get() {
          return store._vm[key];
        }
      });
    })
    // 响应化处理state 
    // this.state = new Vue({
    //   data: options.state
    // });
    this._vm = new Vue({
      data: {
        // 加两个$，Vue不做代理
        $$state: options.state
      },
      // 把getters当成一个计算属性去实现就可以了。注意computed的函数是无参数的。
      computed,
    });
    // 绑定commit、dispatch的上下文为store实例
    // 绑定commit上下文否则action中调用commit时可能出问题!!
    // 同时也把action绑了，因为action可以互调
    this.commit = this.commit.bind(this)
    this.dispatch = this.dispatch.bind(this)
  }
  // 保护state，防止用户直接修改state，利用存取器
  // 存取器， store.state
  get state() {
    console.log(this._vm);
    return this._vm._data.$$state
  }
  set state(v) {
    console.error('你造吗？你这样不好！');
  }
  // 根据用户传入type执行对应mutation
  // store.commit('add', 1)
  // type: mutation的类型
  // payload：载荷，是参数
  commit(type, payload) {
    const entry = this._mutations[type]
    if (entry) {
      // 传递state给mutation
      entry(this.state, payload)
    }
  }
  // 根据用户传入type执行对应action，同时传递上下文 
  dispatch(type, payload) {
    const entry = this._actions[type]
    if (entry) {
      entry(this, payload)
    }
  }
}
function install(_Vue) {
  Vue = _Vue;
  Vue.mixin({
    beforeCreate() {
      if (this.$options.store) {
        Vue.prototype.$store = this.$options.store
      }
    }
  })
}
// Vuex
export default {
  Store,
  install
}
```

##### vue 数据响应式（2）

```js
// 数组响应式
// 思路：找到数组原型，覆盖那七个修改数组的方法，让它除了做原来的事情之外，还能够额外做更新通知，这样就实现了数组的响应式操作。并将得到的新的原型设置到data中的数组实例原型上，这样这个数组执行调用这些方法的时候就会以我们添加的方法为准。
// 1.替换数组原型中那7个方法
const arrayProto = Object.create(Array.prototype);
// splice,reverse,sort
['push', 'pop', 'shift', 'unshift'].forEach(method => {
  arrayProto[method] = function(...args) {
    // 原始操作
    arrayProto[method].call(this, ...args);
    // 覆盖操作：通知更新（对象响应式里的setter操作dep.notify）
    console.log('数组执行 ' + method + '操作');
  }
});

// 数据响应式
function defineReactive(obj, key, val) {
  // 递归
  observe(val);
  // 对传入obj进行访问拦截
  Object.defineProperty(obj, key, {
    get() {
      console.log('get ' + key);
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        console.log('set ' + key + ':' + newVal);
        // 如果传入的newVal依然是obj，需要做响应化处理
        observe(newVal);
        val = newVal;
        // 更新函数
        update();
      }
    }
  })
}

// 遍历做批量响应化处理
function observe(obj) {
  if (typeof obj !== 'object' || obj == null) return;
  if (Array.isArray(obj)) {
    // 数组数据响应化
    // 覆盖该数组的原型
    obj.__proto__ = arrayProto;
    // 对数组内部的元素做响应化处理
    for (let i = 0; i < obj.length; i++) {
      observe(obj[i]);
    }
  } else {
    Object.keys(obj).forEach(key => {
      defineReactive(obj, key, obj[key]);
    });
  }
}

function set(obj, key, val) {
  defineReactive(obj, key, val);
}

// 更新函数
function update() {
  // 更新试图
  app.innerText = obj.foo;
}

// 单个数据响应化处理
// defineReactive(obj, 'foo', 'foo')
// obj.foo
// obj.foo = 'fooooooooooooooooo'
const obj = { foo: 'foo', bar: 'bar', baz: { a: 1 }, arr: [1,2,3] };
observe(obj);
obj.foo;
obj.foo = 'fooooooooooooooo';
obj.bar;
obj.bar = 'barrrrrrrrrrrrrr';

// obj.baz.a = 10 // 深层的数据，拦截不到，需要递归处理里面的对象数据
obj.baz = {a:100}; // 如果赋值依然是obj，拦截不到，需要在setter中赋值时做响应化处理
obj.baz.a = 100000;

// obj.dong = 'dong' // 添加新的属性，拦截不到，使用set做一次响应化处理
set(obj, 'dong', 'dong');
obj.dong;

// Object.defineProperty()对数组无效
// 分析：改变数组方法只有7个
// 解决方案：覆盖数组实例的原型方法，让他们在修改数组同时还可以通知更新
obj.arr.push(4);
```

##### vue3

响应式内部写法变化

* 响应化需要递归遍历，性能消耗较大。
* 新增或删除属性无法监听
* 数组响应化需要额外实现

Composition API

* 复用性
* 代码组合：增加代码可读性，将变量和它的逻辑写到一块。之前分散在各个配置项比如 data， method 中的东西集中到 setup 的函数里，然后 return 一个对象作为 render 函数的上下文。也就是在 render 函数中想要访问的响应式的数据都会在 setup 函数中构造创建并且 return。响应式需要自己做。

##### 简版 MVVM

![Vue数据响应式](Vue数据响应式.png)

* Vue：框架构造函数。
* Observer：
  * 执行数据响应化（分辨数据是对象还是数组，对这两种类型有不同的操作，所以我们多抽象出来了一层，用这个 Observer 来做）。
    * getter：依赖收集。
    * setter：执行更新函数。
* Compile
  * 编译模版：递归遍历 DOM 树，解析出 node 节点和该节点上动态绑定的值 vm.data.key，还有模版绑定语法类型。根据不同的模版语法创建相应的更新函数，接收解析出来的两个值，做 DOM 操作。
    * 初始化视图，执行更新函数。
    * 创建 Watcher 实例，传入更新函数。
* Watcher：管理更新函数。
* Dep：管理 Watcher。

模版中出现一个值就会有一个 watcher，相同的值只对应一个 dep，所以一个 dep 对应 多个 watcher。

在模版编译的时候，比如指令或差值表达式，调用 Watcher，传入 Vue 实例 vm，data 中的哪个 key，和它对应的 dom 的更新函数 updateFn。

Watcher 中通过 Dep.target = this 将该 watcher 设置到一个 Dep.target 的全局变量中，并将模版中的 key 访问一遍触发 getter，再将 Dep.target 制空。

defineReactive 时创建 dep 实例。

getter 的时候将 Dep.target 也就是 watcher 收集到 dep 中。

setter 的时候调用 dep.notify 通知更新。

vue.js

```js
function defineReactive(obj, key, val) {
  // 递归
  observe(val);
  // 创建一个Dep和当前key一一对应
  const dep = new Dep();
  // 对传入obj进行访问拦截
  Object.defineProperty(obj, key, {
    get() {
      console.log('get ' + key);
      // 依赖收集
      Dep.target && dep.addDep(Dep.target);
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        console.log('set ' + key + ':' + newVal);
        // 如果传入的newVal依然是obj，需要做响应化处理
        observe(newVal);
        val = newVal;
        // 通知更新
        // watchers.forEach(w => w.update())
        dep.notify();
      }
    }
  })
}

function observe(obj) {
  if (typeof obj !== 'object' || obj == null) return;
  // 创建Observer实例
  new Observer(obj);
}

// 代理的原数据已经是响应式的了，所以代理数据不需要再做响应式了，只是单纯的做get，set代理操作就行了
// 代理函数，方便用户直接访问$data中的数据
function proxy(vm, sourceKey) {
  // vm是框架实例，sourceKey是vm中的$data
  // 遍历vm[$data]中的所有key，将它代理到vm上的key
  Object.keys(vm[sourceKey]).forEach(key => {
    // 将$data中的key代理到vm上
    Object.defineProperty(vm, key, {
      get() {
        return vm[sourceKey][key];
      },
      set(newVal) {
        vm[sourceKey][key] = newVal;
      }
    })
  })
}

// 创建Vue构造函数
class Vue {
  constructor(options) {
    // 保存选项
    this.$options = options;
    this.$data = options.data;
    // 响应化处理
    observe(this.$data);
    // 代理
    proxy(this, '$data');
    // 创建编译器
    new Compiler(options.el, this);
  }
}

// 根据对象类型决定如何做响应化
class Observer {
  constructor(value) {
    this.value = value;
    // 判断其类型
    if (typeof value === 'object') {
      this.walk(value);
    }
  }
  // 对象数据遍历响应化
  walk(obj) {
    Object.keys(obj).forEach(key => {
      defineReactive(obj, key, obj[key]);
    });
  }
  // 数组数据响应化，待补充
}

// 观察者:保存更新函数，值发生变化调用更新函数
// const watchers = []
class Watcher {
  constructor(vm, key, updateFn) {
    this.vm = vm;
    this.key = key;
    this.updateFn = updateFn;
    // watchers.push(this)
    // Dep.target静态属性上设置为当前watcher实例
    Dep.target = this;
    this.vm[this.key]; // 读取触发getter
    Dep.target = null; // 收集完就置空，防止编译时，读取下一个同样的key时push进去的是该key的上一个更新函数。
  }
  // 更新函数
  update() {
    this.updateFn.call(this.vm, this.vm[this.key]);
  }
}
// Dep：依赖，管理某个key相关所有Watcher实例
class Dep {
  constructor() {
    this.deps = [];
  }
  addDep(dep) {
    this.deps.push(dep);
  }
  notify() {
    this.deps.forEach(dep => dep.update());
  }
}
```

compile.js

```js
// 编译器
// 递归遍历DOM树
// 判断节点类型，如果是文本，则判断是否是插值绑定
// 如果是元素，则遍历其属性判断是否是指令或事件，然后递归子元素
class Compiler {
  // el是宿主元素
  // vm是Vue实例
  constructor(el, vm) {
    // 保存Vue实例，保存需要操作的DOM元素
    this.$vm = vm
    this.$el = document.querySelector(el)

    if (this.$el) {
      // 执行编译，初始化视图
      this.compile(this.$el)
    }
  }

  // 遍历DOM树，开始做编译工作
  compile(el) {
    // 遍历el树
    const childNodes = el.childNodes;
    Array.from(childNodes).forEach(node => {
      // 判断是否是元素
      if (this.isElement(node)) {
        // console.log('编译元素' + node.nodeName);
        this.compileElement(node)
      } else if (this.isInter(node)) {
        // console.log('编译插值绑定' + node.textContent);
        this.compileText(node)
      }

      // 递归子节点
      if (node.childNodes && node.childNodes.length > 0) {
        this.compile(node)
      }
    })
  }

  // 是否是元素
  isElement(node) {
    return node.nodeType === 1
  }

  // 是否是差值绑定
  isInter(node) {
    // 首先是文本标签，其次内容是{{xxx}}
    return node.nodeType === 3 && /\{\{(.*)\}\}/.test(node.textContent)
  }

  // 文本节点编译
  compileText(node) {
    this.update(node, RegExp.$1, 'text')
  }

  // 元素节点编译
  compileElement(node) {
    // 节点是元素
    // 遍历其属性列表
    const nodeAttrs = node.attributes
    Array.from(nodeAttrs).forEach(attr => {
      // 规定：指令以k-xx="oo"定义 k-text="counter"
      const attrName = attr.name // k-xx k-text
      const exp = attr.value // xx counter
      // 指令处理
      if (this.isDirective(attrName)) {
        const dir = attrName.substring(2) // xx text
        // 执行指令
        this[dir] && this[dir](node, exp)
      }
      // 事件处理
      if (this.isEvent(attrName)) {
        // @click="onClick"
        const dir = attrName.substring(1) // 得到click
        // 事件监听
        this.eventHandler(node, exp, dir)
      }
    })
  }

  // 是否是指令
  isDirective(attr) {
    return attr.indexOf('k-') === 0
  }
  
  // 是否是事件
  isEvent(attr) {
    return attr.indexOf('@') === 0
  }
  
  // k-text
  text(node, exp) {
    this.update(node, exp, 'text')
  }

  
  // k-html
  // 双向绑定，语法糖，它实际上做了两个事，value 值的设定和事件的监听。设置 v-model 就是要实现这两个事情，因此在代码的实现层面实现这两件事情就可以了。
  html(node, exp) {
    this.update(node, exp, 'html')
  }
  
  // k-model
  model(node, exp) {
    // update方法只完成赋值操作，是单向的
    // value赋值
    this.update(node, exp, 'model')
    // 事件监听
    node.addEventListener('input', e => {
      // 将新的值赋值给数据
      this.$vm[exp] = e.target.value
    })
  }

  // 编译函数
  update(node, exp, dir) {
    // 编译初始化
    // 组合最终的DOM更新函数xxUpdater
    const fn = this[dir + 'Updater']
    fn && fn(node, this.$vm[exp])

    // 创建Watcher实例
    // 传入更新函数
    new Watcher(this.$vm, exp, function (val) {
      fn && fn(node, val)
    })
  }

  textUpdater(node, value) {
    node.textContent = value
  }

  htmlUpdater(node, value) {
    node.innerHTML = value
  }
  
  modelUpdater(node, value) {
    // 表单元素赋值
    node.value = value
  }
  
  // 事件监听处理
  eventHandler(node, exp, dir) {
    const fn = this.$vm.$options.methods && this.$vm.$options.methods[exp]
    node.addEventListener(dir, fn.bind(this.$vm))
  }
  
}
```

##### vue 源码调试技巧

搭建调试环境：

1. clone 源码，地址：https://github.com/vuejs/vue.git  版本:2.6.10

2. 安装依赖：npm install

3. 安装 rollup，Vue 的打包工具是 rollup：npm install -g rollup

4. 修改 package.json 中的 dev 打包脚本：增加 --sourcemap

   "dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev"

5. 打包，执行开发脚本，输出最终我们要用的 vue.js：npm run dev

   打包成功之后 dist 下会生成一个全新的 vue.js，和它的 map 文件 vue.js.map

6. 编写测试文件

   examples/test/01-test.html

   把刚才打包的 vue.js 引进来，写一个 vue 程序，接下来就可以调试了。


调试技巧：

* 打开指定文件：ctrl+p
* 断点
* 单步执行：单步跳过函数/单步进入函数

* 查看调用栈：调用栈中可以很好的看到整个的函数执行的流程。

* 定位当前源文件所在位置：sources 代码上右键，Reveal in sidebar 选项。


##### vue 源码分析

1.根据打包命令找到打包的入口文件

核心功能：扩展 $mount

src/platforms/web/entry-runtime-with-compiler.js：

* 针对 web 平台的特点对 $mount 做扩展，扩展的就是跟编译相关的事。(功能扩展的方式值得学习)

  处理 render > template > el 选项：

  选项中如果有 render 直接调用 mount 执行挂载；如果有 template 或 el，将它们进行一定处理最后变成 template，然后将这个 template 执行模版解析和编译，最终得到 render 函数并将其放到选项中去。最后执行挂载操作。

2.寻找 Vue 构造函数

核心功能：定义 $mount, \__patch__, 初始化全局 API(Vue.xxx), 定义 Vue, 初始化实例 API(Vue.prototype.xxx)

src/platforms/web/runtime/index.js：

* 安装 web 平台特有指令和组件；
* 在 Vue 原型上定义了补丁方法 Vue.prototype.\__patch__：把虚拟 DOM 转换成真实 DOM。初始化的赋值和以后的更新都会用到这个 patch，也是 diff 算法发生的地方；
* 定义 $mount：它只做了一件事，就是把 el 做 DOM 查询，然后调用 mountComponent 执行挂载，将首次渲染的结果替换 el。

src/core/index.js：

* 初始化全局 API：Vue.util, Vue.set, Vue.delete, Vue.nextTick, Vue.use, Vue.mixin, Vue.extend, Vue.component, Vue.directive, Vue.filter

src/core/instance/index.js：

* 定义 Vue 构造函数：内部只执行了一行初始化方法 this._init()。
* 使用混入的方式定义 Vue 实例 API（这个混入的方式扩展构造函数原型值得学习）
  * initMixin(Vue)：定义了初始化方法 _init
  * stateMixin(Vue)：定义了 $data,$props,$set,$delete,$watch
  * eventsMixin(Vue)：定义了 $on,$once,$off,$emit
  * lifecycleMixin(Vue)：定义了 _update,$forceUpdate,$destroy
  * renderMixin(Vue)：定义了 $nextTick,_render

3.总体流程：

* 模版编译：编译的结果是得到 render 函数并放入配置中。
  * 解析：ast = parse(template.trim(), options)
    * HTML解析器
    * 文本解析器
    * 过滤器解析器。
  * 优化：optimize(ast, options)
    * 在 AST 中标记静态子树：patch 时，可以跳过静态子树，提高性能。
  * 生成：code = generate(ast, options)
    * 把 AST 转换成代码字符串，传入 new Function(code) 中得到 render 函数。

* 实例化：将配置传入构造函数中，实例化一个根组件（Vue）实例或自定义组件（VueComponent）实例。

  * 初始化 _init：
    * 合并选项
    * initLifecycle(vm)：声明组件实例的 $parent, $root, $children, $refs
    * initEvents(vm)：对父组件传入的自定义事件添加监听
    * initRender(vm)：声明了 $slots, $createElement就是那个h，对$attrs, $listeners 做了响应化处理。
    * callHook(vm, 'beforeCreate')
    * initInjections(vm)：获取祖辈的注入数据
    * initState(vm)：初始化响应式数据 initProps, initMethods, initData, initComputed, initWatch
      * initData：数据响应式，有几个对象数据（包括data）就有几个 Observer 实例，dep 的数量是对象数据个数（包括 data） + data  内所有 key 的数量，几个组件就有几个 Watcher。
        * 数据命名冲突校验
        * 数据代理
        * 执行 observe，传入 data
          * 创建 Observer 实例
            * 创建对象数据的 dep。$set, array 那七个变更数组方法时会使用到这个的 dep 中存放的依赖来做通知更新。
            * 创建每个 key 对应的 dep。
            * 分别做数组和对象的响应化处理。
            * getter：分别对每个 key 的 dep 和对象数据的 dep 做依赖收集，收集的都是组件 Watcher
            * setter：劫持数据变化
              * dep.notify()：通知更新
              * 批量异步更新：将 dep 中收集的所有 Watcher 的更新函数批量异步的执行一遍。
                * watcher.update()
                * queueWatcher()
                * nextTick()
                * timerFunc()
                * flushSchedulerQueue()
                * watcher.run() 
                * watcher.get()
                * updateComponent()
    * initProvide(vm)：给后代提供数据
    * callHook(vm, 'created')
    * 最后判断选项里如果有 el，自动执行 $mount。

* 挂载 $mount

  * 执行 mountComponent

    * callHook(vm, 'beforeMount')

    * 声明更新函数 updateComponent

      * 执行 _render

        * render（配置中的render）
          * createElement：h 方法，传入 tag, data, children 等
            * 原生标签：创建 vnode 并返回
            * 自定义组件：createComponent
              * 获取组件配置
              * 根据组件配置，获取组件构造函数
              * 安装组件管理钩子到该组件的 vnode 上。
                * init：组件初始化，创建组件实例，挂载。patch 时执行 init。
                * prepatch：组件更新之前执行，patch 之前的一些工作
                * insert：组件创建完插入 dom 元素里，调用子组件的 mounted 生命周期
                * destroy：组件销毁相关工作
              * 创建 vnode 并返回

      * 执行 _update，传入  vnode。

        * patch

          * new vnode 不存在就删除

          * old vnode 不存在就新增

            * createElm

          * 都存在

            * oldVnode 是原生标签

              * createElm：创建新节点，把 vnode 创建成 DOM 元素，然后递归创建子元素和子组件。
                * createComponent：如果要创建的是组件，走这个流程
                  * 获取创建组件 vnode 时安装的 init 组件管理钩子并执行：创建组件实例并挂载。
                  * insert：子组件 DOM 树插入父组件的 DOM 树上。
                * 原生标签的创建：
                  * 把 vnode 创建成真实的 DOM，createChildren 递归创建子元素
                  * insert：子组件 DOM 树插入父组件的 DOM 树上。

            * oldVnode 不是原生标签 && 是同一个 vnode 节点

              * patchVnode：执行 diff 更新。

                有孩子先比孩子调用 updateChildren，updateChildren 中还会调用 patchVnode，一直向下递归，将每个 vnode 节点都 patch 一遍。

                每个节点比较的和更新的就是三件事：属性更新，文本更新，子节点更新：

                * isPatchable(vnode)：节点本身的 patch 操作，属性更新。

                * 都无子节点：只是文本的替换。

                * 只有新有子节点：先清空老文本内容，然后为其新增子节点。 

                * 只有老有子节点：移除该节点的所有子节点。

                * 新老均有子节点：对子节点进行 Diff 操作，调用 updateChildren。

                  * updateChildren

                    * 设置双指针，首尾都没有找到相同的节点还是要做双循环。最后根据新老 vnode 的节点剩余情况做相应的新增或删除工作。

                      * 找到相同的节点调用 patchVnode（递归：深度优先）

                      * 移动节点位置（实际的 dom 操作），移动指针做下一个节点的对比（同级比较）

          * invokeInsertHook：调用组件管理钩子 insert。里面调用了 mounted 生命周期钩子。

    * 创建组件 Watcher，传入 updateComponent

      * 执行 updateComponent

    * callHook(vm, 'mounted')

## 工程化

##### webpack 优化

分析工具

* 速度分析：使用 speed-measure-webpack-plugin
* 体积分析：使用 webpack-bundle-analyzer

构建速度优化

* 使用高版本的 webpack 和 Node.js
* 缩小构建目标
* 优化文件查找路径
* 多进程构建
* 多进程压缩代码
* 利用缓存提升二次构建速度

体积优化

* 代码、图片压缩
* Tree Shaking
* Scope Hoisting
* Code Splitting
* 动态 import 加载异步组件
* 使用 cdn 静态资源
* 动态 polyfill

##### webpack 热更新理

##### webpack 原理

Tapable 为 webpack 插件提供了发布订阅的钩子。每个钩子代表一个关键的事件节点。

webpack 就是基于这种发布订阅的一系列的插件运行的事件流。

在 webpack 内部的 compiler 和 compilation 上面做 hooks 的调用。

插件有个 apply 方法，接收一个 compiler 参数。插件里面做 compiler 和 compilation 上的 hooks 的监听。

* 处理配置参数。
* 执行用户配置中的所有插件。
* 根据配置开启 webpack 内部的插件。
* 使用 loader-runner 运行 loaders 进行编译和分析依赖
* 将所有编译好的 js 代码放到 compilation 对象上的 modules 里面。
* 代码优化
* 将 modules 里的代码放到 compilation 对象的 assets 里面去
* 资源生成

##### 手写一个 loader

loader

loader 是一个导出为声明式函数的 javascript 模块，接收资源返回资源：

```js
const loaderUtils = require("loader-utils");
module.exports = function(source) { 
  // 参数获取
  const { name } = loaderUtils.getOptions(this);
  
  // 异常处理
  // 1.throw new Error('Error');
  // 2.this.callback(new Error('Error'), source);
  
  // 返回结果
  // 1.return source;
  // 2.this.callback(null, source, 1, 2); 可以返回多个值
  
  // 异步处理
  const callback = this.async();
  fs.readFile(path.join(__dirname, './demo.txt'), 'utf-8', (err, data) => {
    if (err) {
      callback(err, '');
    }
    callback(null, data);
  });
  
  // 缓存
  // webpack 中默认开启缓存，可以使用以下方法关闭缓存
  // 缓存生效条件：loader 的结果有确定的输出。有依赖的 loader 无法使用缓存。
  this.cacheable(false);
  
  // 文件输出
  const url = loaderUtils.interpolateName(this, "[name].[ext]", source);
  this.emitFile(url, source);
};
```

##### 手写一个 plugin

插件是一个类，有一个 apply 方法。

```js
// 将一段代码输出到文件里面就可以用 RawSource
const { RawSource } = require("webpack-sources"); 
class MyPlugin {
  constructor(options) { 
    this.options = options; 
  }
  apply(compiler) {
    // 插件处理逻辑
    
    // 插件的错误处理
    // 1.throw new Error('error');
    // 2.通过 compilation 对象的 warnings 和 errors 接收
    //   compilation.warnings.push("warning");
    //   compilation.errors.push("error");

    // 文件写入
    // webpack 的构建流程的文件生成是在 emit 阶段，所以在插件里监听 compiler emit 这个 hooks。
    // 监听这个 hook 之后我们可以获取到 compilation 对象
    // 然后只需要将最终要输出的内容设置到 compilation.assets 对象上面去就可以了
    // 最终webpack生成文件的时候会触发emit，然后读取compilation.assets上的资源内容并输出到磁盘目录
    const { path } = this.options;
    compiler.hooks.emit.tapAsync("MyPlugin", (compilation, callback) => { 
      compilation.assets[path] = new RawSource("demo"); 
      callback();
    }); 
  } 
}
module.exports = MyPlugin;
```

## 算法

##### 找出字符串中连续出现最多的字符和个数

```js
// 'abcaakjbb' => {'a':2,'b':2}
// 'abbkejsbcccwqaa' => {'c':3}
function maxRepeat(s) {
    const res = {};
    const arr = s.match(/(\w)\1*/g);
    const maxLen = Math.max(...arr.map(s => s.length));
    for (let item of arr) {
        if (item.length === maxLen) {
            res[item[0]] = maxLen;
        }
    }
    return res;
}
```

##### LRU 算法

```js
//  一个Map对象在迭代时会根据对象中元素的插入顺序来进行
// 新添加的元素会被插入到map的末尾，整个栈倒序查看
class LRUCache {
  constructor(capacity) {
    this.secretKey = new Map();
    this.capacity = capacity;
  }
  get(key) {
    if (this.secretKey.has(key)) {
      let tempValue = this.secretKey.get(key);
      this.secretKey.delete(key);
      this.secretKey.set(key, tempValue);
      return tempValue;
    } else return -1;
  }
  put(key, value) {
    // key存在，仅修改值
    if (this.secretKey.has(key)) {
      this.secretKey.delete(key);
      this.secretKey.set(key, value);
    }
    // key不存在，cache未满
    else if (this.secretKey.size < this.capacity) {
      this.secretKey.set(key, value);
    }
    // 添加新key，删除旧key
    else {
      this.secretKey.set(key, value);
      // 删除map的第一个元素，即为最长未使用的
      this.secretKey.delete(this.secretKey.keys().next().value);
    }
  }
}
// let cache = new LRUCache(2);
// cache.put(1, 1);
// cache.put(2, 2);
// console.log("cache.get(1)", cache.get(1))// 返回  1
// cache.put(3, 3);// 该操作会使得密钥 2 作废
// console.log("cache.get(2)", cache.get(2))// 返回 -1 (未找到)
// cache.put(4, 4);// 该操作会使得密钥 1 作废
// console.log("cache.get(1)", cache.get(1))// 返回 -1 (未找到)
// console.log("cache.get(3)", cache.get(3))// 返回  3
// console.log("cache.get(4)", cache.get(4))// 返回  4
```

##### 动态规划求解硬币找零问题

##### 请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]

```js
// 1
function concatArr (arr1, arr2) {
   const arr = [...arr1];
  let currIndex = 0;
 for (let i = 0; i < arr2.length; i++) {
    const RE = new RegExp(arr2[i])
    while(currIndex < arr.length) {
      ++currIndex
      if (!RE.test(arr[currIndex])) {
         arr.splice(currIndex, 0, a2[i])
         break;
       }
     }
   }
  return arr
 }
 var a1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 
 var a2 = ['A', 'B', 'C', 'D']
 const arr = concatArr(a1, a2)
 console.log(a1) // ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 
 console.log(a2) // ['A', 'B', 'C', 'D']
 console.log(arr) // ['A1', 'A2', 'A', B1', 'B2', 'B', C1', 'C2', 'C', D1', 'D2', 'D'] 
// 2
const arr1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
const arr2 = ['A', 'B', 'C', 'D']
const ret = []
let tmp = arr2[0]
let j = 0
for (let i=0;i<arr1.length;i++) {
  if (tmp === arr1[i].charAt(0)){
    ret.push(arr1[i])
  }else {
    ret.push(tmp)
    ret.push(arr1[i])
    tmp=arr2[++j]
  }
   if(i===arr1.length-1){
      ret.push(tmp)
    }
}
console.log(ret)
// 3
let a1 =  ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
let a2 = ['A', 'B', 'C', 'D'].map((item) => {
  return item + 3
})

let a3 = [...a1, ...a2].sort().map((item) => {
  if(item.includes('3')){
    return item.split('')[0]
  }
  return item
})

// 4
var arr1 = ["A1", "A2", "B1", "B2", "C1", "C2", "D1", "D2"]
var arr2 = ["A", "B", "C", "D"]
var arr3 = arr1.concat(arr2);
arr3.sort().sort(function(a,b){
   if (a.charAt(0) == b.charAt(0) && a.length > b.length){
       return -1
   }
	
})
// 5
var arr1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
var arr2 = ['A', 'B','C', 'D'];

function fn (arr1, arr2) {
let arr3 = [...arr1];
let index = -1;
arr2.forEach((v, i) => {
index = index + 3;
arr3.splice(index, 0, v);
});
return arr3;
}

```

##### 版本号排序算法

```js
// 有一组版本号如下['0.1.1', '2.3.3', '0.302.1', '4.2', '4.3.5', '4.3.4.5']。现在需要对其进行排序，排序的结果为 ['4.3.5','4.3.4.5','2.3.3','0.302.1','0.1.1']

arr.sort((a, b) => {
  let i = 0;
  const arr1 = a.split(".");
  const arr2 = b.split(".");

  while (true) {
    const s1 = arr1[i];
    const s2 = arr2[i];
    i++;
    if (s1 === undefined || s2 === undefined) {
      return arr2.length - arr1.length;
    }

    if (s1 === s2) continue;

    return s2 - s1;
  }
});
console.log(arr);
```

##### 计算数组的交集

给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。

##### 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]

```js
// 生产随机数
var arr = (function(len){
    var a = []
    for(var i = 0; i < len; i++) {
        a.push(Math.floor(Math.random() * 100))
    }
    return a
})(20)

// 排序
arr.sort(function(a, b) {
    return a - b
})
// 去重 (arr 转 set 然后 set 转 arr)
arr = [...(new Set([...arr]))]

var subArr = []

// 用 map 存储
var map = {}
arr.forEach(item => {
    var key = Math.floor(item / 10)
    if(!map[key]) {
        map[key] = []
    }
    map[key].push(item)
})

// map 转 数组
for(var key in map) {
    subArr.push(map[key])
}

console.log(JSON.stringify(subArr))
```

##### 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。

```js
// 1
const find = (S, T) => {
  if (S.length < T.length) return -1
  for (let i = 0; i < S.length; i++) {
    if (S.slice(i, i + T.length) === T) return i
  }
  return -1
}
// 2
const find = (S,T) => S.indexOf(T)
// 3
const find = (S, T) => S.search(T)
// 4
const find = (S, T) => {
  const matched = S.match(T) 
  return matched ? matched.index : -1 
}
```

##### 打印 1-10000之间所有对称数

```js
// 1
[...Array(10000).keys()].filter((x) => { 
  return x.toString().length > 1 && x === Number(x.toString().split('').reverse().join('')) 
})
// 2
var result = [];
for (let i = 1; i <= 10000; i++) {
	let origin = '' + i;
	let reverse = origin.split('').reverse().join('');
	if(origin === reverse) {
		result.push(i);
	}
}
```

##### 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))。

##### 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。

##### 输入 `'1, 2, 3, 5, 7, 8, 10'` 输出 `'1~3, 5, 7~8, 10'`

##### 统计 1 ~ n 整数中出现 1 的次数

##### 在一个字符串数组中有红、黄、蓝三种颜色的球，且个数不相等、顺序不一致，请为该数组排序。使得排序后数组中球的顺序为:黄、红、蓝。

例如：红蓝蓝黄红黄蓝红红黄红，排序后为：黄黄黄红红红红红蓝蓝蓝。

##### 1 到 12 月份的销售额存在一个数组里面

```js
const obj = {1:222, 2:123, 5:888};
const result = Array.from({ length: 12 }).map((_, index) => obj[index + 1] || null);
console.log(result)
```

##### 实现千位分隔符

```js
let format = n => {
    let num = n.toString() // 转成字符串
    let decimals = ''
        // 判断是否有小数
    num.indexOf('.') > -1 ? decimals = num.split('.')[1] : decimals
    let len = num.length
    if (len <= 3) {
        return num
    } else {
        let temp = ''
        let remainder = len % 3
        decimals ? temp = '.' + decimals : temp
        if (remainder > 0) { // 不是3的整数倍
            return num.slice(0, remainder) + ',' + num.slice(remainder, len).match(/\d{3}/g).join(',') + temp
        } else { // 是3的整数倍
            return num.slice(0, len).match(/\d{3}/g).join(',') + temp 
        }
    }
}
format(12323.33)  // '12,323.33'

// 无小数版
let format = n => {
    let num = n.toString() 
    let len = num.length
    if (len <= 3) {
        return num
    } else {
        let remainder = len % 3
        if (remainder > 0) { // 不是3的整数倍
            return num.slice(0, remainder) + ',' + num.slice(remainder, len).match(/\d{3}/g).join(',') 
        } else { // 是3的整数倍
            return num.slice(0, len).match(/\d{3}/g).join(',') 
        }
    }
}
format(1232323)  // '1,232,323'
```

##### 大数相加

```js
// 1
function sumBigNumber(a, b) {
  let res = '';
  let temp = 0;
  
  a = a.split('');
  b = b.split('');
  
  while (a.length || b.length || temp) {
    temp += ~~a.pop() + ~~b.pop();
    res = (temp % 10) + res;
    temp  = temp > 9
  }
  return res.replace(/^0+/, '');
}
// 2
let a = "9007199254740991";
let b = "1234567899999999999";

function add(a ,b){
   //...
}

function add(a ,b){
   //取两个数字的最大长度
   let maxLength = Math.max(a.length, b.length);
   //用0去补齐长度
   a = a.padStart(maxLength , 0);//"0009007199254740991"
   b = b.padStart(maxLength , 0);//"1234567899999999999"
   //定义加法过程中需要用到的变量
   let t = 0;
   let f = 0;   //"进位"
   let sum = "";
   for(let i=maxLength-1 ; i>=0 ; i--){
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t/10);
      sum = t%10 + sum;
   }
   if(f!==0){
      sum = '' + f + sum;
   }
   return sum;
}
```

##### 大数相乘

```js
function multiplyBigNum(num1, num2) {
    //判断输入是不是数字
    if (isNaN(num1) || isNaN(num2)) return "";
    num1 = num1 + ""
    num2 = num2 + ""
    let len1 = num1.length,
        len2 = num2.length;
    let pos = [];

    //j放外面，先固定被乘数的一位，分别去乘乘数的每一位，更符合竖式演算法
    for (let j = len2 - 1; j >= 0; j--) {
        for (let i = len1 - 1; i >= 0; i--) {
            //两个个位数相乘，最多产生两位数，index1代表十位，index2代表个位
            let index1 = i + j,
                index2 = i + j + 1;
            //两个个位数乘积加上当前位置个位已累积的数字，会产生进位，比如08 + 7 = 15，产生了进位1
            let mul = num1[i] * num2[j] + (pos[index2] || 0);
            //mul包含新计算的十位，加上原有的十位就是最新的十位
            pos[index1] = Math.floor(mul / 10) + (pos[index1] || 0);
            //mul的个位就是最新的个位
            pos[index2] = mul % 10;
        }
    }

    //去掉前置0
    let result = pos.join("").replace(/^0+/, "");

    return result - 0 || '0';
}
```

##### 手机号中间4位变*

```js
// 1
const tel = 18877776666; 
tel = "" + tel; 
var ary = tel.split(""); 
ary.splice(3,4,"****"); 
var tel1 = ary.join(""); 
console.log(tel1);
// 2
const tel = 18877776666; 
tel = "" + tel; 
var tel1 = tel.substr(0,3) + "****" + tel.substr(7) 
console.log(tel1);
// 3
const tel = 18877776666;  
tel = "" + tel; 
var tel1 =tel.replace(tel.substring(3,7), "****") 
console.log(tel1);
// 4
const tel = 18877776666;  
tel = "" + tel; 
var reg=/(\d{3})\d{4}(\d{4})/; 
var tel1 = tel.replace(reg, "$1****$2") 
console.log(tel1);
```

## 项目

##### 项目

1. 怎么设计一个组件库。
2. 3000 行代码重构。
3. 使用节流优化用户体验。
4. 优化构建速度，提升开发效率。
5. 基础架构设计
   1. 本地 mock 服务器的搭建
   2. 权限管理
      1. 导航权限
      2. 页面权限
      3. 按钮权限
   3. 请求封装
   4. 公用函数封装
   5. 换肤
   6. 国际化
6.  数据流的管理，从这里还可以延伸到函数式编程，纯函数这些
7. 对于一些复杂组件的设计。
   1. 多级递归表头表格组件
   1. 规则条件筛选组件的设计
   2. form 表单的设计
   4. 虚拟列表

##### 技术不足

1. 具体的项目工程化实践
2. 复杂业务组件的编写
3. 数据结构和算法
4. 架构，设计模式
5. 汇报能力，业务描述能力，沟通能力

## 非技术面

##### 非技术面试

1. 你的优点
   1. 编写代码会考虑可读性，可维护性，性能更好的代码。能够高效高质量的完成工作内容。
   2. 做事有责任感，积极主动，乐观向上，为人随和，和同事之间相处融洽。
   3. 能承受一定的工作压力。
   4. 热爱编程和持续保持学习。
2. 你的缺点
   1. 不是一个能够带头活跃气氛的人。
   2. 有点慢热（相对这个缺点的优点就是稳）。
3. 职业规划
   1. 架构
   2. 管理
4. 最近在看什么书，研究什么技术。
   1. 算法
   2. 架构（webpack源码）
5. 期望薪资
   1. 更注重的是找对工作机会。
   2. 薪资只要我觉得在我能力匹配的范围内都可以接受。
6. 工作考虑的因素
   1. 稳定
   2. 再给公司团队带来一些效益的同时能够在工作中提高自己，并且给自己带来成就感
7. 还有什么问题要问的吗？
   1. 具体做的是什么业务。
   2. 公司的晋升机制。

## 规划

##### 语言包装

复盘，赋能，抓手，对标，沉淀，对齐，拉通，倒逼，颗粒度，落地，中台，方法论，漏斗，组合拳，闭环，生命周期，打法，履约，引爆点，串联，价值转化，纽带，矩阵，协同，反哺，点线面，认知，强化认知，强化心智，交互，兼容，包装，响应，刺激，规模，重组，量化，宽松，资源倾斜，完善逻辑，抽离透传、抽象，复用打法，发力，精细化，布局，商业模式，联动，场景，聚焦，快速响应，影响力，价值，细分，垂直领域，维度，定性定量，聚焦，去中心化，关键路径，接地气，梳理，输出，格局，生态。

##### 入职

1. 毕业证学位证原件复印件
2. 身份证原件复印件3张
3. 体检报告
4. 一寸免冠电子版照片
5. 离职证明原件
6. 户口本首页及本人页复印件2张
7. 招商银行卡原件和复印件1张

##### 规划

1. 讲课能力
2. 技术提升
3. 沟通表达
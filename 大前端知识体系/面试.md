前端面试题汇总：

https://juejin.cn/post/7004638318843412493#heading-21

https://juejin.cn/post/6968713283884974088

https://hub.fastgit.org/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB

https://www.yuque.com/cuggz/interview

https://github.com/lgwebdream/FE-Interview/issues?page=1&q=is%3Aissue+is%3Aopen

前端大班车公众号

大厂面试题（牛客...）

## html

##### html 语义化

语义化使页面具有良好的结构和含义，代码可读性好。

有利于搜索引擎爬取有效信息（seo），支持读屏软件，可以自动生成目录。

##### doctype 的作用

文档类型，用来告知浏览器用什么文档标准来解析这个文档，它必须声明在 html 文档的第一行。

可以通过 document.compatMode 获取浏览器渲染页面的两种模式：

* CSS1Compat：标准模式
* BackCompat：怪异模式，不声明 DOCTYPE 的默认模式。

##### 常用的 meta 标签

```html
<!--描述html文档的编码形式-->
<meta charset="UTF-8">
<!--设置页面关键词-->
<meta name="keywords" content="关键词" />
<!--设置页面描述-->
<meta name="description" content="页面描述内容" />
<!--设置http头-->
<meta http-equiv="expires" content="Wed, 20 Jun 2019 22:33:00 GMT">
<!--设置移动端viewport大小和比例-->
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
```

## css

##### px/em/rem

px：绝对单位，页面精确像素。

em：父节点字体大小，如果自身定义了使用自身字体大小。

rem：根结点字体大小。

##### 隐藏页面的方式

`opacity: 0`：占据空间，可以交互。

`visibility: hidden`：占据空间，不可交互。

`overflow: hidden`：隐藏溢出部分，占据空间，不可交互。

`display: none`：不占据空间，不可交互。

`transform: scale(0, 0)`：平面变换，将元素缩放为 0，占据空间，不可交互。

##### 水平垂直居中

水平居中：

```html
<div class="parent">
	<div class="child"> 啦啦啦 </div>
</div>

<style>
/* 方案一：inline-block + text-align */
.parent { text-align: center; }
.child { display: inline-block; }
/* 方案二：block + margin */
.child { 
  width: 100px; /* 需要设置宽度 */
  display: block; /* 设置成table可以不设置宽度 */
  margin: 0 auto;
}
/* 方案三：absolute + transform/margin */
.parent { position: relative; }
.child {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}
</style>
```

垂直居中：

```html
<div class="parent">
	<div class="child"> 啦啦啦 </div>
</div>

<style>
/* 方案一：table-cell + vertical-align */
.parent {
	display: table-cell; /* 单元格的内容是可以设置水平垂直对齐的 */
  vertical-align: middle; /* 用于设置文本内容的垂直方向对齐方式 */
}
/* 方案二：absolute + transform/margin */
.parent { position: relative; }
.child {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
</style>
```

##### BFC（块级格式化上下文）

BFC 是指一块独立的区域，让处于 BFC 内部的元素与外部的元素相互隔离，不互相产生影响。

BFC 触发条件：

* 根元素 html 元素
* position: fixed/absolute
* float 不是 none
* overflow 不为 visible
* display: inline-block/table-cell/table-caption/flex

BFC 应用：

1. 清除浮动
2. 防止同一 BFC 容器中的相邻元素间的外边距重叠问题

##### 清除浮动

1.父级添加 overflow 属性

通过触发 BFC 方式（就是负责接管自己的宽高），实现清除浮动。

```css
.fahter {
  overflow: hidden; /* auto 也可以 */
}
```

2.额外标签 clear: both;

在最后一个浮动标签后，新加一个标签，给其设置 clear: both; 

3.使用 after 伪元素清除浮动

```css
.clearfix::after {
  display: block; /* 伪元素默认是 inline 的，inline 元素无法帮我们做清除浮动的事情。 */
  content: " ";
  clear: both;
  height: 0;
  visibility: hidden;
  overflow：hidden;
}
```

4.万能清除法

```css
.clearfix::before, .clearfix::after {
  display: block;
  content: " ";
}
.clearfix::after {
  clear: both;
}
```

##### 画三角形

![triangle-up](triangle-up.png)

```css
#triangle {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}
```

##### css 怎么开启硬件加速(GPU 加速)

- transform（当 3D 变换的样式出现时会使用 GPU 加速）
- opacity
- filter
- will-change

采用 transform: translateZ(0) 采用 transform: translate3d(0, 0, 0) 使用 CSS 的 will-change属性。 will-change 可以设置为opacity、transform、top、left、bottom、right。

##### 对 requestAnimationFrame 的理解

请求动画的 API

## Javascript

##### 数据类型

typeof：

值类型：'undefined', 'number', 'string', 'boolean', 'symbol'

引用类型：'function', 'object'(对象，数组，null)

Object.prototype.toString.call(obj)： 

'[object Undefined]', '[object Number]', '[object String]', '[object Boolean]', '[object Symbol]', '[object Function]', '[object Object]', '[object Array]', '[object Null]'

获取数据类型：

```js
function getType(value) {
  if (value === null) return value + "";
  if (typeof value === "object") {
    let valueClass = Object.prototype.toString.call(value),
    type = valueClass.split(" ")[1].split("");
    type.pop();
    return type.join("").toLowerCase();
  } else {
    return typeof value;
  }
}
```

##### 作用域

作用域：作用域就是变量，函数能够使用的范围。

作用域链：自由变量查找的顺序。

自由变量：当前作用域没有定义，但是使用了的变量。

自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在函数执行的地方。

##### 闭包

闭包是一个绑定了执行环境的函数。

* 函数的词法环境
* 函数中用到的未声明的变量
* 函数体

有两个函数，内部函数定义在外部函数中，并且内部函数使用了外部函数环境中定义的变量，当内部函数执行的时候，外部函数就形成了一个闭包。

```js
(function () {
  var a = 1;
  function add() {
    var b = 2;
    var sum = b + a;
    console.log(sum) // 3
  }
  add();
})();
```

闭包作用：

1.私有化数据。

函数中的 data 只能通过 get 和 set 访问，外部无法访问，相当于将变量私有化。

```js
function createCache () {
  const data = {};
  return {
    get(key) {
      return data[key];
    },
    set(key, value) {
      data[key] = value;
    }
  }
}
```

2.使局部变量常驻内存

```js
// 打印 10个10
for (var i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
// 闭包
for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
for (var i = 0; i< 10; i++){
  (function(i) {
    setTimeout(() => {
      console.log(i);
    }, 1000);
  })(i);
}
```

4.节流/防抖函数里都用到了闭包

##### 单线程和异步

单线程：只有一个线程，同一时间只能做一件事情。

单线程原因：避免 dom 渲染的冲突。

异步：在单线程的环境下，针对耗时很长的任务会阻塞后面代码的执行，造成页面卡死状态，所以要将这些任务变成异步来处理。

异步写法：

* 回调函数
* jquery deferred
* Promise
* async/await
* generator

##### event-loop

事件循环是浏览器对异步的实现方式。

整体的 js 代码这个宏任务先执行，同步代码执行完后有微任务执行微任务，没有微任务执行下一个宏任务，如此往复循环至结束。

宏任务之间会触发页面渲染。

```js
// 修改DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
  .append($p1)
  .append($p2)
  .append($p3);
// 微任务：DOM 渲染之前执行
Promise.resolve().then(() => {
  const length = $('#container').children().length;
  alert(`micro task ${length}`);
})
// 宏任务：DOM 渲染之后执行
setTimeout(() => {    
  const length = $('#container').children().length;
  alert(`macro task ${length}`);
})
```

##### 原型和原型链

原型：

* 每个 class 都有显示原型 prototype

* 每个实例都有隐式原型 \_\_proto\_\_

* 实例的隐式原型 \_\_proto\_\_ 指向对应 class 的显示原型 prototype

* prototype 中有一个 constructor 属性，用来引用它的构造函数，Person.prototype.constructor === Person，这是一种循环引用。

原型链：我们把由 \_\_proto\_\_ 串起来的直到 Object.prototype.\_\_proto\_\_ 为 null 的链叫做原型链。

```js
Object.__proto__ === Function.prototype 
Function.__proto__ === Function.prototype 
Function.prototype.__proto__ === Object.prototype 
Object.prototype.__proto__ === null // 原型链顶端

Object instanceof Function; // true
Function instanceof Object; // true
```

##### 继承

对象冒充继承：

```js
function Person(name) {
  this.name = name;
}
function Student(name) {
  this.fn = Person;
  this.fn(name);
  delete this.fn;
}
```

call,apply,bind

call 和 apply 可以实现多重继承，一个子类能够继承多个父类，F1 可以同时从 F2, F3 ... 继承。

原型链继承：

对象继承类

```js
o.__proto__ = F.prototype;
```

类继承类

```js
Student.prototype.__proto__ = Person.prototype;
```

混合方式继承：

```js
function Person(name) {
  this.name = name;
}
Person.prototype.sayName = function() {
  console.log(this.name);
}
function Student(name, age) {
  Person.call(this, name);
  this.age = age;
}
Student.prototype.__proto__ = Person.prototype;
```

class 继承：

```js
class Person {};
class Student extends Person {
  super();
};
```

new 继承：

构造函数创建实例的过程本身就是一种继承，new 的内部其实是做了继承里面的合体工作。

```js
Student.prototype = new Person();
```

##### 模块化

https://juejin.cn/post/6866973719634542606

es module 

commonjs

amd

cmd

前端发展模块化历程及js模块化原理:

1.函数封装

我们在讲函数的时候提到，函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里面编写几个相关函数就是最开始的模块了。

```js
function fn1 () {
  statement
}
function fn2 () {
  statement
}
```

这样在需要的时候加载函数所在文件，调用函数就可以了。

这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。

2.对象

为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中。

```js
var myModule = {
  var1: 1,
  var2: 2,
  fn1: function () {

  },
  fn2: function () {

  }
}
```

这样我们在希望调用模块的时候引用对应文件，然后

myModule.fn2()

这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系

看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员

myModel.var1 = 100;

这样就会产生意外的安全问题

3.立即执行函数

可以通过立即执行函数，来达到隐藏细节的目的

```js
var myModule = (function () {
  var var1 = 1;
  var var2 = 2;
  function fn1 () {

  }
  function fn2 () {

  }
  return {
    fn1: fn1,
    fn2: fn2
  }
})()
```

这样在模块外部无法修改我们没有暴露出来的变量、函数

4.放大模式(扩展模块本身)

如果一个模块很大，必须分成几个部分

```js
var module1 = (function (mod){
  mod.m3 = function () {
    //...
  };
  return mod;
})(module1 || {});
```

上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。

5.输入全局变量(依赖其他模块)

独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。

为了在模块内部调用全局变量，必须显式地将其他变量输入模块。

```js
var module1 = (function ($, YAHOO) {
  //...
})(jQuery, YAHOO);
```

上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。

这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。

Javascript模块规范：CommonJS，AMD，CMD：

require.js实现AMD规范

sea.js实现CMD规范

定义模块(利用的就是模块化的原理，使用自执行函数)，导出模块；引入模块，使用模块

模块化博客：

Javascript模块化编程（一）：模块的写法    

http://www.ruanyifeng.com/blog/2012/10/javascript_module.html  

Javascript模块化编程（二）：AMD规范

http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html

Javascript模块化编程（三）：require.js的用法

http://www.ruanyifeng.com/blog/2012/11/require_js.htmls

模块化使用：

函数定义中调用引入的模块中的函数，始终是这样的两层结构。这个函数还可以作为模块被其他函数引用并且调用。调用时形成多层结构。一层一层的调用和传参。vuex 中的接口和 actions 的结合就能很好的体现这一点。

函数定义的时候是从外层到里层，调用的时候也是从外层到里层。

## 浏览器

##### 前端存储方式

cookie：大小只有4k，设置后自动加入请求头浪费流量，每个 domain 限制 20 个。api 怪异，使用需要自行封装。

localStorage：大小 5M，操作方便，永久性存储。

sessionStorage：只存在于当前页面，不能在窗口之间共享，页面关闭后就会被清理。

Web SQL：关系型数据库。2010 年被废弃。

IndexedDB：NoSQL 非关系型数据库，用键值对进行存储，读取速度快，javascript 操作方便。

##### 跨域

同源策略：针对 ajax 请求，浏览器要求当前网页和请求的服务必须同源，即协议、域名、端口三者一致。

image，css，js，form 表单提交也不受跨域限制：

1.\<img/>

图片可用于统计打点。统计可能是使用第三方统计服务，比如站长之家，百度统计等，这些都是外域的，统计打点无非就是发一个请求，如果用 ajax 发的话就会出现跨域。所以说我们用图片，初始化一个图片，把图片的地址写成第三方统计服务的地址，通过图片去发这个请求就可以了。

2.\<link> \<script>

\<link /> \<script> 可以使用 cdn，cdn 一般都是外域。

跨域解决方案：

所有的跨域解决方案都必须经过 server 端允许和配合。

1.Jsonp

\<script> 可以绕过跨域限制。

服务端可以拼接任意动态数据返回。

只能用 GET 请求，并且要求返回 JavaScript。

2.cors

服务端支持的一种解决跨域的方式，是纯服务器端的操作。

```js
response.setHeader('Access-Control-Allow-Origin', 'http://localhost:8081') // 允许的域名是什么 
response.setHeader('Access-Control-Allow-Headers', 'X-Requested-With')     // 允许的headers是什么 
response.setHeader('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS') // 允许的methods是什么 
response.setHeader('Access-Control-Allow-Credentials', 'true') // 接收跨域的cookie，是否允许传cookie
```

3.设置反向代理

##### Html 文档中各种资源的解析规则

html 在接收到一部分之后就开始解析，不会等到全部接收完再解析。

css 下载不会阻塞 dom 的解析。

css 要等到全部接收完再开始解析。

渲染需要 dom 和 cssom 全部解析完。

js 的执行需要等待 cssom 全部解析完。

js 的下载和解析都会阻塞 dom 的解析。

image, iframe 不会阻塞 dom。

##### script 标签中 defer 和 async 的区别

`<script src="script.js"></script>`

按照顺序来加载并执行脚本，在脚本加载及执行分过程中，会阻塞后续 html 文档的解析。

`<script defer src="script.js"></script>`

加载过程不会影响 html 文档解析，并且在 html 文档解析成功后，DOMContentLoaded 事件触发之前执行脚本。

`<script async src="script.js"></script>`

加载过程不会影响 html 文档解析，加载成功后会立即执行脚本内容，这个过程会阻塞后续 html 文档的解析。

应用场景：

defer：脚本代码依赖于页面中的 DOM 元素，或者被其他脚本文件依赖。

async：脚本并不关心页面中的 DOM 元素，并且也不会产生其他脚本需要的数据。如百度统计。

##### link 标签中 preload, prefetch, preconnect, dns-prefetch 的区别

`<link rel="preload" href="/main.js" as="script">`

浏览器会在遇到如上 link 标签时，立刻开始下载 main.js(异步加载)，并放在内存中，但不会执行。只有当遇到 script 标签加载的也是 main.js 的时候，浏览器才会将预先加载的 JS 执行掉。如果这个时候 JS 仍然没有下载完，浏览器不会重新发请求，而是等待此文件的加载。不仅是 JS 文件，字体和图片等资源也可以用这个属性，不过记得用 as 属性标明资源类型，否则这个设置会失效。

`<link rel="prefetch" href="main.js" as="script">`

浏览器会在空闲的时候，下载 main.js，当有页面使用的时候，直接从缓存中读取。其实是把决定是否和什么时间加载这个资源的决定权交给浏览器。如果在 prefetch 还没下载完的时候，浏览器发现 script 标签也引用了同样的资源，浏览器会再次发起请求，这样会造成加载了两次，所以不要在当前页面马上就要用的资源上用 prefetch，要用 preload。

`<link rel="preconnect" href="https://cdn.bootcss.com">`

提前建立 tcp 链接。

`<link rel="dns-prefetch" href="https://cdn.bootcss.com">`

提前查找 dns 解析域名。

##### 输入地址按下回车的整个流程

1. 键入回车：根据用户输入的内容合成为完整的 URL。浏览器还给了当前页面一次执行 beforeunload 事件的机会。标签页上的图标便进入了加载状态，但显示的依然是之前的页面内容。

2. 查找缓存：有缓存，返回缓存副本，并直接结束请求。没有缓存，发起网络请求过程。

3. 准备 IP 地址：先查找浏览器中的 DNS 数据缓存，没有缓存浏览器会请求 DNS 返回域名对应的 IP。

4. 等待 TCP 队列：Chrome 同一个域名同时最多只能建立 6 个 TCP 连接。

5. 建立 TCP 连接：排队等待结束之后，浏览器通过 TCP 与服务器建立连接。

6. 发送 HTTP 请求：一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。浏览器会向服务器发送请求行，请求头，请求体信息。

7. 服务器处理请求。

8. 服务器返回请求。

9. 断开连接：一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。如果浏览器或者服务器在其头信息中加入了 Connection: Keep-Alive，TCP 会一直保持连接。

10. 重定向：返回的状态码是 301，告诉浏览器要重定向到另外一个网址，重定向的网址包含在响应头 Location 字段中，浏览器使用该地址重新导航。

11. 响应数据类型处理：浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器。 application/octet-stream 告诉浏览器返回的数据是字节流类型。通常浏览器会按照下载类型来处理。如果是 HTML，接下来就需要准备渲染页面了。

12. 更新浏览器界面状态：包括安全状态，地址栏地址，前进后退历史记录，web 页面。

13. 构建 DOM 树：由 HTML 解析器将 html 文件解析成树状结构的 DOM。

14. 样式计算：计算出 DOM 节点中每个元素的具体样式。

15. 布局：根据 DOM 和 ComputedStyle 生成一棵只包含可见元素的布局树，并计算出布局树节点的具体坐标位置。

16. 分层：将页面分成很多图层。

17. 绘制：为每个图层生成绘制列表。

18. 栅格化：将图层分成图块，并将图块利用 GPU 转换成位图。

19. 合成和显示：浏览器根据绘制命令将页面内容绘制到内存，将渲染好的页面显示到显示器上。停止标签图标上的加载动画。


重排会走整个渲染流程，重绘会走绘制之后的渲染流程，合成会走栅格化之后的渲染流程（如使用 transform）

## 网络

##### 网络五层模型

* 物理层

* 数据链路层

* 网络层

  IP 协议

* 传输层

  TCP/UDP 协议

* 应用层

  TELNET/SSH/HTTP/SMTP/POP/SSL/TLS/FTP/MIME/HTML

##### IP

IP 是非常底层的协议，只负责把数据包送达目的主机。

交给对方电脑中的具体哪个应用，就需要 UDP 或 TCP 协议了。

##### UDP

应用于在线视频、互动游戏等关注速度、不要求数据完整性的应用。

* 数据传输不可靠：传输过程中出错的数据包会丢失。
* 速度快。

##### TCP

应用于浏览器请求，邮件等要求数据传输可靠性的应用。

* 重传机制：对于传输过程中丢失的数据包，提供重传机制。
* 排序机制：用来保证把乱序的数据包组合成一个完整的文件。
* 速度慢。

##### HTTP 协议格式

```bash
curl -v http://www.baidu.com
```

请求部分：

* 请求行 request line

  * 请求方法：表示此次 HTTP 请求希望执行的操作类型。只是语义上的约定，并没有强约束。

    GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, TRACE。

    浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法。

    HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起。

    PUT 和 DELETE 分别表示添加资源和删除资源。

    CONNECT 现在多用于 HTTPS 和 WebSocket。

    OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。预检请求的 method 也是 OPTIONS。

  * 请求路径

  * 协议和版本

* 请求头 request header

  HTTP 头也是一种数据，可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一些特殊的 HTTP 头。

  * Accept：告诉服务端想要的数据类型
  * Accept-Charset：想要接收数据的字符集
  * Accept-Encoding：数据编码方式，用来限制服务端如何进行数据压缩。
  * Accept-Language：语言。
  * Authorization：鉴权的 token。
  * Connection：连接方式，如果是 keep-alive，且服务端支持，则会复用连接。
  * Content-Type：请求数据 body 的编码类型。
  * Cookie：客户端存储的 cookie 字符串。
  * Host：Http 访问使用的域名。
  * User-Agent：浏览器的一些相关的信息。操作系统及版本/cpu/浏览器及版本/浏览器渲染引擎/浏览器语言/浏览器插件
  * Cache-Control：控制缓存时效性。
  * If-Modified-Since：上次访问时的更改时间，如果服务端认为此时间后自己没有更新，则会给出 304 响应。
  * If-None-Match：上次访问时使用的 E-Tag，通常是页面的信息摘要。

* 请求体：请求体可能包含文件或者表单数据

  HTTP 请求的 body 主要用于提交表单场景。一些常见的 body 格式是：

  * application/json
  * application/x-www-form-urlencoded
  * multipart/form-data：既有文本数据，又有文件等二进制数据。所有的传输数据类型都会在编码里面去体现。
  * text/xml


响应部分：

* 响应行 response line

  * 协议和版本
  * 状态码
    * 1xx：临时回应，表示客户端请继续。对前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 HTTP 库直接处理掉了，不会让上层应用知晓。
    * 2xx：请求成功。
      * 200：请求成功。
    * 3xx: 表示请求的目标有变化，希望客户端进一步处理。
      * 301&302：永久性与临时性跳转。表示当前资源已经被转移。
      * 304：跟客户端缓存没有更新。
    * 4xx：客户端请求错误。
      * 400：请求参数有语法错误，不能被服务器理解。
      * 401：没登录，鉴权失败。
      * 403：无权限。禁止访问，服务器收到请求，但是拒绝提供服务。
      * 404：表示请求的资源不存在。
    * 5xx：服务端请求错误。
      * 500：服务端错误。
      * 502：网关错误。
      * 503：由于超载，请求超时或停机维护，服务器目前无法使用，一段时间后可恢复正常，服务端暂时性错误，可以一会再试。
  * 状态文本

* 响应头 response header

  * Content-Type：对应 Accept，Accept 里面可以接收好几种不同的数据格式，那么 Content-Type 可以从里面选择一种然后做为它真正返回的数据格式进行一个返回，客户端根据这个来进行一个怎么样的显示。
  * Content-Encoding：对应的是 Accept-Encoding，服务端具体使用的数据压缩方式。
  * Content-Language：语言。
  * Content-Length：内容长度，有利于浏览器判断内容是否已经结束。
  * Connection：连接方式，keep-alive 表示复用连接。
  * Date：当前服务器日期。
  * Keep-Alive：保持连接不断时需要的一些信息，如 timeout=5, max=100。
  * Location：告诉客户端重定向的地址。
  * Server：服务端软件类型。
  * Set-Cookie：设置 cookie，可以存在多个。
  * Via：服务端请求链路，对一些调试场景至关重要，代理服务器相关信息。
  * Vary：代理服务器缓存信息。
  * Cache-Control：缓存控制，用于通知各级缓存保存的时间，例如 max-age=0，表示不要缓存。
  * Expires：过期时间，用于判断下次请求是否需要到服务端取回页面。
  * Last-Modified：页面上次修改的时间。
  * ETag：页面信息摘要，用于判断是否需要重新到服务端取回页面。
  * Access-Control-Allow-Origin：允许的跨域的源，如：'http://localhost:3000'
  * Access-Control-Allow-Headers：允许跨域的请求头，如：'X-Token,Content-Type'
  * Access-Control-Allow-Method：允许跨域的方法，如：'PUT,OPTIONS'
  * Access-Control-Allow-Credentials: true。跨域时默认是不记录 cookie 认证信息的。加上这个让它能够记录，从而能够使用 cookie。

* 响应体：头之后，以一个空行为分隔，响应体则是 HTML 代码。

预检请求：使用了非正常的请求报头或使用非 get/post 的请求会触发预检请求。

##### HTTP 缓存

命中强缓存后不会发送请求，没有命中强缓存后走协商缓存。

强缓存：

cache-control 优先级高于 expires

* expires：它的值为一个绝对时间的 GMT 格式的时间字符串。发送请求的时间在 expires 之前，本地缓存始终有效，强缓存命中。
* cache-control：max-age=number，它是一个相对值，根据资源第一次的请求时间和这个相对值，计算出一个资源过期时间，之后的请求时间在过期时间之前，就能命中缓存。该头可以存在多个。
  * no-cache：不使用强缓存，需要使用缓存协商。
  * no-store：禁止使用强缓存和协商缓存等任何缓存行为。
  * public：可以被所有的用户缓存，包括终端和 CDN 等中间代理服务器。
  * private：只能被终端的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。

协商缓存：

协商缓存由两对 http 头组成。

服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified。

* Last-Modified/If-Modified-Since：

  这两个值是 GMT 格式的时间字符串。

  * 浏览器在第一次请求一个资源，在 respone 的 header 加上 Last-Modified 的 header，表示这个资源在服务器上的最后修改时间。
  * 浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值。服务器根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容和 Last-Modified；如果有变化，就正常返回资源内容和新的 Last-Modified。
  
* Etag/If-None-Match

  这个值是由服务器生成的资源的唯一标识字符串，只要资源有变化这个值就会改变。

  过程与 Last-Modified/If-Modified-Since 类似。不同的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。

* 优缺点

  * Last-Modified
    * 一些文件会周期性的修改时间，但内容并没有改变，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；
    * 某些文件修改非常频繁，比如在秒以下的时间内进行修改，If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
    * 某些服务器不能精确的得到文件的最后修改时间。
  * Etag
    * Etag 能很好的解决上面 Last-Modified 遇到的问题，但由于要生成 hash，会消耗性能。

用户行为对缓存的影响：

![用户行为对缓存的影响](../架构/用户行为对缓存的影响.png)

##### cdn

加快用户访问速度。减轻源服务器的访问压力。

##### https

HTTP + SSL(TLS) = HTTPS

通常情况下，HTTP 会先直接和 TCP 进行通信。在使用 SSL 的 HTTPS 后，则会先演变为和 SSL 进行通信，然后再由 SSL 和 TCP 进行通信。

做到以下三点才能保证信息的安全：

* 信息的保密性
  * 对称加密
  * 非对称加密
* 信息的完整性
  * 摘要算法
* 身份识别
  * 数字证书

##### http2.0

- 二进制分帧传输
- 多路复用
- 头部压缩
- 服务器推送

## 性能优化

##### 性能优化

加载：

* 减少资源体积
  * 代码图片压缩
  * Code Splitting
  * Scope Hoisting
  * Tree shaking
  * 异步组件
  * 单页应用改为多页应用
* 减少访问次数
  * 合并代码
  * 服务端渲染
  * 缓存
* 使用 cdn
* 合理使用资源预加载

渲染：

* css 放在 head 里面

  在 dom 树生成完成之前就把 css 规则给它加载完，当 dom 树生成完之后直接和所有的 css 整合生成一个渲染树，生成一个 Render Tree，然后一步渲染完成，这样的话就不要再出现重复了。

* js 放到 body 最下面

  因为 js 执行和 dom 渲染都是使用的渲染进程的主线程。防止一个页面渲染的过程比较长，让用户尽早的看到渲染后的页面，不要让 js 阻碍 dom 渲染。

* 尽早执行 js

  window.onload：网页全部资源加载完才会执行，包括图片，视频等。

  window.DOMContentLoaded：dom 渲染完即可执行，此时图片，视频可能还没有加载完。

* 懒加载：

  列表图片懒加载：把图片地址赋值成一个默认的预览图片 src="preview.png"。把真正的图片地址放到 data-realsrc 里，当判断到图片露出屏幕的时候再去把图片真正的地址赋值到图片的 src 上。

  ```html
  <img id="img1" src="preview.png" data-realsrc="abc.png" />
  
  <script type="text/javascript">
    var img1 = document.getElementById('img1')
    img1.src = img1.getAttribute('data-realsrc')
  </script>
  ```

* 对 dom 查询进行缓存

* 频繁 dom 操作，合并到一起插入 dom 结构


体验优化：

* 节流防抖
* 骨架屏

## 安全

##### 常见的 web 前端攻击方式有哪些，怎么预防

1.XSS 跨站请求攻击

* 一个博客网站，我发表一篇博客，其中嵌入 \<script> 脚本
* 脚本内容：获取 cookie，发送到我的服务器（服务器配合跨域）
* 发布这篇博客，有人查看它，我轻松收割访问者的 cookie

预防：

* 替换特殊字符，如把 < 变为 \&lt;，把 > 变为 \&gt;
* 这样的话 \<script> 就变为 \<script&gt;，直接显示，而不会作为脚本被执行。只有 html 里面有 script 才会作为脚本被执行
* 前端要替换，后端也要替换，都做总不会有错
* 有 xss npm 工具

2.XSRF 跨站请求伪造

* 你正在购物，看中了某个商品，商品 id 是 100
* 付费接口是 xxx.com/pay?id=100，但没有任何验证
* 我是一个攻击者，我看中了一个商品，id 是 200
* 我向你发送一个电子邮件，邮件标题很吸引人
* 但邮件正文隐藏着 \<img src="xxx.com/pay?id=200" />
* 你一查看邮件，就购买了 id 是 200 的商品

因为你现在正在购物，肯定登录了这个网站了，你就会有用户信息了，图片的地址去访问的时候，你的用户信息已经带过去了。

预防：

* 使用 post 接口，用 img 攻击是攻击不通的，因为 img 的 src 只支持 get 请求
* 增加验证，例如密码，短信验证码，指纹等

## Vue

##### 对 mvvm 的理解

* 数据响应式：数据变化视图更新。
* 模版引擎：提供描述视图的模版语法。
* 渲染：把模版生成真正的 html。

##### 组件间通信

* props
* 自定义事件
* eventbus
* Vuex
* $parent/$root
* $children
* $refs
* provide/inject

##### vue 生命周期

一个 vue 实例从开始创建到被销毁有一个完整的生命周期，这个过程包括开始创建、初始化数据、模版编译、挂载 DOM -》渲染、更新 -〉渲染、卸载等一系列过程。

##### Vue 的父组件和子组件生命周期钩子执行顺序是什么

1. 加载渲染过程
   `父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted`
2. 子组件更新过程
   `父beforeUpdate->子beforeUpdate->子updated->父updated`
3. 父组件更新过程
   `父beforeUpdate->父updated`
4. 销毁过程
   `父beforeDestroy->子beforeDestroy->子destroyed->父destroyed`

##### vue 双向绑定实现原理

数据响应式 + 事件发布订阅

##### vue-router 实现原理

具体任务：

根据地址的变化，从路由表中获取到最新的 component，把它渲染到 router-view 里，就是让 router-view 重新渲染。

* 实现一个插件，vue-router 是一个插件：实现 VueRouter 类和 install 方法 
* 实现两个全局组件：router-view 用于显示匹配组件内容，router-link 用于跳转 
* 监控 url 变化：监听 hashchange 或 pushState/replaceState 事件 
* 响应最新 url：创建一个响应式的属性 current，当它改变时获取对应组件并显示

krouter/kvue-router.js 

```js
import Link from './krouter-link'
import View from './krouter-view'

let Vue;

class KVueRouter {
  constructor(options) {
    this.$options = options
    // 需要创建响应式的current属性
    // 利用Vue提供的defineReactive做响应化
    // 变成响应式的好处是，在任何组件的template或render函数中用到current就会把它收集起来，将来只要我变了，就会通知用到的组件做更新，就是重新render
    Vue.util.defineReactive(this, 'current', '/')
    // 还可以使用这种方式实现current的响应式
    // this.app = new Vue({
    //   data() {
    //     return {
    //       current: '/'
    //     }
    //   }
    // })
 
    // 监控url变化
    window.addEventListener('hashchange', this.onHashChange.bind(this))
    window.addEventListener('load', this.onHashChange.bind(this))

    // 创建路由映射表
    this.routeMap = {}
    options.routes.forEach(route => {
      this.routeMap[route.path] = route
    })
  }
  onHashChange() {
    this.current = window.location.hash.slice(1)
  }
}

// 1.实现一个插件
// 一个插件只是个普通对象，并实现 install 方法。
KVueRouter.install = function (_Vue) {
  // 保存构造函数，在KVueRouter里面使用
  Vue = _Vue;
  // 任务1：挂载$router
  // 怎么获取根实例中的router选项
  // 我只要混入一个生命周期的钩子或者是任何一个方法，我在钩子或方法里面就可以拿到组件的实例了。
  // 加上一个全局的混入，这里写的生命周期的钩子将来会在所有的组件中都执行一遍。
  // 为什么要用混入方式写？主要原因是use代码在前，Router实例创建在后，install中还不能直接拿到创建好的router实例，所以要用mixin的方式在Vue实例创建的时候在钩子函数中将router放到Vue.prototype上。
  Vue.mixin({
    beforeCreate() {
      // 确保根实例的时候才执行
      if (this.$options.router) {
        Vue.prototype.$router = this.$options.router
      }
    }
  })

  // 任务2：注册两个全局组件router-link和router-view
  // 这里不能使用template的方式去描述标签的原因是我们使用的是纯运行时的Vue版本，因为是webpack环境，最终的编译版本中是不存在编译器的，所以没有办法编译template。
  // 所以这里要用到render函数，纯运行时环境只能用render函数来描述你的组件。
  Vue.component('router-link', Link) 
  Vue.component('router-view', View)
}

export default KVueRouter
```

krouter/router-link.js 

```js
export default {
  props: {
    to: {
      type: String,
      required: true
    },
  },
  render(h) {
    // <a href="#/about">abc</a>
    // <router-link to="/about">xxx</router-link>
    // h(tag, data, children)
    console.log(this.$slots);
    return h('a', { attrs: { href: '#' + this.to } }, this.$slots.default)
    // jsx
    // return <a href={'#' + this.to}>{this.$slots.default}</a>
  }
}
```

krouter/router-view.js

```js
export default {  
  render(h) {    
    // 获取path对应的component    
    const {routeMap, current} = this.$router    
    const component = routeMap[current].component || null    
    return h(component)  
  }
}
```

##### vuex 实现原理

kstore/kvuex.js

```js
// 保存构造函数引用，避免import
let Vue;

class Store {
  constructor(options) {
    // this.$options = options;
    // 保存mutations、actions、getters选项
    this._mutations = options.mutations;
    this._actions = options.actions;
    this._getters = options.getters;
    
    // 定义computed选项
    const computed = {}
    // 给用户暴露一个getters
    this.getters = {}
    
    const store = this
    
    Object.keys(this._getters).forEach(key => {
      // 获取用户定义的getters
      const fn = store._getters[key]
      // 转换为computed使用的无参数的形式，做一个高阶封装
      computed[key] = function() {
        return fn(store.state)
      }
      // 将getters设置为只读属性
      Object.defineProperty(store.getters, key, {
				get() {
          return store._vm[key]
        }
      })
    })

    // 响应化处理state 
    // this.state = new Vue({
    //   data: options.state
    // })
    
    this._vm = new Vue({
      data: {
        // 加两个$，Vue不做代理
        $$state: options.state
      },
      // 把getters当成一个计算属性去实现就可以了。注意computed的函数是无参数的。
      computed: {
      	a: function() {
          return this.state.a + this.state.b
        }
      }
      
    })
		
    // 绑定commit、dispatch的上下文为store实例
    // 绑定commit上下文否则action中调用commit时可能出问题!!
    // 同时也把action绑了，因为action可以互调
    this.commit = this.commit.bind(this)
    this.dispatch = this.dispatch.bind(this)
  }

  // 保护state，防止用户直接修改state，利用存取器
  // 存取器， store.state
  get state() {
    console.log(this._vm);
    
    return this._vm._data.$$state
  }

  set state(v) {
    console.error('你造吗？你这样不好！');
  }

  // 根据用户传入type执行对应mutation
  // store.commit('add', 1)
  // type: mutation的类型
  // payload：载荷，是参数
  commit(type, payload) {
    const entry = this._mutations[type]
    if (entry) {
      // 传递state给mutation
      entry(this.state, payload)
    }
  }

  // 根据用户传入type执行对应action，同时传递上下文 
  dispatch(type, payload) {
    const entry = this._actions[type]
    if (entry) {
      entry(this, payload)
    }
  }

}

function install(_Vue) {
  Vue = _Vue;

  Vue.mixin({
    beforeCreate() {
      if (this.$options.store) {
        Vue.prototype.$store = this.$options.store
      }
    }
  })

}

// Vuex
export default {
  Store,
  install
}
```

##### 数据响应式

```js
// 数组响应式
// 思路：找到数组原型，覆盖那七个修改数组的方法，让它除了做原来的事情之外，还能够额外做更新通知，这样就实现了数组的响应式操作。并将得到的新的原型设置到data中的数组实例原型上，这样这个数组执行调用这些方法的时候就会以我们添加的方法为准。
// 1.替换数组原型中那7个方法
// 拿到数组原型
const originalProto = Array.prototype;
// 备份一份，修改备份
const arrayProto = Object.create(originalProto);

// splice,reverse,sort
['push', 'pop', 'shift', 'unshift'].forEach(method => {
  arrayProto[method] = function() {
    // 原始操作
    arrayProto[method].apply(this, arguments);
    // 覆盖操作：通知更新（对象响应式里的setter操作dep.notify）
    console.log('数组执行 ' + method + '操作');
  }
})

// 数据响应式
function defineReactive(obj, key, val) {
  // 递归
  observe(val);
  // 对传入obj进行访问拦截
  Object.defineProperty(obj, key, {
    get() {
      console.log('get ' + key);
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        console.log('set ' + key + ':' + newVal);
        // 如果传入的newVal依然是obj，需要做响应化处理
        observe(newVal);
        val = newVal;
        // 更新函数
        update();
      }
    }
  })
}

// 遍历做批量响应化处理
function observe(obj) {
  if (typeof obj !== 'object' || obj == null) return;
  if (Array.isArray(obj)) {
    // 数组数据响应化
    // 覆盖该数组的原型
    obj.__proto__ = arrayProto;
    // 对数组内部的元素做响应化处理
    for (let i = 0; i < obj.length; i++) {
      observe(obj[i]);
    }
  } else {
    Object.keys(obj).forEach(key => {
      defineReactive(obj, key, obj[key]);
    });
  }
}

function set(obj, key, val) {
  defineReactive(obj, key, val);
}

// 更新函数
function update() {
  // 更新试图
  app.innerText = obj.foo;
}

// 单个数据响应化处理
// defineReactive(obj, 'foo', 'foo')
// obj.foo
// obj.foo = 'fooooooooooooooooo'
const obj = { foo: 'foo', bar: 'bar', baz: { a: 1 }, arr: [1,2,3] };
observe(obj);
obj.foo;
obj.foo = 'fooooooooooooooo';
obj.bar;
obj.bar = 'barrrrrrrrrrrrrr';

// obj.baz.a = 10 // 深层的数据，拦截不到，需要递归处理里面的对象数据
obj.baz = {a:100}; // 如果赋值依然是obj，拦截不到，需要在setter中赋值时做响应化处理
obj.baz.a = 100000;

// obj.dong = 'dong' // 添加新的属性，拦截不到，使用set做一次响应化处理
set(obj, 'dong', 'dong');
obj.dong;

// Object.defineProperty()对数组无效
// 分析：改变数组方法只有7个
// 解决方案：覆盖数组实例的原型方法，让他们在修改数组同时还可以通知更新
obj.arr.push(4);
```

##### 简版 MVVM

![Vue数据响应式](Vue数据响应式.png)

* KVue：框架构造函数。
* Observer：
  * 执行数据响应化（分辨数据是对象还是数组，对这两种类型有不同的操作，所以我们多抽象出来了一层，用这个 Observer 来做）。
    * getter：依赖收集。
    * setter：执行更新函数。
* Compile
  * 编译模版：递归遍历 DOM 树，解析出 node 节点和该节点上动态绑定的值 vm.data.key，还有模版绑定语法类型。根据不同的模版语法创建相应的更新函数，接收解析出来的两个值，做 DOM 操作。
    * 初始化视图，执行更新函数。
    * 创建 Watcher 实例，传入更新函数。
* Watcher：管理更新函数。
* Dep：管理 Watcher。

kvue.js

```js
function defineReactive(obj, key, val) {
  // 递归
  observe(val);
  // 创建一个Dep和当前key一一对应
  const dep = new Dep();
  // 对传入obj进行访问拦截
  Object.defineProperty(obj, key, {
    get() {
      console.log('get ' + key);
      // 依赖收集
      Dep.target && dep.addDep(Dep.target);
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        console.log('set ' + key + ':' + newVal);
        // 如果传入的newVal依然是obj，需要做响应化处理
        observe(newVal);
        val = newVal;
        // 通知更新
        // watchers.forEach(w => w.update())
        dep.notify();
      }
    }
  })
}

function observe(obj) {
  if (typeof obj !== 'object' || obj == null) return;
  // 创建Observer实例
  new Observer(obj);
}

// 代理的原数据已经是响应式的了，所以代理数据不需要再做响应式了，只是单纯的做get，set代理操作就行了
// 代理函数，方便用户直接访问$data中的数据
function proxy(vm, sourceKey) {
  // vm是框架实例，sourceKey是vm中的$data
  // 遍历vm[$data]中的所有key，将它代理到vm上的key
  Object.keys(vm[sourceKey]).forEach(key => {
    // 将$data中的key代理到vm上
    Object.defineProperty(vm, key, {
      get() {
        return vm[sourceKey][key];
      },
      set(newVal) {
        vm[sourceKey][key] = newVal;
      }
    })
  })
}

// 创建KVue构造函数
class KVue {
  constructor(options) {
    // 保存选项
    this.$options = options;
    this.$data = options.data;
    // 响应化处理
    observe(this.$data);
    // 代理
    proxy(this, '$data');
    // 创建编译器
    new Compiler(options.el, this);
  }
}

// 根据对象类型决定如何做响应化
class Observer {
  constructor(value) {
    this.value = value;
    // 判断其类型
    if (typeof value === 'object') {
      this.walk(value);
    }
  }
  // 对象数据遍历响应化
  walk(obj) {
    Object.keys(obj).forEach(key => {
      defineReactive(obj, key, obj[key]);
    });
  }
  // 数组数据响应化，待补充
}

// 观察者:保存更新函数，值发生变化调用更新函数
// const watchers = []
class Watcher {
  constructor(vm, key, updateFn) {
    this.vm = vm;
    this.key = key;
    this.updateFn = updateFn;
    // watchers.push(this)
    // Dep.target静态属性上设置为当前watcher实例
    Dep.target = this;
    this.vm[this.key]; // 读取触发getter
    Dep.target = null; // 收集完就置空，防止编译时，读取下一个同样的key时push进去的是该key的上一个更新函数。
  }
  // 更新函数
  update() {
    this.updateFn.call(this.vm, this.vm[this.key]);
  }
}
// Dep：依赖，管理某个key相关所有Watcher实例
class Dep {
  constructor() {
    this.deps = [];
  }
  addDep(dep) {
    this.deps.push(dep);
  }
  notify() {
    this.deps.forEach(dep => dep.update());
  }
}
```

compile.js

```js
// 编译器
// 递归遍历DOM树
// 判断节点类型，如果是文本，则判断是否是插值绑定
// 如果是元素，则遍历其属性判断是否是指令或事件，然后递归子元素
class Compiler {
  // el是宿主元素
  // vm是KVue实例
  constructor(el, vm) {
    // 保存kVue实例，保存需要操作的DOM元素
    this.$vm = vm
    this.$el = document.querySelector(el)

    if (this.$el) {
      // 执行编译，初始化视图
      this.compile(this.$el)
    }
  }

  // 遍历DOM树，开始做编译工作
  compile(el) {
    // 遍历el树
    const childNodes = el.childNodes;
    Array.from(childNodes).forEach(node => {
      // 判断是否是元素
      if (this.isElement(node)) {
        // console.log('编译元素' + node.nodeName);
        this.compileElement(node)
      } else if (this.isInter(node)) {
        // console.log('编译插值绑定' + node.textContent);
        this.compileText(node)
      }

      // 递归子节点
      if (node.childNodes && node.childNodes.length > 0) {
        this.compile(node)
      }
    })
  }

  // 是否是元素
  isElement(node) {
    return node.nodeType === 1
  }

  // 是否是差值绑定
  isInter(node) {
    // 首先是文本标签，其次内容是{{xxx}}
    return node.nodeType === 3 && /\{\{(.*)\}\}/.test(node.textContent)
  }

  // 文本节点编译
  compileText(node) {
    this.update(node, RegExp.$1, 'text')
  }

  // 元素节点编译
  compileElement(node) {
    // 节点是元素
    // 遍历其属性列表
    const nodeAttrs = node.attributes
    Array.from(nodeAttrs).forEach(attr => {
      // 规定：指令以k-xx="oo"定义 k-text="counter"
      const attrName = attr.name // k-xx k-text
      const exp = attr.value // xx counter
      // 指令处理
      if (this.isDirective(attrName)) {
        const dir = attrName.substring(2) // xx text
        // 执行指令
        this[dir] && this[dir](node, exp)
      }
      // 事件处理
      if (this.isEvent(attrName)) {
        // @click="onClick"
        const dir = attrName.substring(1) // 得到click
        // 事件监听
        this.eventHandler(node, exp, dir)
      }
    })
  }

  // 是否是指令
  isDirective(attr) {
    return attr.indexOf('k-') === 0
  }
  
  // 是否是事件
  isEvent(attr) {
    return attr.indexOf('@') === 0
  }
  
  // k-text
  text(node, exp) {
    this.update(node, exp, 'text')
  }

  
  // k-html
  // 双向绑定，语法糖，它实际上做了两个事，value 值的设定和事件的监听。设置 v-model 就是要实现这两个事情，因此在代码的实现层面实现这两件事情就可以了。
  html(node, exp) {
    this.update(node, exp, 'html')
  }
  
  // k-model
  model(node, exp) {
    // update方法只完成赋值操作，是单向的
    // value赋值
    this.update(node, exp, 'model')
    // 事件监听
    node.addEventListener('input', e => {
      // 将新的值赋值给数据
      this.$vm[exp] = e.target.value
    })
  }

  // 编译函数
  update(node, exp, dir) {
    // 编译初始化
    // 组合最终的DOM更新函数xxUpdater
    const fn = this[dir + 'Updater']
    fn && fn(node, this.$vm[exp])

    // 创建Watcher实例
    // 传入更新函数
    new Watcher(this.$vm, exp, function (val) {
      fn && fn(node, val)
    })
  }

  textUpdater(node, value) {
    node.textContent = value
  }

  htmlUpdater(node, value) {
    node.innerHTML = value
  }
  
  modelUpdater(node, value) {
    // 表单元素赋值
    node.value = value
  }
  
  // 事件监听处理
  eventHandler(node, exp, dir) {
    const fn = this.$vm.$options.methods && this.$vm.$options.methods[exp]
    node.addEventListener(dir, fn.bind(this.$vm))
  }
  
}
```

##### vue diff 算法

必要性：lifecycle.js - mountComponent()，组件中可能存在多个 key 的变化，一个组件又只有一个 Watcher ，所以需要知道具体哪里发生了变化，这时就必须要用 diff 算法去比对具体哪里变化。

执行方式：patch.js - patchVnode()，patchVnode 是 diff 发生起始的地方，整体策略：深度优先，同层比较 updateChildren() 递归操作。

diff 算法是虚拟 DOM 技术的必然产物：通过新旧虚拟 DOM 的对比（即diff），将变化的地方更新在真实 DOM 上。diff 高效的对比过程也降低了时间复杂度，提高性能。

Vue 中 diff 执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果 oldVnode 和新的渲染结果 newVnode，此过程称为 patch。

##### vue 模版编译

字符串模版 => 抽象语法树(AST) => 生成 JS 函数。

模板编译的主要目标是将模板 template 转换为渲染函数 render。这个过程是一个字符串模版被转换成 JS 函数。

入口文件 entry-runtime-with-compiler.js 中，如果存在 template 或 el 选项就会执行编译，会执行 compileToFunctions 方法，把模版传进去。通过方法名就可以知道，它可以把字符串模版变成一个函数，它会返回 render 函数。

编译分为三步：解析、优化和生成，src/compiler/index.js。

- 解析 - parse：解析器把模版转换为 AST 对象，抽象语法树，它是对我们将来我们要生成的代码的 JS 对象的描述，将来遍历这棵树，把代码生成。这是底层代码生成器的必要知识。用对象的形式来描述 JS 代码，先把字符串变成对象，这个对象是有格式规定的，能描述将来要生成的代码。解析器内部分了HTML解析器、文本解析器和过滤器解析器。
- 优化 - optimize：在 AST 中标记静态子树，静态子树是界面中永远不变的节点，如两层嵌套以上的纯文本节点。
  - 每次重新渲染，不需要为静态子树创建新节点。
  - 虚拟 DOM 中 patch 时，可以跳过静态子树。
- 代码生成 - generate：把 AST 转换成代码字符串，比如一个字符串形式的函数，然后用 new Function(code) 把字符串函数的代码作为参数传进去就可以得到一个真正的 render 函数。

processIf 用于解析 v-if，genIf 用于生成条件语句相关代码。

processFor 用于解析 v-for 指令，genFor 用于生成相应代码。

v-if，v-for 这些指令只能在编译器阶段处理，如果我们要在 render 函数处理条件或循环只能使用 if 和 for，然后生成VNode。

##### vue 批量异步更新策略

侦听到数据变化，不会把对应的 Watcher 直接更新，而是开启一个队列，存放所有需要变化的组件 Watcher，启动一个微任务 Promise.resolve().then()，在面里遍历队列，一次性的执行所有 Watcher 的更新函数，更新函数把所有的 DOM 更新全部做完之后，浏览器统一的刷新一次，就达到了我们期待的高效方式。

如果一个 key 同时被多次修改，导致 Watcher 被多次触发，只会被推入到队列中一次，避免不必要的计算和 DOM 操作。

异步策略的选择会有优先级，根据当前执行环境的支持情况，会分别使用 Promise.then、MutationObserver、setImmediate、setTimeout，如果使用宏任务做的话，用户体验就不好了，因为它只能到下一个循环才能看到结果了。

##### 源码剖析准备

搭建调试环境：

1. clone 源码，地址：https://github.com/vuejs/vue.git  版本:2.6.10

2. 安装依赖：npm install

3. 安装 rollup，因为 Vue 的打包工具用的是 rollup：npm install -g rollup

4. 修改开发脚本：添加代码映射，调试的过程中能够直接调试和研究源码。

   修改 package.json 中的 dev 打包脚本：

   "dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev"

5. 打包，执行开发脚本，输出最终我们要用的 vue.js：npm run dev

   打包成功之后 dist 下会生成一个全新的 vue.js，和它的 map 文件 vue.js.map

6. 编写测试文件

   创建一个测试脚本来看看我们打包的东西是否正常。在任何地方写都可以，vue 有些案例在 examples 里，我们就可以在这来编写测试文件。

   examples/test/01-test.html

   把刚才打包的 vue.js 引进来，剩下的就正常的写一个 vue 程序就行了。

   浏览器打开不报错的跑起来，并且有 vue 初始化的一些输出就可以了，接下来就可以调试了。

调试技巧：

* 打开指定文件：ctrl+p

* 断点：想知道某个地方到底发生了什么事情，让浏览器执行到这个地方的时候停下来，继不继续向下执行由我们调试控制。

* 单步执行

  * 单步跳过函数
  * 单步进入函数

* 查看调用栈

  研究代码的过程中，想搞清楚先后之间的调用关系，有时函数进入过深的时候，往往就搞不清楚了。这时就可以好好的研究这个 Call Stack，可以很有效的帮你把思路理顺，是谁调用的谁，整个过程会显得很清晰，调用栈中可以很好的看到整个的函数执行的流程。

* 定位当前源文件所在位置

  以方便下次再研究的时候心中有数，以后就知道在哪找到这个代码了，随着这个过程研究的次数越来越多，我可能就把整个源码的脉络都熟悉了。

  sources 代码上右键，找到 Reveal in sidebar 命令，在侧边栏里就会显示这个文件所在的目录。 

源码目录结构：

以后自己研究的过程中应该很清楚的找到这些目录和想要的文件才行。

/dist                              发布目录，最终输出的所有js文件都在这里，各个发布版本之间存在差异。
/examples                    范例，里面有我们研究源码时的测试代码
/flow                             2.6 这个版本还是基于 flow 去写的，所以还会有 flow 这个类型声明文件，针对 flow 的类型声明
/types                           对 TS 的类型声明
/packages                    里面有一些核心代码之外的独立库，这些东西它认为不应当是项目核心的东西，它单独的拆分写到									 这些包 里头了，所以它跟我们核心代码无关。
/scripts                         我们要找入口文件，还要跟这里的构建脚本打打交道
/src                               源码，我们就是要研究这里面的所有东西
    /compiler                  编译器相关
    /core                         核心代码，要常来这里看看啊
    	/components        通用组件，keep-alive，为什么只有这一个组件，因为它是所有平台通用的。weex 或 web 平台会									 有特殊的像 transition 这样的组件，它会写到其他的目录去。就会写到 platforms 这个目录的 									 weex 或 web 里头单独去组织，所以代码的分工是非常清楚的，很值得去借鉴。
    	/instance     		 构造函数等，在核心代码中，最应该关心的目录应该是这个。Vue 的构造函数就会在这里头。查找									 的思路是什么呢，怎么会找到这里。
   	 /global-api            全局 API
        /observer              响应式相关
        /vdom                   虚拟 DOM 相关

输出的各个发布版本的含义：

* runtime：仅包含运行时，不包含编译器，意味着写程序的时候不能使用 template 这个配置项去写字符串的模版。
* common：只能用于像 nodejs 的 require 的方式称为 commonjs，用 cjs 规范来进行打包的，用于像 webpack1，broswerify 等老旧版本打包工具，现在很少用到。
* esm：ES（ECMA Script）模块规范，主要用于 webpack2+ 这些打包工具。
* umd：universal module definition，就是什么都不加的，如 vue.js。浏览器里面直接引，不经过打包工具打包的一般会用这个版本。兼容 cjs 和 amd 规范（异步模块），浏览器里面加载模块都希望是异步的啊，所以 amd 规范特别适合在浏览器里使用。

找入口：

使用打包工具的项目的源码入口文件怎么找，一般先从 package.json 开始，找到我们打包的脚本命令 dev，是 rollup 打包的，-c 指明了配置文件在哪，然后根据打包脚本命令的参数和打包工具配置文件的代码逻辑就能够找到你想要那个输出版本的入口文件到底是谁。

从这个源码入口文件开始研究源码，我们要多次与这个入口文件打交道，尤其是初始化过程。

##### Vue 总体流程

从入口文件开始，根据文件或模块的引用路径寻找 Vue 构造函数。发现每个文件模块的作用，最后根据一个简单的 new Vue() 程序，断点调试，串联整理整个初始化流程。

src/platforms/web/entry-runtime-with-compiler.js 入口文件：

保存一份原型上的 $mount，然后针对该平台的特点对 $mount 做扩展。这里是 web 平台，所以扩展的就是跟编译相关的事，处理 render，template，el 选项。选项中如果有 render 直接调用 mount 执行挂载；如果有 template 或 el，将它们进行一定处理最后变成 template，然后将这个 template 执行模版解析和编译工作，最终得到 render 函数并将其放到选项中去，然后调用 mount 执行挂载。所以不管是 render，template 还是 el，最终都是要得到 render 渲染函数。 

src/platforms/web/runtime/index.js：

* 安装 web 平台特有指令和组件；
* 在 Vue 原型上定义了补丁方法 Vue.prototype.\__patch__ 把虚拟 DOM 转换成真实 DOM，初始化的赋值和以后的更新都会用到这个 patch；
* 实现了 $mount，它只做了一件事，就是把传过来的宿主 el 做 DOM 查询，然后调用 mountComponent 执行初始化挂载，将首次渲染的结果替换 el。

src/core/index.js：

开始进入到核心代码里了。定义全局 API。

src/core/instance/index.js：

* 定义 Vue 构造函数，构造函数内部只执行了一行代码，就是初始化方法 this._init()，这个方法是通过混入的方式混入进来的，具体是通过 initMixin(Vue) 方法给 Vue 原型添加 \_init 方法，将来 new Vue() 的时候执行这个初始化方法；
* 使用混入的方式定义 Vue 实例 API：initMixin(Vue)，状态相关api stateMixin(Vue)，事件相关api eventsMixin(Vue)，跟生命周期相关的更新渲染等 lifecycleMixin(Vue)，渲染函数相关api renderMixin(Vue)

src/core/instance/init.js：

* 初始化方法 _init 定义的地方；
* _init 方法做的事情是创建组件实例，初始化其数据、属性、事件等，然后执行挂载 $mount。

```js
initLifecycle(vm)     // 声明组件实例的$parent $root $children $refs，组件创建的顺序是自上而下的，挂载的顺序是自下而上的，当我创建完毕之后，立刻执行挂载，找到老爹执行一次挂载。
initEvents(vm)       // 处理父组件传入的事件和回调，就是对父组件传入的事件添加监听，事件的派发和监听是一个人
initRender(vm)       // 跟渲染相关的东西，也就是跟虚拟dom相关的东西。声明了$slots,$createElement就是那个h

callHook(vm, 'beforeCreate') // 完成了上面三件事之后，会调一个beforeCreate，所以beforeCreate里面可以用上面声明的所有的东西

initInjections(vm)    // 注入数据 resolve injections before data/props
initState(vm)         // 重要：数据的初始化props，methods，data，computed，watch，数据响应式
initProvide(vm)       // 提供数据 resolve provide after data/props

callHook(vm, 'created') // 上面的事情都做完后，会有一个created这个生命周期，这个时候所有的初始化全部完成了，你可以放心大胆做你任何想做的事情了。
```

1. new Vue() 进入到构造函数，调用 _init()

2. _init() 里执行一系列的初始化工作。最后判断有 el 执行 $mount，使用 template 或 render 需要手动执行 $mount。

   * initState(vm)：数据响应式，这里做了一系列数据的初始化，包括 props、methods、data、computed 和 watch。

     * initData(vm)：data 响应式，获取 data，设置代理，启动响应式 observe。
       * observe(value)：判断传入的数据 value 是不是对象，不是直接 return。然后尝试从 value 中获取一个 Observer 实例 ob = value.\__ob__，如果该对象数据是响应式的，就会有这个 ob，不是的话，就创建 Observer 实例，进行响应化处理，最后返回 Observer 实例 ob。也就是说一个对象类型的数据要进行一次响应式观察处理，每次只处理一个对象数据和里面的一层，然后递归把所有深层次的数据都处理到。
         * Observer(value)：做数据响应化，它只处理对象类型的数据。
           * 为每一个对象类型的数据本身的 ob 创建一个 dep。object 里面新增($set)或者删除属性，array 那七个变更数组方法时会使用到这个的 dep 中存放的依赖来做这个对象本身变化的通知更新。
           * 给这个要做响应化处理的对象类型的数据设置 \__ob__ 的属性，值为当前的 Observer 实例 this，就是为每个对象类型的数据都附加一个 Observer 实例。
           * 分别做数组和对象的响应化处理：
             * 数组
               * 替换数组原型。
                 * 执行原来的方法功能
                 * 通知更新：使用 ob 中的 dep 来通知更新。
               * 如果数组里面的元素是对象，还需要对其做响应化处理，对其执行 observe
             * 对象
               * defineReactive：遍历，对每个 key 做数据响应化。
                 * 创建每个 key 对应的 dep，这个细粒度的 dep 是为用户 Watcher 准备的，而不是为了整个组件的渲染 Watcher。
                 * 使用 observe(val) 做递归处理，因为 val 有可能是对象，并且 observe 可以返回 ob，依赖收集时会用到。
                 * Object.defineProperty：数据劫持，为每个 key 做响应化拦截。
                   * get：收集依赖，最终收集的 Watcher 都是一个，就是该组件实例对应的那个 Watcher。render 函数里有动态的值需要去访问，这时就触发了 getter，然后做依赖收集。
                     * 对每个 key 对应的 dep 做收集。
                     * 如果要做响应化的数据是对象，也就是说存在 ob，还要对他们中的 ob 对应的 dep 做收集。
                     * 如果要做响应化的数据是数组，要把数组中的对象或数组，还要对他们中的 ob 对应的 dep 做收集。
                   * set：
                     * 如果赋的新值是对象，也要做响应化处理。
                     * dep.notify()：数据的变化后，通知更新，下面开始异步批量更新的实现
                       * watcher.update()：执行所有收集的 Watcher 的 update 方法
                         * queueWatcher(watcher)：将 watcher 入队
                           * nextTick(flushSchedulerQueue)：传入 flushSchedulerQueue
                             * timerFunc()：启动了一个微任务，传入执行 flushSchedulerQueue 的方法 flushCallbacks，Promise.resolve.then(flushCallbacks)，将来会执行 flushSchedulerQueue
                               * flushSchedulerQueue()：真正的更新操作
                                 * watcher.run() 
                                   * watcher.get()：调用 watcher 创建时传入的更新函数。
                                     * updateComponent()
                                       * 跟初始化一样的操作...

   * vm.$mount()，执行挂载，只做了 mountComponent 这一个事。

     * mountComponent()，执行挂载转换

       * 声明 updateComponent() 更新函数，并没有调用，里面执行下面两个方法

         * vm.\_render()：调用 render 函数获取当前组件对应的最新的虚拟 DOM，并把虚拟 DOM 传入 \_update() 中

           * render()：返回 vnode
             * createElement()：h 方法
               * 如果编译后生成的 render 函数的 tag 是字符串
                 * tag 是保留标签直接创建 vnode
                   * vnode = new VNode()
                 * tag 是自定义组件
                   * resolveAsset()：获取组件构造函数
                   * vnode = createComponent()：把构造函数，props，事件等作为参数传进去，根据用户写的组件的所有配置创建一个与之相对应的 vnode。
                     * 处理传递的数据，属性，事件等。
                     * installComponentHooks()：安装它体内的自定义组件管理钩子到该组件的 vnode 上，涉及到组件如何实例化创建和挂载的地方。
                       * componentVNodeHooks：默认的组件管理钩子
                         * init：将来的某个时刻会执行这个初始化
                           * 如果是 keep-alive 组件，就不需要再创建组件实例，直接从缓存中拿出来就行了。
                           * 不是 keep-alive，组件需要重新创建。这个组件创建和挂载的过程是在 patch 中执行的。
                             * child = createComponentInstanceForVnode()：创建组件实例
                             * child.$mount()：创建完实例后挂载，然后接着执行该组件的 _init watcher render update createComponent... 等一系列的这个组件下的那些事情，递归向下创建它下面的那些组件和 DOM 的那棵树。
                         * prepatch
                         * insert
                         * destroy
                     * new VNode()：创建 vnode 并返回，自定义组件的 vnode 中会有一个特别的属性 componentInstance，将来组件实例创建完成之后，这个属性会被填充，patch 的时候执行组件管理钩子 init，创建组件实例。
                 * tag 是选项或构造函数
                   * vnode = createComponent()

         * vm.\_update()：执行更新

           * vm.\__patch__()：它就是 patch 函数，传入新老 vnode，做对比找出最小变化，执行 DOM 操作，返回 vnode。把 vnode 转换为真实 DOM，这里执行完，页面就会有显示了，初始化过程就结束了。这里的 vnode 就是组件对应的整棵虚拟 DOM 树，首先进行组件的整棵 vnode 树的比较，可能有三种情况：

             * 组件的 new vnode 树不存在就删

             * 组件的 old vnode 树不存在就增：从上到下，创建挂载创建挂载，最后把整棵树创建完毕后一起放到页面中去，然后删除之前的宿主。虚拟 DOM 创建完成了，就要开始执行 patch 了，patch 里发现以前没有现在有，所以要执行一次创建元素，要把 vnode 批量创建成 DOM 元素，在创建 DOM 树的过程中就要做组件实例的创建和挂载。

               * createElm：把 vnode 变成真实 DOM，根组件执行更新函数时，会递归创建子元素和子组件，首次执行 _update() 时，patch() 会通过 createElm() 创建根元素，子元素创建研究从这里开始。
                 * createComponent()：如果要创建的是组件，走这个流程
                   * 获取创建组件 vnode 时安装的组件管理钩子并执行，创建组件实例并挂载
                   * initComponent()：组件实例的属性，事件，样式等初始化
                     * invokeCreateHooks()：执行属性相关的钩子，如事件监听 updateDOMListeners()
                   * insert()：该组件对应的 DOM 树枝插入父组件的 DOM 树上的操作
                 * 原生标签的创建，把之前得到的 vnode 转换为真实的 DOM
                   * createChildren()：递归创建子元素
                   * invokeCreateHooks()：执行属性相关的钩子，如事件监听 updateDOMListeners()
                     * addEventListener()：原生的事件监听
                   * insert()：该组件对应的 DOM 树枝插入父组件的 DOM 树上的操作

             * 都存在就执行 diff 执行更新。

               * patchVnode：diff 算法发生的地方。对组件的整棵 vnode 树中的每个 vnode 节点进行比较。自顶向下，从最顶层的根节点开始比较，判断是一个节点，对这个节点本身做打补丁操作，这个操作主要是该节点本身的属性更新操作。深度优先：有孩子先比孩子调用 updateChildren，updateChildren 中还会调用 patchVnode，一直向下递归，直到该分支上没有孩子为止，将每个 vnode 节点都 patch 一遍。

                 * isPatchable(vnode)：节点属性更新，根据平台特性拿出属性的更新函数并传入新老 vnode 去执行属性的更新。

                 * 当新老节点都无子节点的时候，只是文本的替换。

                 * 如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点。 

                 * 当新节点没有子节点而老节点有子节点的时候，则移除该节点的所有子节点。

                 * 新老节点均有子节点，则对子节点进行 Diff 操作，调用 updateChildren。

                   * updateChildren：同级比较，深度优先的递归走完后，再比同一级别数组的下一个节点，直到全部比较完成。

                     比较的过程同时做了 DOM 操作，DOM 操作也是微任务，所以浏览器会等这些 Diff 过程中的 DOM 操作都做完后才统一刷新。

                     updateChildren 主要作用是用一种较高效的方式比对新旧两个 VNode 的 children 得出最小操作补丁。

                     两个数组的比较方式：大部分操作都是有规律的，前后插入或正序倒序等。所以为了提高效率，会做一些假设，就是在新老孩子数组的首尾很有可能找到相同的节点，这样就避免做循环了，方法是设置双指针，首尾都没有找到相同的节点还是要做双循环。

                     找到相同的节点做该节点本身的打补丁操作，移动节点位置，移动指针做下一个节点的对比。

       * 构建组件实例的时候，创建了一个和组件实例相关的 Watcher，传入更新函数，初始化过程 Watcher 会执行一次更新函数，以后有更新，Watcher 会让更新函数再次执行。

总结：

组件配置 => VueComponent 实例 => render() => Virtual DOM => DOM。

数据发生变化，渲染函数会再次执行，得到全新的虚拟 DOM，通过新旧虚拟 DOM 比对得到最小 DOM 操作，最后把虚拟 DOM 再变成真实的 DOM。

组件声明了之后，接下来一定会去创建实例和挂载。创建实例了才能够走 Vue 中的流程，挂载了才能跟 DOM 有联系。

组件是可复用的 VueComponent 实例，继承自 Vue。

虚拟 DOM 是真实 DOM 的映射，用来描述真实 DOM 的 JS 对象。

组件化机制就是从 new Vue().$mount() 创建根组件实例和挂载的过程开始，先处理组件自身的 DOM 元素和属性，然后创建子组件，子组件会在组件的 patch 过程中实例化和挂载，再走一遍子组件的上述的过程，就这样一层一层的向下创建，直到完成整个树的创建。自定义组件创建有两个关键的过程，一个是 vnode 的创建过程，一个是 vnode 转真实 DOM 的过程，这两个过程的关键方法都叫创建组件 createComponent。一个是安装组件的实例化和挂载的，一个是调用组件的实例化和挂载的。

有几个组件 _init 就会执行几次了，从根组件开始向下依次执行。

首次 render 时，会得到整棵树的 VNode 结构。

组件创建和挂载顺序：组件创建顺序自上而下，组件挂载顺序自下而上，这里的挂载指的不是 $mount，而是实际的 dom 插入父级的时机。

## 工程化

##### babel 原理

Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）。

- 解析：将代码解析成抽象语法树（AST），在解析过程中有两个阶段：词法分析和语法分析。
- 转换：对 AST 节点进行转换操作。这部分也是 Babel 插件介入工作的部分。
- 生成：将经过转换的 AST 再转换成 js 代码。

##### webpack 优化

分析工具

* 初级分析：使用 webpack 内置的 stats
* 速度分析：使用 speed-measure-webpack-plugin
* 体积分析：使用 webpack-bundle-analyzer

构建速度优化策略

* 使用高版本的 webpack 和 Node.js
* 缩小构建目标
* 多进程/多实例构建
* 多进程/多实例并行压缩代码
* 充分利用缓存提升二次构建速度

体积优化策略

* 代码、图片压缩
* 使用 cdn 静态资源
* Code Splitting
* 代码分割和动态 import
* Tree Shaking
* Scope Hoisting
* 动态 polyfill

##### webpack 热更新原理

##### webpack 原理

##### 手写一个 loader

##### 手写一个 plugin

## Javascript API 实现

##### 实现 let（7）2021.11.29

```js
// 1
{
  let a = 1;
  console.log(a); // 1
}
console.log(a);
// 相当于
(function () {
  var a = 1;
  console.log(a); // 1
})();
console.log(a); // a is not defined

// 2
var fns = [];
for (let i = 0; i < 10; i++) {
  fns[i] = function() {
    console.log(i);
  };
}
fns[0](); // 0
// 相当于
var fns = [];
for (var i = 0; i < 10; i++) {
  (function(i) {
    fns[i] = function() {
      console.log(i);
    };
  })(i);
}
fns[0](); // 0
```

##### 实现 const（7）2021.11.29

```js
function _const(key, value) {
  window.key = value;
  Object.defineProperty(window, key, {
    enumerable: false,
    configurable: false,
    get() {
      return value;
    },
    set(newVal) {
      if(newVal !== value){
        throw new TypeError('不能重复定义');
      } else {
        return value;
      }
    }
  });
}
```

##### 实现数组 push（8）2021.11.25

```js
Array.prototype.push = function() {
	for(let i = 0; i < arguments.length; i++){
		this[this.length] = arguments[i];
	}
	return this.length;
}
```

##### 实现数组 filter（8）2021.11.25

```js
Array.prototype.filter = function(fn) {
  if (typeof fn !== 'function') throw TypeError('参数必须是一个函数');
  const res = [];
  for (let i = 0; i < this.length; i++) {
    if (fn(this[i], i)) res.push(this[i]); 
  }
  return res;
}
```

##### 实现数组 map（8）2021.11.25

```js
Array.prototype.map = function(fn) {
  if (typeof fn !== 'function') throw TypeError('参数必须是一个函数');
  const res = [];
  for (let i = 0; i < this.length; i++) {
    res.push(fn(this[i], i));
  }
  return res;
}
```

##### 实现数组 flat（8）2021.11.25

```js
// 1 reduce + 递归
function flat(arr, depth = 1) {
  if(!Array.isArray(arr) || depth <= 0) return arr;
  return arr.reduce((acc, cur) => {
    return Array.isArray(cur) ？ acc.concat(flat(cur, depth - 1)) : acc.concat(cur);
  }, []);
}
// 2 迭代
function flat(arr) {
  const res = [];
  const arrs = [...arr];
  while(arrs.length) {
    const tmp = arrs.shift();
    Array.isArray(tmp) ? arrs.unshift(...tmp) : res.push(tmp);
  }
  return res;
}
// 3 递归
function flat(arr, depth = 1) {
  if(!Array.isArray(arr) || depth <= 0) return arr;
  const res = [];
  arr.forEach(item => {
    Array.isArray(item) ? res.push(...flat(item, depth - 1)) : res.push(item);
  })
  return res;
}
```

##### 实现字符串 trim（8）2021.11.28

```js
String.prototype.trim = function() {
  return this.replace(/(^\s*)|(\s*$)/g, '');
}
```

##### 实现字符串 repeat（8）2021.11.25

```js
// 1
String.prototype.repeat = function(n) {
	return (new Array(n + 1)).join(this);
}
// 2 递归
String.prototype.repeat = function(n) {
  return n > 0 ? this.repeat(n - 1) + this : '';
}
```

##### 实现 Object.create（8）2021.11.25

```js
Object.create = function(obj) {
  function F() {};
  F.prototype = obj;
  return new F();
}
```

##### 实现 Object.is（8）2021.11.25

```js
Object.is = function (x, y) {
  // 全等情况下，只有 +0 -0 返回 false
  if (x === y) {
    // 1/+0 === Infinity 1/-0 === -Infinity
    return x !== 0 || 1 / x === 1 / y;
  }
	// 不全等情况下，只有 NaN NaN 返回 true
  return x !== x && y !== y;
};
```

##### 实现 Object.assign（8）2021.11.25

```js
Object.assign = function(target, ...sources) {
    if (target == null) throw new TypeError('Cannot convert undefined or null to object');
  	const res = Object(target);
    sources.forEach(source => {
      for (let key in source) {
        if (source.hasOwnProperty(key)) res[key] = source[key];
      }
    });
    return res;
}
```

##### 实现 instanceof（8）2021.11.25

```js
function Instanceof(left, right) {
  while (true) {
    if (left == null) return false;
    if (left.__proto__ === right.prototype) return true;
    left = left.__proto__;
  }
}
```

##### 实现 JSON.parse（8）2021.11.25

```js
// 1 eval
JSON.parse = function(jsonStr) {
  return eval(`(${jsonStr})`);
}
// 2 new Function()
JSON.parse = function(jsonStr) {
	return (new Function(`return ${jsonStr}`))();
}
```

##### 实现 new（8）2021.11.27

```js
function New(fn, ...args) {
  const obj = Object.create(fn.prototype);
  const res = fn.call(obj, ...args);
  if (res && (typeof res === 'object' || typeof res === 'function')) return res;
  return obj;
}
```

##### 实现 call apply bind（8）2021.11.28

call

```js
Function.prototype.call = function (obj, ...args) {
  obj = obj == null ? window : Object(obj);
  obj.fn = this;
  const res = obj.fn(...args);
  delete obj.fn;
  return res;
}
```

apply   

```js
Function.prototype.apply = function (obj, args) {
  obj = obj == null ? window : Object(obj);
  obj.fn = this;
  const res = args ? obj.fn(...args) : obj.fn();
  delete obj.fn;
  return res;
}
```

bind

```js
Function.prototype.bind = function(obj, ...args) {
  obj = obj == null ? window : Object(obj);
  const fn  = this;
  const bound = function(...innerArgs) {
    if (this instanceof bound) {
      return new fn(...args, ...innerArgs);
    } else {
      // return fn.call(obj, ...args, ...innerArgs);
      obj.fn = fn;
      const res = obj.fn(...args, ...innerArgs);
      delete obj.fn;
      return res;
    }
  }
  return bound;
}
```

##### 实现 Promise.all（8）2021.11.29

```js
Promise.all = function(promises) {
  return new Promise((resolve, reject) => {
    const result = [];
  	let count = 0;
    if (promises.length === 0) {
      resolve(result);
    } else {
      for (let i = 0; i < promises.length; i++) {
        Promise.resolve(promises[i]).then(res => {
          result[i] = res;
          count++;
          if (count === promises.length) {
            resolve(result);
          }
        }, err => {
          reject(err);
        });
      }
    }
  });
}
```

##### 实现 Promise.race（8）2021.11.29

```js
Promise.race = function(promises) {
  return new Promise((resolve, reject) => {
    for (let i = 0; i < promises.length; i++) {
      Promise.resolve(promises[i]).then(res => {
        resolve(res);
      }, err => {
        reject(err);
      });
    }
  });
}
```

##### 实现 Promise.prototype.finally（7）2021.11.29

```js
Promise.prototype.finally = function(cb) {
  const P = this.constructor;
  return this.then(res => {
    return P.resolve(cb()).then(() => res);
  }, err => {
    return P.resolve(cb()).then(() => { throw err });
  });
}
```

##### 实现取消 promise（7）2021.11.29

```js
function cancel(promise) {
  const obj = {};
  const p = new Promise((resolve, reject) => {
    obj.resolve = resolve;
    obj.reject = reject;
  });
  obj.promise = Promise.race([p, promise]);
  return obj;
}
// 使用
const testPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(123);
  }, 1000);
});
const cancelPromise = cancel(testPromise);
cancelPromise.promise.then(res => {
  console.log(res);
}); 
// 取消
cancelPromise.resolve("取消");
```

##### 实现 Promise

https://juejin.cn/post/6844903796129136654

https://juejin.cn/post/6945319439772434469

.then() 链式调用的工作原理

* then 传入的函数返回了 promise 实例，那 then 函数返回就是这个 promise 实例；
* then 传入的函数返回的不是 promise 实例，那 then 函数会返回一个全新的 promise 实例并 resolve 这个返回的数据；
* then 传入的函数什么都没返回，那 then 函数也是会返回一个全新的 promise 实例并 resolve undefined。
* then 传入的是非函数，那 then 函数返回的是该 then 前面的那个的 promise 实例。

所以不管怎么样，then() 最终都会返回一个 promise 对象，这样就能保证我们能连续的使用链式调用。

```js
// 1
class Mypromise {
  constructor(fn) {
    // 表示状态
    this.state = "pending";
    // 表示then注册的成功函数
    this.successFun = [];
    // 表示then注册的失败函数
    this.failFun = [];

    let resolve = (val) => {
      // 保持状态改变不可变（resolve和reject只准触发一种）
      if (this.state !== "pending") return;

      // 成功触发时机  改变状态 同时执行在then注册的回调事件
      this.state = "success";
      // 为了保证then事件先注册（主要是考虑在promise里面写同步代码） promise规范 这里为模拟异步
      setTimeout(() => {
        // 执行当前事件里面所有的注册函数
        this.successFun.forEach((item) => item.call(this, val));
      });
    };

    let reject = (err) => {
      if (this.state !== "pending") return;
      // 失败触发时机  改变状态 同时执行在then注册的回调事件
      this.state = "fail";
      // 为了保证then事件先注册（主要是考虑在promise里面写同步代码） promise规范 这里模拟异步
      setTimeout(() => {
        this.failFun.forEach((item) => item.call(this, err));
      });
    };
    // 调用函数
    try {
      fn(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  // 实例方法 then

  then(resolveCallback, rejectCallback) {
    // 判断回调是否是函数
    resolveCallback =
      typeof resolveCallback !== "function" ? (v) => v : resolveCallback;
    rejectCallback =
      typeof rejectCallback !== "function"
        ? (err) => {
            throw err;
          }
        : rejectCallback;
    // 为了保持链式调用  继续返回promise
    return new Mypromise((resolve, reject) => {
      // 将回调注册到successFun事件集合里面去
      this.successFun.push((val) => {
        try {
          //    执行回调函数
          let x = resolveCallback(val);
          //（最难的一点）
          // 如果回调函数结果是普通值 那么就resolve出去给下一个then链式调用  如果是一个promise对象（代表又是一个异步） 那么调用x的then方法 将resolve和reject传进去 等到x内部的异步 执行完毕的时候（状态完成）就会自动执行传入的resolve 这样就控制了链式调用的顺序
          x instanceof Mypromise ? x.then(resolve, reject) : resolve(x);
        } catch (error) {
          reject(error);
        }
      });

      this.failFun.push((val) => {
        try {
          //    执行回调函数
          let x = rejectCallback(val);
          x instanceof Mypromise ? x.then(resolve, reject) : reject(x);
        } catch (error) {
          reject(error);
        }
      });
    });
  }
}

// 使用
// let promise1 = new Mypromise((resolve, reject) => {
//   setTimeout(() => {
//     resolve(123);
//   }, 2000);
// });
// let promise2 = new Mypromise((resolve, reject) => {
//   setTimeout(() => {
//     resolve(1234);
//   }, 1000);
// });

// Mypromise.all([promise1,promise2]).then(res=>{
//   console.log(res);
// })

// Mypromise.race([promise1, promise2]).then(res => {
//   console.log(res);
// });

// promise1
//   .then(
//     res => {
//       console.log(res); //过两秒输出123
//       return new Mypromise((resolve, reject) => {
//         setTimeout(() => {
//           resolve("success");
//         }, 1000);
//       });
//     },
//     err => {
//       console.log(err);
//     }
//   )
//   .then(
//     res => {
//       console.log(res); //再过一秒输出success
//     },
//     err => {
//       console.log(err);
//     }
//   );

// 2
function myPromise(constructor){
    let self=this;
    self.status="pending" //定义状态改变前的初始状态
    self.value=undefined;//定义状态为resolved的时候的状态
    self.reason=undefined;//定义状态为rejected的时候的状态
    function resolve(value){
        //两个==="pending"，保证了状态的改变是不可逆的
       if(self.status==="pending"){
          self.value=value;
          self.status="resolved";
       }
    }
    function reject(reason){
        //两个==="pending"，保证了状态的改变是不可逆的
       if(self.status==="pending"){
          self.reason=reason;
          self.status="rejected";
       }
    }
    //捕获构造异常
    try{
       constructor(resolve,reject);
    }catch(e){
       reject(e);
    }
}
myPromise.prototype.then=function(onFullfilled,onRejected){
   let self=this;
   switch(self.status){
      case "resolved":
        onFullfilled(self.value);
        break;
      case "rejected":
        onRejected(self.reason);
        break;
      default:       
   }
}

// 3
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

function Promise(excutor) {
    let that = this; // 缓存当前promise实例对象
    that.status = PENDING; // 初始状态
    that.value = undefined; // fulfilled状态时 返回的信息
    that.reason = undefined; // rejected状态时 拒绝的原因
    that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数
    that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数

    function resolve(value) { // value成功态时接收的终值
        if(value instanceof Promise) {
            return value.then(resolve, reject);
        }
        // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。
        setTimeout(() => {
            // 调用resolve 回调对应onFulfilled函数
            if (that.status === PENDING) {
                // 只能由pending状态 => fulfilled状态 (避免调用多次resolve reject)
                that.status = FULFILLED;
                that.value = value;
                that.onFulfilledCallbacks.forEach(cb => cb(that.value));
            }
        });
    }
    function reject(reason) { // reason失败态时接收的拒因
        setTimeout(() => {
            // 调用reject 回调对应onRejected函数
            if (that.status === PENDING) {
                // 只能由pending状态 => rejected状态 (避免调用多次resolve reject)
                that.status = REJECTED;
                that.reason = reason;
                that.onRejectedCallbacks.forEach(cb => cb(that.reason));
            }
        });
    }

    // 捕获在excutor执行器中抛出的异常
    // new Promise((resolve, reject) => {
    //     throw new Error('error in excutor')
    // })
    try {
        excutor(resolve, reject);
    } catch (e) {
        reject(e);
    }
}

Promise.prototype.then = function(onFulfilled, onRejected) {
    const that = this;
    let newPromise;
    // 处理参数默认值 保证参数后续能够继续执行
    onFulfilled =
        typeof onFulfilled === "function" ? onFulfilled : value => value;
    onRejected =
        typeof onRejected === "function" ? onRejected : reason => {
            throw reason;
        };
    if (that.status === FULFILLED) { // 成功态
        return newPromise = new Promise((resolve, reject) => {
            setTimeout(() => {
                try{
                    let x = onFulfilled(that.value);
                    resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值
                } catch(e) {
                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);
                }
            });
        })
    }

    if (that.status === REJECTED) { // 失败态
        return newPromise = new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    let x = onRejected(that.reason);
                    resolvePromise(newPromise, x, resolve, reject);
                } catch(e) {
                    reject(e);
                }
            });
        });
    }

    if (that.status === PENDING) { // 等待态
        // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中
        return newPromise = new Promise((resolve, reject) => {
            that.onFulfilledCallbacks.push((value) => {
                try {
                    let x = onFulfilled(value);
                    resolvePromise(newPromise, x, resolve, reject);
                } catch(e) {
                    reject(e);
                }
            });
            that.onRejectedCallbacks.push((reason) => {
                try {
                    let x = onRejected(reason);
                    resolvePromise(newPromise, x, resolve, reject);
                } catch(e) {
                    reject(e);
                }
            });
        });
    }
};
```

##### todo

1. 实现数组 flat
2. call apply bind

## Javascript 手写题

##### 数组去重（8）2021.11.29

```js
// 1.传统方式，遍历元素挨个比较，去重
function uniqueArr(arr) {
  const res = [];
  const map = new Map();
  for (let item of arr) {
  	if (!map.has(item)) {
			res.push(item);
      map.set(item, 1);
    }
  }
  return res;
}
// 2.使用Set（无序，不能重复）
function uniqueArr(arr) {
  return [...new Set(arr)];
}
```

##### 浅拷贝（8）2021.11.29

```js
// Object.assign
let a = {a: 1, b: 2};
let b = Object.assign({}, a);
// ...
let a = {a: 1, b: 2};
let b = {...a};
// slice
let a = [1, {a: 1}];
let b = a.slice();
// concat
let a = [1, {a: 1}];
let b = [].concat(a);
```

##### 深拷贝（8）2021.11.29

```js
// 1 
// 1.如果obj里面存在时间对象,JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。
// 2.如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象。
// 3.如果obj里有函数，undefined，则序列化的结果会把函数，undefined丢失。
// 4.如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。
// 5.JSON.stringify()只能序列化对象的可枚举的自有属性。如果obj中的对象是有构造函数生成的，则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的构造函数constructor，即无法继续使用构造函数原型上的属性。
// 6.如果对象中存在循环引用的情况也无法正确实现深拷贝。
const o = JSON.parse(JSON.stringify(obj));

// 2
function isObject(val) {
  return typeof val === "object" && val !== null;
}
function deepClone(obj, hash = new WeakMap()) {
  if (!isObject(obj)) return obj;
  if (hash.has(obj)) return hash.get(obj);
  const res = Array.isArray(obj) ? [] : {};
  hash.set(obj, res);
  // Reflect.ownKeys(obj)=Object.getOwnPropertyNames(obj)+Object.getOwnPropertySymbols(obj)
  [
    ...Object.getOwnPropertyNames(obj),
    ...Object.getOwnPropertySymbols(obj),
  ].forEach(key => {
    res[key] = deepClone(obj[key], hash);
  });
  return res;
}
```

##### 节流（8）2021.11.30

节流是频繁操作的时候保持一个频率触发。比如拖拽一个元素时，要随时拿到这个元素被拖拽的位置。

```js
// 定时器版
function throttle(fn, delay = 100) {
  let flag = true;
  return function(...args) {
		if (!flag) return;
    flag = false;
    setTimeout(() => {
      fn.call(this, ...args);
      flag = true;
    }, delay);
  }
}
// 时间戳版
function throttle(fn, delay = 100) {
  let prev = 0;
  return function(...args) {
    const now = Date.now();
    if (now - prev > delay) {
      fn.call(this, ...args);
      prev = now;
    }
  }
}
// 使用
div.addEventListener('drag', throttle(function(e) {
  console.log(e.offsetX, e.offsetY);
}, 300));
```

##### 防抖（8）2021.11.30

防抖是频繁操作的最后时刻触发。比如输入停止后一段时间没有再输入才会请求接口。

```js
// 定时器版
function debounce (fn, delay = 100) {
  let timer = null;
  return function(...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.call(this, ...args);
      timer = null;
    }, delay)
  }
}
// 使用
input.addEventListener('keyup', debounce(function() {
  console.log(input.value);
}, 300));
```

##### 发布订阅（8）2021.11.30

```js
class EventEmitter {
  constructor() {
    this.events = {};
  }
  on(name, handler){
    this.events[name] = this.events[name] || [];
    this.events[name].push(handler);
  }
  emit(name, ...args) {
    if (!this.events[name]) throw new Error('该事件未注册');
    this.events[name].forEach(fn => fn.call(this, ...args));
  }
  off(name, handler) {
    if (!this.events[name]) throw new Error('该事件未注册');
    if (!handler) {
			delete this.events[name];
    } else {
      this.events[name] = this.events[name].filter(fn => fn !== handler);
    }
  }
  once(name, handler) {
    function fn(...args) {
      handler.call(this, ...args);
      this.off(name, fn);
    }
    this.on(name, fn);
  }
}
```

##### sleep 函数（8）2021.11.30

```js
function sleep(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}
// 使用
sleep(1000).then(()=>{
  console.log(1);
})
async function output() {
  let out = await sleep(1000);
  console.log(1);
}
output();
```

##### 通用事件封装（8）2021.12.01

```js
function bindEvent (elem, type, selector, fn) {
  if (fn == null) {
    fn = selector;
    selector = null;
  }
  elem.addEventListener(type, event => {
    const target = event.target;
    if (selector) {
      // 代理绑定
      if (selector.contains(target)) {
        fn.call(target, event);
      }
    } else {
      // 普通绑定
      fn.call(target, event);
    }
  })
}
```

##### ajax 封装（8）2021.12.01

```js
function ajax (url, method, postData) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open(method, url);
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(JSON.parse(xhr.responseText));
        } else {
          reject(new Error(xhr.responseText));
        }
      }
    }
    method === 'GET' ? xhr.send() : xhr.send(JSON.stringify(postData));
  });
}
```

##### setTimeout 实现 setInterval（8）2021.12.01

```js
function setInterval(fn, time) {
	function interval() {
    fn();
    setTimeout(interval, time);
  }
  return setTimeout(interval, time);
}
```

##### setInterval 实现 setTimeout（8）2021.12.01

```js
const setTimeout = (fn, time) => {
  const timer = setInterval(() => {
    fn();
    clearInterval(timer);
  }, time);
  return timer;
}
```

##### Jsonp 封装（8）2021.12.02

```js
// 发送请求
function createScript(src) {
  const script = document.createElement('script');
  script.src = src;
  script.type = "text/javascript";
  document.body.appendChild(script);
}
createScript("http://xxx.xxx.com/xxx.js?callback=handleResponse");
// 接收数据
function handleResponse(res) {
  console.log(res);
}
// 接口返回一个携带数据的函数调用的js
handleResponse({a: 1, b: 2});
```

##### 解析 URL Params（8）2021.12.02

```js
// 1.传统方式，查找location.search
function query(name) {
  const search = location.search.substring(1);
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i');
  const res = search.match(reg);
  return res ? res[2] : null;
}
// 2.新api，URLSearchParams
function query(name) {
  const p = new URLSearchParams(location.search);
  return p.get(name);
}
```

##### 对象扁平化（8）2021.12.02

```js
function isObject(val) {
  return typeof val === "object" && val !== null;
}
function flatten(obj) {
  if (!isObject(obj)) return obj;
  const res = {};
  function dfs(cur, prefix) {
    if (isObject(cur)) {
      if (Array.isArray(cur)) {
        cur.forEach((item, index) => {
          dfs(item, `${prefix}[${index}]`);
        });
      } else {
        for (let key in cur) {
          dfs(cur[key], `${prefix}${prefix ? "." : ""}${key}`);
        }
      }
    } else {
      res[prefix] = cur;
    }
  };
  dfs(obj, '');
  return res;
}
// 测试
const obj = {
  a: {
    b: 1,
    c: 2,
    d: {e: 5}
  },
  b: [1, 3, {a: 2, b: 3}],
  c: 3
};
flatten(obj);
```

##### 对象反扁平化

```js
function unflatten(data) {
  if (!isObject(data) || Array.isArray(data)) return data;
  const regex = /\.?([^.\[\]]+)|\[(\d+)\]/g;
  const resultholder = {};
  for (let p in data) {
    let cur = resultholder;
    let prop = "";
    let m;
    while(m = regex.exec(p)) {
      cur = cur[prop] || (cur[prop] = (m[2] ? [] : {}));
      prop = m[2] || m[1];
    }
    cur[prop] = data[p];
  }
  return resultholder[""] || resultholder;
}
```

##### 函数柯里化（5）

柯里化（currying）是把接受多个参数的函数变换成接受一个参数的函数，并且返回接受剩余参数且返回结果的新函数的技术。

柯里化后的函数接收参数的数量与原函数的形参数量相等时，执行原函数；当接收的参数数量小于原函数形参数量时，返回一个用于接收剩余参数的函数。

```js
// 1 只能传被柯里化函数形参的个数，多少都不行
function currying(fn, ...args) {
    const length = fn.length;
    return function(...newArgs){
        const allArgs = [...args, ...newArgs];
        if (allArgs.length < length) {
            return currying.call(this, fn, ...allArgs);
        } else {
            return fn.apply(this, allArgs);
        }
    }
}
const add = (a, b, c) => a + b + c;
const addCurrying = currying(add);
console.log(addCurrying(1)(2)(3));
console.log(addCurrying(1,2)(3));
console.log(addCurrying(1)(2,3));
console.log(addCurrying(1,2,3));

// 2 参数长度不固定，最后需要手动调用一次
function currying(fn, ...args) {
    let allArgs = [...args];
    return function temp(...newArgs) {
        if (newArgs.length) {
            allArgs = [...allArgs, ...newArgs];
            return temp;
        } else {
            const res = fn.apply(this, allArgs);
            allArgs = [...args];
            return res;
        }
    }
}
const add = (...args) => args.reduce((a, b) => a + b);
const addCurrying = currying(add);
console.log(addCurrying(1)(2)(3)(4,5)());
console.log(addCurrying(1)(2)(3,4,5)());
console.log(addCurrying(1)(2,3,4,5)());
```

柯里化用途

```js
// 1 校验规则
// 原函数
function checkByRegExp(regExp, string) {
    return regExp.test(string);  
}
// 普通使用
checkByRegExp(/^1\d{10}$/, '18642838455'); // 校验电话号码
checkByRegExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'test@163.com'); // 校验邮箱
// 柯里化后使用
let check = currying(checkByRegExp);
let checkCellPhone = check(/^1\d{10}$/);
let checkEmail = check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);
checkCellPhone('18642838455'); // 校验电话号码
checkCellPhone('13109840560'); // 校验电话号码
checkCellPhone('13204061212'); // 校验电话号码
checkEmail('test@163.com'); // 校验邮箱
checkEmail('test@qq.com'); // 校验邮箱
checkEmail('test@gmail.com'); // 校验邮箱
// 2 提取对象数组的某一属性
const list = [
    {name:'lucy'},
    {name:'jack'}
];
// 普通使用
const names = list.map(item => item.name);
// 柯里化使用
const prop = currying((key, obj) => obj[key]);
const names = list.map(prop('name'));
```

##### compose（5）

```js
function compose(...fns) {
    if (!fns.length) return (v) => v;
    if (fns.length === 1) return fns[0];
    return fns.reduce((pre, cur) => (...args) => pre(cur(...args)));
}
function compose(...fns) {
    if (!fns.length) return v => v;
    if (fns.length === 1) return fns[0];
    return fns.reduce((pre, cur) => {
        return (...args) => {
            return pre(cur(...args));
        }
    });
}
// 使用
function fn1(x) {
  return x + 1;
}
function fn2(x) {
  return x + 2;
}
function fn3(x) {
  return x + 3;
}
function fn4(x) {
  return x + 4;
}
const a = compose(fn1, fn2, fn3, fn4); // a = (...args) => fn1(fn2(fn3(fn4(...args))))
console.log(a(1)); // 1+4+3+2+1=11
```

##### LazyMan（5）

```js
class LazyManClass {
  constructor(name) {
    this.tasks = [];
    const task = () => {
      console.log(`Hi! This is ${name}`);
      this.next();
    };
    this.tasks.push(task);
    setTimeout(() => {
      // 所有任务添加完之后开始初始化执行任务队列的任务。
      this.next();
    }, 0);
  }
  next() {
    // 取第一个任务执行
    const task = this.tasks.shift();
    task && task();
  }
  sleep(time) {
    this.sleepWrapper(time, false);
    return this;
  }
  sleepFirst(time) {
    this.sleepWrapper(time, true);
    return this;
  }
  sleepWrapper(time, isFirst) {
    const task = () => {
      setTimeout(() => {
        console.log(`等待${time}秒`);
        this.next();
      }, time * 1000);
    };
    if (isFirst) {
      this.tasks.unshift(task);
    } else {
      this.tasks.push(task);
    }
  }
  eat(name) {
    const task = () => {
      console.log(`eat ${name}`);
      this.next();
    };
    this.tasks.push(task);
    return this;
  }
}
function LazyMan(name) {
  return new LazyManClass(name);
}
LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(4).eat('junk food');
```

##### 循环打印红黄绿

红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次。如何让3个灯不断交替重复亮灯？

```js
function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}
// callback
const task = (timer, light, callback) => {
    setTimeout(() => {
        if (light === 'red') {
            red()
        }
        else if (light === 'green') {
            green()
        }
        else if (light === 'yellow') {
            yellow()
        }
        callback()
    }, timer)
}
const step = () => {
    task(3000, 'red', () => {
        task(2000, 'green', () => {
            task(1000, 'yellow', step)
        })
    })
}
step()

// promise
const task = (timer, light) => 
    new Promise((resolve, reject) => {
        setTimeout(() => {
            if (light === 'red') {
                red()
            }
            else if (light === 'green') {
                green()
            }
            else if (light === 'yellow') {
                yellow()
            }
            resolve()
        }, timer)
    })
const step = () => {
    task(3000, 'red')
        .then(() => task(2000, 'green'))
        .then(() => task(2100, 'yellow'))
        .then(step)
}
step()

// async/await
const taskRunner =  async () => {
    await task(3000, 'red')
    await task(2000, 'green')
    await task(2100, 'yellow')
    taskRunner()
}
taskRunner()
```

##### 每隔一秒打印 1,2,3,4

```js
// 使用闭包实现
for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  })(i);
}
// 使用 let 块级作用域
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
```

##### 分片思想解决大数据量渲染问题

```js
let ul = document.getElementById("container");
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total / once;
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal, curIndex) {
  if (curTotal <= 0) {
    return false;
  }
  //每页多少条
  let pageCount = Math.min(curTotal, once);
  window.requestAnimationFrame(function () {
    for (let i = 0; i < pageCount; i++) {
      let li = document.createElement("li");
      li.innerText = curIndex + i + " : " + ~~(Math.random() * total);
      ul.appendChild(li);
    }
    loop(curTotal - pageCount, curIndex + pageCount);
  });
}
loop(total, index);
```

##### 将虚拟 Dom 转化为真实 Dom

```js
{
  tag: 'DIV',
  attrs:{
  id:'app'
  },
  children: [
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] }
      ]
    },
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] },
        { tag: 'A', children: [] }
      ]
    }
  ]
}
// 把上诉虚拟Dom转化成下方真实Dom
<div id="app">
  <span>
    <a></a>
  </span>
  <span>
    <a></a>
    <a></a>
  </span>
</div>

// 真正的渲染函数
function _render(vnode) {
  // 如果是数字类型转化为字符串
  if (typeof vnode === "number") {
    vnode = String(vnode);
  }
  // 字符串类型直接就是文本节点
  if (typeof vnode === "string") {
    return document.createTextNode(vnode);
  }
  // 普通DOM
  const dom = document.createElement(vnode.tag);
  if (vnode.attrs) {
    // 遍历属性
    Object.keys(vnode.attrs).forEach((key) => {
      const value = vnode.attrs[key];
      dom.setAttribute(key, value);
    });
  }
  // 子数组进行递归操作
  vnode.children.forEach((child) => dom.appendChild(_render(child)));
  return dom;
}
```

##### DOM2JSON

```js
<div>
  <span>
    <a></a>
  </span>
  <span>
    <a></a>
    <a></a>
  </span>
</div>

把上诉dom结构转成下面的JSON格式

{
  tag: 'DIV',
  children: [
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] }
      ]
    },
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] },
        { tag: 'A', children: [] }
      ]
    }
  ]
}

function dom2Json(domtree) {
  let obj = {};
  obj.name = domtree.tagName;
  obj.children = [];
  domtree.childNodes.forEach((child) => obj.children.push(dom2Json(child)));
  return obj;
}
```

##### 程序把 entry 转换成如下对象

```js
var entry = {
a: {
b: {
  c: {
    dd: 'abcdd'
  }
},
d: {
  xx: 'adxx'
},
e: 'ae'
}
}

// 要求转换成如下对象
var output = {
'a.b.c.dd': 'abcdd',
'a.d.xx': 'adxx',
'a.e': 'ae'
}

```

##### 把 entry 转换成如下对象

```js
var entry = {
'a.b.c.dd': 'abcdd',
'a.d.xx': 'adxx',
'a.e': 'ae'
}

// 要求转换成如下对象
var output = {
a: {
b: {
  c: {
    dd: 'abcdd'
  }
},
d: {
  xx: 'adxx'
},
e: 'ae'
}
}

```

##### 列表转成树形结构

```js
[
    {
        id: 1,
        text: '节点1',
        parentId: 0 //这里用0表示为顶级节点
    },
    {
        id: 2,
        text: '节点1_1',
        parentId: 1 //通过这个字段来确定子父级
    }
    ...
]

转成
[
    {
        id: 1,
        text: '节点1',
        parentId: 0,
        children: [
            {
                id:2,
                text: '节点1_1',
                parentId:1
            }
        ]
    }
]
// 1
function listToTree(data) {
  let temp = {};
  let treeData = [];
  for (let i = 0; i < data.length; i++) {
    temp[data[i].id] = data[i];
  }
  for (let i in temp) {
    if (+temp[i].parentId != 0) {
      if (!temp[temp[i].parentId].children) {
        temp[temp[i].parentId].children = [];
      }
      temp[temp[i].parentId].children.push(temp[i]);
    } else {
      treeData.push(temp[i]);
    }
  }
  return treeData;
}

// 2
function convert(list) {
	const res = []
	const map = list.reduce((res, v) => (res[v.id] = v, res), {})
	for (const item of list) {
		if (item.parentId === 0) {
			res.push(item)
			continue
		}
		if (item.parentId in map) {
			const parent = map[item.parentId]
			parent.children = parent.children || []
			parent.children.push(item)
		}
	}
	return res
}
// 3
const convert = list => {
  let map = new Map();
  let result = []
  list.forEach(el => {
    map.set(el.id, el);
  });
  list.forEach(el => {
		let parent = map.get(el.parentId);
		if (!parent) {
			// parentId === 0
			el.children = []
			return 
		}
    if (parent.hasOwnProperty('children')) {
      parent.children.push(el);
    } else {
      parent['children'] = [];
      parent.children.push(el);
    }
	});
	for (let i = 0; i < list.length; i++) {
		const el = list[i];
		if (el.parentId === 0) {
			result.push(el)
		}
	}
	return result
};
let list = [
  { id: 1, name: '部门A', parentId: 0 },
  { id: 2, name: '部门B', parentId: 0 },
  { id: 3, name: '部门C', parentId: 1 },
  { id: 4, name: '部门D', parentId: 1 },
  { id: 5, name: '部门E', parentId: 2 },
  { id: 6, name: '部门F', parentId: 3 },
  { id: 7, name: '部门G', parentId: 2 },
  { id: 8, name: '部门H', parentId: 4 }
];
convert(list)

```

##### 树形结构转成列表

```js
[
    {
        id: 1,
        text: '节点1',
        parentId: 0,
        children: [
            {
                id:2,
                text: '节点1_1',
                parentId:1
            }
        ]
    }
]
转成
[
    {
        id: 1,
        text: '节点1',
        parentId: 0 //这里用0表示为顶级节点
    },
    {
        id: 2,
        text: '节点1_1',
        parentId: 1 //通过这个字段来确定子父级
    }
    ...
]

function treeToList(data) {
  let res = [];
  const dfs = (tree) => {
    tree.forEach((item) => {
      if (item.children) {
        dfs(item.children);
        delete item.children;
      }
      res.push(item);
    });
  };
  dfs(data);
  return res;
}
```

##### jsonToTree

```js
// 方法1
var treeList = [
    {
        title: '系统管理',
        parentName: '',
        parentId: 0,
        id: 1,
    },
    {
        title: '菜单管理',
        parentName: '系统管理',
        parentId: 1,
        id: 11,
    },
    {
        title: '菜单新增',
        parentName: '菜单管理',
        parentId: 11,
        id: 111,
    },
    {
        title: '菜单编辑',
        parentName: '菜单管理',
        parentId: 11,
        id: 112,
    },
    {
        title: '菜单删除',
        parentName: '菜单管理',
        parentId: 11,
        id: 113,
    },
    {
        title: '角色管理',
        parentName: '系统管理',
        parentId: 1,
        id: 22,
    },
    {
        title: '角色新增',
        parentName: '角色管理',
        parentId: 22,
        id: 221,
    },
    {
        title: '角色编辑',
        parentName: '角色管理',
        parentId: 22,
        id: 222,
    },
    {
        title: '角色删除',
        parentName: '角色管理',
        parentId: 22,
        id: 223,
    },
    {
        title: '用户管理',
        parentName: '系统管理',
        parentId: 1,
        id: 33,
    },
    {
        title: '用户新增',
        parentName: '用户管理',
        parentId: 33,
        id: 331,
    },
    {
        title: '用户编辑',
        parentName: '用户管理',
        parentId: 33,
        id: 332,
    },
    {
        title: '用户删除',
        parentName: '用户管理',
        parentId: 33,
        id: 333,
    }
]
function jsonToTree(lists, id, parentId) {
    var idList = {},
        treeList = [];
    for (var i = 0, len = lists.length; i < len; i++) {
        //生成一个以id为键的对象
        idList[lists[i][id]] = lists[i]
    }
    for (var j = 0, len1 = lists.length; j < len1; j++) {
        var aVal = lists[j];
        var aValParent = idList[aVal[parentId]];
        //如果aValParent存在；就说明当前的aVal是aValParent的孩子
        if (aValParent) {
            if ('chindren' in aValParent) {
                aValParent['children'].push(aVal)
            } else {
                aValParent['children'] = [];
                aValParent['children'].push(aVal)
            }
        } else {
            treeList.push(aVal)
        }
    }
    return treeList
}
// 方法2
var data=[
  { id: 40, parentId: 31, note: "的萨达是" }, 
  { id: 20, parentId: 11, note: "的萨达是" },
  { id: 22, parentId: 20, note: "dsadas" },
  { id: 12, parentId: null, note: "dsadasad萨达s" }, 
  { id: 11, parentId: undefined, note: "dqwds" }, 
  { id: 24, parentId: 22, note: "搜索" },
  { id: 34, parentId: 22, note: "搜索" }
]
function fnSetTreeData(data) {
  var data = [...data];
  var tree = data.filter((father) => {
    var branchArr = data.filter((child) => {
      if (father.id == child.parentId) child._hasParent = true;
      return father.id == child.parentId;

      // MARK 为什么这样写就报错 ? 
      // if (father.id == child.parentId) child._hasParent = true;
      // return child._hasParent
    });
    if (branchArr.length > 0) father.children = branchArr;
    return !father._hasParent;
  });
  // MARK 为什么在这里还得加一个过滤
  tree = tree.filter((item) => {
    return !item._hasParent;
  })
  return tree
}
console.log(JSON.stringify(fnSetTreeData(data), null, 2))
// 方法3
var data = [
  { id: 40, parentId: 31, note: "的萨达是" }, 
  { id: 20, parentId: 11, note: "的萨达是" },
  { id: 22, parentId: 20, note: "dsadas" },
  { id: 12, parentId: null, note: "dsadasad萨达s" }, 
  { id: 11, parentId: undefined, note: "dqwds" }, 
  { id: 24, parentId: 22, note: "搜索" },
  { id: 34, parentId: 22, note: "搜索" }
]
function listToTree(data) {
  let arr = JSON.parse(JSON.stringify(data))
  const listChildren = (obj, filter) => {
    [arr, obj.children] = arr.reduce((res, val) => {
      if (filter(val))
        res[1].push(val)
      else
        res[0].push(val)
      return res
    }, [[],[]])
    obj.children.forEach(val => {
      if (arr.length)
      listChildren(val, obj => obj.parentId === val.id)
    })
  }

  const tree = {}
  listChildren(tree, val => arr.findIndex(i => i.id === val.parentId) === -1)
  return tree.children
}
// 方法4
var aaa= [{name:'wwb',id:111},{name:'aaa',id:0,pid:"mei"},{name:'a',id:1,pid:"mei"},{name:'b',id:2,pid:1},{name:'c',id:3,pid:1},{name:'d',id:4,pid:2},{name:'e',id:5,pid:2}];

function test(ary,data){

    var data=data?data:(function(ary){
      var tempAry=[];
      var idList=[];
      ary.forEach(function(item){idList.push(item.id)});
     function deb(id,idList){
         var flag=true;
        for(var ida in idList){
            if(id==idList[ida]){
                flag=false;
            }       
        }
         return flag;
     }

      for(var i=0,len=ary.length;i<len;i++){
        if(ary[i].pid==undefined||(ary[i].pid!=undefined&&deb(ary[i].pid,idList))){
          var obj={name:ary[i].name,id:ary[i].id};
          tempAry.push(obj);
        }
       }
        return tempAry; 
    }(ary));

    var temp=0;
   if(data.constructor==Array){
     for(var i=0,len=data.length;i<len;i++){
        for(var j=0,lenA=ary.length;j<lenA;j++){
           if(ary[j].pid==data[i].id){
           var obj={name:ary[j].name,id:ary[j].id};
           data[i].child=data[i].child||[];
           data[i].child.push(obj);
           temp++;
       }
     }
    }
   }

   if(temp>0){
     if(data.constructor==Array){
      for(var n=0,lenB=data.length;n<lenB;n++){
        data[n].child=test(ary,data[n].child?data[n].child:[]);
        if(data[n].child.length==0){
            delete data[n].child;
        }
          delete data[n].id;
      } 
    }
   }else{
       for(var n=0,lenB=data.length;n<lenB;n++){
          delete data[n].id;
       } 

   }
    return data;

}
var a=test(aaa);
sconsole.log(a)
```

##### 实现模板字符串解析

```js
let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';
let data = {
  name: '姓名',
  age: 18
}
render(template, data); // 我是姓名，年龄18，性别undefined
```

##### 找出 element 元素的全部 input 元素

```js
function findAllInputElement(element) {
  const rec = function (element, arr) {
    if (element.nodeName.toUpperCase() === "INPUT") {
      arr.push(element)
    }
    let children = element.childNodes
    children.forEach(element => {
      rec(element, arr)
    });
    return arr
  }
  return rec(element, [])
}
```

##### 判读对象是否存在循环引用

```js
const isCycleObject = (obj,parent) => {
    const parentArr = parent || [obj];
    for(let i in obj) {
        if(typeof obj[i] === 'object') {
            let flag = false;
            parentArr.forEach((pObj) => {
                if(pObj === obj[i]){
                    flag = true;
                }
            })
            if(flag) return true;
            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);
            if(flag) return true;
        }
    }
    return false;
}


const a = 1;
const b = {a};
const c = {b};
const o = {d:{a:3},c}
o.c.b.aa = a;

console.log(isCycleObject(o))
```

##### 根据以下要求，写一个数组去重函数

1. 如传入的数组元素为`[123, "meili", "123", "mogu", 123]`，则输出：`[123, "meili", "123", "mogu"]`
2. 如传入的数组元素为`[123, [1, 2, 3], [1, "2", 3], [1, 2, 3], "meili"]`，则输出：`[123, [1, 2, 3], [1, "2", 3], "meili"]`
3. 如传入的数组元素为`[123, {a: 1}, {a: {b: 1}}, {a: "1"}, {a: {b: 1}}, "meili"]`，则输出：`[123, {a: 1}, {a: {b: 1}}, {a: "1"}, "meili"]`



## 算法

##### 排序算法

初级排序：选择排序/插入排序/冒泡排序

高级排序：快速排序/归并排序/堆排序

##### 深度优先搜索，广度优先搜索

##### 二分查找

##### 移动零

##### 两数之和

##### 三数之和

##### 判断括号字符串是否有效

##### 查找字符串中出现最多的字符和个数

##### 找出字符串中连续出现最多的字符和个数

```js
'abcaakjbb' => {'a':2,'b':2}
'abbkejsbcccwqaa' => {'c':3}
```

##### 查找文章中出现频率最高的单词

```js
function findMostWord(article) {
  // 合法性判断
  if (!article) return;
  // 参数处理
  article = article.trim().toLowerCase();
  let wordList = article.match(/[a-z]+/g),
    visited = [],
    maxNum = 0,
    maxWord = "";
  article = " " + wordList.join("  ") + " ";
  // 遍历判断单词出现次数
  wordList.forEach(function(item) {
    if (visited.indexOf(item) < 0) {
      // 加入 visited 
      visited.push(item);
      let word = new RegExp(" " + item + " ", "g"),
        num = article.match(word).length;
      if (num > maxNum) {
        maxNum = num;
        maxWord = item;
      }
    }
  });
  return maxWord + "  " + maxNum;
}
```

##### 字符串中出现的不重复的最长长度

```js
var lengthOfLongestSubstring = function (s) {
    let map = new Map();
    let i = -1
    let res = 0
    let n = s.length
    for (let j = 0; j < n; j++) {
        if (map.has(s[j])) {
            i = Math.max(i, map.get(s[j]))
        }
        res = Math.max(res, j - i)
        map.set(s[j], j)
    }
    return res
};
```

##### 最长公共前缀

[14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

##### 最长不含重复字符的子字符串

[剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

##### 旋转数组

[旋转数组](https://leetcode-cn.com/problems/rotate-array/)

##### 第 k 个缺失的正整数

[第 k 个缺失的正整数](https://leetcode-cn.com/problems/kth-missing-positive-number/)

##### LRU 算法

```js
//  一个Map对象在迭代时会根据对象中元素的插入顺序来进行
// 新添加的元素会被插入到map的末尾，整个栈倒序查看
class LRUCache {
  constructor(capacity) {
    this.secretKey = new Map();
    this.capacity = capacity;
  }
  get(key) {
    if (this.secretKey.has(key)) {
      let tempValue = this.secretKey.get(key);
      this.secretKey.delete(key);
      this.secretKey.set(key, tempValue);
      return tempValue;
    } else return -1;
  }
  put(key, value) {
    // key存在，仅修改值
    if (this.secretKey.has(key)) {
      this.secretKey.delete(key);
      this.secretKey.set(key, value);
    }
    // key不存在，cache未满
    else if (this.secretKey.size < this.capacity) {
      this.secretKey.set(key, value);
    }
    // 添加新key，删除旧key
    else {
      this.secretKey.set(key, value);
      // 删除map的第一个元素，即为最长未使用的
      this.secretKey.delete(this.secretKey.keys().next().value);
    }
  }
}
// let cache = new LRUCache(2);
// cache.put(1, 1);
// cache.put(2, 2);
// console.log("cache.get(1)", cache.get(1))// 返回  1
// cache.put(3, 3);// 该操作会使得密钥 2 作废
// console.log("cache.get(2)", cache.get(2))// 返回 -1 (未找到)
// cache.put(4, 4);// 该操作会使得密钥 1 作废
// console.log("cache.get(1)", cache.get(1))// 返回 -1 (未找到)
// console.log("cache.get(3)", cache.get(3))// 返回  3
// console.log("cache.get(4)", cache.get(4))// 返回  4
```

##### 动态规划求解硬币找零问题

##### 请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]

```js
// 1
function concatArr (arr1, arr2) {
   const arr = [...arr1];
  let currIndex = 0;
 for (let i = 0; i < arr2.length; i++) {
    const RE = new RegExp(arr2[i])
    while(currIndex < arr.length) {
      ++currIndex
      if (!RE.test(arr[currIndex])) {
         arr.splice(currIndex, 0, a2[i])
         break;
       }
     }
   }
  return arr
 }
 var a1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 
 var a2 = ['A', 'B', 'C', 'D']
 const arr = concatArr(a1, a2)
 console.log(a1) // ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 
 console.log(a2) // ['A', 'B', 'C', 'D']
 console.log(arr) // ['A1', 'A2', 'A', B1', 'B2', 'B', C1', 'C2', 'C', D1', 'D2', 'D'] 
// 2
const arr1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
const arr2 = ['A', 'B', 'C', 'D']
const ret = []
let tmp = arr2[0]
let j = 0
for (let i=0;i<arr1.length;i++) {
  if (tmp === arr1[i].charAt(0)){
    ret.push(arr1[i])
  }else {
    ret.push(tmp)
    ret.push(arr1[i])
    tmp=arr2[++j]
  }
   if(i===arr1.length-1){
      ret.push(tmp)
    }
}
console.log(ret)
// 3
let a1 =  ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
let a2 = ['A', 'B', 'C', 'D'].map((item) => {
  return item + 3
})

let a3 = [...a1, ...a2].sort().map((item) => {
  if(item.includes('3')){
    return item.split('')[0]
  }
  return item
})

// 4
var arr1 = ["A1", "A2", "B1", "B2", "C1", "C2", "D1", "D2"]
var arr2 = ["A", "B", "C", "D"]
var arr3 = arr1.concat(arr2);
arr3.sort().sort(function(a,b){
   if (a.charAt(0) == b.charAt(0) && a.length > b.length){
       return -1
   }
	
})
// 5
var arr1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
var arr2 = ['A', 'B','C', 'D'];

function fn (arr1, arr2) {
let arr3 = [...arr1];
let index = -1;
arr2.forEach((v, i) => {
index = index + 3;
arr3.splice(index, 0, v);
});
return arr3;
}

```

##### 版本号排序算法

```js
// 有一组版本号如下['0.1.1', '2.3.3', '0.302.1', '4.2', '4.3.5', '4.3.4.5']。现在需要对其进行排序，排序的结果为 ['4.3.5','4.3.4.5','2.3.3','0.302.1','0.1.1']

arr.sort((a, b) => {
  let i = 0;
  const arr1 = a.split(".");
  const arr2 = b.split(".");

  while (true) {
    const s1 = arr1[i];
    const s2 = arr2[i];
    i++;
    if (s1 === undefined || s2 === undefined) {
      return arr2.length - arr1.length;
    }

    if (s1 === s2) continue;

    return s2 - s1;
  }
});
console.log(arr);
```

##### 计算数组的交集

给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。

##### 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]

```js
// 生产随机数
var arr = (function(len){
    var a = []
    for(var i = 0; i < len; i++) {
        a.push(Math.floor(Math.random() * 100))
    }
    return a
})(20)

// 排序
arr.sort(function(a, b) {
    return a - b
})
// 去重 (arr 转 set 然后 set 转 arr)
arr = [...(new Set([...arr]))]

var subArr = []

// 用 map 存储
var map = {}
arr.forEach(item => {
    var key = Math.floor(item / 10)
    if(!map[key]) {
        map[key] = []
    }
    map[key].push(item)
})

// map 转 数组
for(var key in map) {
    subArr.push(map[key])
}

console.log(JSON.stringify(subArr))
```

##### 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。

```js
// 1
const find = (S, T) => {
  if (S.length < T.length) return -1
  for (let i = 0; i < S.length; i++) {
    if (S.slice(i, i + T.length) === T) return i
  }
  return -1
}
// 2
const find = (S,T) => S.indexOf(T)
// 3
const find = (S, T) => S.search(T)
// 4
const find = (S, T) => {
  const matched = S.match(T) 
  return matched ? matched.index : -1 
}
```

##### 打印 1-10000之间所有对称数

```js
// 1
[...Array(10000).keys()].filter((x) => { 
  return x.toString().length > 1 && x === Number(x.toString().split('').reverse().join('')) 
})
// 2
var result = [];
for (let i = 1; i <= 10000; i++) {
	let origin = '' + i;
	let reverse = origin.split('').reverse().join('');
	if(origin === reverse) {
		result.push(i);
	}
}
```

##### 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))。

##### 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。

##### 输入 `'1, 2, 3, 5, 7, 8, 10'` 输出 `'1~3, 5, 7~8, 10'`

##### 统计 1 ~ n 整数中出现 1 的次数

##### 在一个字符串数组中有红、黄、蓝三种颜色的球，且个数不相等、顺序不一致，请为该数组排序。使得排序后数组中球的顺序为:黄、红、蓝。

例如：红蓝蓝黄红黄蓝红红黄红，排序后为：黄黄黄红红红红红蓝蓝蓝。

##### 1 到 12 月份的销售额存在一个数组里面

```js
const obj = {1:222, 2:123, 5:888};
const result = Array.from({ length: 12 }).map((_, index) => obj[index + 1] || null);
console.log(result)
```

##### 实现千位分隔符

```js
let format = n => {
    let num = n.toString() // 转成字符串
    let decimals = ''
        // 判断是否有小数
    num.indexOf('.') > -1 ? decimals = num.split('.')[1] : decimals
    let len = num.length
    if (len <= 3) {
        return num
    } else {
        let temp = ''
        let remainder = len % 3
        decimals ? temp = '.' + decimals : temp
        if (remainder > 0) { // 不是3的整数倍
            return num.slice(0, remainder) + ',' + num.slice(remainder, len).match(/\d{3}/g).join(',') + temp
        } else { // 是3的整数倍
            return num.slice(0, len).match(/\d{3}/g).join(',') + temp 
        }
    }
}
format(12323.33)  // '12,323.33'

// 无小数版
let format = n => {
    let num = n.toString() 
    let len = num.length
    if (len <= 3) {
        return num
    } else {
        let remainder = len % 3
        if (remainder > 0) { // 不是3的整数倍
            return num.slice(0, remainder) + ',' + num.slice(remainder, len).match(/\d{3}/g).join(',') 
        } else { // 是3的整数倍
            return num.slice(0, len).match(/\d{3}/g).join(',') 
        }
    }
}
format(1232323)  // '1,232,323'
```

##### 大数相加

```js
// 1
function sumBigNumber(a, b) {
  let res = '';
  let temp = 0;
  
  a = a.split('');
  b = b.split('');
  
  while (a.length || b.length || temp) {
    temp += ~~a.pop() + ~~b.pop();
    res = (temp % 10) + res;
    temp  = temp > 9
  }
  return res.replace(/^0+/, '');
}
// 2
let a = "9007199254740991";
let b = "1234567899999999999";

function add(a ,b){
   //...
}

function add(a ,b){
   //取两个数字的最大长度
   let maxLength = Math.max(a.length, b.length);
   //用0去补齐长度
   a = a.padStart(maxLength , 0);//"0009007199254740991"
   b = b.padStart(maxLength , 0);//"1234567899999999999"
   //定义加法过程中需要用到的变量
   let t = 0;
   let f = 0;   //"进位"
   let sum = "";
   for(let i=maxLength-1 ; i>=0 ; i--){
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t/10);
      sum = t%10 + sum;
   }
   if(f!==0){
      sum = '' + f + sum;
   }
   return sum;
}
```

##### 大数相乘

```js
function multiplyBigNum(num1, num2) {
    //判断输入是不是数字
    if (isNaN(num1) || isNaN(num2)) return "";
    num1 = num1 + ""
    num2 = num2 + ""
    let len1 = num1.length,
        len2 = num2.length;
    let pos = [];

    //j放外面，先固定被乘数的一位，分别去乘乘数的每一位，更符合竖式演算法
    for (let j = len2 - 1; j >= 0; j--) {
        for (let i = len1 - 1; i >= 0; i--) {
            //两个个位数相乘，最多产生两位数，index1代表十位，index2代表个位
            let index1 = i + j,
                index2 = i + j + 1;
            //两个个位数乘积加上当前位置个位已累积的数字，会产生进位，比如08 + 7 = 15，产生了进位1
            let mul = num1[i] * num2[j] + (pos[index2] || 0);
            //mul包含新计算的十位，加上原有的十位就是最新的十位
            pos[index1] = Math.floor(mul / 10) + (pos[index1] || 0);
            //mul的个位就是最新的个位
            pos[index2] = mul % 10;
        }
    }

    //去掉前置0
    let result = pos.join("").replace(/^0+/, "");

    return result - 0 || '0';
}
```

##### 手机号中间4位变*

```js
// 1
const tel = 18877776666; 
tel = "" + tel; 
var ary = tel.split(""); 
ary.splice(3,4,"****"); 
var tel1 = ary.join(""); 
console.log(tel1);
// 2
const tel = 18877776666; 
tel = "" + tel; 
var tel1 = tel.substr(0,3) + "****" + tel.substr(7) 
console.log(tel1);
// 3
const tel = 18877776666;  
tel = "" + tel; 
var tel1 =tel.replace(tel.substring(3,7), "****") 
console.log(tel1);
// 4
const tel = 18877776666;  
tel = "" + tel; 
var reg=/(\d{3})\d{4}(\d{4})/; 
var tel1 = tel.replace(reg, "$1****$2") 
console.log(tel1);s
```

## 项目

##### 项目

## 面试准备

##### 面试准备

简历

面试

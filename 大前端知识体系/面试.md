面试题来源：

前端面试手册.pdf

前端面试题汇总：

https://juejin.cn/post/7004638318843412493#heading-21

https://juejin.cn/post/6968713283884974088

https://hub.fastgit.org/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB

https://www.yuque.com/cuggz/interview

前端大班车公众号

大厂面试题（牛客...）



## html

##### html 语义化

html 语义化使页面具有良好的结构和含义。

对开发者友好，使代码有良好的可读性。

对机器友好，有利于搜索引擎爬取有效信息。

##### 常用的 meta 标签

```html
<!--描述html文档的编码形式-->
<meta charset="UTF-8">
<!--设置http头-->
<meta http-equiv="expires" content="Wed, 20 Jun 2019 22:33:00 GMT">
<!--设置移动端viewport大小和比例-->
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
```

##### src 和 href 的区别

当解析到 src 加载的资源时，会暂停其他资源的下载和处理，直到该资源加载、执行完毕，所以一般 js 脚本会放到文档底部而不是头部。

当解析到 href 加载的资源时，会并行下载资源，不会停止对当前文档的处理。css 文件一般放到头部。

##### Html 文档中各种资源的解析规则，互相影响和阻塞规则

##### script 标签中 defer 和 async 的区别

`<script src="script.js"></script>`

按照顺序来加载并执行脚本，在脚本加载及执行分过程中，会阻塞后续 html 文档的解析。

`<script defer src="script.js"></script>`

加载过程不会影响 html 文档解析，并且在 html 文档解析成功后，DOMContentLoaded 事件触发之前执行脚本。

`<script async src="script.js"></script>`

加载过程不会影响 html 文档解析，加载成功后会立即执行脚本内容，这个过程会阻塞后续 html 文档的解析。

应用场景：

defer：脚本代码依赖于页面中的DOM元素，或者被其他脚本文件依赖。

async：脚本并不关心页面中的DOM元素，并且也不会产生其他脚本需要的数据。如百度统计。

## css

##### px/em/rem

px：绝对单位，页面精确像素。

em：父节点字体大小，如果自身定义了使用自身字体大小。

rem：根结点字体大小。

##### 水平垂直居中

水平居中：

```html
<div class="parent">
	<div class="child"> 啦啦啦 </div>
</div>

<style>
/* 方案一：inline-block + text-align */
.parent { text-align: center; }
.child { display: inline-block; }
/* 方案二：block + margin */
.child { 
  width: 100px; /* 需要设置宽度 */
  display: block;
  margin: 0 auto;
}
/* 方案三：absolute + transform/margin */
.parent { position: relative; }
.child {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}
</style>
```

垂直居中：

```html
<div class="parent">
	<div class="child"> 啦啦啦 </div>
</div>

<style>
/* 方案一：table-cell + vertical-align */
.parent {
	display: table-cell; /* 单元格的内容是可以设置水平垂直对齐的 */
  vertical-align: middle; /* 用于设置文本内容的垂直方向对齐方式 */
}
/* 方案二：absolute + transform/margin */
.parent { position: relative; }
.child {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
</style>
```

水平垂直居中：

就是将水平和垂直居中方案进行整合，这三种方式都可以实现定宽高和不定宽高元素的水平垂直居中。

```html
<div class="parent">
	<div class="child"> 啦啦啦 </div>
</div>

<style>
/* 方案一：inline-block + text-align 实现水平方向居中，table-cell + vertical-align 实现垂直方向居中 */
.parent {
	display: table-cell; 
  vertical-align: middle; 
  text-align: center;
}
.child { 
  display: inline-block;
}
/* 方案二：table/block + margin 实现水平方向居中，table-cell + vertical-align 实现垂直方向居中 */
.parent {
	display: table-cell; 
  vertical-align: middle; 
}
.child { 
  display: table; /* 为了更加符合语义化，改成block也可以，但是只能实现定宽元素的水平垂直居中 */
  margin: 0 auto;
}
/* 方案三：absolute + transform/margin 实现水平方向和垂直方向居中 */
.parent {
	position: relative; /* 不脱离文档流 */
}
.child { 
  position: absolute; 
  top: 50%;
  left: 50%;
  transfrom: translate(-50%, -50%);
}
</style>
```

##### BFC（块级格式化上下文）

BFC 是指一块独立的区域，让处于 BFC 内部的元素于外部的元素相互隔离，不互相产生影响。

BFC 触发条件：

* 根元素 html 元素
* position: fixed/absolute
* float 不是 none
* overflow 不为 visible
* display: inline-block/table-cell/table-caption

##### 清除浮动

父元素布局的时候不会去管浮动元素，有可能浮动元素会超出父元素从而对其他的元素产生影响，所以作为父元素一定要清除浮动，保证对外面是无害的，不会影响其他元素。

浮动元素不会占据父元素的布局空间，解决浮动元素的父元素高度塌陷的问题。

1.父级添加 overflow 属性（不推荐）

通过触发 BFC 方式（就是负责接管自己的宽高），实现清除浮动。

设置了 overflow 属性，父元素就需要知道内容的高度来设置相应的行为，所以这种方式就可以阻止高度塌陷，从而清除浮动。

```css
.fahter {
  overflow: hidden; /* auto 也可以 */
}
```

2.额外标签法（不推荐）

在最后一个浮动标签后，新加一个标签，给其设置 clear: both; 

3.使用 after 伪元素清除浮动（推荐使用）

因为浮动元素只会影响他后面的块的排列，所以在父元素内部的最下面加一个清除浮动的元素，clear: both; 的意思是保证这个元素的左右两边都是干净的，没有浮动元素，这样就能把父级撑起来它应有的高度，从而把浮动的影响去掉，解决高度塌陷。

```css
.clearfix::after {
  display: block; /* 伪元素默认是 inline 的，inline 元素无法帮我们做清除浮动的事情。 */
  content: " ";
  clear: both;
  height: 0;
  visibility: hidden;
  overflow：hidden;
}
```

4.使用 before 和 after 双伪元素清除浮动（万能清除法）（推荐使用）

```css
.clearfix::before, .clearfix::after {
  display: block;
  content: " ";
}
.clearfix::after {
  clear: both;
}
```

##### 画三角形

![triangle-up](triangle-up.png)

```css
#triangle-up {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}
```

## Javascript

##### load 和 DOMContentLoaded 的区别

load 事件在页面所有资源全部加载完成后（包括 DOM 文档树，css 文件，js 文件，图片资源等）会执行。

DOMContentLoaded 事件在形成 DOM 树后就会触发。

##### let const

let

* let 声明的变量是拥有块级作用域的。
* 用 let 声明的全局变量不能通过 window 的属性去访问。
* var 定义的变量可以重复，let 声明的变量不允许重复定义。
* let 声明的变量不会进行变量提升。

const

* const 具备以上 let 的所有特点
* const 它定义的是常量。既然是常量，也就是说它不能再被修改了。
* const 不允许先声明再赋值，let, var 都可以，就是声明的时候必须做初始化。

##### toString 和 toLocaleString 的区别

* 当目标是四位以上数字时，会以 ',' 三个做一个分隔

* 当目标是标准时间格式时

  ```js
  var sd = new Date()
  
  console.log(sd) // Wed Feb 15 2017 11:21:31 GMT+0800 (CST)
  console.log(sd.toString()) // "Wed Feb 15 2017 11:21:31 GMT+0800 (CST)"
  console.log(sd.toLocaleString()) // "2017/2/15 上午11:21:31"
  ```

##### 单线程和异步

单线程：只有一个线程，同一时间只能做一件事情。

单线程原因：避免dom渲染的冲突

解决方案：异步。把需要等待一段时间才能做的事情变成异步，先执行其他的 js 代码，这样就不会阻塞后面代码的执行从而造成页面卡死的状态了。

传统异步：基于 callback 函数形式来调用的，每个异步里面加个回调函数，在合适的时间去执行这个回调函数。

回调式异步写法的缺点：没有按照书写的顺序来执行，可读性差，callback 中不容易模块化

异步写法：

* 回调函数
* jquery deferred
* Promise
* async/await
* generator

##### event-loop

event loop 是浏览器对异步的实现方式。

事件循环的顺序，决定了 JavaScript 代码的执行顺序。

整体的 js 代码这个宏任务先执行，同步代码执行完后有微任务执行微任务，没有微任务执行下一个宏任务，如此往复循环至结束。

每一次 call stack 结束后，就是每次宏任务结束后，会触发页面渲染，然后再进行下一次循环就是下一个宏任务。

```js
// 修改DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
  .append($p1)
  .append($p2)
  .append($p3)
// 下面代码会先执行，然后页面渲染才会变化。
console.log('length',  $('#container').children().length )
alert('本次 call stack 结束，尚未触发 DOM 渲染')
```

宏任务：页面渲染后再触发，微任务：页面渲染前会触发。

```js
// 修改DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
  .append($p1)
  .append($p2)
  .append($p3)
// 微任务：DOM 渲染之前执行
Promise.resolve().then(() => {
  const length = $('#container').children().length     
  alert(`micro task ${length}`)
})
// 宏任务：DOM 渲染之后执行
setTimeout(() => {    
  const length = $('#container').children().length
  alert(`macro task ${length}`)
})
```

##### new Object() 和 Object.create() 有什么区别

```js
// 1.{}等同于new Object()，原型都是Object.prototype
// 2.Object.create(null)，必须传一个参数，可以是一个对象也可以是null。传入null就是没有原型。传入对象就是指定原型。Object.create()就是创建一个空对象，然后把空对象的原型指定为传入的这个对象上。
  const obj1 = {
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  }
  const obj2 = new Object({
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj3 = new Object(obj1)
  console.log(obj1 === obj3)            // true
  const obj4 = Object.create(null)      // {}，但是没有原型
  const obj5 = new Object()             // {}，有原型
  const obj6 = Object.create({          // {}，原型就是传入的这个对象
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj7 = Object.create(obj1)      // 意思就是说我们通过obj1创建了obj6，通过create方式来创建的。
  console.log(obj6.__proto__ === obj1)  // true
  console.log(obj6 === obj1)            // false
  console.log(obj1 === obj3)            // true 
```

##### 作用域

作用域：作用域就是变量，函数能够使用的范围。

作用域链：自由变量查找的顺序。

自由变量：当前作用域没有定义，但是使用了的变量。

自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在函数执行的地方。

##### 闭包

MDN：闭包是函数和该函数中使用的声明在该函数的词法环境中的变量的组合。

闭包是一个绑定了执行环境的函数。

在 JavaScript 中找到对应的闭包组成部分。JavaScript 中的函数完全符合闭包的定义。

* 环境部分
  * 环境：函数的词法环境（执行上下文的一部分）
  * 标识符列表：函数中用到的未声明的变量
* 表达式部分：函数体

有两个函数，内部函数定义在外部函数中，并且内部函数使用了外部函数环境中定义的变量，当内部函数执行的时候，外部函数就形成了一个闭包。这个变量可以常驻内存，不被垃圾回收。

```js
(function () {
  var a = 1;
  function add() {
    var b = 2;
    var sum = b + a;
    console.log(sum) // 3
  }
  add();
})();
```

add 函数本身，以及其内部可访问的变量 a，这两个组合起来就被称为闭包。

```js
function a() {
  var i=0;
  function b() {
    alert(++i)
  }
  return b
}
var c = a()
c()
```

闭包作用：

1.私有化数据，除了闭包还可以使用 proxy  Symbol 等。

函数中的 name 只能通过 getname 和 setname 两个访问，外部无法访问，相当于将变量私有化。

``` js
function Person() {
  var name = 'tom';
  this.getname = function () {
		retunr name;
  }
  this.setname = function (val) {
		name = val;
  }
}
const tom = new Person();
console.log(tom.getname()); // tom
tom.setname('jeck');
console.log(tom.getname()); // jeck
console.log(name) // undefined
```

```js
function createCache () {
  const data = {} // 闭包中的数据，被隐藏，不被外界访问
  return {
    get (key) {
      return data[key]
    },
    set (key, value) {
      data[key] = value
    }
  }
}
const c = createCache()
c.set('a', 100)
console.log(c.get('a'))
```

2.使局部变量常驻内存

创建 10 个 \<a> 标签，点击的时候弹出对应的序号。

```js
let i, a
for (i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function (e) {
    e.preventDefault()
    alert(i)
  })
  document.body.appendChild(a)
}
```

```js
let a
for (let i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function (e) {
    e.preventDefault()
    alert(i)
  })
  document.body.appendChild(a)
}
```

```js
let i, a
for (i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', (function (i) {
    return function (e) {
      e.preventDefault()
      alert(i)
    }
  })(i))
  document.body.appendChild(a)
}
```

##### js 作用域链

##### 模块化

es module 

commonjs

amd

cmd

前端发展模块化历程及js模块化原理:

1.函数封装

我们在讲函数的时候提到，函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里面编写几个相关函数就是最开始的模块了。

```js
function fn1 () {
  statement
}
function fn2 () {
  statement
}
```

这样在需要的时候加载函数所在文件，调用函数就可以了。

这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。

2.对象

为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中。

```js
var myModule = {
  var1: 1,
  var2: 2,
  fn1: function () {

  },
  fn2: function () {

  }
}
```

这样我们在希望调用模块的时候引用对应文件，然后

myModule.fn2()

这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系

看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员

myModel.var1 = 100;

这样就会产生意外的安全问题

3.立即执行函数

可以通过立即执行函数，来达到隐藏细节的目的

```js
var myModule = (function () {
  var var1 = 1;
  var var2 = 2;
  function fn1 () {

  }
  function fn2 () {

  }
  return {
    fn1: fn1,
    fn2: fn2
  }
})()
```

这样在模块外部无法修改我们没有暴露出来的变量、函数

4.放大模式(扩展模块本身)

如果一个模块很大，必须分成几个部分

```js
var module1 = (function (mod){
  mod.m3 = function () {
    //...
  };
  return mod;
})(module1 || {});
```

上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。

5.输入全局变量(依赖其他模块)

独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。

为了在模块内部调用全局变量，必须显式地将其他变量输入模块。

```js
var module1 = (function ($, YAHOO) {
  //...
})(jQuery, YAHOO);
```

上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。

这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。

Javascript模块规范：CommonJS，AMD，CMD：

require.js实现AMD规范

sea.js实现CMD规范

定义模块(利用的就是模块化的原理，使用自执行函数)，导出模块；引入模块，使用模块

模块化博客：

Javascript模块化编程（一）：模块的写法    

http://www.ruanyifeng.com/blog/2012/10/javascript_module.html  

Javascript模块化编程（二）：AMD规范

http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html

Javascript模块化编程（三）：require.js的用法

http://www.ruanyifeng.com/blog/2012/11/require_js.htmls

关于js众多模块化标准：

* 没有模块化的时代
* AMD成为标准，require.js
* 前端打包工具，使得nodejs的commonjs模块化可以被使用了
* es6出现，想统一现在所有模块化的标准

模块打包工具：

rollup功能单一，webpack功能强大

rollup输出之后的内容小。对于源代码很多，很复杂，多人维护的代码库非常重要。因为它能优化冗余内容，对于小的程序来说可能无所谓，但对于一些庞大的开发环境中，如果能优化一点点，哪怕是百分之四百分之五概率的冗余的代码，最后输出的内容就会有很大的影响。rollup的功能比较单一，它就是能打包模块化，没有模块化，rollup就没用了。但是js不可能没有模块化。现在的开发环境，模块化是一个非常重要的存在。所以rollup功能单一，但是做到了极致。webpack功能比较强大，但是它的学习成本非常的高。这一点可以参考《设计原则》和《Linux/Unix设计思想》这两本书。它们都提到一个单一值的原则，就是所有的东西呢你都给我做成一个单一功能就行了，没必要说更好更快更强。在软件设计中这是一个不好的事情。软件设计中比较喜欢一个东西只做一件事情，做好了就行了。越简单越单一越好，不能说一个东西把所有东西都干完。让其他的工具没有事干。这样是不好的。

模块化使用：

函数定义中调用引入的模块中的函数，始终是这样的两层结构。这个函数还可以作为模块被其他函数引用并且调用。调用时形成多层结构。一层一层的调用和传参。vuex 中的接口和 actions 的结合就能很好的体现这一点。

函数定义的时候是从外层到里层，调用的时候也是从外层到里层。

##### js 数据类型

简单类型：boolean null undefined number string symbol

复杂类型：object

值类型：undefined number string boolean symbol

引用类型：function object（对象，数组，null）

##### 判断是否是数组

```js
if (Array.isArray(value)) {
   return true;
}
// 兼容
if (!Array.isArray) {
  Array.isArray = function (arg) {
		return Object.prototype.toString.call(arg) === '[object Array]';
  }
}
```

##### 数组去重

```js
// 1.传统方式，遍历元素挨个比较，去重
function unique (arr) {
  const res = []
  arr.forEach(item => {
    if (res.indexOf(item) < 0) {
      res.push(item)
    }
  })
  return res
}
// 2.使用Set（无序，不能重复）
function unique (arr) {
  const set = new Set(arr)
  return [...set]
}
```

##### call apply 应用场景

检验数据类型：

```js
function type(obj) {
  var regexp = /\s(\w+)\]/
  var result =  regexp.exec(Object.prototype.toString.call(obj))[1]
  return result
}
console.log(type([123]))      // Array
console.log(type('123'))      // String
console.log(type(123))        // Number
console.log(type(null))       // Null
console.log(type(undefined))  // Undefined
```

数组取最大/小值：

```js
var arr = [11, 1, 0, 2, 3, 5];
// 取最大
var max1 = Math.max.call(null, ...arr)
var max2 = Math.max.apply(null, arr)
// 取最小
var min1 = Math.min.call(null, ...arr)
var min2 = Math.min.apply(null, arr)
```

伪数组转数组：

```js
var fn = function () {
  var arr = Array.prototype.slice.call(arguments)
  console.log(arr) // [1, 2, 3, 4]
};
fn(1, 2, 3, 4);
```

##### 手写 call apply bind

call

```js
// es5
Function.prototype.call_ = function (obj) {
  //判断是否为null或者undefined,同时考虑传递参数不是对象情况
  obj = obj ? Object(obj) : window
  var args = []
  // 注意i从1开始
  for (var i = 1, len = arguments.length; i < len; i++) {
  	args.push("arguments[" + i + "]")
  };
  obj.fn = this // 此时this就是函数fn
  var result = eval("obj.fn(" + args + ")") // 执行fn
  delete obj.fn // 删除fn
  return result
}

// es6
Function.prototype.call_ = function (obj) {
  obj = obj ? Object(obj) : window
  obj.fn = this
  // 利用拓展运算符直接将arguments转为数组
  let args = [...arguments].slice(1)
  let result = obj.fn(...args)
  delete obj.fn
  return result
}
```

apply   

```js
// es5
Function.prototype.apply_ = function (obj, arr) {
  obj = obj ? Object(obj) : window
  obj.fn = this
  var result
  if (!arr) {
    result = obj.fn()
  } else {
    var args = []
    // 注意这里的i从0开始
    for (var i = 0, len = arr.length; i < len; i++) {
      args.push("arr[" + i + "]")
    }
    result = eval("obj.fn(" + args + ")") // 执行fn
  }
  delete obj.fn //删除fn
  return result
}

// es6
Function.prototype.apply_ = function (obj, arr) {
  obj = obj ? Object(obj) : window
  obj.fn = this
  let result
  if (!arr) {
    result = obj.fn()
  } else {
    result = obj.fn(...arr)
  }
  delete obj.fn
  return result
}
```

bind

```js
// es5 方法1
Function.prototype.bind1 = function () {
  // 将函数参数解析为数组
  const args = Array.prototype.slice.call(arguments)
  // 获取 this (取出数组第一项，数组剩余的就是传递的参数)
  const t = args.shift()
  const self = this // 当前函数
  // 返回一个函数
  return function () {
    // 执行原函数，并返回结果
    return self.apply(t, args)
  }
}
// 使用
function fn1 (a, b, c) {
  console.log('this', this)
  console.log(a, b, c)
  return 'this is fn1'
}
const fn2 = fn1.bind({x: 100}, 10, 20, 30)
const res = fn2()
console.log(res)

// es5 方法2
Function.prototype.bind_ = function (obj) {
  if (typeof this !== "function") {
    throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
  };
  var args = Array.prototype.slice.call(arguments, 1);
  var fn = this;
  // 创建中介函数
  var fn_ = function () {};
  var bound = function () {
    var params = Array.prototype.slice.call(arguments);
    // 通过constructor判断调用方式，为true this指向实例，否则为obj
    fn.apply(this.constructor === fn ? this : obj, args.concat(params));
    console.log(this);
  };
  fn_.prototype = fn.prototype;
  bound.prototype = new fn_();
  return bound;
}

// es6
Function.prototype.bind = function(thisArg) {
  if(typeof this !== 'function'){
    throw new TypeError(this + 'must be a function')
  }
  // 存储函数本身
  const _this  = this
  // 去除thisArg的其他参数 转成数组
  const args = [...arguments].slice(1)
  // 返回一个函数
  const bound = function() {
    // 可能返回了一个构造函数，我们可以 new F()，所以需要判断
    if (this instanceof bound) {
      return new _this(...args, ...arguments)
    }
    // apply修改this指向，把两个函数的参数合并传给thisArg函数，并执行thisArg函数，返回执行结果
    return _this.apply(thisArg, args.concat(...arguments))
  }
  return bound
}
```

##### 手写一个简易的 jquery

```js
// jquery是做dom查询的，所以首先constructor里面要传入一个selector
class jQuery {
  constructor (selector) {
    const result = document.querySelectorAll(selector)
    const length = result.length
    for (let i = 0; i < length; i++) {
  		this[i] = result[i]
    }
    this.length = length
    this.selector = selector
  }
  get (index) {
    return this[index]
  }
  each (fn) {
    for (let i = 0; i < this.length; i++) {
      const elem = this[i]
      fn(elem)
  	}
	}
  on (type, fn) {
    return this.each(elem => {
      elem.addEventListener(type, fn, false)
    })
  }
	// 可以扩展很多dom 操作 api
  // ...
}
// 使用
const $p = new jQuery('p')
$p.get(1)
$p.each(elem => console.log(elem.nodeName))
$p.on('click', elem => console.log('clicked'))
```

##### Proxy

代理的核心价值是屏蔽原始信息，保证原始信息的安全。

```js
let o = {
  name: 'xiaoming',
  price: 190
}
let d = new Proxy(o, {})
```

* 第一个参数：你要代理谁。

* 第二个参数：代理之后我能干什么。比如劫持构造函数，劫持你的 get, set。对于其他的操作基本用不到。

操作传成 {} 就相当于没操作，没操作就等于是透传。

```js
d.revoke() // 撤销代理
```

##### promise async/await

.then() 链式调用的工作原理

* then 传入的函数返回了 promise 实例，那 then 函数返回就是这个 promise 实例；
* then 传入的函数返回的不是 promise 实例，那 then 函数会返回一个全新的 promise 实例并 resolve 这个返回的数据；
* then 传入的函数什么都没返回，那 then 函数也是会返回一个全新的 promise 实例并 resolve undefined。
* then 传入的是非函数，那 then 函数返回的是该 then 前面的那个的 promise 实例。

所以不管怎么样，then() 最终都会返回一个 promise 对象，这样就能保证我们能连续的使用链式调用。

Promise.all() & Promise.rase()

```js
// all
const p1 = Promise.resolve(1)
const p2 = Promise.resolve(2)
const p3 = Promise.resolve(3)
Promise.all([p1, p2, p3])
  .then(value => {
    console.log(value) // [1, 2, 3]
  })
// rase
const p1 = () => {
  return new Promise((resolve, reject) => {
    setTimeout(function () {
      resolve(1)
    }, 0)
  })
}
const p2 = () => {
  return new Promise((resolve, reject) => {
    setTimeout(function () {
      resolve(2)
    }, 1000)
  })
}
Promise.race([p1(), p2()])
  .then(value => {
    console.log(value) // 1
  })
```

Promise.all 实现

```js
Promise.all = arr => {
  let aResult = [];    // 用于存放每次执行后返回结果
  return new _Promise(function (resolve, reject) {
    let i = 0;
    next();    // 开始逐次执行数组中的函数(重要)
    function next() {
      arr[i].then(function (res) {
        aResult.push(res);    // 存储每次得到的结果
        i++;
        if (i == arr.length) {    // 如果函数数组中的函数都执行完，便resolve
          resolve(aResult);
        } else {
          next();
        }
      })
    }
  })
}
```

##### 节流/防抖

```js
// 节流
// 定时器版
function throttle(fn, wait) {
  let timer;
  return function() {
    let context = this
    let args = arguments
    // timer没有的时候才执行函数
    if (!timer) {
      timer = setTimeout(() => {
        timer = null
        fn.apply(context, args)
      }, wait)
    }
  }
}
// 时间戳版
function throttle(fn, wait) {
  let previous = 0
  return function() {
    let now = Date.now()
    let context = this
    let args = arguments
    if (now - previous > wait) {
      fn.apply(context, args)
      previous = now
    }
  }
}
// 使用
var fn = function () {
 console.log('boom')
}
document.onclick = throttle(fn, 500)


// 防抖
function debounce(fn, wait) {
  var timer = null
  return function () {
    var context = this
    var args = arguments
    // 只要timer有就清除它
    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, wait)
  }
}
// 立即执行版
function debounce(func, wait) {
  let timer;
  return function() {
    let context = this
    let args = arguments
    if (timer) {
      clearTimeout(timer)
    }
    let callNow = !timer;
    timer = setTimeout(() => {
      timer = null;
    }, wait)
    if (callNow) func.apply(context, args);
  }
}
// 使用
var fn = function () {
 console.log('boom')
}
document.onclick = debounce(fn, 500)
```

##### 防抖 debounce

* 监听一个输入框，文字变化后触发 change 事件。
* 直接监听 keyup 事件，则会频繁触发 change 事件。
* 防抖：用户在输入结束或暂停的时候，才会触发 change 事件。

防抖简易 demo：

```js
const input1 = document.getElementById('input1')
let timer = null
input1.addEventListener('keyup', function () {
  if (timer) {
    clearTimeout(timer)
  }
  timer = setTimeout(() => {
    // 模拟触发change事件
    console.log(input1.value)
    // 清空定时器
    timer = null
  }, 500)
})
// debounce是对函数的封装，所以它最终返回应该是一个函数
// 函数的封装就是将大部分逻辑封装起来，使使用的时候更加简单，只写业务逻辑就行了。jq zepto等库和插件都是这个原理。
function debounce (fn, delay = 500) {
  // 这个timer是在闭包中的，timer这个数据就被隐藏了，不会被外面轻易拿到
  let timer = null

  return function () {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      // this是为了获取添加事件的dom对象，arguments是为了将事件函数接收到的参数透传给fn
      fn.apply(this, arguments)
      timer = null
    }, delay)
  }
}

// 使用
input1.addEventListener('keyup', debounce(function () {
  console.log(input1.value)
}, 300))
```

##### 节流 throttle

防抖的场景是频繁输入和频繁操作的时候最后的时候才去触发。节流是你在频繁输入频繁操作的时候它会保持一个频率连续触发。

* 比如拖拽一个元素时，要随时拿到这个元素被拖拽的位置。
* 如果直接用 drag 事件，则会频繁触发，很容易导致卡顿。
* 这个时候我们需要节流：无论拖拽的速度多快，都会每隔 100ms 触发一次。

节流简易 demo：

```js
const div1 = document.getElementById('div1')
let timer = null
div1.addEventListener('drag', function (e) {
  if (timer) {
    return 
  }
  timer = setTimeout(() => {
    console.log(e.offsetX, e.offsetY)
    timer = null
  }, 100)
})
// 节流函数封装
function throttle (fn, delay = 100) {
  let timer = null
  return function () {
    if (timer) {
      return
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments)
      timer = null
    }, delay)
  }
}

// 使用
input1.addEventListener('drag', throttle(function (e) {
  console.log(e.offsetX, e.offsetY)
}, 200))
```

##### 跨域

同源策略：

ajax 请求的时候，浏览器要求当前网页和 server 必须同源（安全），同源指的是协议、域名、端口三者一致。在服务端或非浏览器的环境下是没有这个限制的。

加载图片，css，js 可无视同源策略：

同源策略第一个条件就是 ajax 请求，如果不是 ajax 请求，比如说图片，css，js 等文件的加载可无视同源策略，它们的地址都可以跨域，浏览器不会限制。

图片，css，js 可以无视同源策略，都是有一定的功能需求的，浏览器也是为了它们有一定功能做了一些考虑。

form 表单提交，不受跨域限制。

```html
<img src="跨域的图片地址" />
<link href="跨域的css地址" />
<script src="跨域的js地址"></script>
```

1.\<img/>

图片可用于统计打点。统计可能是使用第三方统计服务，比如站长之家，百度统计等，这些都是外域的，统计打点无非就是发一个请求，如果用 ajax 发的话就会出现跨域。所以说我们用图片，初始化一个图片，把图片的地址写成第三方统计服务的地址，在地址里面写上我们各种各样需要的参数，通过图片去发这个请求就可以了。

2.\<link/> \<script>

\<link /> \<script> 可以使用 cdn，cdn 一般都是外域。

3.\<script> 可以实现 jsonp

jsonp 是前端实现跨域一个比较常用的方案。

跨域解决方案：

所有的跨域，都必须经过 server 端允许和配合。

如果未经 server 端允许就实现的跨域，说明浏览器有漏洞，是一个危险信号。

1.Jsonp

我们先看一个问题，浏览器随便访问一个网址，服务端返回的一定是一个 html 文件吗。服务端拿到这个网址 url 之后分析，获取这个请求文件的内容，然后把文件内容返回，其实服务端不一定返回一个 html 文件的内容，服务端可以动态拼接任何的数据内容返回，只要符合相应文件的格式要求，同理 script 去访问一个 js 地址，也不一定就返回一个 js 静态文件。

Jsonp 原理

* \<script> 可以绕过跨域限制
* 服务端可以拼接任意动态数据返回
* 所以就可以通过 \<script> 获得跨域的数据，只要服务端愿意返回
* 只能用 GET 请求，并且要求返回 JavaScript。

jsonp 简易 demo

```html
<script>
  window.callback = function (data) {
    // 这是我们跨域接收的信息
    console.log(data)
  }
</script>

<!-- 这个script将返回 callback({x: 100, y: 200}) -->
<script src="https://imooc.com/getData.js?cb=callback&id=123"></script>
```

2.cors

其实不管我们有没有返回 'Access-Control-Allow-Origin' 这个头，浏览器它都会向我们的服务去发送这个请求，浏览器在发送一个请求的时候它并不知道我们这个服务是不是跨域的，所以说它还是会发送请求，并且接收你的返回内容，只不过呢在浏览器接收到它的数据返回的时候，它看到里面没有一个'Access-Control-Allow-Origin'这么一个头并且设置为允许的话，那么它会把这个请求返回的内容给它忽略掉并且在控制台中报跨域的错。

服务端支持的一种解决跨域的方式，是纯服务器端的操作。

cors 其实是一个统称，就是服务器端可以设置 http header，在服务端 response 返回的时候可以设置 header，如下面这些东西。

```js
response.setHeader('Access-Control-Allow-Origin', 'http://localhost:8081') // 允许的域名是什么 
response.setHeader('Access-Control-Allow-Headers', 'X-Requested-With')     // 允许的headers是什么 
response.setHeader('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS') // 允许的methods是什么 
response.setHeader('Access-Control-Allow-Credentials', 'true') // 接收跨域的cookie，是否允许传cookie
```

##### ajax

xhr.readyState 等于 4 的时候才说明 ajax 请求成功了，然后判断 xhr.status 也就是 http 状态码就可以了。比如网络断开的情况下 xhr 不可能等于 4，所以前端 ajax 请求的业务逻辑中根本就不用判断类似断网的这种情况。

简易 ajax 封装：

```js
// 回调函数版
function ajax (url, method, successFn, errorFn, postData) {
  const xhr = new XMLHttpRequest()
  xhr.open(method, url, true)
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        successFn(
          JSON.parse(xhr.responseText) // 返回的信息是字符串
        )
      } else if (xhr.status === 404) {
        errorFn(new Error('404 not found'))
      }
    }
  }
  if (method === 'GET') {
  	xhr.send()
  } else {
    xhr.send(JSON.stringify(postData)) // 发送的数据也要求是字符串
  }
}

const url = '/data/test.json'
const method = 'POST'
const postData = {
  username: 'zhangsan',
  password: 'xxx'
}
ajax(url, method, postData, function(res) {
  console.log(res)
}, function(err) {
  console.log(err)
})
```

```js
// promise版
function ajax (url, method, postData) {
  const p = new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest()
    xhr.open(method, url, true)
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(
            JSON.parse(xhr.responseText)
          )
        } else if (xhr.status === 404) {
          reject(new Error('404 not found'))
        }
      }
    }
    if (method === 'GET') {
      xhr.send()
    } else {
      xhr.send(JSON.stringify(postData)) // 发送的数据也要求是字符串
    }
  })
  return p
}

const url = '/data/test.json'
const method = 'GET'
const postData = {
  username: 'zhangsan',
  password: 'xxx'
}
ajax(url, method, postData)
  .then(res => {
    console.log(res)
  })
  .catch(err => {
    console.log(err)
  })
```

##### 深拷贝

浅拷贝

```js
// Object.assign
let a = {a: 1, b: 2};
let b = Object.assign({}, a);
// ...
let a = {a: 1, b: 2};
let b = {...a};
// slice
let a = [1, {a: 1}];
let b = a.slice();
// concat
let a = [1, {a: 1}];
let b = [].concat(a);
```

深拷贝

```js
// 1
// 1.如果obj里面存在时间对象,JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。
// 2.如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象。
// 3.如果obj里有函数，undefined，则序列化的结果会把函数，undefined丢失。
// 4.如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。
// 5.JSON.stringify()只能序列化对象的可枚举的自有属性。如果obj中的对象是有构造函数生成的，则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的构造函数constructor，即无法继续使用构造函数原型上的属性。
// 6.如果对象中存在循环引用的情况也无法正确实现深拷贝。
JSON.parse(JSON.stringify(obj));
// 2
function deepClone (obj = {}) {
  if (typeof obj !== 'object' || obj == null) {
    return obj;
  }
  let result;
  if (obj instanceof Array) {
    result = [];
  } else {
    result = {};
  }
  for (let key in obj) {
    // 只拷贝对象自身的属性，排除继承了父类原型上的属性
    if (obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[key]);
    }
  }
  return result;
}
```

##### 实现 event bus

##### 实现 instanceof

##### 模拟 new

##### 模拟 Object.create

##### 实现类的继承

##### 原型和原型链

原型：

* 每个 class 都有显示原型 prototype

* 每个实例都有隐式原型 \_\_proto\_\_

* 实例的隐式原型 \_\_proto\_\_ 指向对应 class 的显示原型 prototype

* prototype 中有一个 constructor 属性，用来引用它的构造函数，Person.prototype.constructor === Person，这是一种循环引用。

原型链：

我们把由 \_\_proto\_\_ 串起来的直到 Object.prototype.\_\_proto\_\_ 为 null 的链叫做原型链。

对象在获取属性或方法的时候，先在自身的属性和方法中寻找，如果找不到则顺着隐式原型 \_\_proto\_\_ 指向的原型链一直向上查找。

原型链关系：

```js
var zjh = new Person()
zjh.__proto__ === Person.prototype 
Person.prototype.__proto__ === Object.prototype 
Object.prototype.__proto__ === null 
        
Object.__proto__ === Function.prototype 
Function.__proto__ === Function.prototype 
Function.prototype.__proto__ === Object.prototype 
Object.prototype.__proto__ === null // 原型链顶端
```

instanceof：

instanceof 是判断一个对象是由哪个 class 构建出来的，由于父类也参与了构建实例的一部分，所以 instanceof 父类得到的也是 true，instanceof 也是顺着原型链往上找的。Object 是所有类的父类，所有对象都是继承自 Object，它是原型链的末端。

```js
[] instanceof Array // true
[] instanceof Object // true
{} instanceof Object // true

xialuo instanceof Student // true
xialuo instanceof People // true
xialuo instanceof Object // true
```

##### 继承

对象冒充继承：

this 是函数调用的时候才确定的，用要继承的对象来调用函数，这个对象就变成了函数的 this，也就继承了函数 this 上的属性和方法。

对象冒充内部实现原理

哪个函数要被继承，就调用哪个函数。用继承的对象调用。

```js
function ClassA(sColor) {
  this.color = sColor
  this.sayColor = function () {
    alert(this.color)
  }
}
function ClassB(sColor) {
  this.newMethod = ClassA
  this.newMethod(sColor)
  delete this.newMethod 
  // 以上三步就是call和apply内部实现的核心步骤
}
```

call,apply,bind

call 和 apply 关注的就是 this 和传参两件事。

call 和 apply 可以用来重新定义函数的 this 指向，就是将传进去的对象替换掉函数的 this，使对象拥有这个函数内部用 this 定义的属性和方法，从而达到继承的目的。

```js
function ClassA () {
	this.a = 123
}
var obj = {}
console.log(obj.a) // undefined
classA.call(obj)
console.log(obj.a) // 123
```

call 和 apply 可以实现多重继承，一个子类能够继承多个父类，F1 可以同时从 F2, F3 ... 继承。

call 和 apply 改变了函数的 this，并且执行了该函数，而 bind 是改变了函数的 this，但并不会立即执行函数，而是返回一个绑定了 this 的新函数。

bind 的作用与 call 和 apply 一样，都是可以改变函数运行时上下文，区别是 call 和 apply 在调用函数之后会立即执行，而 bind 方法调用并改变函数运行时上下文后，返回一个新的函数，供我们需要时再调用。

原型链继承：

对象继承类

```js
o.__proto__ = F.prototype  
```

类继承类

```js
F1.prototype.__proto__ = F2.prototype
```

混合方式继承：

对象冒充可以传参数和继承构造函数内部属性，但是不能继承到原型，原型链可以继承原型，但是不能传参数也不能继承构造函数内部，所以要使用混合模式。

```js
// ClassA
function ClassA(sColor) {
  this.color = sColor
}
ClassA.prototype.sayColor = function() {
  alert(this.color)
}
// ClassB继承ClassA
function ClassB(sColor, sName) {
  ClassA.call(this, sColor)
  this.name = sName
}
ClassB.prototype.__proto__ = ClassA.prototype

//new和es6的extends实现的继承就是上面的这两个方式的结合。
```

class 继承：

class 是面向对象的一个语法实现。class 本质上类似于一个模版，我们可以通过这个模版去构建一些东西。构建的时候，我们可以去复制上一些属性和方法。

当我们有很多个 class，这个 class 中有一些比较通用的属性的时候，我们就可以把它抽离出来。通过 extends 这个关键字来做继承。里面通过 super 来执行父类的构造函数，然后扩展和重写它的一些方法。

```js
// es6 类继承
class People {}
class Student extends People {}
// Student继承于People，所以Student的原型的隐式原型正好指向People的显示原型。
console.log(Student.prototype.__proto__ === People.prototype) // true

console.log(People.prototype.__proto__ === Object.prototype) // true
console.log(Object.prototype.__proto__ === null) // true 原型链顶端
```

new 继承：

构造函数创建实例的过程本身就是一种继承，new 的内部其实是做了继承里面的合体工作

```js
ClassB.prototype = new ClassA()
```

new 操作符的作用：new Fn(arguments) 的时候 js 内部就会调用下面这个 New 函数

```js
function New (Fn, arguments) {
  var o = {}									 // 创建一个新对象
  o.__proto__ = Fn.prototype	 // 继承构造函数的原型
  Fn.apply(o, arguments)		   // 继承构造函数内部，并传参     
  return o                     // 如果构造器返回的是对象，则返回，否则返回第一步创建的对象。
}   
```

##### 实现 JSON.parse

##### 解析 URL Params 为对象

获取当前页面 url 参数

```js
// 1.传统方式，查找location.search
function query (name) {
  const search = location.search.substring(1)
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
  const res = search.match(reg)
  if (res == null) {
    return null
  }
  return res[2]
}
// 2.新api，URLSearchParams
function query (name) {
  const search = location.search
  const p = new URLSearchParams(search)
  return p.get(name)
}
```

##### 模版引擎实现

##### 转化为驼峰命名

##### 查找字符串中出现最多的字符和个数

##### 字符串查找

##### 实现千位分隔符

##### trim

```js
String.prototype.trim = function () {
  return this.replace(/(^\s*)|(\s*$)/g, "");
}
```

## 浏览器

##### 前端存储方式

cookie：大小只有4k，设置后自动加入请求头浪费流量，每个 domain 限制 20 个。api 怪异，使用需要自行封装。

localStorage：大小 5M，操作方便，永久性存储。

sessionStorage：只存在于当前页面，不能在窗口之间共享，页面关闭后就会被清理。

Web SQL：关系型数据库。2010 年被废弃。

IndexedDB：NoSQL 非关系型数据库，用键值对进行存储，读取速度快，javascript 操作方便。

##### DOM 事件

事件流：事件捕获阶段 -》处于目标阶段 -〉事件冒泡阶段

##### 事件

事件来自输入设备，输入设备有三种：

* 键盘
* 鼠标
* 触摸屏

###### 捕获与冒泡

捕获过程是从外向内，冒泡过程是从内向外。

在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。

建议这样使用冒泡和捕获机制：默认使用冒泡模式，当开发组件时，遇到需要父元素控制子元素的行为，可以使用捕获机制。

addEventListener 三个参数：

* 事件名称
* 事件处理函数
* 捕获还是冒泡

事件处理函数不一定是函数，也可以是个 JavaScript 具有 handleEvent 方法的对象：

```js
var o = {
  handleEvent: event => console.log(event)
}
document.body.addEventListener("keydown", o, false);
```

第三个参数不一定是 bool 值，也可以是个对象，它提供了更多选项。

* once：只执行一次。
* passive：承诺此事件监听不会调用 preventDefault，这有助于性能。
* useCapture：是否捕获（否则冒泡）。

###### 事件代理

事件代理是基于事件冒泡做的，在事件冒泡这个机制的基础上去实现事件代理，代理就是因为数量太多或结果比较复杂，不好去挨个都去绑定事件，所以把事件绑到某一个父元素上，在事件里判断是不是我们想要触发事件的那个元素，再去做一些其他的操作。

###### 焦点

浏览器 API 提供了 API 来操作焦点：

其实原本键盘事件不需要捕获过程，但是为了跟 pointer 设备保持一致，也规定了从外向内传播的捕获过程。

```js
document.body.focus()
document.body.blur()
```

###### 事件应用

通用事件监听函数

```js
// 定义
function bindEvent (elem, type, fn) {
  elem.addEventListener(type, fn)
}
// 使用
const btn1 = document.getElementById('btn1')
bindEvent(btn1, 'click', event => {
  console.log(event.target) // 触发事件的目标元素，就是这个btn1这个dom对象
  event.preventDefault() // 阻止浏览器默认行为
  event.stopPropagation() // 阻止事件冒泡
  console.log('clicked')
})
```

适用普通的绑定和事件代理的绑定。

```js
// 定义
function bindEvent (elem, type, selector, fn) {
  if (fn == null) {
    fn = selector
    selector = null
  }
  elem.addEventListener(type, event => {
    const target = event.target
    if (selector) {
      // 代理绑定
      if (target.matched(selector)) {
        fn.call(target, event)
      }
    } else {
      // 普通绑定
      fn.call(target, event)
    }
  })
}

// 使用
const btn1 = document.getElementById('btn1')
const div3 = document.getElementById('div3')
bindEvent(btn1, 'click', function (event) {
  event.preventDefault()
  alert(this.innerHTML)
})
bindEvent(div3, 'click', 'a', function (event) {
  event.preventDefault()
  alert(this.innerHTML)
})
```

##### 输入地址按下回车的整个流程

## http

##### http 格式

常见状态码

常用消息头

##### http 缓存

##### TCP

tcp/udp

三次握手

四次挥手

##### 网络四层分层模型

* 物理层

* 网络层

* 传输层

  TCP/UDP

* 应用层

  TELNET/SSH/HTTP/SMTP/POP/SSL/TLS/FTP/MIME/HTML

##### cdn

## Vue

##### 对 mvvm 的理解

MVVM 框架三要素：

* 数据响应式：数据变化视图更新。
* 模版引擎：提供描述视图的模版语法。
* 渲染：把模版生成真正的 html。

##### v-model 实现原理

##### vue是如何实现双向绑定的

##### 自定义指令

##### 对 vue 生命周期的理解

一个 vue 实例从开始创建到被销毁有一个完整的生命周期，这个过程包括开始创建、初始化数据、模版编译、挂载 DOM -》渲染、更新 -〉渲染、卸载等一系列过程。

* var vm = new Vue({}) 开始创建一个 Vue 的实例对象

##### vue 组件间通信

##### vue 响应式系统

##### vue diff 算法

必要性：lifecycle.js - mountComponent()，组件中可能存在多个 key 的变化，一个组件又只有一个 Watcher ，所以需要知道具体哪里发生了变化，这时就必须要用 diff 算法去比对具体哪里变化。

执行方式：patch.js - patchVnode()，patchVnode 是 diff 发生起始的地方，整体策略：深度优先，同层比较 updateChildren() 递归操作。

diff 算法是虚拟 DOM 技术的必然产物：通过新旧虚拟 DOM 的对比（即diff），将变化的地方更新在真实 DOM 上。diff 高效的对比过程也降低了时间复杂度，提高性能。

Vue 中 diff 执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果 oldVnode 和新的渲染结果 newVnode，此过程称为 patch。

##### vue 模版编译

字符串模版 => 抽象语法树(AST) => 生成 JS 函数。

模板编译的主要目标是将模板 template 转换为渲染函数 render。这个过程是一个字符串模版被转换成 JS 函数。

入口文件 entry-runtime-with-compiler.js 中，如果存在 template 或 el 选项就会执行编译，会执行 compileToFunctions 方法，把模版传进去。通过方法名就可以知道，它可以把字符串模版变成一个函数，它会返回 render 函数。

编译分为三步：解析、优化和生成，src/compiler/index.js。

- 解析 - parse：解析器把模版转换为 AST 对象，抽象语法树，它是对我们将来我们要生成的代码的 JS 对象的描述，将来遍历这棵树，把代码生成。这是底层代码生成器的必要知识。用对象的形式来描述 JS 代码，先把字符串变成对象，这个对象是有格式规定的，能描述将来要生成的代码。解析器内部分了HTML解析器、文本解析器和过滤器解析器。
- 优化 - optimize：在 AST 中标记静态子树，静态子树是界面中永远不变的节点，如两层嵌套以上的纯文本节点。
  - 每次重新渲染，不需要为静态子树创建新节点。
  - 虚拟 DOM 中 patch 时，可以跳过静态子树。
- 代码生成 - generate：把 AST 转换成代码字符串，比如一个字符串形式的函数，然后用 new Function(code) 把字符串函数的代码作为参数传进去就可以得到一个真正的 render 函数。

processIf 用于解析 v-if，genIf 用于生成条件语句相关代码。

processFor 用于解析 v-for 指令，genFor 用于生成相应代码。

v-if，v-for 这些指令只能在编译器阶段处理，如果我们要在 render 函数处理条件或循环只能使用 if 和 for，然后生成VNode。

##### vue 批量异步更新策略

侦听到数据变化，不会把对应的 Watcher 直接更新，而是开启一个队列，存放所有需要变化的组件 Watcher，启动一个微任务 Promise.resolve().then()，在面里遍历队列，一次性的执行所有 Watcher 的更新函数，更新函数把所有的 DOM 更新全部做完之后，浏览器统一的刷新一次，就达到了我们期待的高效方式。

如果一个 key 同时被多次修改，导致 Watcher 被多次触发，只会被推入到队列中一次，避免不必要的计算和 DOM 操作。

异步策略的选择会有优先级，根据当前执行环境的支持情况，会分别使用 Promise.then、MutationObserver、setImmediate、setTimeout，如果使用宏任务做的话，用户体验就不好了，因为它只能到下一个循环才能看到结果了。

## VUE

### CSS

##### Scoped CSS

html 上该组件下的所有元素和子组件的根元素上都会添加上一个 date-v-xxx 的自定义属性，CSS 选择器也会加上这个属性去选择。

所以想要控制 scoped 的子组件的样式，父级也要加上 scoped，只能控制子组件跟元素，不能穿透子组件去控制子组件里面的样式。

深度作用选择器：使用 >>> 操作符，必须配合 scoped 的 style 使用才能生效。

预处理器无法正确解析 >>> ，可以使用 /deep/ 或 ::v-deep 操作符取而代之。

原理：

```vue
<!-- 父组件 -->
<div class="father">
  <h1>父组件</h1>
  <son />
</div>
<style lang="scss" scoped>
h1 {
  color: skyblue;
}
.father {
  /deep/ h2 {
    color: bisque;
  }
}
</style>
<!-- 子组件 -->
<template>
  <div class="son">
    <h2>子组件</h2>
  </div>
</template>
<style scoped lang="scss">
h2 {
  color: red;
}
</style>

<!-- 最终生成的代码 -->
<div data-v-fae5bece class="father">
	<h1 data-v-fae5bece>父组件</h1>
	<div data-v-469af010 data-v-fae5bece class="son">
		<h2 data-v-469af010> 子组件</h2>
  </div>
</div>
<style>
h1[data-v-fae5bece] { // scope 原理
  color: skyblue;
}
.father[data-v-fae5bece] h2 { // 穿透原理
  color: bisque; 
}
h2[data-v-469af010] {
  color: red; // 没生效
}
</style>
```

##### CSS Module

css-loader 的 modules 设置为 true 就会将我们写的 class 改掉，然后当你引入 css 文件模块的时候，它会给你返回一个 class 的列表，这个列表就是原来的 class 跟编译之后的 class 名字的对应关系。

```js
import styles from "./style.css";
// import { className } from "./style.css";

element.innerHTML = '<div class="' + styles.className + '">';
```

选择器不能在模版中直接使用，而会把所有的选择器放到计算属性 $style 里，然后通过 $style.xx 去访问选择器。选择器会被动态的转换成很有特点的名字，来和其他的组件做区分。

生成的选择器：文件名\_选择器本身名字\_hash。它不会影响元素本身，只会影响你最终类名的生成。

选择器权重相同的情况下，父组件的样式会覆盖子组件的样式。

```vue
<template>
	<div>
    <a :class="$style.red">awesome-vue</a>
    <a :class="{[$style.red]:isRed}">awesome-vue</a>
    <a :class="[$style.red, $style.bold]">awesome-vue</a>
  </div>
</template>
<style lang="scss" module>
  .red {  
    color: #f00;
  }
  .bold {
    font-weight: bold;
  }
</style>
<script>
  export default {
    created () {
      // $style 是计算属性，所以在 JS 里也可以访问，从而做一些你想做的逻辑操作：
      console.log(this.$style.red)
    }
  }
</script>
```

### 过度 & 动画

在插入、更新或者移除 DOM 时，使用 transition 组件做过渡或动画。

过渡和动画的过程都是设置在 active 上的。v-enter/v-leave/v-enter-to/v-leave-to 都是设置初始或结束状态的，可以没有。

css 方式是通过过渡类名，js 方式是通过钩子函数。

在下列情形中，可以给任何元素和组件添加进入/离开过渡

- 条件渲染 (使用 `v-if`)
- 条件展示 (使用 `v-show`)
- 动态组件
- 组件根节点

##### transition 组件基础使用

transition 组件会为嵌套元素自动添加跟动画相关的类名称，使用这些类名称来做 css 过度动画就可以了。

1. 过渡被触发时，马上加 v-enter/v-leave 和 v-enter-active/v-leave-active。
2. 下一帧马上移除 v-enter/v-leave，然后添加 v-enter-to/v-leave-to。
3. 动画结束后移除 v-enter-active/v-leave-active 和 v-enter-to/v-leave-to。

```vue
<template>
	<transition name="fade"> 
    <div></div>
  </transition> 
</template>

<style> 
  .fade-enter-active, .fade-leave-active { 
    transition: opacity .5s;
  }
  .fade-enter, .fade-leave-to { 
    opacity: 0;
  } 
  .fade-enter-to, .fade-leave { 
    opacity: 1;
  }
</style>
```

##### 结合 CSS 动画库

通过自定义过度类名，使用第三方定义好的动画。

自定义过度类名：

- enter-class
- enter-active-class
- enter-to-class (2.1.8+)
- leave-class
- leave-active-class
- leave-to-class (2.1.8+)

```html
<link href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1" rel="stylesheet" type="text/css">
```

```vue
<transition enter-active-class="animated bounceIn" leave-active-class="animated bounceOut">
	<div></div>
</transition>
```

##### JavaScript 钩子

```vue
<transition
  v-on:before-enter="beforeEnter" // 动画开始前，设置初始状态
  v-on:enter="enter" // 执行动画
  v-on:after-enter="afterEnter" // 动画结束，清理工作
  v-on:enter-cancelled="enterCancelled" // 取消动画
  v-on:before-leave="beforeLeave"
  v-on:leave="leave"
  v-on:after-leave="afterLeave"
  v-on:leave-cancelled="leaveCancelled"
></transition>
```

保留 CSS 中过度动画的部分，加上 JS 钩子做动画起始状态：

```html
<style>
  .fade-enter-active, .fade-leave-active { 
    transition: opacity .5s; 
  }
</style>

<template>
	<transition 
		@before-enter="beforeEnter" 
		@enter="enter"
		@before-leave="beforeLeave" 
		@leave="leave">
  	<div></div>
  </transition>
</template>

<script>
export default {
	methods: {
    beforeEnter(el) {
    	el.style.opacity = 0; // 设置初始状态
    },
    enter(el, done) {
      document.body.offsetHeight; // 触发回流激活动画
      el.style.opacity = 1; // 设置结束状态
      el.addEventListener('transitionend', done); // 监听动画结束事件，并执行done函数
    },
    beforeLeave(el) {
    	el.style.opacity = 1; // 设置初始状态
    },
    leave(el, done) {
      document.body.offsetHeight; // 触发回流激活动画
      el.style.opacity = 0; // 设置结束状态
      el.addEventListener('transitionend', done); // 监听动画结束事件，并执行done函数
    }
  },
}
</script>
```

纯js方案：

```html
<template>
	<transition name="fade"
		:css="false" // 禁用css
    @before-enter="beforeEnter"
    @enter="enter"
    @before-leave="beforeLeave"
    @leave="leave"></transition>
</template>

<script>
import "https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js";
export default {
	methods: {
    beforeEnter(el) {
      el.style.opacity = 0;
    },
    enter(el, done) {
      Velocity(el, { opacity: 1 }, { duration: 500, complete: done });
    },
    beforeLeave(el) {
      el.style.opacity = 1;
    },
    leave(el, done) {
      Velocity(el, { opacity: 0 }, { duration: 500, complete: done });
    }
  },
}
</script>
```

### VueRouter

##### 编程式导航

\<router-link> 实现的功能和编程式导航是相同的。router.push 等效于 \<router-link :to="..."> ，router.replace 等效于 \<router-link :to="..." replace> 。

router.replace 用法跟  router.push 一样，但是会替换掉当前的 history 记录。

query 设置了 url 上就会有，params 需要在路由配置的时候做动态路由匹配 url 上才会有。

```js
// router.push(location, onComplete?, onAbort?)
// 参数是字符串路径或一个描述地址的对象。
// 字符串
router.push('user') // 字符串路径
router.push('/user') // 字符串路径
router.push(`/user/${userId}`) // 带params参数的字符串路径
router.push(`/user?userId=${userId}`) // 带query参数的字符串路径
// 对象 path
router.push({ path: 'user' })
router.push({ path: '/user' })
router.push({ path: `/user/${userId}` })
router.push({ path: `/user?userId=${userId}` })
router.push({ path: '/user', params: { userId: '123' }}) // 失效，页面拿不到params的信息
router.push({ path: '/user', query: { userId: '123' }})
// 对象 name
router.push({ name: 'user' })
router.push({ name: 'user', params: { userId: '123' }})
router.push({ name: 'user', query: { userId: '123' }})

// router.resolve()
// 跳转新页面
const routeUrl = this.$router.resolve(url)
window.open(routeUrl.href, '_blank')

// router.go(n)
// 参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 `window.history.go(n)`。
```

##### 导航守卫

全局守卫

```js
const router = new VueRouter({ 
  routes: [ 
    {
      path: '/about',
      name: 'about',
      component: () => import(/* webpackChunkName: "about" */'../views/About.vue'),
      children: [
        {
          path: '/about/course/:name', // 基于父路由的相对路径
          name: 'detail',
          component: () => import('../views/Detail.vue')
  			}
      ],
			meta: {
        auth: true                  
      }
    }
  ] 
})

// 在每一次路由跳转的时候，这3个钩子都会被触发
router.beforeEach((to, from, next) => {
  // to: Route: 即将要进入的目标 路由对象，我要去哪的路由
  // from: Route: 当前导航正要离开的路由，我来自于哪的路由
  // next: Function: 一定要调用该方法来 resolve 这个钩子。我应不应该放行的next函数。
  
  // 判断要去的路由是否需要守卫，因为不是所有路由都需要守卫的。
  // 这里有一些比较常见的手法，比如利用meta数据的方式。
  if (to.meta.auth) {
		// 判断用户是否登录
    // 在一个全局公共的地方去保存这个登录状态
    if (window.isLogin) {
      // 登录了放行
    	next() 
    } else {
      // 没登录跳到登录页面，并把原本要去的也买呢传递过去，使其登录后可以直接跳到原本想去的页面
      next('/login?redirect=' + to.fullPath)
    }
  } else {
    // 不需要守卫的路由，它可以直接访问。
    next()
  }
})
router.beforeResolve((to, from, next) => {
  console.log('before resolve invoked')
  next()
})
// 每次导航跳转之后会触发，所以就不需要next了
router.afterEach((to, from) => {
  console.log('after each invoked')
})
```

路由独享的守卫

```js
const router = new VueRouter({ 
  routes: [
    {
      path: '/about',
      name: 'about',
      component: () => import(/* webpackChunkName: "about" */'../views/About.vue'),
      children: [
        {
          path: '/about/course/:name', // 基于父路由的相对路径
          name: 'detail',
          component: () => import('../views/Detail.vue')
  			}
      ],
     	// 这个钩子只有在我们进入这个路由之前，才会被调用
			beforeEnter(to, from, next) {
        if (window.isLogin) {
          next()
        } else {
          next('/login?redirect=' + to.fullPath)
        }
      }
    }
  ] 
})
```

组件内守卫

```vue
<script>
export default {
  beforeRouteEnter(to, from, next) {
    if (window.isLogin) {
      next();
    } else {
      next("/login?redirect=" + to.fullPath);
    }
    // 这里获取不到组件实例this，因为进入组件路由之前组件实例还没有创建，想要使用组件实例，需要在next的回调中获取。
    // next(vm => {
    //   console.log(vm.id)
    // })
  },
  
  // 不同的路由下使用同一个组件时触发，例如params变化时，可以在这个时候重新获取数据，避免了使用watch来观察params中的id变化。因为使用的是同一个组件所以mounted只会触发一次，所以数据的获取不能在mounted里做，只能使用beforeRouteUpdate这个路由钩子或者使用watch来获取数据
  beforeRouteUpdate (to, from, next) {
    console.log('todo update enter')
    next()
  },
  
  // 路由离开的时候，这时可以做提醒用户是否要离开的操作，用来控制页面离开的行为
  beforeRouteLeave (to, from, next) {
    console.log('todo leave enter')
    if (global.confirm('are you sure?')) {
      next()
    }	
  }
}
</script>
```

### VueRouter 原理

##### 核心使用步骤

步骤一：注册，应用 VueRouter 插件

```js
import Router from 'vue-router' 
Vue.use(Router)
```

步骤二：创建 VueRouter 实例

```js
export default new Router({...})
```

步骤三：在根组件上添加该实例

挂载这个实例是为了在所有组件都可以使用 $router，可以访问到路由的实例，全局使用是需要把它注册到 prototype 上去的：Vue.prototype.$router = router。我在这只是注册了一个 router，它怎么将它挂到 prototype 上去的呢，所以 router 插件里面要做的一件事就是拿出当前的选项，然后挂载到 Vue.prototype.$router上。

```js
import router from './router' 
new Vue({ 
  router 
}).$mount("#app");
```

步骤四：添加路由视图 router-view

路由出口，它起到容器或坑位的作用，将来所有的内容就会在这里面做刷新和替换，它到底是怎么替换的？

router-link 和 router-view 这两个组件为什么可以直接用。说明 router 插件里面会有这两个组件的声明和注册。

```vue
<router-view></router-view>
```

步骤五：导航 router-link

```vue
<router-link to="/">Home</router-link> 
```

##### 需求设计思路

通过使用的分析，大概就能知道做 vue-router 插件有哪些任务了。

需求是当浏览器 url 的地址发生变化的时候我们能够知道，并且页面不刷新，同时还能切换页面内容。

浏览器里有两种解决方案：

hash：添加 hash 浏览器不会刷新，而且会收到 hashchange 这个事件，这样我们就知道 hash 发生变化了。

h5 的 history API：h5 的 history API 有一个 pushState/replaceState 事件，利用的真实的 url 变化，操作 history 历史记录的堆栈，利用这些事件，url 是会发生变化的，但是浏览器的行为是依然不跳转。

##### 源码实现

具体任务：

根据地址的变化，从路由表中获取到最新的 component，把它渲染到 router-view 里，就是让 router-view 重新渲染。

* 实现一个插件，vue-router 是一个插件：实现 VueRouter 类和 install 方法 
* 实现两个全局组件：router-view 用于显示匹配组件内容，router-link 用于跳转 
* 监控 url 变化：监听 hashchange 或 popstate 事件 
* 响应最新 url：创建一个响应式的属性 current，当它改变时获取对应组件并显示

krouter/kvue-router.js 

```js
import Link from './krouter-link'
import View from './krouter-view'

let Vue;

class KVueRouter {
  constructor(options) {
    this.$options = options
    // 需要创建响应式的current属性
    // 利用Vue提供的defineReactive做响应化
    // 变成响应式的好处是，在任何组件的template或render函数中用到current就会把它收集起来，将来只要我变了，就			 会通知用到的组件做更新，就是重新render
    Vue.util.defineReactive(this, 'current', '/')
    // 还可以使用这种方式实现current的响应式
    // this.app = new Vue({
    //   data() {
    //     return {
    //       current: '/'
    //     }
    //   }
    // })
 
    // 监控url变化
    window.addEventListener('hashchange', this.onHashChange.bind(this))
    window.addEventListener('load', this.onHashChange.bind(this))

    // 创建一个路由映射表
    this.routeMap = {}
    options.routes.forEach(route => {
      this.routeMap[route.path] = route
    })
  }
  onHashChange() {
    this.current = window.location.hash.slice(1)
  }
}

// 1.实现一个插件
// 一个插件只是个普通对象，并实现 install 方法。
KVueRouter.install = function (_Vue) {
  // 保存构造函数，在KVueRouter里面使用
  Vue = _Vue;
  // 任务1：挂载$router
  // 怎么获取根实例中的router选项
  // 我只要混入一个生命周期的钩子或者是任何一个方法，我在钩子或方法里面就可以拿到组件的实例了。
  // 加上一个全局的混入，这里写的生命周期的钩子将来会在所有的组件中都执行一遍。
  // 为什么要用混入方式写？主要原因是use代码在前，Router实例创建在后，install中还不能直接拿到创建好的router实例，所以要用mixin的方式在Vue实例创建的时候在钩子函数中将router放到Vue.prototype上。
  Vue.mixin({
    beforeCreate() {
      // 确保根实例的时候才执行
      if (this.$options.router) {
        Vue.prototype.$router = this.$options.router
      }
    }
  })

  // 任务2：注册两个全局组件router-link和router-view
  // 这里不能使用template的方式去描述标签的原因是我们使用的是纯运行时的Vue版本，因为是webpack环境，最终的编译版本中是不存在编译器的，所以没有办法编译template。
  // 所以这里要用到render函数，纯运行时环境只能用render函数来描述你的组件。
  Vue.component('router-link', Link) 
  Vue.component('router-view', View)
}

export default KVueRouter
```

krouter/router-link.js 

```js
export default {
  props: {
    to: {
      type: String,
      required: true
    },
  },
  render(h) {
    // <a href="#/about">abc</a>
    // <router-link to="/about">xxx</router-link>
    // h(tag, data, children)
    console.log(this.$slots);
    return h('a', { attrs: { href: '#' + this.to } }, this.$slots.default)
    // jsx
    // return <a href={'#' + this.to}>{this.$slots.default}</a>
  }
}
```

krouter/router-view.js

```js
export default {  render(h) {    // 获取path对应的component    const {routeMap, current} = this.$router    const component = routeMap[current].component || null    return h(component)  }}
```

### Vuex

##### 模块

user.js

```js
export default {  namespaced: true, // 设置独立的命名空间，避免命名冲突，副作用是访问的时候稍微麻烦一点   state: {    isLogin: false  },  mutations: {    login(state) {      state.isLogin = true    }  },  actions: {    login({commit}, username) {      return new Promise((resolve, reject) => {        setTimeout(() => {          if (username === 'admin') {            commit('login');            resolve();          } else {            reject();          }        }, 1000);      })    }  }}
```

```js
import user from './user'

export default new Vuex.Store({
  modules: {
    user
  }
})
```

访问和调用

```vue
<template>
	<button @click="login" v-if="!$store.state.user.isLogin">登录</button>
</template>

<script>
export default {
  methods: {
		login() {
			// this.$store.commit('user/login')
      this.$store.dispatch('user/login', 'admin').then(() => {
       
      }).catch(() => {})
    }
  }
}
</script>
```

模块之间的调用：

```js
// 1. 在actions中使用
commit('a/getList', {}, { root: ture })
dispatch('a/getList', {}, { root: ture })
// 可以从actions接收的store对象中解构出rootState和rootGetters，使用这两个对象就可以获取其他模块的state和getters
actions: {
  a({ rootState, rootGetters}, params) {
    console.log(rootState.a.data)
    console.log(rootGetters['a/getterData'])
	}
}
// 2.在任何地方使用，直接把相应模块文件引入
```

##### 映射方法

mapState 返回的是一个对象键值对的形式，键是 isLogin，值是将来要生成的 function，这个 function 返回的值就是 Store 中 isLogin 的值，正好对应 computed 的形式。

```vue
<template>
	<button v-if="!isLogin" @click="login">登录</button>
</template>

<script>
import { 
  mapState,
  mapMutations,
  mapActions
} from 'vuex'

export default {
  computed: {
    // ...mapState('user/isLogin') // 映射出来的名字是 user/isLogin
    ...mapState('user', ['isLogin']) // 映射出来的名字是 isLogin
  },
  methods: {
    // ...mapMutations('user', ['login'])
    // ...mapActions('user', ['login']),
    ...mapMutations(['user/login']),
    ...mapActions(['user/login']),
    login() {
      // this['login']();
      this['user/login']();
    }
  }
}
</script>
```

##### 给 vuex 加上热更替的功能

store.js

```js
if (module.hot) {
  module.hot.accept([
    // 这个数组里面的列表对应的就是我们去引用的那几个文件它的地址
    './state/state',
    './mutations/mutations',
    './getters/getters',
    './actions/actions'
  ], () => {
    const newState = require('./state/state').default
    const newMutations = require('./mutations/mutations').default
    const newGetters = require('./getters/getters').default
    const newActions = require('./actions/actions').default
    store.hotUpdate({
      state: newState,
      mutations: newMutations,
      getters: newGetters,
      actions: newActions
    })
  })
}
```

### Vuex 原理

##### 需求设计思路

有一个视图 view，有一个 Vuex 的 Store 实例，Store 里有一个 state 属性，在 view 里使用 $store.state.xx 来访问 Store 里的数据。我们现在要实现一个 view 和 Store 之间的单向数据流，我想改 state，必须通过 Store 提供的 commit 方法提交一个 mutation 去改，所以 Store 里面还要实现一个 commit 方法，根据 type 参数可以从用户配置的那些 mutations 里找到对应的修改方法，然后用这个方法对 state 做修改，让这个 state 是一个响应式的数据，state 状态的变化就能够通知界面去重新的 render，我们利用 Vue 来做 state 的数据响应式。所以 Vuex 是跟 Vue 强耦合的，只能用在 Vue 里面。

要实现一个 Store 类，里面有一个 state 属性，还有两个方法，commit 和 dispath。commit 可以直接改 state，dispatch是给它传个上下文，让它通过调 commit 的方式来改 state。这是写 store 的思路。还有一个数据响应式的问题，是通过 new Vue({data: options.state}) 的方式将 state 变成响应式数据的，这样 state 发生变化，使用 state 数据的组件就会重新 render。

##### 源码实现

kstore/kvuex.js

```js
// 保存构造函数引用，避免import
let Vue;

class Store {
  constructor(options) {
    // this.$options = options;
    // 保存mutations、actions、getters选项
    this._mutations = options.mutations;
    this._actions = options.actions;
    this._getters = options.getters;
    
    // 定义computed选项
    const computed = {}
    // 给用户暴露一个getters
    this.getters = {}
    
    const store = this
    
    Object.keys(this._getters).forEach(key => {
      // 获取用户定义的getters
      const fn = store._getters[key]
      // 转换为computed使用的无参数的形式，做一个高阶封装
      computed[key] = function() {
        return fn(store.state)
      }
      // 将getters设置为只读属性
      Object.defineProperty(store.getters, key, {
				get() {
          return store._vm[key]
        }
      })
    })

    // 响应化处理state 
    // this.state = new Vue({
    //   data: options.state
    // })
    
    this._vm = new Vue({
      data: {
        // 加两个$，Vue不做代理
        $$state: options.state
      },
      // 把getters当成一个计算属性去实现就可以了。注意computed的函数是无参数的。
      computed: {
      	a: function() {
          return this.state.a + this.state.b
        }
      }
      
    })
		
    // 绑定commit、dispatch的上下文为store实例
    // 绑定commit上下文否则action中调用commit时可能出问题!!
    // 同时也把action绑了，因为action可以互调
    this.commit = this.commit.bind(this)
    this.dispatch = this.dispatch.bind(this)
  }

  // 保护state，防止用户直接修改state，利用存取器
  // 存取器， store.state
  get state() {
    console.log(this._vm);
    
    return this._vm._data.$$state
  }

  set state(v) {
    console.error('你造吗？你这样不好！');
  }

  // 根据用户传入type执行对应mutation
  // store.commit('add', 1)
  // type: mutation的类型
  // payload：载荷，是参数
  commit(type, payload) {
    const entry = this._mutations[type]
    if (entry) {
      // 传递state给mutation
      entry(this.state, payload)
    }
  }

  // 根据用户传入type执行对应action，同时传递上下文 
  dispatch(type, payload) {
    const entry = this._actions[type]
    if (entry) {
      entry(this, payload)
    }
  }

}

function install(_Vue) {
  Vue = _Vue;

  Vue.mixin({
    beforeCreate() {
      if (this.$options.store) {
        Vue.prototype.$store = this.$options.store
      }
    }
  })

}

// Vuex
export default {
  Store,
  install
}
```

## VUE组件化

先想好数据结构，然后根据数据结构渲染组件。

### 组件间通信

##### props

###### 父给子传值

props 用于接收父组件传递过来的数据。

```js
// parent
<HelloWorld msg="Welcome to Your Vue.js App"/>
  
// child
props: { msg: String }
```

###### 写法

```js
// 1.字符串数组形式
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
// 2.对象形式
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
// 3.带有验证需求的对象
props: {
  // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
  propA: Number,
  // 多个可能的类型
  propB: [String, Number],
  // 必填的字符串
  propC: {
   	type: String,
    required: true
	},
  // 带有默认值的数字
  propD: {
    type: Number,
    default: 100
  },
  // 带有默认值的对象
  propE: {
    type: Object,
    // 对象或数组默认值必须从一个工厂函数获取
    default: function () {
      return { message: 'hello' }
    }
  },
  // 自定义验证函数
  propF: {
    validator: function (value) {
      // 这个值必须匹配下列字符串中的一个
      return ['success', 'warning', 'danger'].indexOf(value) !== -1
    }
  }
}
```

###### 传入一个对象的所有 property

如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 `v-bind` (取代 `v-bind:prop-name`)

```js
post: {
  id: 1,
  title: 'My Journey with Vue'
}
```

```vue
<blog-post v-bind="post"></blog-post>
```

等价于：

```vue
<blog-post
  v-bind:id="post.id"
  v-bind:title="post.title"
></blog-post>
```

###### 单向数据流

你不应该在一个子组件内部改变 prop。

有两种常见的试图变更一个 prop 的情形：

1.希望将 prop 作为一个本地的数据来使用，在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值。

```js
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}
```

2.这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：

```js
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```

注意：对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。如果不想影响父组件的状态要用 watch 监听该 prop，监听中对这个数据进行深拷然后赋值给子组件的 data 数据。

###### 非 Prop 的 Attribute

没有相应 prop 接收的属性。 它们会被添加到这个组件的根元素上。

inheritAttrs: false 可以禁止这些非 prop 的属性被添加到根元素。它不会影响 style 和 class 的绑定。

所有的非 prop 属性和值会以对象键值对的形式被收纳到子组件实例的 $attrs 里头( class 和 style 除外)。

有了 inheritAttrs: false 和 $attrs，你就可以手动决定这些 attribute 会被赋予哪个元素。可以使用 $attrs 将属性绑定到子组件的任意一个元素上。

###### $listeners

$listeners 和 $attrs 是类似的。

子组件的事件处理函数没有在当前子组件内部声明，而是老爹传进来的。

用处：做比较高级的封装组件，你封了一个其他组件，还想给它传一个回调函数让它去调用，就可以用这种方式，回调函数是在老爹里声明的。

```js
// parent
<HelloWorld @click="handle"/>
methods: {
	handle() {
		console.log('来自老爹的回调', this)
  }
}

// child
// $listeners会被展开并监听
<p v-on="$listeners"></p>
```

###### 替换/合并已有的 Attribute

大多数从外部提供给组件的 attribute 的值会替换掉组件内部设置好的值。class 和 style attribute 的值会被合并起来。

##### 自定义事件

子给父传值

当子组件需要和父级组件进行通信，可以派发并监听自定义事件。

```js
// parent
<Cart @add="cartAdd($event)"></Cart>

// child
this.$emit('add', good)
```

##### eventbus

事件总线

任意两个组件之间传值常用事件总线或 Vuex 的方式。

在 Vue 的原型上添加另外一个独立的 Vue 的实例，把它作为事件总线，那么在任意的组件中都可以通过 this.$bus 的方式来使用事件监听和派发，这样就可以实现跨层级的组件传参了。

实践中通常用 Vue 代替 Bus，因为 Vue 已经实现了相应接口。

Bus 只要实现事件派发和监听这两个接口，并且把用户关心的所有回调收集起来就行了，这是一个典型的发布订阅模式。

```js
class Bus {
  constructor(){
    this.callbacks = {}
  }
  $on(name, fn){
    this.callbacks[name] = this.callbacks[name] || []
    this.callbacks[name].push(fn)
  }
  $emit(name, args){
    if(this.callbacks[name]){
      this.callbacks[name].forEach(cb => cb(args))
    }
  } 
}
```

```js
// main.js
Vue.prototype.$bus = new Bus()

// child1
this.$bus.$on('foo', handle)

// child2
this.$bus.$emit('foo')
```

##### Vuex

创建唯一的全局数据管理者 Store，通过它管理数据并通知组件状态变更，它是组件通信的最佳实践。

##### 边界情况

我们在做一些通用组件的时候这些不常用的方式就用得着了。Vuex 等常用的通信方式这么好，为什么还要用这些不常用的方式，最主要的原因是不能强迫用户装 Vuex。因为我们现在要写的是通用组件，所以你能使用的是框架提供给你的最原始最基础的 API，不可以使用超出框架的其他东西，否则就有很强的侵入性，就不是一个很好的组件库了。

###### $parent/$root

子组件访问老爹可以用 $parent，访问根元素可以用 $root。

兄弟组件之间通信可通过共同祖辈搭桥，$parent 或 $root。从原理上来讲跟总线模式是一样的，互相通信的组件之间有一个共同的中介人。

发布订阅模式，事件它的派发和监听者必须是同一个，事件谁派发谁监听。

```js
// brother1
this.$parent.$on('foo', handle)

// brother2
this.$parent.$emit('foo')
```

###### $children

父组件可以通过 $children 访问子组件。

注意：$children 不能保证子元素顺序，比如孩子组件中有异步组件，那它将来注册在 children 里面的位置是在后面的，虽然它声明在前面。

```js
// parent
this.$children[0].xx = 'xxx'
```

###### $refs

获取子节点引用。

可以通过 $refs 的方式找到当前老爹里面包含的所有的孩子，直接去访问。除了组件实例本身，还能访问一些 DOM 元素，平时用的还是挺多的。

```js
// parent
<HelloWorld ref="hw"/>

mounted() {
  this.$refs.hw.xx = 'xxx'
}
```

###### provide/inject

实际工作中不常遇到，因为有 Vuex。比如祖宗组件里有一个值，想传给特别深的一个后代元素，这时候就能用到依赖注入这种方式，一个是提供，一个是注入。它可以跨层级的传参，如果没有 Vuex 可以使用的话，可以用这种方式。平时开发中很少用，只限于 UI 库的开发过程。

通过这种方式设置的值不是响应式的，所以不要改它，不然会有警告。但是你要传一个引用类型进来，访问里面动态的值，然后修改它，也是完全可行的。但是很少这样做，一般都是单向的，就是从上往下传个值就完了。

```js
// ancestor
provide() {
  return {foo: 'foo'}
}

// descendant
inject: ['foo']
```

### 复合组件

在外面提供内容，将来分发到里面的指定位置，这就是内容分发技术。

Vue 中用插槽来做组件的内容分发，组件中使用插槽留出位置来接收父组件传递过来的不确定的内容。

插槽是 Vue 实现的内容分发 API，用于复合组件开发。该技术在通用组件库开发中有大量应用。

子组件中使用 \<slot>\</slot> 占据坑位，父组件中使用 \<template>\</template> 模版占位符填充坑位。

##### 匿名插槽

```vue
<!-- parent -->
<comp>hello</comp>

<!-- comp -->
<div>
  <slot></slot>
</div>
```

sync 修饰符：为了写法更简洁。:show.sync="isShow" 将来会展开成 :show="isShow" @update:show="isShow=$event" 的形式。所以将来子组件要派发的事件就是 update:show。

##### 具名插槽

如果存在多个独立内容要分发，可以使用具名插槽，把内容分发到指定的位置。

```vue
<!-- parent -->
<Comp2>
  <!-- 默认插槽用default做参数 -->
  <template v-slot:default>具名插槽</template> 
  <!-- 具名插槽用插槽名做参数 -->
  <template v-slot:content>内容...</template>
</Comp2> 

<!-- comp2 -->
<div>
  <slot></slot>
	<slot name="content"></slot>
</div>
```

##### 作用域插槽

在你声明的 \<template>\</template> 里面的数据到底是用来自当前的父组件的还是来自于子组件的，如果分发内容要用到子组件中的数据就用作用域插槽，否则就用普通插槽。

```vue
<!-- parent -->
<Comp3>
  <!-- 把v-slot的值指定为一个作用域上下文对象 slotProps: {foo: 'xxxxx'}--> 
  <template v-slot:default="slotProps">
		来自子组件数据:{{slotProps.foo}} 
  </template>
</Comp3>

<!-- comp3 -->
<div>
  <slot :foo="data"></slot>
</div>
```

### 双向绑定

##### 非自定义组件

```vue
<input v-model="data"/>
// 相当于：
<input :value="data" @input="data=e.target.value"/>
```

##### 自定义组件

v-model 是一个语法糖，v-model 最终会转换成一个属性的传递 :value="values" 和一个事件的监听 @input="values=$event"。$event 是固定的名字，表示传递出来的参数。

```vue
<course-add v-model="data"></course-add>
// 相当于：
<course-add :value="data" @input="data=$event"></course-add>
```

上面的事是 Vue 给我们做好了的，我们要做的事情是在组件的内部，接收一个叫 value 的 prop 属性，根据业务需求触发一个事件，事件中触发 input 事件，把值传出去，this.$emit('input', newValue)。

```js
// 非表单元素绑定
Vue.component('course-add', {
	props: ['value'],
  template: `
		<div>
			<!-- 需要实现input的:value和@input --> 
			<div @click="handleClick"> {{ value }} </div>
		</div> 
	`,
	methods: {
    handleClick() {
      const newValue = 123
      this.$emit('input', newValue)
    }
  }
})
// 表单元素绑定
Vue.component('course-add', {
	props: ['value'],
  template: `
		<div>
			<!-- 需要实现input的:value和@input --> 
			<input :value="value" @input="onInput"/> 
		</div> 
	`,
	methods: {
    onInput(e) {
      this.$emit('input', e.target.value)
    }
  }
})
```

### 通用表单组件

##### 需求分析

在开始之前要做一个需求分析，到底要什么样的功能，为了实现这些功能要做一些什么事情。

* KForm 
  * 接收数据
  * 指定校验规则
* KformItem
  * 执行校验
  * 显示错误信息
* KInput
  * 维护数据 

##### 实现 KInput.vue

```vue
<template>
  <div>
    <input :type="type" :value="value" @input="onInput" v-bind="$attrs">
  </div>
</template>

<script>
  export default {
    inheritAttrs: false, // 避免传入的属性继承到根元素上
    props: {
      value: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: 'text'
      }
    },
    methods: {
      onInput(e) {
        this.$emit('input', e.target.value)
        // 通知父级执行校验
        this.$parent.$emit('validate')
      }
    },
  }
</script>
```

##### 实现 KFormItem

```vue
<template>
  <div>
    <!-- label -->
    <label v-if="label">{{label}}</label>

    <!-- KInput的坑位 -->
    <slot></slot>

    <!-- 校验信息显示 -->
    <p v-if="error">{{error}}</p>
  </div>
</template>

<script>
// Asyc-validator
import Schema from "async-validator";

export default {
  inject: ["form"],
  data() {
    return {
      error: "" // error是空说明校验通过
    };
  },
  props: {
    label: {
      type: String,
      default: ""
    },
    prop: {
      type: String
    }
  },
  mounted() {
    this.$on("validate", () => {
      this.validate();
    });
  },
  methods: {
    validate() {
      // 规则
      const rules = this.form.rules[this.prop];
      // 当前值
      const value = this.form.model[this.prop];

      // 校验描述对象
      const desc = { [this.prop]: rules };
      // 创建Schema实例
      const schema = new Schema(desc);
      return schema.validate({ [this.prop]: value }, errors => {
        if (errors) {
          this.error = errors[0].message;
        } else {
          // 校验通过
          this.error = "";
        }
      });
    }
  }
};
</script>
```

##### 实现 KForm

```vue
<template>
  <div>
    <slot></slot>
  </div>
</template>

<script>
export default {
  provide() {
    return {
      form: this
    };
  },
  props: {
    model: {
      type: Object,
      required: true
    },
    rules: {
      type: Object
    }
  },
  methods: {
    validate(cb) {
      // 获取所有孩子KFormItem
      const tasks = this.$children
        .filter(item => item.prop) // 过滤掉没有prop属性的Item
        .map(item => item.validate());

      // 统一处理所有Promise结果
      Promise.all(tasks)
        .then(() => cb(true))
        .catch(() => cb(false));
    }
  }
};
</script>
```

##### 使用

```vue
<template>
  <div>
    <!-- KForm -->
    <KForm :model="userInfo" :rules="rules" ref="loginForm">
      <!-- 用户名 -->
      <KFormItem label="用户名" prop="username">
        <KInput v-model="userInfo.username" placeholder="请输入用户名"></KInput>
      </KFormItem>
      <!-- 密码 -->
      <KFormItem label="密码" prop="password">
        <KInput type="password" v-model="userInfo.password" placeholder="请输入用户名"></KInput>
      </KFormItem>
      <!-- 提交按钮 -->
      <KFormItem>
        <button @click="login">登录</button>
      </KFormItem>
    </KForm>
  </div>
</template>

<script>
import KInput from "@/components/form/KInput.vue";
import KFormItem from "@/components/form/KFormItem.vue";
import KForm from "@/components/form/KForm.vue";
import Notice from "@/components/Notice.vue";

export default {
  data() {
    return {
      userInfo: {
        username: "tom",
        password: ""
      },
      rules: {
        username: [{ required: true, message: "请输入用户名称" }],
        password: [{ required: true, message: "请输入密码" }]
      }
    };
  },
  components: {
    ElementTest,
    KInput,
    KFormItem,
    KForm
  },
  methods: {
    login() {
      this.$refs["loginForm"].validate(valid => {
        const notice = this.$create(Notice, {
          title: "社会你杨哥喊你来搬砖",
          message: valid ? "请求登录!" : "校验失败!",
          duration: 2000
        });
        notice.show();
      });
    }
  }
};
</script>
```

##### 修正 input 中 $parent 写法的问题

想跨层级的去传参，还不能使用 $parent/$root/$children 等，element 官方用的是混入的方式，在 src/mixins 写了一个 emitter.js 派发器。它可以做两件事，一个叫广播一个叫冒泡派发事件，这个东西在 vue1.0 里是有的，2.0 之后删了。element 觉得它有用，所以自己实现了，这个东西可以隔层的去派事件，比如在 input 里可以不停的向上去找我想要的组件让它去派发事件。这个东西是作为一个混入被引入的，主要是为了复用。

1.mixin emitter
2.声明 componentName
3.dispatch()																				





### 弹窗组件

其他的组件的内容都是在 app 里的，弹窗这类组件已经脱离出当前 Vue 管理的实例了。这样做的好处是比较好控制弹窗的位置等东西。它们在当前 Vue 根实例之外独立存在，通常挂载于 body，而不是 app，所以不能将它声明在任何一个 app 组件下的 compunents 选项作为当前 app 的组件从而使用 Vue 内部来创建构造函数和实例的能力，需要我们自己去创建实例。

需求：现在有一个 Notice.vue 这样的组件，要用函数的方式去创建这个组件的实例，并且将来把它挂在到 body 上面去。

##### 实现 create 函数

create 方法将来接收一个组件（其实就是组件的配置）和一些参数，创建这个组件的实例，并将其挂载到 body 上去，最终返回这个组件实例。

方法一： 

Vue.extend 方法是 Vue 的一个静态方法，它里面创建了一个子类 VueComponent，继承 Vue，组件实例就是通过 VueComponent 创建的。它是框架本身调的方法。

utils/create.js

```js
import Vue from 'vue'

function create(Component, props) {
  // 获得组件的构造函数
  const Ctor = Vue.extend(Component);
  // 获得组件实例，组件实例创建之后得到虚拟DOM
	// 用propsDate传递参数，相当于使用模版时父组件传过来的props
  cosnt comp = new Ctor({propsDate: props});
  // 组件实例挂载，得到真实DOM
  comp.$mount();
  // 获取真实DOM后，做手动挂载
  document.body.appendChild(comp.$el);
  // 作为一个组件，不停的往界面中去追加而不去清除，将来内存就爆了。
  comp.remove = function() {
    document.body.removeChild(comp.$el);
    comp.$destroy();
  }
  return comp;
}

export default create
```

方法二：

借助 Vue 来创建根实例，使用 render 方法，直接把传入的组件渲染出来，整个过程会有组件实例的创建，然后我们从中获取组件的实例就可以了。

utils/create.js

```js
import Vue from 'vue'

function create(Component, props) {
  // 这个实例会把这个组件作为根组件把它渲染出来了，所以我们就能得到虚拟DOM，挂载后得到真实DOM
  const vm = new Vue({
    render: h => h(Component, {props}),
  }).$mount(); // 不指定宿主元素，则会创建真实DOM，但是不会做追加操作，因为没有目标对象可追加，也不可以使用body
  // 获取真实DOM后，做手动挂载
  document.body.appendChild(vm.$el);
  // 获取传入的组件的实例
  const comp = vm.$children[0];
  // 清除自己
  comp.remove = function() {
    document.body.removeChild(vm.$el);
    vm.$destroy();
  }
  return comp;
}

export default create
```

##### 实现 Notice.vue

```vue
<template>
  <div class="box" v-if="isShow">
    <h3>{{title}}</h3>
    <p class="box-content">{{message}}</p>
  </div>
</template>

<script>
export default {
  props: {
    title: {
      type: String,
      default: ""
    },
    message: {
      type: String,
      default: ""
    },
    duration: {
      type: Number,
      default: 1000
    }
  },
  data() {
    return {
      isShow: false
    };
  },
  methods: {
    show() {
      this.isShow = true;
      setTimeout(this.hide, this.duration);
    },
    hide() {
      this.isShow = false;
      this.remove();
    }
  }
};
</script>

<style>
.box {
  position: fixed;
  width: 100%;
  top: 16px;
  left: 0;
  text-align: center;
  pointer-events: none;
  background-color: #fff;
  border: grey 3px solid;
  box-sizing: border-box;
}
.box-content {
  width: 200px;
  margin: 10px auto;
  font-size: 14px;  
  padding: 8px 16px;
  background: #fff;
  border-radius: 3px;
  margin-bottom: 8px;
}
</style>
```

main.js

```js
import create from './utils/create'

Vue.prototype.$create = create;
```

使用

```js
this.$create(Notice, {
  title: '弹窗组件',
  message: '提示信息',
  duration: 1000
}).show();
```

##### 封装成 Vue 插件的形式，便于使用。

utils/create.js

```js
import Vue from 'vue'
import Notice from 'Notice.vue'

function create() {
  //...
}

export default {
  install(Vue) {
    Vue.prototype.$notice = function(options) {
      return create(Notice, options)
    }
  }
}
```

main.js

```js
import Vue from 'vue'
import create from './utils/create'

Vue.use(create)
```

### 表单业务组件封装

* 组件外部

  * 传入遍历数据
    * 表单的类型
    * label 
    * 是否展示 label
    * 当前表单需要绑定的 v-model 变量名
    * model 的默认值（非必须）
    * 一些其他属性的传递
  * 绑定所有表单对应的 v-model 对象集合
  * 接收内部触发出来的事件，主要是内部提交表单的事件，外部做列表的刷新

  ```vue
  <template>
    <div>
      <div class="searchHeader">
        <sel-header-component
          :sel-header-list="search.selHeaderList"
          v-model="search.selHeaderModelObj"
          @submit="searchResult"
        />
      </div>
    </div>
  </template>
  <script>
  import SelHeaderComponent from '@/components/configSelHeader'
  
  export default {
    components: {
      SelHeaderComponent
    },
    data () {
      return {
        // 查询条件
        search: {
          selHeaderList: [ // header可选项的初始化list
            {
              key: 'nameCn',
              label: '请输入目录的中文名称',
              showLabel: false,
              selType: 'input',
              width: 300
            },
            {
              key: 'nameEn',
              label: '请输入目录的英文名称',
              showLabel: false,
              selType: 'input',
              width: 300
            },
            {
              key: 'creator',
              label: '请输入创建人',
              showLabel: false,
              selType: 'input',
              width: 300
            }
          ],
          selHeaderModelObj: {} // model
        }
      }
    },
    created() {
      const obj = {}
      this.search.selHeaderList.forEach(td => {
        if (td.defaultValue) {
          obj[td.key] = td.defaultValue
        } else {
          obj[td.key] = ''
        }
      })
      this.selHeaderModelObj = obj
    }
  }
  </script>
  ```

* 组件内部

  * 根据数据遍历出所有表单
    * 将所有表单类型写出来，根据传入的数据判断哪个显示
    * 是否展示 label
    * 当前表单需要绑定的 v-model 变量名
    * 一些其他属性的传递
  * 表单上绑定的事件，使用 $emit 触发出来
  * v-model 的处理
    * 使用 prop value 接收传进来的 v-model 对象集合，并绑定到每个表单元素上。
    * 当值变化时，触发 @input 事件把组件上 v-model 对象集合传出去
      * 可以使用 @input 事件
      * 使用 watch

  ```vue
  <template>
    <div class="selHeaderWrap">
      <el-form :inline="true">
        <el-form-item
          v-for="(item,index) in selHeaderList"
          :key="index"
          :label="item.showLabel ? item.label : ''"
        >
          <el-input
            v-if="item.selType==='input'"
            v-model="value[item.key]"
            :placeholder="item.label"
            size="small"
            clearable
            @keyup.enter.native="submit"
            @clear="submit"
            :style="{width: item.width+'px'}"
            @input="input($event, item.key)"
          >
            <i slot="prefix" class="el-input__icon el-icon-search" />
          </el-input>
        </el-form-item>
      </el-form>
    </div>
  </template>
  <script>
  export default {
    props: {
      selHeaderList: {
        type: Array,
        default: () => []
      },
      value: {
        type: Object,
        default: () => {}
      }
    },
    methods: {
      submit (val) {
        this.$emit('submit', val)
      },
      input(e, key) {
        this.value[key] = e
        this.$emit('input', this.value)
      }
    }
  }
  </script>
  ```

select 的 options 的数据可以放在每个数据中，也可以像 modelObj 一样做一个映射。



### 拖拽表单组件

##### 需求

后台管理：左侧固定列表中有一些表单，例如文本框，下拉框。可以将这些表单元素拖拽到右侧的自适应的区域，将表单以原来的宽度放入一行，放不下换行。保存右侧的表单信息和顺序到后端。

用户界面：将来可以在用户端按顺序显示后台操作保存的表单。

##### 根据需求寻找适合的组件

先到 vue 社区搜索 drag 相关的组件。

根据需求最终筛选出的组件：

* vuedraggable 
* vue-smooth-dnd 
* vue-drag-and-drop-kanban 基于 cue-smooth-dnd
* vue-formbuilder 基于 vuedraggable

##### 设计思路

1. 首先要实现样式操作上的符合：两个列表之间的双向拖拽，能够满足自适应的两列布局，拖拽过去后一行显示超出换行并且保持元素拖拽之前的宽度。
2. 可以将内容也拖拽过去。
3. 可以记录右侧列表的所有元素和顺序。

##### 遇见的问题

单纯使用 vuedraggable 的双列表进行的拖拽

1. 内容是元素或组件的时候，元素和组件无法复制过去。需要封装一个组件，使拖拽和被拖拽的列表内容都使用这个组件进行渲染，配合 list 数据判断渲染的元素类型。
2. list 数据只能接收 name, id 两个内容，无法接收其他内容。



### Vue 组件化实践

根据数据渲染视图。

配合路由创建相应组件，组件里搭建整体结构，然后在相应位置插入子组件，一层一层向下写。

基本页面上的每一块都分成组件，然后按照不分组件的时候怎么写就怎么写里面的功能，然后再处理需要处理的组件之间的数据通信问题就行了。将几个组件公用的数据放到公共的父组件中。

将功能先用原始的 html 的方式实现，再从中拆分出组件。



## VUE源码剖析

### 最简单的数据响应式

```js
// 数组响应式
// 思路：找到数组原型，覆盖那七个修改数组的方法，让它除了做原来的事情之外，还能够额外做更新通知，这样就实现了数组的响应式操作。并将得到的新的原型设置到data中的数组实例原型上，这样这个数组执行调用这些方法的时候就会以我们添加的方法为准。
// 1.替换数组原型中那7个方法
// 拿到数组原型
const originalProto = Array.prototype
// 备份一份，修改备份
const arrayProto = Object.create(originalProto)

// splice,reverse,sort
['push', 'pop', 'shift', 'unshift'].forEach(method => {
  arrayProto[method] = function() {
    // 原始操作
    arrayProto[method].apply(this, arguments)
    // 覆盖操作：通知更新（对象响应式里的setter操作dep.notify）
    console.log('数组执行 ' + method + '操作');
    
  }
})

// 数据响应式
function defineReactive(obj, key, val) {
  // 递归
  observe(val)
  
  // 对传入obj进行访问拦截
  Object.defineProperty(obj, key, {
    get() {
      console.log('get ' + key);
      return val
    },
    set(newVal) {
      if (newVal !== val) {
        console.log('set ' + key + ':' + newVal);
        // 如果传入的newVal依然是obj，需要做响应化处理
        observe(newVal)
        val = newVal
        // 更新函数
        update()
      }
    }
  })
}

// 遍历做批量响应化处理
function observe(obj) {
  if (typeof obj !== 'object' || obj == null) {
    // 希望传入的是obj
    return
  }
  
  // 数组数据响应化
  if (Array.isArray(obj)) {
    // 覆盖该数组的原型
    obj.__proto__ = arrayProto
    // 对数组内部的元素做响应化处理
    for (let i = 0; i < obj.length; i++) {
      observe(obj[i])
    }
  } else {
    Object.keys(obj).forEach(key => {
      defineReactive(obj, key, obj[key])
    })
  }
  
}

function set(obj,key,val) {
  defineReactive(obj,key,val)
}

// 更新函数
function update() {
  // 更新试图
  app.innerText = obj.foo
}

// 单个数据响应化处理
// defineReactive(obj, 'foo', 'foo')
// obj.foo
// obj.foo = 'fooooooooooooooooo'

const obj = { foo: 'foo', bar: 'bar', baz: { a: 1 }, arr: [1,2,3] }

observe(obj)

obj.foo
obj.foo = 'fooooooooooooooo'
obj.bar
obj.bar = 'barrrrrrrrrrrrrr'

// obj.baz.a = 10 // 深层的数据，拦截不到，需要递归处理里面的对象数据
obj.baz = {a:100} // 如果赋值依然是obj，拦截不到，需要在setter中赋值时做响应化处理
obj.baz.a = 100000

// obj.dong = 'dong' // 添加新的属性，拦截不到，使用set做一次响应化处理
set(obj, 'dong', 'dong')
obj.dong

// Object.defineProperty()对数组无效
// 分析：改变数组方法只有7个
// 解决方案：覆盖数组实例的原型方法，让他们在修改数组同时还可以通知更新
obj.arr.push(4)
```



### 简版 MVVM

![Vue数据响应式](/Users/zhaoyang/tool/images/前端知识体系/前端工程实践/Vue/Vue数据响应式.png)

* KVue：框架构造函数。
* Observer：
  * 执行数据响应化（分辨数据是对象还是数组，对这两种类型有不同的操作，所以我们多抽象出来了一层，用这个 Observer 来做）。
    * getter：依赖收集。
    * setter：执行更新函数。
* Compile
  * 编译模版：递归遍历 DOM 树，解析出 node 节点和该节点上动态绑定的值 vm.data.key，还有模版绑定语法类型。根据不同的模版语法创建相应的更新函数，接收解析出来的两个值，做 DOM 操作。
    * 初始化视图，执行更新函数。
    * 创建 Watcher 实例，传入更新函数。
* Watcher：管理更新函数。
* Dep：管理 Watcher。

kvue.js

```js
function defineReactive(obj, key, val) {
  // 递归
  observe(val)

  // 创建一个Dep和当前key一一对应
  const dep = new Dep()
  
  // 对传入obj进行访问拦截
  Object.defineProperty(obj, key, {
    get() {
      console.log('get ' + key);
      // 依赖收集在这里
      Dep.target && dep.addDep(Dep.target)
      return val
    },
    set(newVal) {
      if (newVal !== val) {
        console.log('set ' + key + ':' + newVal);
        // 如果传入的newVal依然是obj，需要做响应化处理
        observe(newVal)
        val = newVal

        // 通知更新
        // watchers.forEach(w => w.update())
        dep.notify()
      }
    }
  })
}

function observe(obj) {
  if (typeof obj !== 'object' || obj == null) {
    // 希望传入的是obj
    return
  }

  // 创建Observer实例
  new Observer(obj)
}

// 代理的原数据已经是响应式的了，所以代理数据不需要再做响应式了，只是单纯的做get，set代理操作就行了
// 代理函数，方便用户直接访问$data中的数据
function proxy(vm, sourceKey) {
  // vm是框架实例，sourceKey是vm中的$data
  // 遍历vm[$data]中的所有key，将它代理到vm上的key
  Object.keys(vm[sourceKey]).forEach(key => {
    // 将$data中的key代理到vm上
    Object.defineProperty(vm, key, {
      get() {
        return vm[sourceKey][key]
      },
      set(newVal) {
        vm[sourceKey][key] = newVal
      }
    })
  })
}

// 创建KVue构造函数
class KVue {
  constructor(options) {
    // 保存选项
    this.$options = options;
    this.$data = options.data;

    // 响应化处理
    observe(this.$data)

    // 代理
    proxy(this, '$data')

    // 创建编译器
    new Compiler(options.el, this)
  }
}

// 根据对象类型决定如何做响应化
class Observer {
  constructor(value) {
    this.value = value

    // 判断其类型
    if (typeof value === 'object') {
      this.walk(value)
    }
  }

  // 对象数据遍历响应化
  walk(obj) {
    Object.keys(obj).forEach(key => {
      defineReactive(obj, key, obj[key])
    })
  }

  // 数组数据响应化，待补充
}

// 观察者:保存更新函数，值发生变化调用更新函数
// const watchers = []
class Watcher {
  constructor(vm, key, updateFn) {
    this.vm = vm

    this.key = key

    this.updateFn = updateFn

    // watchers.push(this)

    // Dep.target静态属性上设置为当前watcher实例
    Dep.target = this
    this.vm[this.key] // 读取触发getter
    Dep.target = null // 收集完就置空，防止编译时，读取下一个同样的key时push进去的是该key的上一个更新函数。
  }

  // 更新函数
  update() {
    this.updateFn.call(this.vm, this.vm[this.key])
  }
}

// Dep：依赖，管理某个key相关所有Watcher实例
class Dep {
  constructor(){
    this.deps = []
  }

  addDep(dep) {
    this.deps.push(dep)
  }

  notify() {
    this.deps.forEach(dep => dep.update())
  }
}
```

compile.js

```js
// 编译器
// 递归遍历DOM树
// 判断节点类型，如果是文本，则判断是否是插值绑定
// 如果是元素，则遍历其属性判断是否是指令或事件，然后递归子元素
class Compiler {
  // el是宿主元素
  // vm是KVue实例
  constructor(el, vm) {
    // 保存kVue实例，保存需要操作的DOM元素
    this.$vm = vm
    this.$el = document.querySelector(el)

    if (this.$el) {
      // 执行编译，初始化视图
      this.compile(this.$el)
    }
  }

  // 遍历DOM树，开始做编译工作
  compile(el) {
    // 遍历el树
    const childNodes = el.childNodes;
    Array.from(childNodes).forEach(node => {
      // 判断是否是元素
      if (this.isElement(node)) {
        // console.log('编译元素' + node.nodeName);
        this.compileElement(node)
      } else if (this.isInter(node)) {
        // console.log('编译插值绑定' + node.textContent);
        this.compileText(node)
      }

      // 递归子节点
      if (node.childNodes && node.childNodes.length > 0) {
        this.compile(node)
      }
    })
  }

  // 是否是元素
  isElement(node) {
    return node.nodeType === 1
  }

  // 是否是差值绑定
  isInter(node) {
    // 首先是文本标签，其次内容是{{xxx}}
    return node.nodeType === 3 && /\{\{(.*)\}\}/.test(node.textContent)
  }

  // 文本节点编译
  compileText(node) {
    this.update(node, RegExp.$1, 'text')
  }

  // 元素节点编译
  compileElement(node) {
    // 节点是元素
    // 遍历其属性列表
    const nodeAttrs = node.attributes
    Array.from(nodeAttrs).forEach(attr => {
      // 规定：指令以k-xx="oo"定义 k-text="counter"
      const attrName = attr.name // k-xx k-text
      const exp = attr.value // xx counter
      // 指令处理
      if (this.isDirective(attrName)) {
        const dir = attrName.substring(2) // xx text
        // 执行指令
        this[dir] && this[dir](node, exp)
      }
      // 事件处理
      if (this.isEvent(attrName)) {
        // @click="onClick"
        const dir = attrName.substring(1) // 得到click
        // 事件监听
        this.eventHandler(node, exp, dir)
      }
    })
  }

  // 是否是指令
  isDirective(attr) {
    return attr.indexOf('k-') === 0
  }
  
  // 是否是事件
  isEvent(attr) {
    return attr.indexOf('@') === 0
  }
  
  // k-text
  text(node, exp) {
    this.update(node, exp, 'text')
  }

  
  // k-html
  // 双向绑定，语法糖，它实际上做了两个事，value 值的设定和事件的监听。设置 v-model 就是要实现这两个事情，因此在代码的实现层面实现这两件事情就可以了。
  html(node, exp) {
    this.update(node, exp, 'html')
  }
  
  // k-model
  model(node, exp) {
    // update方法只完成赋值操作，是单向的
    // value赋值
    this.update(node, exp, 'model')
    // 事件监听
    node.addEventListener('input', e => {
      // 将新的值赋值给数据
      this.$vm[exp] = e.target.value
    })
  }

  // 编译函数
  update(node, exp, dir) {
    // 编译初始化
    // 组合最终的DOM更新函数xxUpdater
    const fn = this[dir + 'Updater']
    fn && fn(node, this.$vm[exp])

    // 创建Watcher实例
    // 传入更新函数
    new Watcher(this.$vm, exp, function (val) {
      fn && fn(node, val)
    })
  }

  textUpdater(node, value) {
    node.textContent = value
  }

  htmlUpdater(node, value) {
    node.innerHTML = value
  }
  
  modelUpdater(node, value) {
    // 表单元素赋值
    node.value = value
  }
  
  // 事件监听处理
  eventHandler(node, exp, dir) {
    const fn = this.$vm.$options.methods && this.$vm.$options.methods[exp]
    node.addEventListener(dir, fn.bind(this.$vm))
  }
  
}
```



### 源码剖析准备

##### 搭建调试环境

1. clone 源码，地址：https://github.com/vuejs/vue.git  版本:2.6.10

2. 安装依赖：npm install

3. 安装 rollup，因为 Vue 的打包工具用的是 rollup：npm install -g rollup

4. 修改开发脚本：添加代码映射，调试的过程中能够直接调试和研究源码。

   修改 package.json 中的 dev 打包脚本：

   "dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev"

5. 打包，执行开发脚本，输出最终我们要用的 vue.js：npm run dev

   打包成功之后 dist 下会生成一个全新的 vue.js，和它的 map 文件 vue.js.map

6. 编写测试文件

   创建一个测试脚本来看看我们打包的东西是否正常。在任何地方写都可以，vue 有些案例在 examples 里，我们就可以在这来编写测试文件。

   examples/test/01-test.html

   把刚才打包的 vue.js 引进来，剩下的就正常的写一个 vue 程序就行了。

   浏览器打开不报错的跑起来，并且有 vue 初始化的一些输出就可以了，接下来就可以调试了。

##### 调试技巧

* 打开指定文件：ctrl+p

* 断点：想知道某个地方到底发生了什么事情，让浏览器执行到这个地方的时候停下来，继不继续向下执行由我们调试控制。

* 单步执行

  * 单步跳过函数
  * 单步进入函数

* 查看调用栈

  研究代码的过程中，想搞清楚先后之间的调用关系，有时函数进入过深的时候，往往就搞不清楚了。这时就可以好好的研究这个 Call Stack，可以很有效的帮你把思路理顺，是谁调用的谁，整个过程会显得很清晰，调用栈中可以很好的看到整个的函数执行的流程。

* 定位当前源文件所在位置

  以方便下次再研究的时候心中有数，以后就知道在哪找到这个代码了，随着这个过程研究的次数越来越多，我可能就把整个源码的脉络都熟悉了。

  sources 代码上右键，找到 Reveal in sidebar 命令，在侧边栏里就会显示这个文件所在的目录。 

##### 源码目录结构

以后自己研究的过程中应该很清楚的找到这些目录和想要的文件才行。

/dist                              发布目录，最终输出的所有js文件都在这里，各个发布版本之间存在差异。
/examples                    范例，里面有我们研究源码时的测试代码
/flow                             2.6 这个版本还是基于 flow 去写的，所以还会有 flow 这个类型声明文件，针对 flow 的类型声明
/types                           对 TS 的类型声明
/packages                    里面有一些核心代码之外的独立库，这些东西它认为不应当是项目核心的东西，它单独的拆分写到									 这些包 里头了，所以它跟我们核心代码无关。
/scripts                         我们要找入口文件，还要跟这里的构建脚本打打交道
/src                               源码，我们就是要研究这里面的所有东西
    /compiler                  编译器相关
    /core                         核心代码，要常来这里看看啊
    	/components        通用组件，keep-alive，为什么只有这一个组件，因为它是所有平台通用的。weex 或 web 平台会									 有特殊的像 transition 这样的组件，它会写到其他的目录去。就会写到 platforms 这个目录的 									 weex 或 web 里头单独去组织，所以代码的分工是非常清楚的，很值得去借鉴。
    	/instance     		 构造函数等，在核心代码中，最应该关心的目录应该是这个。Vue 的构造函数就会在这里头。查找									 的思路是什么呢，怎么会找到这里。
   	 /global-api            全局 API
        /observer              响应式相关
        /vdom                   虚拟 DOM 相关

##### 输出的各个发布版本的含义

* runtime：仅包含运行时，不包含编译器，意味着写程序的时候不能使用 template 这个配置项去写字符串的模版。
* common：只能用于像 nodejs 的 require 的方式称为 commonjs，用 cjs 规范来进行打包的，用于像 webpack1，broswerify 等老旧版本打包工具，现在很少用到。
* esm：ES（ECMA Script）模块规范，主要用于 webpack2+ 这些打包工具。
* umd：universal module definition，就是什么都不加的，如 vue.js。浏览器里面直接引，不经过打包工具打包的一般会用这个版本。兼容 cjs 和 amd 规范（异步模块），浏览器里面加载模块都希望是异步的啊，所以 amd 规范特别适合在浏览器里使用。

##### 找入口

使用打包工具的项目的源码入口文件怎么找，一般先从 package.json 开始，找到我们打包的脚本命令 dev，是 rollup 打包的，-c 指明了配置文件在哪，然后根据打包脚本命令的参数和打包工具配置文件的代码逻辑就能够找到你想要那个输出版本的入口文件到底是谁。

从这个源码入口文件开始研究源码，我们要多次与这个入口文件打交道，尤其是初始化过程。



### Vue 总体流程

从入口文件开始，根据文件或模块的引用路径寻找 Vue 构造函数。发现每个文件模块的作用，最后根据一个简单的 new Vue() 程序，断点调试，串联整理整个初始化流程。

##### src/platforms/web/entry-runtime-with-compiler.js 入口文件：

保存一份原型上的 $mount，然后针对该平台的特点对 $mount 做扩展。这里是 web 平台，所以扩展的就是跟编译相关的事，处理 render，template，el 选项。选项中如果有 render 直接调用 mount 执行挂载；如果有 template 或 el，将它们进行一定处理最后变成 template，然后将这个 template 执行模版解析和编译工作，最终得到 render 函数并将其放到选项中去，然后调用 mount 执行挂载。所以不管是 render，template 还是 el，最终都是要得到 render 渲染函数。 

##### src/platforms/web/runtime/index.js：

* 安装 web 平台特有指令和组件；
* 在 Vue 原型上定义了补丁方法 Vue.prototype.\__patch__ 把虚拟 DOM 转换成真实 DOM，初始化的赋值和以后的更新都会用到这个 patch；
* 实现了 $mount，它只做了一件事，就是把传过来的宿主 el 做 DOM 查询，然后调用 mountComponent 执行初始化挂载，将首次渲染的结果替换 el。

##### src/core/index.js：

开始进入到核心代码里了。定义全局 API。

##### src/core/instance/index.js：

* 定义 Vue 构造函数，构造函数内部只执行了一行代码，就是初始化方法 this._init()，这个方法是通过混入的方式混入进来的，具体是通过 initMixin(Vue) 方法给 Vue 原型添加 \_init 方法，将来 new Vue() 的时候执行这个初始化方法；
* 使用混入的方式定义 Vue 实例 API：initMixin(Vue)，状态相关api stateMixin(Vue)，事件相关api eventsMixin(Vue)，跟生命周期相关的更新渲染等 lifecycleMixin(Vue)，渲染函数相关api renderMixin(Vue)

##### src/core/instance/init.js：

* 初始化方法 _init 定义的地方；
* _init 方法做的事情是创建组件实例，初始化其数据、属性、事件等，然后执行挂载 $mount。

```js
initLifecycle(vm)     // 声明组件实例的$parent $root $children $refs，组件创建的顺序是自上而下的，挂载的顺序是自下而上的，当我创建完毕之后，立刻执行挂载，找到老爹执行一次挂载。
initEvents(vm)       // 处理父组件传入的事件和回调，就是对父组件传入的事件添加监听，事件的派发和监听是一个人
initRender(vm)       // 跟渲染相关的东西，也就是跟虚拟dom相关的东西。声明了$slots,$createElement就是那个h

callHook(vm, 'beforeCreate') // 完成了上面三件事之后，会调一个beforeCreate，所以beforeCreate里面可以用上面声明的所有的东西

initInjections(vm)    // 注入数据 resolve injections before data/props
initState(vm)         // 重要：数据的初始化props，methods，data，computed，watch，数据响应式
initProvide(vm)       // 提供数据 resolve provide after data/props

callHook(vm, 'created') // 上面的事情都做完后，会有一个created这个生命周期，这个时候所有的初始化全部完成了，你可以放心大胆做你任何想做的事情了。
```

1. new Vue() 进入到构造函数，调用 _init()

2. _init() 里执行一系列的初始化工作。最后判断有 el 执行 $mount，使用 template 或 render 需要手动执行 $mount。

   * initState(vm)：数据响应式，这里做了一系列数据的初始化，包括 props、methods、data、computed 和 watch。

     * initData(vm)：data 响应式，获取 data，设置代理，启动响应式 observe。
       * observe(value)：判断传入的数据 value 是不是对象，不是直接 return。然后尝试从 value 中获取一个 Observer 实例 ob = value.\__ob__，如果该对象数据是响应式的，就会有这个 ob，不是的话，就创建 Observer 实例，进行响应化处理，最后返回 Observer 实例 ob。也就是说一个对象类型的数据要进行一次响应式观察处理，每次只处理一个对象数据和里面的一层，然后递归把所有深层次的数据都处理到。
         * Observer(value)：做数据响应化，它只处理对象类型的数据。
           * 为每一个对象类型的数据本身的 ob 创建一个 dep。object 里面新增($set)或者删除属性，array 那七个变更数组方法时会使用到这个的 dep 中存放的依赖来做这个对象本身变化的通知更新。
           * 给这个要做响应化处理的对象类型的数据设置 \__ob__ 的属性，值为当前的 Observer 实例 this，就是为每个对象类型的数据都附加一个 Observer 实例。
           * 分别做数组和对象的响应化处理：
             * 数组
               * 替换数组原型。
                 * 执行原来的方法功能
                 * 通知更新：使用 ob 中的 dep 来通知更新。
               * 如果数组里面的元素是对象，还需要对其做响应化处理，对其执行 observe
             * 对象
               * defineReactive：遍历，对每个 key 做数据响应化。
                 * 创建每个 key 对应的 dep，这个细粒度的 dep 是为用户 Watcher 准备的，而不是为了整个组件的渲染 Watcher。
                 * 使用 observe(val) 做递归处理，因为 val 有可能是对象，并且 observe 可以返回 ob，依赖收集时会用到。
                 * Object.defineProperty：数据劫持，为每个 key 做响应化拦截。
                   * get：收集依赖，最终收集的 Watcher 都是一个，就是该组件实例对应的那个 Watcher。render 函数里有动态的值需要去访问，这时就触发了 getter，然后做依赖收集。
                     * 对每个 key 对应的 dep 做收集。
                     * 如果要做响应化的数据是对象，也就是说存在 ob，还要对他们中的 ob 对应的 dep 做收集。
                     * 如果要做响应化的数据是数组，要把数组中的对象或数组，还要对他们中的 ob 对应的 dep 做收集。
                   * set：
                     * 如果赋的新值是对象，也要做响应化处理。
                     * dep.notify()：数据的变化后，通知更新，下面开始异步批量更新的实现
                       * watcher.update()：执行所有收集的 Watcher 的 update 方法
                         * queueWatcher(watcher)：将 watcher 入队
                           * nextTick(flushSchedulerQueue)：传入 flushSchedulerQueue
                             * timerFunc()：启动了一个微任务，传入执行 flushSchedulerQueue 的方法 flushCallbacks，Promise.resolve.then(flushCallbacks)，将来会执行 flushSchedulerQueue
                               * flushSchedulerQueue()：真正的更新操作
                                 * watcher.run() 
                                   * watcher.get()：调用 watcher 创建时传入的更新函数。
                                     * updateComponent()
                                       * 跟初始化一样的操作...

   * vm.$mount()，执行挂载，只做了 mountComponent 这一个事。

     * mountComponent()，执行挂载转换

       * 声明 updateComponent() 更新函数，并没有调用，里面执行下面两个方法

         * vm.\_render()：调用 render 函数获取当前组件对应的最新的虚拟 DOM，并把虚拟 DOM 传入 \_update() 中

           * render()：返回 vnode
             * createElement()：h 方法
               * 如果编译后生成的 render 函数的 tag 是字符串
                 * tag 是保留标签直接创建 vnode
                   * vnode = new VNode()
                 * tag 是自定义组件
                   * resolveAsset()：获取组件构造函数
                   * vnode = createComponent()：把构造函数，props，事件等作为参数传进去，根据用户写的组件的所有配置创建一个与之相对应的 vnode。
                     * 处理传递的数据，属性，事件等。
                     * installComponentHooks()：安装它体内的自定义组件管理钩子到该组件的 vnode 上，涉及到组件如何实例化创建和挂载的地方。
                       * componentVNodeHooks：默认的组件管理钩子
                         * init：将来的某个时刻会执行这个初始化
                           * 如果是 keep-alive 组件，就不需要再创建组件实例，直接从缓存中拿出来就行了。
                           * 不是 keep-alive，组件需要重新创建。这个组件创建和挂载的过程是在 patch 中执行的。
                             * child = createComponentInstanceForVnode()：创建组件实例
                             * child.$mount()：创建完实例后挂载，然后接着执行该组件的 _init watcher render update createComponent... 等一系列的这个组件下的那些事情，递归向下创建它下面的那些组件和 DOM 的那棵树。
                         * prepatch
                         * insert
                         * destroy
                     * new VNode()：创建 vnode 并返回，自定义组件的 vnode 中会有一个特别的属性 componentInstance，将来组件实例创建完成之后，这个属性会被填充，patch 的时候执行组件管理钩子 init，创建组件实例。
                 * tag 是选项或构造函数
                   * vnode = createComponent()

         * vm.\_update()：执行更新

           * vm.\__patch__()：它就是 patch 函数，传入新老 vnode，做对比找出最小变化，执行 DOM 操作，返回 vnode。把 vnode 转换为真实 DOM，这里执行完，页面就会有显示了，初始化过程就结束了。这里的 vnode 就是组件对应的整棵虚拟 DOM 树，首先进行组件的整棵 vnode 树的比较，可能有三种情况：

             * 组件的 new vnode 树不存在就删

             * 组件的 old vnode 树不存在就增：从上到下，创建挂载创建挂载，最后把整棵树创建完毕后一起放到页面中去，然后删除之前的宿主。虚拟 DOM 创建完成了，就要开始执行 patch 了，patch 里发现以前没有现在有，所以要执行一次创建元素，要把 vnode 批量创建成 DOM 元素，在创建 DOM 树的过程中就要做组件实例的创建和挂载。

               * createElm：把 vnode 变成真实 DOM，根组件执行更新函数时，会递归创建子元素和子组件，首次执行 _update() 时，patch() 会通过 createElm() 创建根元素，子元素创建研究从这里开始。
                 * createComponent()：如果要创建的是组件，走这个流程
                   * 获取创建组件 vnode 时安装的组件管理钩子并执行，创建组件实例并挂载
                   * initComponent()：组件实例的属性，事件，样式等初始化
                     * invokeCreateHooks()：执行属性相关的钩子，如事件监听 updateDOMListeners()
                   * insert()：该组件对应的 DOM 树枝插入父组件的 DOM 树上的操作
                 * 原生标签的创建，把之前得到的 vnode 转换为真实的 DOM
                   * createChildren()：递归创建子元素
                   * invokeCreateHooks()：执行属性相关的钩子，如事件监听 updateDOMListeners()
                     * addEventListener()：原生的事件监听
                   * insert()：该组件对应的 DOM 树枝插入父组件的 DOM 树上的操作

             * 都存在就执行 diff 执行更新。

               * patchVnode：diff 算法发生的地方。对组件的整棵 vnode 树中的每个 vnode 节点进行比较。自顶向下，从最顶层的根节点开始比较，判断是一个节点，对这个节点本身做打补丁操作，这个操作主要是该节点本身的属性更新操作。深度优先：有孩子先比孩子调用 updateChildren，updateChildren 中还会调用 patchVnode，一直向下递归，直到该分支上没有孩子为止，将每个 vnode 节点都 patch 一遍。

                 * isPatchable(vnode)：节点属性更新，根据平台特性拿出属性的更新函数并传入新老 vnode 去执行属性的更新。

                 * 当新老节点都无子节点的时候，只是文本的替换。

                 * 如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点。 

                 * 当新节点没有子节点而老节点有子节点的时候，则移除该节点的所有子节点。

                 * 新老节点均有子节点，则对子节点进行 Diff 操作，调用 updateChildren。

                   * updateChildren：同级比较，深度优先的递归走完后，再比同一级别数组的下一个节点，直到全部比较完成。

                     比较的过程同时做了 DOM 操作，DOM 操作也是微任务，所以浏览器会等这些 Diff 过程中的 DOM 操作都做完后才统一刷新。

                     updateChildren 主要作用是用一种较高效的方式比对新旧两个 VNode 的 children 得出最小操作补丁。

                     两个数组的比较方式：大部分操作都是有规律的，前后插入或正序倒序等。所以为了提高效率，会做一些假设，就是在新老孩子数组的首尾很有可能找到相同的节点，这样就避免做循环了，方法是设置双指针，首尾都没有找到相同的节点还是要做双循环。

                     找到相同的节点做该节点本身的打补丁操作，移动节点位置，移动指针做下一个节点的对比。

       * 构建组件实例的时候，创建了一个和组件实例相关的 Watcher，传入更新函数，初始化过程 Watcher 会执行一次更新函数，以后有更新，Watcher 会让更新函数再次执行。

##### 总结

组件配置 => VueComponent 实例 => render() => Virtual DOM => DOM。

数据发生变化，渲染函数会再次执行，得到全新的虚拟 DOM，通过新旧虚拟 DOM 比对得到最小 DOM 操作，最后把虚拟 DOM 再变成真实的 DOM。

组件声明了之后，接下来一定会去创建实例和挂载。创建实例了才能够走 Vue 中的流程，挂载了才能跟 DOM 有联系。

组件是可复用的 VueComponent 实例，继承自 Vue。

虚拟 DOM 是真实 DOM 的映射，用来描述真实 DOM 的 JS 对象。

组件化机制就是从 new Vue().$mount() 创建根组件实例和挂载的过程开始，先处理组件自身的 DOM 元素和属性，然后创建子组件，子组件会在组件的 patch 过程中实例化和挂载，再走一遍子组件的上述的过程，就这样一层一层的向下创建，直到完成整个树的创建。自定义组件创建有两个关键的过程，一个是 vnode 的创建过程，一个是 vnode 转真实 DOM 的过程，这两个过程的关键方法都叫创建组件 createComponent。一个是安装组件的实例化和挂载的，一个是调用组件的实例化和挂载的。

有几个组件 _init 就会执行几次了，从根组件开始向下依次执行。

首次 render 时，会得到整棵树的 VNode 结构。

组件创建和挂载顺序：组件创建顺序自上而下，组件挂载顺序自下而上，这里的挂载指的不是 $mount，而是实际的 dom 插入父级的时机。







## 性能优化

组件分割

缓存

Tree shaking

原则：多使用内存缓存，减少计算，减少网络请求

方向：加载页面要更快，页面渲染要更快，页面操作要更流畅

让网页加载的更快，渲染的更快，运行的更流畅。

* 让加载更快：减少网络加载耗时。

  * 减少资源体积：压缩代码，js 代码，css 代码，图片都可以压缩。
  * 减少访问次数：合并代码，ssr 服务端渲染（会将首屏页面和内容一起返回，减少一次 ajax 请求页面内容的时间，加速首屏渲染。），缓存
  * 使用 cdn 

* 让渲染更快：减少 cpu 计算量。多使用内存、缓存或其他方法。（空间换时间）

  * css 放在 head 里面

    在dom树生成完成之前就把 css 规则给它加载完，当 dom 树生成完之后直接和所有的 css 整合生成一个渲染树，生成一个 Render Tree，然后一步渲染完成，这样的话就不要再出现重复了。

  * js 放到 body 最下面

    因为 js 执行和 dom 渲染都是使用的渲染进程的主线程。防止一个页面渲染的过程比较长，让用户尽早的看到渲染后的页面，不要让 js 阻碍 dom 渲染。

  * 尽早执行 js

    window.onload：网页全部资源加载完才会执行，包括图片，视频等。

    window.DOMContentLoaded：dom 渲染完即可执行，此时图片，视频可能还没有加载完。

  * 懒加载：

    列表图片懒加载：把图片地址赋值成一个默认的预览图片 src="preview.png"。把真正的图片地址放到 data-realsrc 里，当判断到图片露出屏幕的时候再去把图片真正的地址赋值到图片的 src 上。

    ```html
    <img id="img1" src="preview.png" data-realsrc="abc.png" />
    
    <script type="text/javascript">
      var img1 = document.getElementById('img1')
      img1.src = img1.getAttribute('data-realsrc')
    </script>
    ```

  * 对 dom 查询进行缓存

  * 频繁 dom 操作，合并到一起插入 dom 结构

  * 节流 throttle 防抖 debounce：你要知道节流防抖是怎么回事，节流防抖不是让渲染更快，而是让渲染更加流畅，是体验性的优化。当然归到让渲染更快，渲染优化里面也没问题。



## 浏览器兼容

##### 浏览器兼容

1.DOM 事件处理程序的兼容写法

```js
var eventshiv = {
  // event兼容
  getEvent: function(event) {
    return event ? event : window.event;
  },

  // 添加事件句柄
  addHandler: function(elem, type, listener) {
    if (elem.addEventListener) {
      elem.addEventListener(type, listener, false)
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, listener)
    } else {
      elem['on' + type] = listener
    }
  },

  // 移除事件句柄
  removeHandler: function(elem, type, listener) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, listener, false)
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, listener)
    } else {
      elem['on' + type] = null
    }
  },

  // 取消默认行为
  preventDefault: function(event) {
    if (event.preventDefault) {
      event.preventDefault()
    } else {
      event.returnValue = false
    }
  },

  // 阻止事件冒泡
  stopPropagation: function(event) {
    if (event.stopPropagation) {
      event.stopPropagation()
    } else {
      event.cancelBubble = true
    }
  }
}
```

2.IE9 以下浏览器不能使用 opacity

```css
.class {  
  filter:alpha(opacity=50);  
  -moz-opacity:0.5;  
  opacity: 0.5;  
}
```

3.图片默认有间距

使用 float 为 img 布局。

4.不同浏览器的标签默认的外补丁和内补丁不同

使用 css reset

5.ajax 写法

IE：ActiveXObject
其他：xmlHttpReuest

## 安全

##### 常见的 web 前端攻击方式有哪些，怎么预防

1.XSS 跨站请求攻击

* 一个博客网站，我发表一篇博客，其中嵌入 \<script> 脚本
* 脚本内容：获取 cookie，发送到我的服务器（服务器配合跨域）
* 发布这篇博客，有人查看它，我轻松收割访问者的 cookie

预防：

* 替换特殊字符，如把 < 变为 \&lt;，把 > 变为 \&gt;
* 这样的话 \<script> 就变为 \<script&gt;，直接显示，而不会作为脚本被执行。只有 html 里面有 script 才会作为脚本被执行
* 前端要替换，后端也要替换，都做总不会有错
* 有 xss npm 工具

2.XSRF 跨站请求伪造

* 你正在购物，看中了某个商品，商品 id 是 100
* 付费接口是 xxx.com/pay?id=100，但没有任何验证
* 我是一个攻击者，我看中了一个商品，id 是 200
* 我向你发送一个电子邮件，邮件标题很吸引人
* 但邮件正文隐藏着 \<img src="xxx.com/pay?id=200" />
* 你一查看邮件，就购买了 id 是 200 的商品

因为你现在正在购物，肯定登录了这个网站了，你就会有用户信息了，图片的地址去访问的时候，你的用户信息已经带过去了。

预防：

* 使用 post 接口，用 img 攻击是攻击不通的，因为 img 的 src 只支持 get 请求
* 增加验证，例如密码，短信验证码，指纹等

## 工程化

##### webpack 和 css

webpack 给 css 提供了相当多的能力和处理方式。

* css-loader 将 css 变成 js
* style-loader 将 js 样式插入 head
* ExtractTextWebpackPlugin 将 css 从 js 中提取出来
* css modules 解决 css 命名冲突的问题
* less-loader sass-loader 等各类预处理器
* postcss-loader postcss 处理

## 算法

##### 排序算法

初级排序：选择排序/插入排序/冒泡排序

高级排序：快速排序/归并排序/堆排序

##### 查找算法

二分查找

线性查找

## TCP 协议

### 一个数据包的“旅程”

下面我将分别从“数据包如何送达主机”“主机如何将数据包转交给应用”和“数据是如何被完整地送达应用程序”这三个角度来为你讲述数据的传输过程。

互联网，实际上是一套理念和协议组成的体系架构。其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍。

互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。比如你现在听的音频数据，是拆分成一个个小的数据包来传输的，并不是一个大的文件一次传输过来的。

### 1. IP：把数据包送达目的主机

数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准。互联网上不同的在线设备都有唯一的地址，地址只是一个数字。

计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

### 2. UDP：把数据包送达应用程序

IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称 UDP。

UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以 IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。

在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。

虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

### 3. TCP：把数据完整地送达应用程序

对于浏览器请求，或者邮件这类要求数据传输可靠性的应用，如果使用 UDP 来传输会存在两个问题：

* 数据包在传输过程中容易丢失；
* 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。

基于这两个问题，我们引入 TCP 了。TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:

* 对于数据包丢失的情况，TCP 提供重传机制；
* TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

下面我们再看下完整的 TCP 连接过程，通过这个过程你可以明白 TCP 是如何保证重传机制和数据包的排序功能的。

从下图可以看出，一个完整的 TCP 连接的生命周期包括了“建立连接“传输数据”和“断开连接”三个阶段。

![一个TCP连接的生命周期](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/一个TCP连接的生命周期.png)

* **首先，建立连接阶段**。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
* **其次，传输数据阶段**。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
* **最后，断开连接阶段**。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

到这里你应该就明白了，TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

## HTTP 请求流程

在上一篇文章中我介绍了 TCP 协议是如何保证数据完整传输的，相信你还记得，一个 TCP 连接过程包括了建立连接、传输数据和断开连接三个阶段。

而 HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。

### 浏览器端发起 HTTP 请求流程

如果你在浏览器地址栏里键入极客时间网站的地址：http://time.geekbang.org/index.html， 那么接下来，浏览器会完成哪些动作呢？下面我们就一步一步详细“追踪”下。

#### 1. 构建请求

首先，浏览器构建请求行信息，构建好后，浏览器准备发起网络请求。

```
GET /index.html HTTP1.1
```

#### 2. 查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。

当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：

* 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
* 对于网站来说，缓存是实现快速资源加载的重要组成部分。

如果缓存查找失败，就会进入网络请求过程了。

#### 3. 准备 IP 地址和端口

在了解网络请求之前，我们需要先看看 HTTP 和 TCP 的关系。因为浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的，你可以结合下图更好地理解这二者的关系。

![TCP 和 HTTP 的关系示意图](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/TCP 和 HTTP 的关系示意图.png)

那接下来你可以思考这么“一连串”问题：

* HTTP 网络请求的第一步是做什么呢？结合上图看，是和服务器建立 TCP 连接。
* 那建立连接的信息都有了吗？上一篇文章中，我们讲到建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。
* 那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？

在上一篇文章中，我们介绍过数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如极客时间网站的 IP 是 39.106.233.176,  难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。

所以，这样一路推导下来，你会发现在第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。

拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。

#### 4. 等待 TCP 队列

现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？

答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。

当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。

#### 5. 建立 TCP 连接

排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。

#### 6. 发送 HTTP 请求

一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。

![HTTP 请求数据格式](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/HTTP 请求数据格式.png)

首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。

发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。

另外一个常用的请求方法是 POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。

在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。

### 服务器端处理 HTTP 请求流程

历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。

#### 1. 返回请求

一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：

```bash
curl -i  https://time.geekbang.org/
```

注意这里加上了 -i 是为了返回响应行、响应头和响应体的数据，返回的结果如下图所示，你可以结合这些数据来理解服务器是如何响应浏览器的。

![服务器响应的数据格式](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/服务器响应的数据格式.png)

首先服务器会返回响应行，包括协议版本状态码。

并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：

* 最常用的状态码是 200，表示处理成功；
* 如果没有找到页面，则会返回 404。

随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。

发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。

以上这些就是服务器响应浏览器的具体过程。

#### 2. 断开连接

通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：

```
Connection:Keep-Alive 
```

那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。

#### 3. 重定向

到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开 geekbang.org 后，你会发现最终打开的页面地址是 https://www.geekbang.org。

这两个 URL 之所以不一样，是因为涉及到了一个重定向操作。跟前面一样，你依然可以使用 curl 来查看下请求 geekbang.org 会返回什么内容？

```bash
curl -I geekbang.org
```

注意这里输入的参数是 -I，和 -i 不一样，-I 表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示：

![服务器返回响应行和响应头（含重定向格式）](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/服务器返回响应行和响应头（含重定向格式）.jpg)

从图中你可以看到，响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。这也就解释了为什么输入的是 geekbang.org，最终打开的却是 https://www.geekbang.org 了。

不过也不要认为这种跳转是必然的。如果你打开 https://12306.cn，你会发现这个站点是打不开的。这是因为 12306 的服务器并没有处理跳转，所以必须要手动输入完整的 https://www.12306.cn 才能打开页面。

### 总结

完整的 HTTP 请求示意图，用来展现浏览器中的 HTTP 请求所经历的各个阶段。

![HTTP 请求流程示意图](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/HTTP 请求流程示意图.png)

从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。

## 导航流程

下图是从输入 URL 到页面展示完整流程示意图：

![从输入 URL 到页面展示完整流程示意图](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/从输入 URL 到页面展示完整流程示意图.png)

用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。

### 从输入 URL 到页面展示

现在我们知道了浏览器几个主要进程的职责，还有在导航过程中需要经历的几个主要的阶段，下面我们就来详细分析下这些阶段，同时也就解答了开头所说的那道经典的面试题。

#### 1. 用户输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。

* 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。
* 如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 https://time.geekbang.org。

当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。

当前页面没有监听 beforeunload 事件或者同意了继续后续流程，那么浏览器便进入下图的状态：

![开始加载 URL 浏览器状态](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/开始加载 URL 浏览器状态.png)

从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。

#### 2. URL 请求过程

接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。

首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。

接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。

服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）

##### （1）重定向

在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。

##### （2）响应数据类型处理

在处理了跳转信息之后，我们继续导航流程的分析。URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，那么浏览器是如何区分它们呢？

答案是 Content-Type 告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。

![含有 HTML 格式的 Content-Type](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/含有 HTML 格式的 Content-Type.png)

![含有 stream 格式的 Content-Type](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/含有 stream 格式的 Content-Type.png)

如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。

所以，不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

#### 3. 准备渲染进

程默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。

总结来说，打开一个新页面采用的渲染进程策略就是：

* 通常情况下，打开新的页面都会使用单独的渲染进程；
* 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点（拥有相同的协议和根域名）的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

#### 4. 提交文档

所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：

* 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
* 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
* 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
* 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

其中，当浏览器进程确认提交之后，更新内容如下图所示：

![导航完成状态](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/导航完成状态.png)

这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。

#### 5. 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示：

![渲染结束](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/渲染结束.png)

至此，一个完整的页面就生成了。那文章开头的“从输入 URL 到页面展示，这中间发生了什么？”这个过程及其“串联”的问题也就解决了。

### 总结

下面我来简单总结下这篇文章的要点：

* 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。
* Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。
* 浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。

导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁，如果你理解了导航流程，那么你就能完整串起来整个页面显示流程，这对于你理解浏览器的工作原理起到了点睛的作用。

## 渲染流程

### 渲染流程

输入的是 HTML、CSS、JavaScript 数据，经过渲染模块的处理，最终输出为屏幕上的像素。

由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线：

![渲染流水线示意图](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/渲染流水线示意图.png)

按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。内容比较多，在介绍每个阶段的过程中，你应该重点关注以下三点内容：

* 开始每个子阶段都有其输入的内容；
* 然后每个子阶段有其处理过程；
* 最终每个子阶段会生成输出内容。

### 构建 DOM 树

因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

DOM 树的构建过程，你可以参考下图：

![DOM 树构建过程示意图](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/DOM 树构建过程示意图.png)

从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。

为了更加直观地理解 DOM 树，你可以打开 Chrome 的“开发者工具”，选择“Console”标签来打开控制台，然后在控制台里面输入“document”后回车，这样你就能看到一个完整的 DOM 树结构，如下图所示：

图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。

![DOM 可视化](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/DOM 可视化.png)

### 样式计算（Recalculate Style）

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。

#### 1. 把 CSS 转换为浏览器能够理解的结构

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 document.styleSheets，然后就看到如下图所示的结构：

渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。

![styleSheets](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/styleSheets.png)

#### 2. 转换样式表中的属性值，使其标准化

CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

![标准化属性值](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/标准化属性值.png)

#### 3. 计算出 DOM 树中每个节点的具体样式

样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。

![样式的继承过程界面](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/样式的继承过程界面.png)

![DOM 元素最终计算的样式](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/DOM 元素最终计算的样式.png)

### 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。

#### 1. 创建布局树

你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。

布局树的构造过程：

![布局树构造过程示意图](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/布局树构造过程示意图.png)

#### 2. 布局计算

现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。

在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

### 分层

现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？答案依然是否定的。

因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。

要想直观地理解什么是图层，你可以打开 Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况。

渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。

现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

1. 拥有层叠上下文属性的元素会被提升为单独的一层。

   明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。

2. 需要剪裁（clip）的地方也会被创建为图层。

![布局树和图层树关系示意图](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/布局树和图层树关系示意图.png)

### 图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。

试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？通常，你会把你的绘制操作分解为三步：

1. 绘制蓝色背景；
2. 在中间绘制一个红色的圆；
3. 再在圆上绘制绿色三角形。

渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

绘制列表中的指令非常简单，就是让其执行一个简单的绘制操作，比如绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。

![绘制列表](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/绘制列表.png)

### 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，实际的绘制操作是由渲染引擎中的合成线程来完成的。

![渲染进程中的合成线程和主线程](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/渲染进程中的合成线程和主线程.png)

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。

有的图层可以很大，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

基于这个原因，合成线程会将图层划分为图块，这些图块的大小通常是 256x256 或者 512x512，然后合成线程会按照视口附近的图块来优先准备好交给删格化去生成位图。

![图层被划分为图块示意图](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/图层被划分为图块示意图.png)

实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：

通常，栅格化过程都会使用 GPU 来加速生成，渲染进程把生成图块的指令发送给 GPU，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，最终生成位图的操作是在 GPU 中完成的，生成的位图被保存在 GPU 内存中。

![GPU 栅格化](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/GPU 栅格化.png)

### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

### 渲染流水线大总结

好了，我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：

![完整的渲染流水线示意图](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/完整的渲染流水线示意图.png)

结合上图，一个完整的渲染流程大致可总结为如下：

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### 相关概念

有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。

#### 1. 更新了元素的几何属性（重排）

如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

![更新元素的几何属性](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/更新元素的几何属性.png)

#### 2. 更新元素的绘制属性（重绘）

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

![更新元素背景](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/更新元素背景.png)

#### 3. 直接合成阶段

那如果你更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图：

我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

![避开重排和重绘](/Users/zhaoyang/tool/images/前端知识体系/浏览器工作原理/避开重排和重绘.png)


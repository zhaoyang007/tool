
##### 前端主要业务逻辑

* 处理页面显示的数据和接口返回的数据
  * 字段一致时，可以直接使用后端返回的数据字段。
  * 字段不一致时，页面数据字段可以自己定义，然后根据接口返回的数据来拼接处理成页面想要显示的数据，只要返回的数据全部存在就行了。接口返回的数据我们其实只关心返回的数据值，而不是 key。针对接口请求和返回的数据字段处理同理。
* 代码注释可以记录关键的数据结构。
* 前端业务关注的模块：回显，操作，提交

##### 代码规范

* 常量抽成字典使用
* 对象点获取比较多时，考虑用解构，会省去很多代码
* 返回值增加兼容

##### 函数的调用关系

而且回调函数之间只有两层关系，再复杂的结构也可以拆解开成两层两层的关系，最终有互相依赖的函数回调关系的只有那两层。

##### 跨 js 文件的时序问题解决，用回调函数

```js
// page1.js
var ensureGetIdFlag = false
var ensureGetIdCallbackQueue = []
function ensureGetId (callback) {
  if (ensureGetIdFlag === true) {
    callback()
    return
  }
  ensureGetIdCallbackQueue.push(callback)
}
$.ajax({
  url: "",
  data: "",
  type: "",
  success: function (data) {
    ensureGetIdFlag = true
    for(var i = ensureGetIdCallbackQueue.length - 1; i >= 0; i--){
      ensureGetIdCallbackQueue[i](data)
    }
  }
})
// page2.js
ensureGetId(function (data) {})
```

##### 流程图框架

jointjs, jsplumb

##### 会改变原数组的方法

```js
push, pop, shift, unshift, reverse, sort, splice
```

##### 下载文件

a标签

```js
// 静态
<a href="下载地址" download="下载文件名称">点击下载文件</a>
// 动态生成a标签
var downloadElement = document.createElement('a');
downloadElement.href = '下载地址';
downloadElement.download = '文件名'; // 下载后文件名
document.body.appendChild(downloadElement);
downloadElement.style.display = 'none';
downloadElement.click(); // 点击下载
document.body.removeChild(downloadElement); // 下载完成移除元素
```

window.open()

```js
window.open("下载地址");
```

form表单	

```js
// get
var form = document.createElement('form'); // 定义一个form表单 
form.setAttribute('style', 'display:none');
form.setAttribute('method', 'post');
form.setAttribute('action', '下载地址')               
document.body.appendChild(form);               
from.submit(); // 提交表单，实现下载      
// post
var form = document.createElement('form'); // 定义一个form表单
form.setAttribute('style', 'display:none');
form.setAttribute('target', '');
form.setAttribute('method', 'post');
form.setAttribute('action', '下载地址');
var input1 = document.createElement('input'); // 创建查询参数
input1.setAttribute('type', 'hidden');
input1.setAttribute('name', 'param1');
input1.setAttribute('value', 'value1');
document.body.appendChild(form);
form.appendChild(input1);
form.submit(); // 提交表单，实现下载   
```

接口返回的结果为文件流数据时

```js
// 我们需要将文件流转化为Blob形式，再讲Blob数据转化为下载的链接，即可下载。
var blob = new Blob([后台返回的文件流数据], {type: 'application/x-rar-compressed'});//转化为Blob形式，type为文件类型
var href = window.URL.createObjectURL(blob); // 创建下载的链接
var downloadElement = document.createElement('a'); // 创建a标签
downloadElement.href = href;//a标签中加入下载链接
downloadElement.download = '文件名'; // 下载后文件名
document.body.appendChild(downloadElement);
downloadElement.style.display = 'none';
downloadElement.click(); // 点击下载
document.body.removeChild(downloadElement); // 下载完成移除元素
window.URL.revokeObjectURL(href); // 释放掉blob对象
```

##### findLastIndex

```js
Array.prototype.fakeFindLastIndex = function(cb, context) {
  let array = this;
  for (let i = array.length-1; i >=0; i--) {
    const element = array[i];
    if (cb.call(context, element, i, array)) {
      return i;
    }
  }
  return -1;
}	
```

##### 如何捕获 js 程序中的异常

```js
// 1.手动捕获异常
// 这种方式用的比较常见，觉得哪个地方可能会风险比较高，那就用一个try catch给它包起来，然后有异常就输出
try {
  // todo
} catch (ex) {
  console.error(ex) // 手动捕获catch
} finally {
  // todo
}
// 2.自动捕获异常
// 一种兜底方案，比如说我们想要监听一下前端页面，已经上线了，我们做一个统计监听，我们看一下前端页面有没有什么js错误，一般我们第一种方式就是用上面的方式在该try catch的地方打上try catch，如果catch到我们就发一个统计打点，作为一个记录。第二种方式就是我们不可能每一行都用try catch。这样成本太高。我们只在一个高风险的地方用try catch，其他地方我们用一个window.onerror就可以了。它会自动捕获你程序中的一些问题。
window.onerror = function (message, source, lineNum, colNum, error) {
  // 报错信息 源码 行号 列号 错误栈
  // 第一，对跨域的js，如cdn，会告诉你错误了，但不会有详细的报错信息
  // 第二，对于压缩的js，还要配合sourceMap去反查到为压缩代码的行，列
}
//所以通过这两个方式来集合，你就能监听到页面上绝大部分的错误。
```

##### rem  根据根元素的字体大小搞来搞去

```css
html {
  font-size: 62.5%; /* 10÷16=62.5% */
}
@media only screen and (min-width: 481px){
  html {
    font-size: 94%!important; /* 15.04÷16=94% */
  }
}
@media only screen and (min-width: 561px){
  html {
    font-size: 109%!important; /* 17.44÷16=109% */
  }
}
@media only screen and (min-width: 641px){
  html {
    font-size: 125%!important; /* 20÷16=125% */
  }
}
```

##### 禁用手型

```css
div {
	cursor: not-allowed;
}
```

##### 文字超出末尾显示省略号

```css
div {
  width: 200px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
```

##### 是否可选择文本

```css
div {
  user-select: none; /* none用户不能选择文本，text用户可以选择文本 */
}
```

##### css reset

https://meyerweb.com/eric/tools/css/reset/

https://yuilibrary.com/yui/docs/cssreset

https://necolas.github.io/normalize.css/

##### height

* height 不会继承，在所有元素都不设置高度的情况下，如果想给某个元素设置 height: 100% 需要从 html 开始，每一层都要设置 height: 100%，才会有效。
* 父级元素的高度会被设置了高度的子元素撑开，高度就为子元素的高度。

##### 字体

指定字体：

```
body {
  font-family: 'PingFang SC', 'Microsoft Yahei', serif;
}
```

自定义字体：

```
@font-face {
  font-family: 'IF';
  src: url('./IndieFlower.ttf');
}
.custom-font {
  font-family: 'IF';
}
```

iconfont: 

既然可以自定义字体，所谓自定义字体原理就是规定每个字长什么样，如果规定每个字是图标的样子，就可以把文字当做图标用了。

##### 强制类型转换

```js
/* 字符串转数字 */
// 1.parseInt(string, radix)
// 把 string 以 radix 进制解析成十进制整数，radix 默认是十进制
parseInt('11') // 11
parseInt('11', 2) // 3 
// 如果字符串前缀是 "0x" 或者 "0X"，则 parseInt 将其解释为十六进制数
parseInt('0x11') // 17
// 解析时会跳过空格，只解析字符串中的第一个数字，如果第一个非空格字符是非数字字符，则返回 NaN。
parseInt(' 11fagg') // 11
parseInt('a') // NaN
// 2.parseFloat(string) 
// 以十进制解析成十进制整数或浮点数。
parseFloat('11') // 11
parseFloat('11.3') // 11.3
// 解析时会跳过空格，只解析字符串中的第一个数字，如果第一个非空格字符是非数字字符，则返回 NaN。
parseInt(' 11fagg') // 11
parseInt('a') // NaN
// 3.Number(object)
// 将对象整体的值以十进制转换为十进制整数或浮点数的数字，如果对象整体的值无法转换为数字，返回 NaN。
Number('11') // 11
Number('11aa') // NaN
// 参数是 Boolean 值，返回 1 和 0。
// 参数是 null 值，返回 0。
// 参数是 undefined，返回 NaN。
// 参数是 Date 对象，返回从 1970 年 1 月 1 日至今的毫秒数。

/* 数字转字符串 */
// 1.Number 类定义的 toString(radix) 方法：把数字以十进制转为 radix 进制字符串，不指定此参数，转为十进制。
let a = 10;
a.toString() // '10'
a.toString(2) // '1010'
// 2.Number 类定义的 toFixed(x) 方法：把数字四舍五入为指定小数位数 x 的字符串。
let a = 10.156
a.toFixed(2) // '10.16'
```

##### sort(sortBy)

用于数组排序。

参数：可选，规定排序顺序，必须是函数。

如果没有使用参数，把数组的元素都转换成字符串（如有必要），按照字符编码的顺序进行排序。

如果想按照其他标准进行排序，需要提供比较函数，该函数接收要比较的两个值 a 和 b，返回一个用于说明这两个值的相对顺序的数字：

* a 小于 b，返回负数，升序
* a 大于 b，返回正数，升序
* a 小于 b，返回正数，降序
* a 大于 b，返回负数，降序
* a 等于 b，返回 0

```js
// 对象型数组，按某个对象的key做升降序排列
function compare(prop, order) {
  return function (obj1, obj2) {
    var val1 = obj1[prop];
    var val2 = obj2[prop];
    if (!isNaN(Number(val1)) && !isNaN(Number(val2))) {
      val1 = Number(val1);
      val2 = Number(val2);
    }
    if (val1 < val2) {
      if (order === 'ascending') {
        return -1
      } else {
        return 1
      }
    } else if (val1 > val2) {
      if (order === 'ascending') {
        return 1
      } else {
        return -1
      }
    } else {
      return 0;
    }
  }
}
const arr = [
  {a: 1, b: 2, c: 3},
  {a: 3, b: 2, c: 3},
  {a: 2, b: 2, c: 3},
]
arr.sort(compare('a', 'ascending'))
```

##### cookie

cookie 本身是用于浏览器端和 server 端通讯的，也就是 http 请求的一部分。

早期没有专门的本地存储，只能用 cookie 来做本地存储。

cookie api：

cookie是个字符串，中间用分号分割，每一部分都是key=value的形式。

```js
document.cookie = 'key=value;path=path;domain=domain;max-age=max-age-in-seconds;expires=date-in-GMTString-format;secure'
```

每次赋值，相同的key会覆盖，不同key会追加：

```js
document.cookie = 'a=100'
console.log(document.cookie) // 'a=100'
document.cookie = 'b=200'
console.log(document.cookie) // 'a=100; b=200'
document.cookie = 'a=300'
console.log(document.cookie) // 'b=200; a=300'
```

简化`document.cookie` 的获取方法

```js
var docCookies = {
  getItem: function (sKey) {
    return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[-.+*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
  },
  setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
    if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
    var sExpires = "";
    if (vEnd) {
      switch (vEnd.constructor) {
        case Number:
          sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
          break;
        case String:
          sExpires = "; expires=" + vEnd;
          break;
        case Date:
          sExpires = "; expires=" + vEnd.toUTCString();
          break;
      }
    }
    document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
    return true;
  },
  removeItem: function (sKey, sPath, sDomain) {
    if (!sKey || !this.hasItem(sKey)) { return false; }
    document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + ( sDomain ? "; domain=" + sDomain : "") + ( sPath ? "; path=" + sPath : "");
    return true;
  },
  hasItem: function (sKey) {
    return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[-.+*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
  },
  keys: /* optional method: you can safely remove it! */ function () {
    var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
    for (var nIdx = 0; nIdx < aKeys.length; nIdx++) { aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); }
    return aKeys;
  }
};

// 使用
docCookies.setItem("test0", "Hello world!");
docCookies.setItem("test1", "Unicode test: \u00E0\u00E8\u00EC\u00F2\u00F9", Infinity);
docCookies.setItem("test2", "Hello world!", new Date(2020, 5, 12));
docCookies.setItem("test3", "Hello world!", new Date(2027, 2, 3), "/blog");
docCookies.setItem("test4", "Hello world!", "Sun, 06 Nov 2022 21:43:15 GMT");
docCookies.setItem("test5", "Hello world!", "Tue, 06 Dec 2022 13:11:07 GMT", "/home");
docCookies.setItem("test6", "Hello world!", 150);
docCookies.setItem("test7", "Hello world!", 245, "/content");
docCookies.setItem("test8", "Hello world!", null, null, "example.com");
docCookies.setItem("test9", "Hello world!", null, null, null, true);
docCookies.setItem("test1;=", "Safe character test;=", Infinity);
 
alert(docCookies.keys().join("\n"));
alert(docCookies.getItem("test1"));
alert(docCookies.getItem("test5"));
docCookies.removeItem("test1");
docCookies.removeItem("test5", "/home");
alert(docCookies.getItem("test1"));
alert(docCookies.getItem("test5"));
alert(docCookies.getItem("unexistingCookie"));
alert(docCookies.getItem());
alert(docCookies.getItem("test1;="));
```

##### 服务端口占用

```bash
# 1.查看端口使用情况
sudo lsof -i :3000
# 2.杀死进程
sudo kill -9 30778
```

##### 点击按钮出现内容

* 点击按钮出现内容，再次点击页面任何地方，内容消失。
* 再次点击按钮，内容不消失
* 再次点击内容，内容可能消失，可能不消失。

在 document 上加点击事件，事件回调中用 contains 判断，点击的不是让内容消失的元素时，才让内容隐藏。

```vue
<template>
	<div>
    <button class="button">按钮</button>
    <div class="content" v-if="show">内容</div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      show: false
    }
  },
	mounted() {
    const btn = document.getElementsByClassName('button')[0]
    const content = document.getElementsByClassName('content')[0]
    document.addEventListener('click', e => {
      if (!btn.contains(e.target) && !content.contains(e.target)) {
         this.show = false
      }
    })
  }
}
</script>
```

##### 动态设置某元素高度

```vue
<template>
  <div :class="classNames" :ref="classNames">
    <div :class="classNames+ '_header'">
      <img src="./img/user.svg" alt="">
      <div :class="classNames+ '_header_con'">
        <h5>{{user.name}}</h5>
        <p>{{user.desc}}</p>
      </div>
    </div>
    <div :class="classNames+ '_content'">
      <tabs :data="tabsList" v-model="tabsActTit" type="bg" :class="classNames+ '_bg'" @changeTabs="changeTabs"></tabs>
      <tabs :data="tabsLists" v-model="tabsActTits" type="line" @changeTabs="changeChildTabs" v-if="tabsActTit!=='浏览历史'"></tabs>
      <div ref="list" :class="classNames + '_list_con'">
        <do-list v-if="!isBrowse" doc-type="list" @currChange="onCurrChange" :loading="loading" :list="list" :page="page" :content-height="listHeight" :class="classNames+'_list'" send-type="iframe" @sort="onSort" ref="history_list"></do-list>
        <browse-history :content-height="listHeight" v-else/>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      classNames: 'history'
      listHeight: 0
    }
  },
  mounted() {
    this.$nextTick(() => {
      setTimeout(() => {
        this.listHeight = this.$refs[this.classNames].clientHeight - this.$refs.list.getBoundingClientRect().top - 52
      }, 200)
    })
  }
}
</script>
```

##### 列表标题吸顶效果

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    body {
      padding-top: 50px;
    }
    .wrapper {
      height: 600px;
      outline: 1px solid #333;
      position: relative;
    }
    .head-list {
      position: absolute;
      top: 0px;
      left: 0;
      padding-left: 20px;
    }
    #scroll-wrapper {
      height: 100%;
      overflow: scroll;
    }
    .head-item {
      height: 30px;
      line-height: 30px;
      background-color: #fff;
      border: 1px solid #ddd;
    }
    .content-item h3,
    .content-item ul li {
      height: 30px;
      line-height: 30px;
      background-color: #ccc;
      padding-left: 20px;
      border-bottom: 1px solid #ddd;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <div class="wrapper" id="wrap">
    <div class="head-list">
      <!-- <div class="head-item">2020-03-04</div>
      <div class="head-item">2020-03-04</div>
      <div class="head-item">2020-03-04</div> -->
    </div>
    <div id="scroll-wrapper">
      <div class="content-list">
        <div class="content-item">
          <h3>标题1</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
        <div class="content-item">
          <h3>标题2</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
        <div class="content-item">
          <h3>标题3</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
        <div class="content-item">
          <h3>标题4</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
        <div class="content-item">
          <h3>标题5</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
        <div class="content-item">
          <h3>标题6</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
        <div class="content-item">
          <h3>标题7</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
        <div class="content-item">
          <h3>标题8</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
        <div class="content-item">
          <h3>标题9</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
        <div class="content-item">
          <h3>标题10</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
        <div class="content-item">
          <h3>标题11</h3>
          <ul>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
            <li>2020-03-04</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <script>
    const contentItem = document.getElementsByClassName('content-item')
    let arr = []
    let scrollTop = 0
    document.getElementById('scroll-wrapper').addEventListener('scroll', function(e) {
      // 内容向上滚动
      if (e.target.scrollTop > scrollTop) {
        let currentElem = Array.from(contentItem).slice().reverse().find(item => e.target.scrollTop + document.getElementsByClassName('head-list')[0].clientHeight > item.offsetTop)
        // 拿到当前元素的h3的内容
        let date = currentElem.getElementsByTagName('h3')[0].innerHTML
        if (!arr.includes(date)) {
          // 把内容放入要生成head-item元素的数组
          arr.push(date)
        }
      // 内容向下滚动
      } else {
        let currentElem = Array.from(contentItem).slice().find(item => e.target.scrollTop + document.getElementsByClassName('head-list')[0].clientHeight < item.offsetTop + document.getElementsByTagName('h3')[0].clientHeight)
        // 拿到当前元素的h3的内容
        let date = currentElem.getElementsByTagName('h3')[0].innerHTML
        if (arr.includes(date)) {
          // 把内容从数组中移除
          arr.splice(arr.findIndex(item => item === date), 1)
        }
        if (e.target.scrollTop <= 30) {
          arr = []
        }
      }
      // 将得到的arr生成元素插入到head-list
      document.getElementsByClassName('head-list')[0].innerHTML = ''
      if (arr.length > 0) {
        arr.forEach(item => {
          let headItem = document.createElement('div')
          headItem.setAttribute("class", "head-item")
          headItem.innerHTML = item
          document.getElementsByClassName('head-list')[0].appendChild(headItem)
        })
      }
      // 记录每次滚动结束的位置
      scrollTop = e.target.scrollTop
    })
  </script>
</body>
</html>
```

##### 移动端1像素边框实现

```css
@charset "utf-8";
.border,
.border-top,
.border-right,
.border-bottom,
.border-left,
.border-topbottom,
.border-rightleft,
.border-topleft,
.border-rightbottom,
.border-topright,
.border-bottomleft {
    position: relative;
}
.border::before,
.border-top::before,
.border-right::before,
.border-bottom::before,
.border-left::before,
.border-topbottom::before,
.border-topbottom::after,
.border-rightleft::before,
.border-rightleft::after,
.border-topleft::before,
.border-topleft::after,
.border-rightbottom::before,
.border-rightbottom::after,
.border-topright::before,
.border-topright::after,
.border-bottomleft::before,
.border-bottomleft::after {
    content: "\0020";
    overflow: hidden;
    position: absolute;
}
/* border
 * 因，边框是由伪元素区域遮盖在父级
 * 故，子级若有交互，需要对子级设置
 * 定位 及 z轴
 */
.border::before {
    box-sizing: border-box;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    border: 1px solid #eaeaea;
    transform-origin: 0 0;
}
.border-top::before,
.border-bottom::before,
.border-topbottom::before,
.border-topbottom::after,
.border-topleft::before,
.border-rightbottom::after,
.border-topright::before,
.border-bottomleft::before {
    left: 0;
    width: 100%;
    height: 1px;
}
.border-right::before,
.border-left::before,
.border-rightleft::before,
.border-rightleft::after,
.border-topleft::after,
.border-rightbottom::before,
.border-topright::after,
.border-bottomleft::after {
    top: 0;
    width: 1px;
    height: 100%;
}
.border-top::before,
.border-topbottom::before,
.border-topleft::before,
.border-topright::before {
    border-top: 1px solid #eaeaea;
    transform-origin: 0 0;
}
.border-right::before,
.border-rightbottom::before,
.border-rightleft::before,
.border-topright::after {
    border-right: 1px solid #eaeaea;
    transform-origin: 100% 0;
}
.border-bottom::before,
.border-topbottom::after,
.border-rightbottom::after,
.border-bottomleft::before {
    border-bottom: 1px solid #eaeaea;
    transform-origin: 0 100%;
}
.border-left::before,
.border-topleft::after,
.border-rightleft::after,
.border-bottomleft::after {
    border-left: 1px solid #eaeaea;
    transform-origin: 0 0;
}
.border-top::before,
.border-topbottom::before,
.border-topleft::before,
.border-topright::before {
    top: 0;
}
.border-right::before,
.border-rightleft::after,
.border-rightbottom::before,
.border-topright::after {
    right: 0;
}
.border-bottom::before,
.border-topbottom::after,
.border-rightbottom::after,
.border-bottomleft::after {
    bottom: 0;
}
.border-left::before,
.border-rightleft::before,
.border-topleft::after,
.border-bottomleft::before {
    left: 0;
}
@media (max--moz-device-pixel-ratio: 1.49), (-webkit-max-device-pixel-ratio: 1.49), (max-device-pixel-ratio: 1.49), (max-resolution: 143dpi), (max-resolution: 1.49dppx) {
    /* 默认值，无需重置 */
}
@media (min--moz-device-pixel-ratio: 1.5) and (max--moz-device-pixel-ratio: 2.49), (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49), (min-device-pixel-ratio: 1.5) and (max-device-pixel-ratio: 2.49), (min-resolution: 144dpi) and (max-resolution: 239dpi), (min-resolution: 1.5dppx) and (max-resolution: 2.49dppx) {
    .border::before {
        width: 200%;
        height: 200%;
        transform: scale(.5);
    }
    .border-top::before,
    .border-bottom::before,
    .border-topbottom::before,
    .border-topbottom::after,
    .border-topleft::before,
    .border-rightbottom::after,
    .border-topright::before,
    .border-bottomleft::before {
        transform: scaleY(.5);
    }
    .border-right::before,
    .border-left::before,
    .border-rightleft::before,
    .border-rightleft::after,
    .border-topleft::after,
    .border-rightbottom::before,
    .border-topright::after,
    .border-bottomleft::after {
        transform: scaleX(.5);
    }
}
@media (min--moz-device-pixel-ratio: 2.5), (-webkit-min-device-pixel-ratio: 2.5), (min-device-pixel-ratio: 2.5), (min-resolution: 240dpi), (min-resolution: 2.5dppx) {
    .border::before {
        width: 300%;
        height: 300%;
        transform: scale(.33333);
    }
    .border-top::before,
    .border-bottom::before,
    .border-topbottom::before,
    .border-topbottom::after,
    .border-topleft::before,
    .border-rightbottom::after,
    .border-topright::before,
    .border-bottomleft::before {
        transform: scaleY(.33333);
    }
    .border-right::before,
    .border-left::before,
    .border-rightleft::before,
    .border-rightleft::after,
    .border-topleft::after,
    .border-rightbottom::before,
    .border-topright::after,
    .border-bottomleft::after {
        transform: scaleX(.33333);
    }
}
```

##### Javascript 固有对象 API

在自己的浏览器中计算出来 JavaScript 有多少固有对象。

```js
var set = new Set()
var objects = [
  eval,
  isFinite,
  isNaN,
  parseFloat,
  parseInt,
  decodeURI,
  decodeURIComponent,
  encodeURI,
  encodeURIComponent,
  Array,
  Date,
  RegExp,
  Promise,
  Proxy,
  Map,
  WeakMap,
  Set,
  WeakSet,
  Function,
  Boolean,
  String,
  Number,
  Symbol,
  Object,
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError,
  ArrayBuffer,
  SharedArrayBuffer,
  DataView,
  Float32Array,
  Float64Array,
  Int8Array,
  Int16Array,
  Int32Array,
  Uint8Array,
  Uint16Array,
  Uint32Array,
  Uint8ClampedArray,
  Atomics,
  JSON,
  Math,
  Reflect]
objects.forEach(o => set.add(o))

for(var i = 0; i < objects.length; i++) {
  var o = objects[i]
  for(var p of Object.getOwnPropertyNames(o)) {
    var d = Object.getOwnPropertyDescriptor(o, p)
    if( (d.value !== null && typeof d.value === "object") || (typeof d.value === "function"))
      if(!set.has(d.value))
        set.add(d.value), objects.push(d.value)
    if( d.get )
      if(!set.has(d.get))
        set.add(d.get), objects.push(d.get)
    if( d.set )
      if(!set.has(d.set))
        set.add(d.set), objects.push(d.set)
  }
}
```

JavaScript 所有固有对象：

mac系统：Google Chrome：版本 79.0.3945.130（正式版本） （64 位）：总共 989 个 JavaScript 固有对象。

主要使用 Object.getOwnPropertyNames, Object.getOwnPropertyDescriptor 两种方法。

全部的 JavaScript 固有对象基本包含：

* 函数
* 函数中的 prototype 属性
* 构造器
* 构造器中的 object 和 functions 还有 get set 的属性，一般就是 function 属性和 get set 属性
* 构造器原型
* 构造器原型中的 object 和 function 还有 get set 的属性，一般就是 function 属性和 get set 属性
* Atomics, JSON, Math, Reflect
* Atomics, JSON, Math, Reflect 中的 object 和 function 还有 get set 的属性，一般就是 function 属性和 get set 属性

1.三个值：（3）

```
Infinity、NaN、undefined
```

2.九个函数：（11）

```js
eval
isFinite
isNaN
parseFloat
	parseFloat.prototype: {constructor: ƒ parseFloat()}
parseInt
	parseInt.prototype: {constructor: ƒ parseInt()}
decodeURI
decodeURIComponent
encodeURI
encodeURIComponent
```

3.一些构造器：（共880个）

```js
		Array: function Array() { [native code] }（共65个）
      function isArray() { [native code] }
      function from() { [native code] }
      function of() { [native code] }
      function () { [native code] } // pop
      function () { [native code] } // reverse
      function () { [native code] } // shift
      function () { [native code] } // keys
      function () { [native code] } // values
      function () { [native code] } // entries
      function () { [native code] } // indexOf
      function () { [native code] } // every
      function () { [native code] } // some
      function () { [native code] } // forEach
      function () { [native code] } // map
      function () { [native code] } // filter
      function () { [native code] } // find
      function () { [native code] } // findIndex
      function () { [native code] } // includes
      function () { [native code] } // join
      function () { [native code] } // slice
      function () { [native code] } // concat
      function () { [native code] } // push
      function () { [native code] } // splice
      function () { [native code] } // unshift
      function () { [native code] } // sort
      function () { [native code] } // lastIndexOf
      function () { [native code] } // reduce
      function () { [native code] } // reduceRight
      function () { [native code] } // copyWithin
      function () { [native code] } // fill
      Array.prototype: Array(0)，是个数组
        function concat() { [native code] }
        function copyWithin() { [native code] }
        function fill() { [native code] }
        function find() { [native code] }
        function findIndex() { [native code] }
        function lastIndexOf() { [native code] }
        function pop() { [native code] }
        function push() { [native code] }
        function reverse() { [native code] }
        function shift() { [native code] }
        function unshift() { [native code] }
        function slice() { [native code] }
        function sort() { [native code] }
        function splice() { [native code] }
        function includes() { [native code] }
        function indexOf() { [native code] }
        function join() { [native code] }
        function keys() { [native code] }
        function entries() { [native code] }
        function values() { [native code] }
        function forEach() { [native code] }
        function filter() { [native code] }
        function flat() { [native code] }
        function flatMap() { [native code] }
        function map() { [native code] }
        function every() { [native code] }
        function some() { [native code] }
        function reduce() { [native code] }
        function reduceRight() { [native code] }
        function toLocaleString() { [native code] }
        function toString() { [native code] }
        function flatten() { [native code] }
          flatten.prototype: {constructor: ƒ flatten()}
    Date: function Date() { [native code] }（共50个）
      function now() { [native code] }
      function parse() { [native code] }
      function UTC() { [native code] }
      Date.prototype: Object
        function toString() { [native code] }
        function toDateString() { [native code] }
        function toTimeString() { [native code] }
        function toISOString() { [native code] }
        function toUTCString() { [native code] }
        function getDate() { [native code] }
        function setDate() { [native code] }
        function getDay() { [native code] }
        function getFullYear() { [native code] }
        function setFullYear() { [native code] }
        function getHours() { [native code] }
        function setHours() { [native code] }
        function getMilliseconds() { [native code] }
        function setMilliseconds() { [native code] }
        function getMinutes() { [native code] }
        function setMinutes() { [native code] }
        function getMonth() { [native code] }
        function setMonth() { [native code] }
        function getSeconds() { [native code] }
        function setSeconds() { [native code] }
        function getTime() { [native code] }
        function setTime() { [native code] }
        function getTimezoneOffset() { [native code] }
        function getUTCDate() { [native code] }
        function setUTCDate() { [native code] }
        function getUTCDay() { [native code] }
        function getUTCFullYear() { [native code] }
        function setUTCFullYear() { [native code] }
        function getUTCHours() { [native code] }
        function setUTCHours() { [native code] }
        function getUTCMilliseconds() { [native code] }
        function setUTCMilliseconds() { [native code] }
        function getUTCMinutes() { [native code] }
        function setUTCMinutes() { [native code] }
        function getUTCMonth() { [native code] }
        function setUTCMonth() { [native code] }
        function getUTCSeconds() { [native code] }
        function setUTCSeconds() { [native code] }
        function valueOf() { [native code] }
        function getYear() { [native code] }
        function setYear() { [native code] }
        function toJSON() { [native code] }
        function toLocaleString() { [native code] }
        function toLocaleDateString() { [native code] }
        function toLocaleTimeString() { [native code] }
    RegExp: function RegExp() { [native code] }（共54个）
      function get input() { [native code] }
      function set input() { [native code] }
      function get $_() { [native code] }
      function set $_() { [native code] }
      function get lastMatch() { [native code] }
      function set lastMatch() { [native code] }
      function get $&() { [native code] }
      function set $&() { [native code] }
      function get lastParen() { [native code] }
      function set lastParen() { [native code] }
      function get $+() { [native code] }
      function set $+() { [native code] }
      function get leftContext() { [native code] }
      function set leftContext() { [native code] }
      function get $`() { [native code] }
      function set $`() { [native code] }
      function get rightContext() { [native code] }
      function set rightContext() { [native code] }
      function get $'() { [native code] }
      function set $'() { [native code] }
      function get $1() { [native code] }
      function set $1() { [native code] }
      function get $2() { [native code] }
      function set $2() { [native code] }
      function get $3() { [native code] }
      function set $3() { [native code] }
      function get $4() { [native code] }
      function set $4() { [native code] }
      function get $5() { [native code] }
      function set $5() { [native code] }
      function get $6() { [native code] }
      function set $6() { [native code] }
      function get $7() { [native code] }
      function set $7() { [native code] }
      function get $8() { [native code] }
      function set $8() { [native code] }
      function get $9() { [native code] }
      function set $9() { [native code] }
      function escape() { [native code] }
        escape.prototype: {constructor: ƒ escape()}
      RegExp.prototype: Object
        function exec() { [native code] }
        function get dotAll() { [native code] }
        function get flags() { [native code] }
        function get global() { [native code] }
        function get ignoreCase() { [native code] }
        function get multiline() { [native code] }
        function get source() { [native code] }
        function get sticky() { [native code] }
        function get unicode() { [native code] }
        function compile() { [native code] }
        function toString() { [native code] }
        function test() { [native code] }
    Promise: function Promise() { [native code] }（共14个）
      function all() { [native code] }
      function race() { [native code] }
      function resolve() { [native code] }
      function reject() { [native code] }
      function allSettled() { [native code] }
      function(){return e.apply(o,arguments)} // finally
        {constructor: ƒ ()}
      function try() { [native code] }
        try.prototype: {constructor: ƒ try()}
      Promise.prototype: Promise
        function then() { [native code] }
        function catch() { [native code] }
        function finally() { [native code] }
    Proxy: function Proxy() { [native code] }（共2个）
      function Proxy() { [native code] }
      function revocable() { [native code] }
    Map: function Map() { [native code] }（共20个）
      function(){return e.apply(o,arguments)} // toJSON
        {constructor: ƒ ()}
      function of() { [native code] }
        of.prototype: {constructor: ƒ of()}
      function from() { [native code] }
        from.prototype: {constructor: ƒ from()}
      Map.prototype: Map
        function get() { [native code] }
        function set() { [native code] }
        function has() { [native code] }
        function delete() { [native code] }
        function clear() { [native code] }
        function entries() { [native code] }
        function forEach() { [native code] }
        function keys() { [native code] }
        function get size() { [native code] }
        function values() { [native code] }
        function toJSON() { [native code] }
          toJSON.prototype: {constructor: ƒ toJSON()}
    WeakMap: function WeakMap() { [native code] }（共10个）
      function of() { [native code] }
        of.prototype: {constructor: ƒ of()}
      function from() { [native code] }
        from.prototype: {constructor: ƒ from()}
      WeakMap.prototype: WeakMap
        function delete() { [native code] }
        function get() { [native code] }
        function set() { [native code] }
        function has() { [native code] }
    Set: function Set() { [native code] }（共18个）
      function(){return e.apply(o,arguments)} // toJSON
        {constructor: ƒ ()}
      function of() { [native code] }
        of.prototype: {constructor: ƒ of()}
      function from() { [native code] }
        from.prototype: {constructor: ƒ from()}
      Set.prototype: Set
        function has() { [native code] }
        function add() { [native code] }
        function delete() { [native code] }
        function clear() { [native code] }
        function entries() { [native code] }
        function forEach() { [native code] }
        function get size() { [native code] }
        function values() { [native code] }
        function toJSON() { [native code] }
          toJSON.prototype: {constructor: ƒ toJSON()}
    WeakSet: function WeakSet() { [native code] }（共9个）
      function of() { [native code] }
        of.prototype: {constructor: ƒ of()}
      function from() { [native code] }
        from.prototype: {constructor: ƒ from()}
      WeakSet.prototype: WeakSet
        function delete() { [native code] }
        function has() { [native code] }
        function add() { [native code] }
    Function: function Function() { [native code] }（共8个）
      function () { [native code] } // 不明
      Function.prototype: function () { [native code] }
        function apply() { [native code] }
        function bind() { [native code] }
        function call() { [native code] }
        function toString() { [native code] }
          toString.prototype: {constructor: ƒ toString()}
    Boolean: function Boolean() { [native code] }（共4个）
      Boolean.prototype: Boolean
        function toString() { [native code] }
        function valueOf() { [native code] }
    String: function String() { [native code] }（共54个）
      function fromCharCode() { [native code] }
      function fromCodePoint() { [native code] }
      function raw() { [native code] }
      String.prototype: String
        function anchor() { [native code] }
        function big() { [native code] }
        function blink() { [native code] }
        function bold() { [native code] }
        function charAt() { [native code] }
        function charCodeAt() { [native code] }
        function codePointAt() { [native code] }
        function concat() { [native code] }
        function endsWith() { [native code] }
        function fontcolor() { [native code] }
        function fontsize() { [native code] }
        function fixed() { [native code] }
        function includes() { [native code] }
        function indexOf() { [native code] }
        function italics() { [native code] }
        function lastIndexOf() { [native code] }
        function link() { [native code] }
        function localeCompare() { [native code] }
        function match() { [native code] }
        function matchAll() { [native code] }
        function normalize() { [native code] }
        function padEnd() { [native code] }
        function padStart() { [native code] }
        function repeat() { [native code] }
        function replace() { [native code] }
        function search() { [native code] }
        function slice() { [native code] }
        function small() { [native code] }
        function split() { [native code] }
        function strike() { [native code] }
        function sub() { [native code] }
        function substr() { [native code] }
        function substring() { [native code] }
        function sup() { [native code] }
        function startsWith() { [native code] }
        function toString() { [native code] }
        function toLocaleLowerCase() { [native code] }
        function toLocaleUpperCase() { [native code] }
        function toLowerCase() { [native code] }
        function toUpperCase() { [native code] }
        function valueOf() { [native code] }
        function trim() { [native code] }
          trim.prototype: {constructor: ƒ trim()}
        function at() { [native code] }
          at.prototype: {constructor: ƒ at()}
        function trimStart() { [native code] }
          trimStart.prototype: {constructor: ƒ trimStart()}
        function trimEnd() { [native code] }
          trimEnd.prototype: {constructor: ƒ trimEnd()}
    Number: function Number() { [native code] }（共16个）
      function isFinite() { [native code] }
      function isInteger() { [native code] }
      function isNaN() { [native code] }
      function isSafeInteger() { [native code] }
      function parseFloat() { [native code] }
        parseFloat.prototype: {constructor: ƒ parseFloat()}
      function parseInt() { [native code] }
        parseInt.prototype: {constructor: ƒ parseInt()}
      Number.prototype: Number
        function toExponential() { [native code] }
        function toFixed() { [native code] }
        function toPrecision() { [native code] }
        function toString() { [native code] }
        function valueOf() { [native code] }
        function toLocaleString() { [native code] }
    Symbol: function Symbol() { [native code] }（共11个）
      "asyncIterator"
      "hasInstance"
      "isConcatSpreadable"
      "iterator"
      "match"
      "matchAll"
      "replace"
      "search"
      "species"
      "split"
      "toPrimitive"
      "toStringTag"
      "unscopables"
      "observable"
      function for() { [native code] }
      function keyFor() { [native code] }
      function useSetter() { [native code] }
        useSetter.prototype: {constructor: ƒ useSetter()}
      function useSimple() { [native code] }
        useSimple.prototype: {constructor: ƒ useSimple()}
      Symbol.prototype: Symbol
        function toString() { [native code] }
        function valueOf() { [native code] }
        function get description() { [native code] }
    Object: function Object() { [native code] }（共35个）
      function assign() { [native code] }
      function getOwnPropertyDescriptor() { [native code] }
      function getOwnPropertyDescriptors() { [native code] }
      function getOwnPropertyNames() { [native code] }
      function getOwnPropertySymbols() { [native code] }
      function is() { [native code] }
      function preventExtensions() { [native code] }
      function seal() { [native code] }
      function create() { [native code] }
      function defineProperties() { [native code] }
      function defineProperty() { [native code] }
      function freeze() { [native code] }
      function getPrototypeOf() { [native code] }
      function setPrototypeOf() { [native code] }
      function isExtensible() { [native code] }
      function isFrozen() { [native code] }
      function isSealed() { [native code] }
      function keys() { [native code] }
      function entries() { [native code] }
      function fromEntries() { [native code] }
      function values() { [native code] }
      Object.prototype: Object
        function __defineGetter__() { [native code] }
        function __defineSetter__() { [native code] }
        function hasOwnProperty() { [native code] }
        function __lookupGetter__() { [native code] }
        function __lookupSetter__() { [native code] }
        function isPrototypeOf() { [native code] }
        function propertyIsEnumerable() { [native code] }
        function toString() { [native code] }
        function valueOf() { [native code] }
        function get __proto__() { [native code] }
        function set __proto__() { [native code] }
        function toLocaleString() { [native code] }
    Error: function Error() { [native code] }（共6个）
      function captureStackTrace() { [native code] }
      function isError() { [native code] }
        isError.prototype: {constructor: ƒ isError()}
      Error.prototype: Object
        "message"
        function toString() { [native code] }
    EvalError: function EvalError() { [native code] }（共3个）
      EvalError.prototype: Error
        "message"
        function toString() { [native code] }
    RangeError: function RangeError() { [native code] }（共3个）
      RangeError.prototype: Error
        "message"
        function toString() { [native code] }
    ReferenceError: function ReferenceError() { [native code] }（共3个）
      ReferenceError.prototype: Error
        "message"
        function toString() { [native code] }
    SyntaxError: function SyntaxError() { [native code] }（共3个）
      SyntaxError.prototype: Error
        "message"
        function toString() { [native code] }
    TypeError: function TypeError() { [native code] }（共3个）
      TypeError.prototype: Error
        "message"
        function toString() { [native code] }
    URIError: function URIError() { [native code] }（共3个）
      URIError.prototype: Error
        "message"
        function toString() { [native code] }
    ArrayBuffer: function ArrayBuffer() { [native code] }（共7个）
      function isView() { [native code] }
      function(){return e.apply(o,arguments)} //
        function.prototype: {constructor: ƒ useSimple()}
      ArrayBuffer.prototype: ArrayBuffer
        function get byteLength() { [native code] }
        function slice() { [native code] }
    SharedArrayBuffer: function SharedArrayBuffer() { [native code] }（共4个）
      SharedArrayBuffer.prototype: SharedArrayBuffer
        function get byteLength() { [native code] }
        function slice() { [native code] }
    DataView: function DataView() { [native code] }（共25个）
      DataView.prototype: DataView
        function get buffer() { [native code] }
        function get byteLength() { [native code] }
        function get byteOffset() { [native code] }
        function getInt8() { [native code] }
        function setInt8() { [native code] }
        function getUint8() { [native code] }
        function setUint8() { [native code] }
        function getInt16() { [native code] }
        function setInt16() { [native code] }
        function getUint16() { [native code] }
        function setUint16() { [native code] }
        function getInt32() { [native code] }
        function setInt32() { [native code] }
        function getUint32() { [native code] }
        function setUint32() { [native code] }
        function getFloat32() { [native code] }
        function setFloat32() { [native code] }
        function getFloat64() { [native code] }
        function setFloat64() { [native code] }
        function getBigInt64() { [native code] }
        function setBigInt64() { [native code] }
        function getBigUint64() { [native code] }
        function setBigUint64() { [native code] }
    Typed Array
    Float32Array: function Float32Array() { [native code] }（共50个）
    Float64Array: function Float64Array() { [native code] }（共50个）
    Int8Array: function Int8Array() { [native code] }（共50个）
    Int16Array: function Int16Array() { [native code] }（共50个）
    Int32Array: function Int32Array() { [native code] }（共50个）
    Uint8Array: function Uint8Array() { [native code] }（共50个）
    Uint16Array: function Uint16Array() { [native code] }（共50个）
    Uint32Array: function Uint32Array() { [native code] }（共50个）
    Uint8ClampedArray: function Uint8ClampedArray() { [native code] }（共50个）
```

4.四个用于当作命名空间的对象：（共108个）

```js
		Atomics: Atomics（共14个）
      function load() { [native code] }
      function store() { [native code] }
      function add() { [native code] }
      function sub() { [native code] }
      function and() { [native code] }
      function or() { [native code] }
      function xor() { [native code] }
      function exchange() { [native code] }
      function compareExchange() { [native code] }
      function isLockFree() { [native code] }
      function wait() { [native code] }
      function wake() { [native code] }
      function notify() { [native code] }
    JSON: JSON（共3个）
      function parse() { [native code] }
      function stringify() { [native code] }
    Math: Math（共57个）
      function abs() { [native code] }
      function acos() { [native code] }
      function acosh() { [native code] }
      function asin() { [native code] }
      function asinh() { [native code] }
      function atan() { [native code] }
      function atanh() { [native code] }
      function atan2() { [native code] }
      function ceil() { [native code] }
      function cbrt() { [native code] }
      function expm1() { [native code] }
      function clz32() { [native code] }
      function cos() { [native code] }
      function cosh() { [native code] }
      function exp() { [native code] }
      function floor() { [native code] }
      function fround() { [native code] }
      function hypot() { [native code] }
      function imul() { [native code] }
      function log() { [native code] }
      function log1p() { [native code] }
      function log2() { [native code] }
      function log10() { [native code] }
      function max() { [native code] }
      function min() { [native code] }
      function pow() { [native code] }
      function random() { [native code] }
      function round() { [native code] }
      function sign() { [native code] }
      function sin() { [native code] }
      function sqrt() { [native code] }
      function tan() { [native code] }
      function tanh() { [native code] }
      function trunc() { [native code] }
      function sinh() { [native code] }
        sinh.prototype: {constructor: ƒ sinh()}
      function clamp() { [native code] }
        clamp.prototype: {constructor: ƒ clamp()}
      function degrees() { [native code] }
        degrees.prototype: {constructor: ƒ degrees()}
      function fscale() { [native code] }
        fscale.prototype: {constructor: ƒ fscale()}
      function iaddh() { [native code] }
        iaddh.prototype: {constructor: ƒ iaddh()}
      function isubh() { [native code] }
        isubh.prototype: {constructor: ƒ isubh()}
      function imulh() { [native code] }
        imulh.prototype: {constructor: ƒ imulh()}
      function radians() { [native code] }
        radians.prototype: {constructor: ƒ radians()}
      function scale() { [native code] }
        scale.prototype: {constructor: ƒ scale()}
      function umulh() { [native code] }
        umulh.prototype: {constructor: ƒ umulh()}
      function signbit() { [native code] }
        signbit.prototype: {constructor: ƒ signbit()}
    Reflect: Object（共34个）
      function defineProperty() { [native code] }
      function deleteProperty() { [native code] }
      function apply() { [native code] }
      function construct() { [native code] }
      function get() { [native code] }
      function getOwnPropertyDescriptor() { [native code] }
      function getPrototypeOf() { [native code] }
      function has() { [native code] }
      function isExtensible() { [native code] }
      function ownKeys() { [native code] }
      function preventExtensions() { [native code] }
      function set() { [native code] }
      function setPrototypeOf() { [native code] }
      function enumerate() { [native code] }
        enumerate.prototype: {constructor: ƒ enumerate()}
      function defineMetadata() { [native code] }
        defineMetadata.prototype: {constructor: ƒ defineMetadata()}
      function deleteMetadata() { [native code] }
        deleteMetadata.prototype: {constructor: ƒ deleteMetadata()}
      function getMetadata() { [native code] }
        getMetadata.prototype: {constructor: ƒ getMetadata()}
      function getMetadataKeys() { [native code] }
        getMetadataKeys.prototype: {constructor: ƒ getMetadataKeys()}
      function getOwnMetadata() { [native code] }
        getOwnMetadata.prototype: {constructor: ƒ getOwnMetadata()}
      function getOwnMetadataKeys() { [native code] }
        getOwnMetadataKeys.prototype: {constructor: ƒ getOwnMetadataKeys()}
      function hasMetadata() { [native code] }
        hasMetadata.prototype: {constructor: ƒ hasMetadata()}
      function hasOwnMetadata() { [native code] }
        hasOwnMetadata.prototype: {constructor: ƒ hasOwnMetadata()}
      function metadata() { [native code] }
        metadata.prototype: {constructor: ƒ metadata()}
```

##### Javascript 常用 API

数组

push pop shift unshift reverse sort splice forEach some every reduce 会改变原数组

```js
Array: function Array() { [native code] }（共65个）
  function isArray() { [native code] }
  function from() { [native code] }
  function of() { [native code] }
	Array.prototype: Array(0)，是个数组
    function forEach() { [native code] }
    function push() { [native code] }
    function indexOf() { [native code] }
    function map() { [native code] }
    function filter() { [native code] }
    function find() { [native code] }
    function findIndex() { [native code] }
    function splice() { [native code] }
    function slice() { [native code] }
    function join() { [native code] }
    function sort() { [native code] }
    function concat() { [native code] }
    function includes() { [native code] }
    function fill() { [native code] }
    function every() { [native code] }
    function some() { [native code] }
    function reduce() { [native code] }
    function lastIndexOf() { [native code] }
    function pop() { [native code] }
    function shift() { [native code] }
    function unshift() { [native code] }
    function reverse() { [native code] }
    function reduceRight() { [native code] }
    function flat() { [native code] }
    function flatMap() { [native code] } // 相当于先map再flat
    function toString() { [native code] }
```

object

```js
Object: function Object() { [native code] }
	function keys() { [native code] } // 返回一个对象自身可枚举属性组成的数组
	function values() { [native code] } // 返回一个对象自身可枚举属性值组成的数组
  function entries() { [native code] } // 返回一个对象自身可枚举属性的键值对数组，object转数组
	function fromEntries() { [native code] } // 把键值对列表转换为一个对象，数组转object
  function assign() { [native code] } // 将所有可枚举属性的值从一个或多个源对象分配到目标对象。返回目标对象。
	function create() { [native code] } // 创建一个对象，可以设置其__proto__和自身属性。
	function is() { [native code] } // 判断两个值是否为同一个值
	function getOwnPropertyNames() { [native code] } // 返回一个对象的所有自身属性的属性名组成的数组
	function getOwnPropertyDescriptor() { [native code] } // 获取对象上某个自有属性的属性描述符
	function defineProperty() { [native code] } // 在一个对象上定义新的属性或修改现有属性
  Object.prototype:
    function hasOwnProperty() { [native code] } // 判断指定属性是否为该对象自身的属性
    function propertyIsEnumerable() { [native code] } // 判断指定属性是否为该对象可枚举的属性
```

利用 entries 和 fromEntries 来使用数组的 api 操作 object

```js
// 过滤出key的长度为3的的项
const obj = {
  abc: 1,
  def: 2,
  ghijk: 3
}
let res = Object.fromEntries(
  Object.entries(obj).filter(([key, val]) => key.length === 3)
)
console.log(res)
```

字符串 & 正则 & 数字：

```js
String.prototype:
  function charAt() { [native code] } // 根据下标得到对应字符
  function charCodeAt() { [native code] } // 根据下标得到对应字符的编码
  function codePointAt() { [native code] } // 根据下标得到对应字符的编码
  function concat() { [native code] } // 拼接字符串并返回
  function includes() { [native code] } // 判断一个字符串是否包含另外一个字符串
  function indexOf() { [native code] } // 第一次出现的指定值的索引
  function lastIndexOf() { [native code] } // 最后一次出现的指定值的索引
  function match() { [native code] } // 识别出正则匹配到的东西组成一个数组 
  function matchAll() { [native code] }
  function replace() { [native code] }
  function search() { [native code] }
  function slice() { [native code] } // 字符串截取，负数就是从后面数
  function split() { [native code] }
  function substring() { [native code] }
  function toLowerCase() { [native code] }
  function toUpperCase() { [native code] }
  function trim() { [native code] }
  function trimStart() { [native code] }
  function trimEnd() { [native code] }

RegExp.prototype:
  function exec() { [native code] }
  function test() { [native code] }

Number: function Number() { [native code] }
	function isInteger() { [native code] } // 判断给定的参数是否为整数
	Number.prototype:
    function toFixed() { [native code] } // 取小数点后几位，会做四舍五入
    function toString() { [native code] } // 将数字转换成字符串
    function toLocaleString() { [native code] }
```

Set & Map：

Set 和 Map 都是可遍历对象，都可以使用 for of 做遍历。

Map 的 key 可以是任意值，Set 的每个元素可以是任意值。

```js
let set = new Set([1, 2, 3])
let map = new Map([[1, 2], [3, 4], [5, 6]])
```

```js
Set.prototype:
	function add() { [native code] } // 末尾添加元素
  function has() { [native code] } // 是否存在某元素
  function delete() { [native code] } // 删除元素
  function clear() { [native code] } // 删除所有元素
	function get size() { [native code] } // 返回Set对象中元素的个数
	function keys() { [native code] } // 返回所有的keys值组成的SetIterator
	function values() { [native code] } // 返回所有的values值组成的SetIterator
  function entries() { [native code] } // 返回所有[key,vluea]值组成的SetIterator
	function forEach() { [native code] } // 遍历set

WeakSet.prototype:
	function add() { [native code] } // 末尾添加元素
	function has() { [native code] } // 是否存在某元素
  function delete() { [native code] } // 删除元素
  
Map.prototype:
  function get() { [native code] } // 获取元素
  function set() { [native code] } // 设置元素
  function has() { [native code] } // 是否存在某元素
  function delete() { [native code] } // 删除元素
  function clear() { [native code] } // 删除所有元素
	function get size() { [native code] } // 元素数量
  function keys() { [native code] } // 返回所有的keys值组成的MapIterator
  function values() { [native code] } // 返回所有的values值组成的MapIterator
 	function entries() { [native code] } // 返回所有[key,vluea]值组成的MapIterator
  function forEach() { [native code] } // 遍历map
    
WeakMap.prototype:
  function get() { [native code] } // 获取元素
  function set() { [native code] } // 设置元素
  function has() { [native code] } // 是否存在某元素
	function delete() { [native code] } // 删除元素
```

全局函数：

```js
eval
isNaN
parseFloat
parseInt
decodeURI
decodeURIComponent
encodeURI
encodeURIComponent
```

用于当作命名空间的对象：

```js
JSON:
  function parse() { [native code] } // 用来解析JSON字符串
  function stringify() { [native code] } // 将一个JavaScript对象或值转换为JSON字符串
Math:
  function abs() { [native code] }
  function ceil() { [native code] }
  function floor() { [native code] }
  function fround() { [native code] }
  function max() { [native code] }
  function min() { [native code] }
  function pow() { [native code] }
  function random() { [native code] }
  function round() { [native code] }
```

##### es6

class：

es6 中的类：

```js
class Animal {
  // 构造函数
  constructor (type) { 
    this.type = type
  }
  // 公用方法，挂载在原型上的方法
  eat () { 

  }
  // 定义类的静态方法
  static walk () {

  }
}

// 继承
class Dog extends Animal {
  constructor (type) {
    // super调用必须放到构造函数第一行，这个super就是父类的构造函数
    super(type)
  }
}
```

getter setter：

getter 是所访问的属性的真正的返回。

setter 在属性赋值的时候会拦截到，然后做一些你想做的逻辑。通常是做一些判断来控制 getter 中真正返回的那个值。

```js
class Animal {
  constructor (type) { 
    this.type = type
  }
  get age () {
    return 4
  }
  set age (val) {
    this.realAge = val // 这里不能再给age赋值了，不然就变成死循环了
  }
}
let dog = new Animal()

console.log(dog.age) // 4
dog.age = 5
console.log(dog.age) // 4
console.log(dog.realAge) // 5
```

```js
let _age = 4
class Animal {
  constructor (type) { 
    this.type = type
  }
  get age () {
    return _age
  }
  set age (val) {
    if (val > 4 && val < 7) {
      _age = val
    }
  }
}
let dog = new Animal('dog')
console.log(doa.age)
dog.age = 5
console.log(dog.age)
```

generator：

generator 函数执行后返回一个对象，这个对象中有一个 next 函数，是用来控制 generator 函数内部代码的执行的。

函数内部可以使用 yield 来暂停函数的执行。

在调用的过程中，通过 next 来恢复程序的执行。

yield：

```js
function * gen () {
  let val
  // 遇到yield，执行完yield后面的表达式后就会停止。并不会执行赋值操作，下一次next才会赋值。
  val = yield 1 
  console.log(val)
}
const l = gen()
l.next() //
l.next() // undefined
```

next 找函数体中的 yield 或者是函数的结尾，这两者找到一个就会暂停或者结束。

yield 后面可以加一个 *，yield 加 * 之后，它表示的是后面可以是一个可遍历的对象，专业术语叫可迭代的对象。或者是一个 generator 实例，也就是 yield * 后面可以嵌套一个 generator 函数。

next：

next 用来控制函数的恢复执行，next 函数的返回值是一个包含两个属性的对象，done：函数是否已经结束，value：yield 后面的值或者函数 return 的值。

next 传递的参数会作为 yield 表达式的返回值来控制函数内部的数据，不传就是 undefined。也就是说可以通过改变 yield 返回值的方式来改变函数内部的数据或运行结果。

只要有 yield 就会停下来，后面即使是没有代码也需要再 next 一次这个函数才算执行完。done 才为 true。

```js
function * gen () {
  let val
  val = yield [1, 2, 3]
  console.log(val)
}
const l = gen()
console.log(l.next())
console.log(l.next())
// {value: Array(3), done: false}
// undefined
// {value: undefined, done: true}

function * gen () {
  let val
  val = yield [1, 2, 3]
  console.log(val)
}
const l = gen()
console.log(l.next(10))
console.log(l.next(20))
// {value: Array(3), done: false}
// 20
// {value: undefined, done: true}
```

return：

退出函数执行，也可以传值，跟 next 一样。

```js
l.return()
```

throw：

```js
function * gen () {
  while (true) {
    try {
      yield 1
    } catch (e) {
      console.log(e.message)
    }
  }
}
const g = gen()
// 如果你不用generator，用es5去写，你的页面已经死掉了，因为无限循环。但是用generator是死不掉的。因为它虽然是个无限循环，但是它的节奏是由外部来控制的。它就不是一个无限循环了。
console.log(g.next()) // {value: 1, done: false}
console.log(g.next()) // {value: 1, done: false}
console.log(g.next()) // {value: 1, done: false}
console.log(g.next()) // {value: 1, done: false}
// 类似于continue的方式，绕过去了。抛出异常的方式结束函数运行。
g.throw(new Error('ss')) // ss
console.log(g.next()) // {value: 1, done: false}
```

应用场景：

1.处理无限循环的流程

输出 3 的倍数，按照 es5 的写法一定是死循环了。

```js
function * count (x = 1) {
  while (1) {
    if (x % 3 === 0) {
      yield x
    }
    x++
  }
}
let num = count()
console.log(num.next().value) // 3
console.log(num.next().value) // 6
console.log(num.next().value) // 9
console.log(num.next().value) // 12
console.log(num.next().value) // 15
```

2.控制循环

es5 中，一旦这个函数被调用，这个 for 循环就会一次执行完，它是不受控的，不能停下来。

```js
function loop () {
  for (let i = 0; i < 5; i++) {
    console.log(i)
  }
}
loop()
```

如何让遍历停下来，每一步都可以控制是不是要继续进行。generator 就可以帮你做到如何让遍历停下来。

```js
function * loop () {
  for (let i = 0; i < 5; i++) {
    yield console.log(i)
  }
}
const l = loop()
l.next() // 0
l.next() // 1
l.next() // 2
l.next() // 3
l.next() // 4
l.next() // 什么都不会打印了
```

Iterator 自定义遍历器：

es5

```js
let authors = {
  allAuthors: {
    fiction: ['Agla', 'Skks', 'LP'],
    scienceFiction: ['Neal', 'Arthru', 'Ribert'],
    factory: ['J.R.Tole', 'J.M.R', 'Terry P.K']
  },
  Address: []
}
let r = [];
for (let [k, v] of Object.entries(authors.allAuthors)) {
  r = r.concat(v);
}
console.log(r); // ['Agla', 'Skks', 'LP', 'Neal', 'Arthru', 'Ribert', 'J.R.Tole', 'J.M.R', 'Terry P.K']
```

es6

可迭代协议：在对象上存在 Symbol.iterator 这样的 key，值是一个 function，你想判断一个对象是不是可迭代的，你就去找这个对象上有没有以 Symbol.iterator 为 key 的方法，如果没有那这个对象就是不可迭代的。

迭代器协议：一个函数返回一个对象，这个对象里面有一个方法 next，next 的返回值是 done 和 value。generater 是遵循了迭代器协议的。

```js
authors[Symbol.iterator] = function () {
  return { 
    next () {
      return {
        done: false,
        value: 1
      }
    }
  }
}
```

实现自定义遍历器：

输入是 this。

输出是返回值：done 用来表述遍历是否结束，value 用来告诉当前所遍历的值。

```js
authors[Symbol.iterator] = function () {
  // 这里执行一次
  let allAuthors = this.allAuthors;
  let keys = Reflect.ownKeys(allAuthors);
  let values = [];
  return { 
    next () {
      // 最终生成的遍历器循环几次这里就执行几次
      // 返回每次的done和value
      if (!values.length) {
        if (keys.length) {
          values = allAuthors[keys[0]];
          keys.shift();
        }
      }
      return {
        done: !values.length,
        value: values.shift()
      }
    }
  }
}
```

使用 generator 来实现 iterator 的可迭代接口：

```js
authors[Symbol.iterator] = function * () {
  let allAuthors = this.allAuthors;
  let keys = Reflect.ownKeys(allAuthors);
  let values = [];
  // 写一个无限循环，只要keys有值就yield出值，没有值说明遍历结束，直接return退出循环
  while (1) {
    if (!values.length) {
      if (keys.length) {
        values = allAuthors[keys[0]];
        keys.shift();
        yield values.shift();
      } else {
        return false;
      }
    } else {
      yield values.shift();
    }
  }
}
```

使用：

```js
let r = [];
for (let v of authors) {
  r.push(v);
}
console.log(r);
```

##### 正则表达式

正则表达式：正则表达式 (regular expression) 是一个描述字符模式的对象。ECMAScript 的 RegExp 类表示正则表达式，而 String 和 正则表达式都定义了进行强大的【模式匹配】和【文本检索】与【替换】的函数。 

计算机处理的主要就是数字和字符串。

用正则表示字符串中正则出现的规律。

正则表达式可以理解为用许多元字符拼成的表示一串字符串的规则。

无论是正则的方法还是字符串的方法，都是在字符串中去匹配正则。

API：

正则方法：

* test：符合匹配返回 true，不符合返回 false。
* exec：没有分组时，返回第一个匹配的内容。有分组时，返回第一个匹配的内容和分组内容。不受 g 影响。

字符串方法：

* match：没分组没 g，返回第一次匹配到的内容；有分组没 g，返回第一次匹配到的内容和分组内容；没分组有 g 和有分组有 g，都返回所有匹配到的所有内容；没有匹配到，返回 null。
* search：查找返回第一次匹配到的下标，如果没有匹配到，返回 -1。
* replace：将匹配到的字符串替换成指定的字符串。没有 g，只替换第一次匹配到的字符串，有 g, 则全部替换。没有匹配到就不替换。
* split：返回字符串被正则表达式分割后的数组，没匹配到返回原字符串。

```js
var pattern = /8(.*)8/; // 获取 8..8 之间的任意字符
var str = 'This is 8google8, dd 8ggg8';
var arr = str.match(pattern);
var arr = pattern.exec(str);
// RegExp.$1 第一个分组的内容（一个小括号是一组）
// RegExp.$2 第二个分组的内容
```

元字符：

元字符是包含特殊含义的字符，它们有一些特殊功能，可以控制匹配模式的方式。

```js
{} [] ()
{}: 限定前面的一个或一组字符连续出现的次数
  {3}: 限定前面一个或一组字符连续出现3次
  {3,}: 限定前面一个或一组字符连续出现3次到无限，至少3次
  {3,5} : 限定前面一个或一组字符连续出现3次到5次，至少3次，至多5次
[]: 表示范围
(): 表示组，一些分组的应用 $1 $2 ... RegExp.$1...

* + ? 限定括号前面的一个或一组字符连续出现的次数
*: {0,} 限定前面一个或一组字符连续出现0次到无限
+: {1,} 限定前面一个或一组字符连续出现1次到无限，至少1次
?: {0,1} 限定前面一个或一组字符连续出现0次到1次

^ $
^：限制开头的内容
$：限制结尾的内容

. | \
.: 模糊匹配，一个.可以匹配任何一个字符	
|: 表示或
\: 转义符

\d: 表示数字 [0-9]
\D: 表示非数字 [^0-9]
\w: 表示字母、数字、下划线  [a-zA-Z0-9_]
\W: 表示非字母、数字、下划线 [^a-zA-Z0-9_]
\s: 表示空白符
\S: 表示非空白符
```

标志位：

g：全局匹配

i：不区分大小写

m：启用换行模式（有时字符串不只是一行，不加m就只能匹配第一行字符串内容，加m就可以每一行都匹配）

创建正则表达式：

```js
var reg = new RegExp("日本狗",'g'); // 参1：正则，参2：标志位
var reg = /日本狗/g; // 参1：正则，参2：标志位
```

常用正则：

```js
// 浮点数
/^\d+(\.\d+)?$/
// 检查邮政编码（6位数字，第一位不能为0）
/^[1-9]\d{5}$/
/^\d{6}$/
// 检查文件压缩包（xxx.zip\xxx.gz\xxx.rar）
/^\w+\.(zip|gz|rar)$/
// 删除多余空格
str.replace(/\s+/,'');
// 删除首尾空格
str.replace(/^\s+/,'');
str.replace(/\s+$/,'');
// 电子邮件(xxxxx@xxxx(.xxxx)+)
/^\w+@\w+(\.\w+)+$/
// 手机号
/^[1-3]\d{10}$/
/^1\d{10}$/
// 身份证
/^\d{17}(\d|X)$/
// 日期(xxxx-xx-xx|xxxx/xx/xx|xxxx.xx.xx)
/^\d{2}|\d{4}[-\/\.]\d{2}[-\/\.]\d{2}$/
// 只能输入中文
str.replace(/[^\u4e00-\u9fa5]/g,'');
// 账户名只能使用数字字母下划线，且数字不能开头，长度在6-15之间
/^[a-zA-Z_]\w{5,14}$/
// 验证IP
(xxx.)xxx.xxx.xxx| 
/^[12]\d{0,2}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
254.245.255.255
240.196.19.5
/^((25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\.){3}(25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)$/
// 将所有的bag、beg、big和bog改为bug
str.replace(/(bag|beg|big|bog)/g,'bug');
// 将所有方法foo(a,b,c)的实例改为foo(b,a,c)
str.replace(/foo\(([^,]+),([^,]+),([^,]+)\)/g,'foo($2,$1,$3)');
/*
  IPv4
  A: 1-126      10.0.0.0 私有IP  10.0.0.0  网络段 10.255.255.255  广播地址
  B: 128-191   172.16.0.0 —— 172.31.255.255 私有IP
  C: 192-223   192.168.0.0 _ 192.168.255.255
  D: 224-239  组播
  E: 240-255  科研
  127：回环地址
*/
//身份证：
/^[1-9]\d{5}[1-9]\d{3}(0[1-9]|1[0-2])(0[1-9]|(1|2)\d|3[01])\d{3}(\d|x)$/i
// 年
/^[1-9]{1}\d{3}$/g
// 月
/^([1-9]{1}|(1[0-2]{1}))$/g
// 日
/^([1-9]{1}|((1|2){1}\d{1})|(3[01]{1}))$/g;
```

## Vue

##### Scoped CSS

html 上该组件下的所有元素和子组件的根元素上都会添加上一个 date-v-xxx 的自定义属性，CSS 选择器也会加上这个属性去选择。

所以想要控制 scoped 的子组件的样式，父级也要加上 scoped，只能控制子组件跟元素，不能穿透子组件去控制子组件里面的样式。

深度作用选择器：使用 >>> 操作符，必须配合 scoped 的 style 使用才能生效。

预处理器无法正确解析 >>> ，可以使用 /deep/ 或 ::v-deep 操作符取而代之。

原理：

```vue
<!-- 父组件 -->
<div class="father">
  <h1>父组件</h1>
  <son />
</div>
<style lang="scss" scoped>
h1 {
  color: skyblue;
}
.father {
  /deep/ h2 {
    color: bisque;
  }
}
</style>
<!-- 子组件 -->
<template>
  <div class="son">
    <h2>子组件</h2>
  </div>
</template>
<style scoped lang="scss">
h2 {
  color: red;
}
</style>

<!-- 最终生成的代码 -->
<div data-v-fae5bece class="father">
	<h1 data-v-fae5bece>父组件</h1>
	<div data-v-469af010 data-v-fae5bece class="son">
		<h2 data-v-469af010> 子组件</h2>
  </div>
</div>
<style>
h1[data-v-fae5bece] { // scope 原理
  color: skyblue;
}
.father[data-v-fae5bece] h2 { // 穿透原理
  color: bisque; 
}
h2[data-v-469af010] {
  color: red; // 没生效
}
</style>
```

##### CSS Module

css-loader 的 modules 设置为 true 就会将我们写的 class 改掉，然后当你引入 css 文件模块的时候，它会给你返回一个 class 的列表，这个列表就是原来的 class 跟编译之后的 class 名字的对应关系。

```js
import styles from "./style.css";

element.innerHTML = '<div class="' + styles.className + '">';
```

选择器不能在模版中直接使用，而会把所有的选择器放到计算属性 $style 里，然后通过 $style.xx 去访问选择器。选择器会被动态的转换成很有特点的名字，来和其他的组件做区分。

生成的选择器：文件名\_选择器本身名字\_hash。它不会影响元素本身，只会影响你最终类名的生成。

选择器权重相同的情况下，父组件的样式会覆盖子组件的样式。

```vue
<template>
	<div>
    <a :class="$style.red">awesome-vue</a>
    <a :class="{[$style.red]:isRed}">awesome-vue</a>
    <a :class="[$style.red, $style.bold]">awesome-vue</a>
  </div>
</template>
<style lang="scss" module>
  .red {  
    color: #f00;
  }
  .bold {
    font-weight: bold;
  }
</style>
<script>
  export default {
    created () {
      // $style 是计算属性，所以在 JS 里也可以访问，从而做一些你想做的逻辑操作：
      console.log(this.$style.red)
    }
  }
</script>
```

##### 过度 & 动画

在插入、更新或者移除 DOM 时，使用 transition 组件做过渡或动画。

过渡和动画的过程都是设置在 active 上的。v-enter/v-leave/v-enter-to/v-leave-to 都是设置初始或结束状态的，可以没有。

css 方式是通过过渡类名，js 方式是通过钩子函数。

在下列情形中，可以给任何元素和组件添加进入/离开过渡

- 条件渲染 (使用 `v-if`)
- 条件展示 (使用 `v-show`)
- 动态组件
- 组件根节点

transition 组件基础使用：

transition 组件会为嵌套元素自动添加跟动画相关的类名称，使用这些类名称来做 css 过度动画就可以了。

1. 过渡被触发时，马上加 v-enter/v-leave 和 v-enter-active/v-leave-active。
2. 下一帧马上移除 v-enter/v-leave，然后添加 v-enter-to/v-leave-to。
3. 动画结束后移除 v-enter-active/v-leave-active 和 v-enter-to/v-leave-to。

```vue
<template>
	<transition name="fade"> 
    <div></div>
  </transition> 
</template>

<style> 
  .fade-enter-active, .fade-leave-active { 
    transition: opacity .5s;
  }
  .fade-enter, .fade-leave-to { 
    opacity: 0;
  } 
  .fade-enter-to, .fade-leave { 
    opacity: 1;
  }
</style>
```

结合 CSS 动画库：

通过自定义过度类名，使用第三方定义好的动画。

自定义过度类名：

- enter-class
- enter-active-class
- enter-to-class (2.1.8+)
- leave-class
- leave-active-class
- leave-to-class (2.1.8+)

```html
<link href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1" rel="stylesheet" type="text/css">
```

```vue
<transition enter-active-class="animated bounceIn" leave-active-class="animated bounceOut">
	<div></div>
</transition>
```

JavaScript 钩子：

```vue
<transition
  v-on:before-enter="beforeEnter" // 动画开始前，设置初始状态
  v-on:enter="enter" // 执行动画
  v-on:after-enter="afterEnter" // 动画结束，清理工作
  v-on:enter-cancelled="enterCancelled" // 取消动画
  v-on:before-leave="beforeLeave"
  v-on:leave="leave"
  v-on:after-leave="afterLeave"
  v-on:leave-cancelled="leaveCancelled"
></transition>
```

保留 CSS 中过度动画的部分，加上 JS 钩子做动画起始状态：

```html
<style>
  .fade-enter-active, .fade-leave-active { 
    transition: opacity .5s; 
  }
</style>

<template>
	<transition 
		@before-enter="beforeEnter" 
		@enter="enter"
		@before-leave="beforeLeave" 
		@leave="leave">
  	<div></div>
  </transition>
</template>

<script>
export default {
	methods: {
    beforeEnter(el) {
    	el.style.opacity = 0; // 设置初始状态
    },
    enter(el, done) {
      document.body.offsetHeight; // 触发回流激活动画
      el.style.opacity = 1; // 设置结束状态
      el.addEventListener('transitionend', done); // 监听动画结束事件，并执行done函数
    },
    beforeLeave(el) {
    	el.style.opacity = 1; // 设置初始状态
    },
    leave(el, done) {
      document.body.offsetHeight; // 触发回流激活动画
      el.style.opacity = 0; // 设置结束状态
      el.addEventListener('transitionend', done); // 监听动画结束事件，并执行done函数
    }
  },
}
</script>
```

纯js方案：

```html
<template>
	<transition name="fade"
		:css="false" // 禁用css
    @before-enter="beforeEnter"
    @enter="enter"
    @before-leave="beforeLeave"
    @leave="leave"></transition>
</template>

<script>
import "https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js";
export default {
	methods: {
    beforeEnter(el) {
      el.style.opacity = 0;
    },
    enter(el, done) {
      Velocity(el, { opacity: 1 }, { duration: 500, complete: done });
    },
    beforeLeave(el) {
      el.style.opacity = 1;
    },
    leave(el, done) {
      Velocity(el, { opacity: 0 }, { duration: 500, complete: done });
    }
  },
}
</script>
```

##### 通用表单组件

需求分析：

在开始之前要做一个需求分析，到底要什么样的功能，为了实现这些功能要做一些什么事情。

* KForm 
  * 接收数据
  * 指定校验规则
* KformItem
  * 执行校验
  * 显示错误信息
* KInput
  * 维护数据 

实现 KInput.vue：

```vue
<template>
  <div>
    <input :type="type" :value="value" @input="onInput" v-bind="$attrs">
  </div>
</template>

<script>
  export default {
    inheritAttrs: false, // 避免传入的属性继承到根元素上
    props: {
      value: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: 'text'
      }
    },
    methods: {
      onInput(e) {
        this.$emit('input', e.target.value)
        // 通知父级执行校验
        this.$parent.$emit('validate')
      }
    },
  }
</script>
```

实现 KFormItem：

```vue
<template>
  <div>
    <!-- label -->
    <label v-if="label">{{label}}</label>

    <!-- KInput的坑位 -->
    <slot></slot>

    <!-- 校验信息显示 -->
    <p v-if="error">{{error}}</p>
  </div>
</template>

<script>
// Asyc-validator
import Schema from "async-validator";

export default {
  inject: ["form"],
  data() {
    return {
      error: "" // error是空说明校验通过
    };
  },
  props: {
    label: {
      type: String,
      default: ""
    },
    prop: {
      type: String
    }
  },
  mounted() {
    this.$on("validate", () => {
      this.validate();
    });
  },
  methods: {
    validate() {
      // 规则
      const rules = this.form.rules[this.prop];
      // 当前值
      const value = this.form.model[this.prop];

      // 校验描述对象
      const desc = { [this.prop]: rules };
      // 创建Schema实例
      const schema = new Schema(desc);
      return schema.validate({ [this.prop]: value }, errors => {
        if (errors) {
          this.error = errors[0].message;
        } else {
          // 校验通过
          this.error = "";
        }
      });
    }
  }
};
</script>
```

实现 KForm：

```vue
<template>
  <div>
    <slot></slot>
  </div>
</template>

<script>
export default {
  provide() {
    return {
      form: this
    };
  },
  props: {
    model: {
      type: Object,
      required: true
    },
    rules: {
      type: Object
    }
  },
  methods: {
    validate(cb) {
      // 获取所有孩子KFormItem
      const tasks = this.$children
        .filter(item => item.prop) // 过滤掉没有prop属性的Item
        .map(item => item.validate());

      // 统一处理所有Promise结果
      Promise.all(tasks)
        .then(() => cb(true))
        .catch(() => cb(false));
    }
  }
};
</script>
```

使用：

```vue
<template>
  <div>
    <!-- KForm -->
    <KForm :model="userInfo" :rules="rules" ref="loginForm">
      <!-- 用户名 -->
      <KFormItem label="用户名" prop="username">
        <KInput v-model="userInfo.username" placeholder="请输入用户名"></KInput>
      </KFormItem>
      <!-- 密码 -->
      <KFormItem label="密码" prop="password">
        <KInput type="password" v-model="userInfo.password" placeholder="请输入用户名"></KInput>
      </KFormItem>
      <!-- 提交按钮 -->
      <KFormItem>
        <button @click="login">登录</button>
      </KFormItem>
    </KForm>
  </div>
</template>

<script>
import KInput from "@/components/form/KInput.vue";
import KFormItem from "@/components/form/KFormItem.vue";
import KForm from "@/components/form/KForm.vue";
import Notice from "@/components/Notice.vue";

export default {
  data() {
    return {
      userInfo: {
        username: "tom",
        password: ""
      },
      rules: {
        username: [{ required: true, message: "请输入用户名称" }],
        password: [{ required: true, message: "请输入密码" }]
      }
    };
  },
  components: {
    ElementTest,
    KInput,
    KFormItem,
    KForm
  },
  methods: {
    login() {
      this.$refs["loginForm"].validate(valid => {
        const notice = this.$create(Notice, {
          title: "社会你杨哥喊你来搬砖",
          message: valid ? "请求登录!" : "校验失败!",
          duration: 2000
        });
        notice.show();
      });
    }
  }
};
</script>
```

修正 input 中 $parent 写法的问题:

想跨层级的去传参，还不能使用 $parent/$root/$children 等，element 官方用的是混入的方式，在 src/mixins 写了一个 emitter.js 派发器。它可以做两件事，一个叫广播一个叫冒泡派发事件，这个东西在 vue1.0 里是有的，2.0 之后删了。element 觉得它有用，所以自己实现了，这个东西可以隔层的去派事件，比如在 input 里可以不停的向上去找我想要的组件让它去派发事件。这个东西是作为一个混入被引入的，主要是为了复用。

1.mixin emitter
2.声明 componentName
3.dispatch()																				

##### 弹窗组件

其他的组件的内容都是在 app 里的，弹窗这类组件已经脱离出当前 Vue 管理的实例了。这样做的好处是比较好控制弹窗的位置等东西。它们在当前 Vue 根实例之外独立存在，通常挂载于 body，而不是 app，所以不能将它声明在任何一个 app 组件下的 compunents 选项作为当前 app 的组件从而使用 Vue 内部来创建构造函数和实例的能力，需要我们自己去创建实例。

需求：现在有一个 Notice.vue 这样的组件，要用函数的方式去创建这个组件的实例，并且将来把它挂在到 body 上面去。

实现 create 函数：

create 方法将来接收一个组件（其实就是组件的配置）和一些参数，创建这个组件的实例，并将其挂载到 body 上去，最终返回这个组件实例。

方法一： 

Vue.extend 方法是 Vue 的一个静态方法，它里面创建了一个子类 VueComponent，继承 Vue，组件实例就是通过 VueComponent 创建的。它是框架本身调的方法。

utils/create.js

```js
import Vue from 'vue'

function create(Component, props) {
  // 获得组件的构造函数
  const Ctor = Vue.extend(Component);
  // 获得组件实例，组件实例创建之后得到虚拟DOM
	// 用propsDate传递参数，相当于使用模版时父组件传过来的props
  cosnt comp = new Ctor({propsDate: props});
  // 组件实例挂载，得到真实DOM
  comp.$mount();
  // 获取真实DOM后，做手动挂载
  document.body.appendChild(comp.$el);
  // 作为一个组件，不停的往界面中去追加而不去清除，将来内存就爆了。
  comp.remove = function() {
    document.body.removeChild(comp.$el);
    comp.$destroy();
  }
  return comp;
}

export default create
```

方法二：

借助 Vue 来创建根实例，使用 render 方法，直接把传入的组件渲染出来，整个过程会有组件实例的创建，然后我们从中获取组件的实例就可以了。

utils/create.js

```js
import Vue from 'vue'

function create(Component, props) {
  // 这个实例会把这个组件作为根组件把它渲染出来了，所以我们就能得到虚拟DOM，挂载后得到真实DOM
  const vm = new Vue({
    render: h => h(Component, {props}),
  }).$mount(); // 不指定宿主元素，则会创建真实DOM，但是不会做追加操作，因为没有目标对象可追加，也不可以使用body
  // 获取真实DOM后，做手动挂载
  document.body.appendChild(vm.$el);
  // 获取传入的组件的实例
  const comp = vm.$children[0];
  // 清除自己
  comp.remove = function() {
    document.body.removeChild(vm.$el);
    vm.$destroy();
  }
  return comp;
}

export default create
```

实现 Notice.vue：

```vue
<template>
  <div class="box" v-if="isShow">
    <h3>{{title}}</h3>
    <p class="box-content">{{message}}</p>
  </div>
</template>

<script>
export default {
  props: {
    title: {
      type: String,
      default: ""
    },
    message: {
      type: String,
      default: ""
    },
    duration: {
      type: Number,
      default: 1000
    }
  },
  data() {
    return {
      isShow: false
    };
  },
  methods: {
    show() {
      this.isShow = true;
      setTimeout(this.hide, this.duration);
    },
    hide() {
      this.isShow = false;
      this.remove();
    }
  }
};
</script>

<style>
.box {
  position: fixed;
  width: 100%;
  top: 16px;
  left: 0;
  text-align: center;
  pointer-events: none;
  background-color: #fff;
  border: grey 3px solid;
  box-sizing: border-box;
}
.box-content {
  width: 200px;
  margin: 10px auto;
  font-size: 14px;  
  padding: 8px 16px;
  background: #fff;
  border-radius: 3px;
  margin-bottom: 8px;
}
</style>
```

main.js

```js
import create from './utils/create'

Vue.prototype.$create = create;
```

使用

```js
this.$create(Notice, {
  title: '弹窗组件',
  message: '提示信息',
  duration: 1000
}).show();
```

封装成 Vue 插件的形式，便于使用：

utils/create.js

```js
import Vue from 'vue'
import Notice from 'Notice.vue'

function create() {
  //...
}

export default {
  install(Vue) {
    Vue.prototype.$notice = function(options) {
      return create(Notice, options)
    }
  }
}
```

main.js

```js
import Vue from 'vue'
import create from './utils/create'

Vue.use(create)
```

##### 拖拽表单组件

需求:

后台管理：左侧固定列表中有一些表单，例如文本框，下拉框。可以将这些表单元素拖拽到右侧的自适应的区域，将表单以原来的宽度放入一行，放不下换行。保存右侧的表单信息和顺序到后端。

用户界面：将来可以在用户端按顺序显示后台操作保存的表单。

根据需求寻找适合的组件:

先到 vue 社区搜索 drag 相关的组件。

根据需求最终筛选出的组件：

* vuedraggable 
* vue-smooth-dnd 
* vue-drag-and-drop-kanban 基于 cue-smooth-dnd
* vue-formbuilder 基于 vuedraggable

设计思路:

1. 首先要实现样式操作上的符合：两个列表之间的双向拖拽，能够满足自适应的两列布局，拖拽过去后一行显示超出换行并且保持元素拖拽之前的宽度。
2. 可以将内容也拖拽过去。
3. 可以记录右侧列表的所有元素和顺序。

遇见的问题:

单纯使用 vuedraggable 的双列表进行的拖拽

1. 内容是元素或组件的时候，元素和组件无法复制过去。需要封装一个组件，使拖拽和被拖拽的列表内容都使用这个组件进行渲染，配合 list 数据判断渲染的元素类型。
2. list 数据只能接收 name, id 两个内容，无法接收其他内容。



## 布局

### 经典布局

行内盒变为块级盒的方式：

* float
* position: absolute/fixed
* display: block/inline-block/table-cell

脱离文档流：元素脱离文档流后，margin: 0 auto 属性值会失效。

正常流布局主要是使用：

* table 属性。
* inline-block 利用块级元素的纵向排布和行内元素的横向排布来完成布局的。
* float 使块级元素横向排布。

##### 表格布局

表格

```html
<style>
  table {
    width: 800px;
    height: 200px;
    border-collapse: collapse; /* 合并边框 */
  }
</style>

<table>
  <tr>
    <td class="left">左</td>
    <td class="right">右</td>
  </tr>
</table>
```

css 规范中，可以设定一个元素长得像表格。

```html
<style>
  .table {
    width: 800px;
    height: 200px;
    display: table;
  }
  .table-row {
    display: table-row;
  }
  .table-cell {
    display: table-cell;
  }
</style>

<div class="table">
  <div class="table-row">
    <div class="table-cell left">左</div>
    <div class="table-cell right">右</div>
  </div>
</div>
```

##### inline-block 布局

因为文字之间是有间隙的，所以每个 inline-block 的元素之间也存在间隙。

* 把父元素的字体大小设为 0，在里面的元素设置相应的字体大小。
* 把空格去掉或改成注释。

缺点：做自适应比较困难。比较适合做定宽的布局。

##### float

浮动元素会脱离文档流，但是不会脱离文本流。这种布局方式正是 float 本身的含义，float 本来就是用来做类似于图文混排的文字环绕之类的效果的。

浮动元素会形成“块”（BFC）。

float 盒：

* 把盒移动到当前行的最上和最左或最右。
* 上面和当前行的行内级格式上下文的上边缘对齐，左/右和当前行的块级格式上下文的左/右边缘对齐。

### 经典布局应用

##### 两列布局

左列定宽，右列自适应。

左边两列是定宽，右边一列自适应，就是三列布局。四列、五列、六列、n 多列都是这样。

```html
<div class="parent">
	<div class="left"> 左：定宽 </div>
  <div class="right"> 右：自适应 </div>
</div>

<style>
/* 方案一：float + margin */
.left {
	width: 100px;
  float: left;
}
.right { 
  margin-left: 100px; 
}
/* 方案二：float + overflow */
.left {
	width: 100px;
  float: left;
}
.right { 
  overflow: hidden; /* 作用：1.溢出时隐藏 2.开启 BFC 模式：当前元素的内部环境与外界完全隔离。 */
}
/* 方案三：table 相关属性 */
.parent {
  display: table; /* 表格的单元格的宽度如果不设置会自动分配 */
  width: 100%; /* 表格不默认继承父元素宽度 */
}
.left, .right { 
  display: table-cell; 
}
.left { 
  width: 100px; 
}
</style>
```

##### 圣杯布局

左右定宽，中间自适应。

圣杯布局是来源于该布局效果类似圣杯而得名。简单来说，就是指三行三列布局。

​              头部

定宽 + 自适应 + 定宽

​              底部

传统三列布局实现圣杯布局效果：

缺点：作为主要内容存放的容器 center 放在最后面，不利于搜索引擎的抓取。

```html
<div class="left"></div>
<div class="right"></div>
<!-- 非浮动元素可以占据浮动元素的位置，浮动元素不能占据非浮动元素的位置，所以html结构位置要这样排放 -->
<div class="center"></div> 

<style>
.left{
	width: 100px;
  float: left;
}
.right { 
  width: 100px;
  float: right;
}
.center {
	margin-left: 100px;
  margin-right: 100px;
}
</style>
```

圣杯布局：

三列都左浮动之后，center 占 100%，然后使用 margin 把被挤下去的左右定宽挪到相应位置即可。

```html
<!-- 当原有的html结构没有办法很好的解决的时候，就在现有结构中增加父级结构或子级元素，改变其结构 -->
<div class="parent">
  <div class="center"></div> <!-- 为了对搜索引擎友好，center放在最前面 -->
  <div class="left"></div>
  <div class="right"></div>
</div>

<style>
.parent {
  height: 300px; /* 解决高度塌陷 */
  margin-left: 100px;
  margin-right: 100px;
}
.left, .center, .right {
	height: 300px;
  float: left;
}
.left {
  width: 100px;
  margin-left: -100%;
  position: relative;
  left: -100px;
  /* transform: translateX(-100px); */
}
.center {
	width: 100%;
}
.right {
  width: 100px;
  margin-left: -100px;
  position: relative;
  right: -100px;
  /* transform: translateX(100px); */
}
</style>
```

##### 双飞翼布局

针对圣杯布局的优化，主要是优化了圣杯布局中开启定位的问题。

```html
<div class="parent">
  <div class="center">
  	<div class="inner"></div>
  </div>
  <div class="left"></div>
  <div class="right"></div>
</div>

<style>
.parent {
  height: 300px;
}
.left, .center, .right {
	height: 300px;
  float: left;
}
.left {
  width: 100px;
  margin-left: -100%;
}
.center {
	width: 100%:
}
.right {
  width: 100px;
  margin-left: -100px;
}
.inner {
  height: 300px;
  margin-left: 100px;
  margin-right: 100px;
}
</style>
```

##### 等分布局

一行被分为若干列，每一列的宽度是相同的。

```html
<div class="parent">
    <div class="column"></div>
    <div class="column"></div>
    <div class="column"></div>
</div>

<style>
/* 方案一：百分比宽度 + inline-block。 */
/* float 也可以实现类似的效果，但是 float 元素只能做顶对齐，不如 inline-block 灵活。 */
.parent {
  font-size: 0;
}
.column {
  width: 33.33%;
 	height: 300px;
  display: inline-block;
  outline: solid 1px blue;
 	font-size: 30px;
}
/* 方案二：百分比宽度 + float */
.parent {
  height: 300px;
  /* 等分布局存在间距的情况，去掉多余的那个 margin-left
  margin-left: -10px; 
  */
}
.column {
  float: left;
  width: 25%;
  height: 300px; 
  /* 等分布局存在间距的情况
  box-sizing: border-box;
  padding-left: 10px;
  */
}
/* 方案三：display: table; + display: table-cell; */
.parent {
  display: table;
  width: 100%;
  /* 等分布局存在间距的情况，去掉多余的那个 margin-left
  margin-left: -10px;
 	*/
}
.column {
	display: table-cell;
  height: 300px;
  /* 等分布局存在间距的情况
  box-sizing: border-box;
  padding-left: 10px;
  */
}
</style>
```

##### 等高布局

一行被划分成若干列，每一列的高度是相同的。

```html
<div class="parent">
  <div class="left">aj;fafja;f</div>
  <div class="right">ahf;a fah;f nfha;kjf90wufngna;  ahfakfja;ljfa;lfj fahfaof a faj;</div>
</div>

<style>
/* 方案一：float + padding + margin */
/* 这种解决方案实现的不是真正的等高布局，只是视觉上等高的伪等高布局。 */
.parent {
  overflow: hidden; /* 解决浮动元素的父级元素高度塌陷问题 */
}
.left, .right { 
  width: 100px;
  float: left;
  padding-bottom: 9999px;
  margin-bottom: -9999px;
}
.right {overflow: hidden;}
/* 方案二：display: table + display: table-cell; */
.parent {
  display: table;
  width: 100%;
}
.left, .right { 
  display: table-cell; /* 表格的单元格默认是等高的 */
  width: 100px;
}
</style>
```

##### 全屏布局

全屏布局是指 html 页面铺满整个浏览器窗口，没有滚动条，可以跟随浏览器的大小变化而变化。

整个页面的高度和宽度都是自适应的效果。

主要的实现方式就是使用定位。

```html
<header></header>
<div class="content">
  <div class="left"></div>
  <div class="right"></div>
</div>
<footer></footer>

<style>
  html, body {
    margin: 0;
    overflow: hidden; /* 保证垂直或水平方向不会出现滚动条 */
  }
  header {
    height: 100px;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background-color: lightgray;
  }
  .content {
    position: fixed;
    left: 0;
    right: 0;
    top: 100px;
    bottom: 100px;
    background-color: lightblue; 
    overflow: auto; /* 处理内容溢出 */
  }
  .content .left {
    width: 300px;
    position: fixed;
    left: 0;
    top: 100px;
    bottom: 100px;
    background-color: lightcoral;
  }
  .content .right {
    position: fixed;
    top: 100px;
    bottom: 100px;
    right: 0;
    left: 300px;
    background-color: greenyellow;
  }
  footer {
    height: 100px;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: lightslategray;
  }
</style>
```

### 弹性布局（flexbox）

##### 弹性容器

弹性容器控制的就是：主轴方向，是否可以换行，子元素在主轴和侧轴的排列（对齐）方式。

```js
// 设置在弹性父元素身上，子元素的布局方式就会按照flex的方式去排版
display: flex; 

// 设置主轴方向
flex-direction: row;            // 主轴为水平轴，从左到右。默认值
flex-direction: row-reverse;    // 主轴为水平轴，从右到左
flex-direction: column;         // 主轴为垂直轴，从上到下
flex-direction: column-reverse; // 主轴为垂直轴，从下到上

// 当弹性子元素超出弹性容器范围时是否换行
flex-wrap: nowrap;       // 不换行，超出的话，每个子元素都会缩小。默认值。
flex-wrap: wrap;         // 换行
flex-wrap: wrap-reverse; // 换行，且侧轴的起始和结束位置互换

// flex-direction和flex-wrap的复合属性
flex-flow: row nowrap;

// 设置子元素在主轴方向上的排列方式
justify-content: flex-start;    // 从主轴开始点位置开始排列。默认值。
justify-content: flex-end;      // 从主轴结束点位置开始排列
justify-content: center;        // 从中间位置开始排列
justify-content: space-between; // 把主轴上的剩余空间分成n-1份（n是一行子元素的个数）然后插入到子元素中间
justify-content: space-around;  // 把主轴上的剩余空间分成2n份（n是一行子元素的个数）然后在每一个子元素两侧都分配一份

// 设置子元素在侧轴方向上的排列方式
// 一般用于一行元素侧轴排列方式，使元素位于行中
align-items: flex-start; // 从侧轴开始点位置开始排列。默认值。
align-items: flex-end; 	 // 从侧轴结束点位置开始排列
align-items: center;     // 从中间位置开始排列
align-items: stretch;    // 当子元素不设置侧轴方向的宽高属性的时候，会自动去侵占剩余空间
align-items: baseline;   // 子元素会以内容区域去互相对齐
// 一般用于多行元素侧轴排列方式，使行位于容器中
align-content: flex-start;    // 从侧轴开始点位置开始排列。默认值。
align-content: flex-end;      // 从侧轴结束点位置开始排列
align-content: center;        // 从中间位置开始排列
align-content: space-between; // 把侧轴上的剩余空间分成n-1份（n是一行子元素的个数）然后插入到子元素中间
align-content: space-around;  // 把主轴上的剩余空间分成2n份（n是一行子元素的个数）然后在每一个子元素两侧都分配一份
```

##### 弹性子元素

弹性子元素控制的就是：子元素的扩展，收缩，宽度，覆盖父容器在侧轴的单行情况设置的排列方式。

```js
// 设置弹性子元素的扩展比率
// 可以控制子元素侵占主轴方向上的剩余空间，把剩余空间按照子元素的flex-grow去分割，然后按需分配
flex-grow: 0; // 默认值0

// 设置弹性子元素的收缩比率
// 可以控制在超出并且不换行的子元素主轴方向上的收缩，把需要空出来的空间按照子元素的flex-shrink去分割，然后按需分配
flex-shrink: 1; // 默认值1

// 分配剩余空间前，决定弹性子元素在主轴方向上的大小
// 优先级：max-width/min-width > flex-basis > width
// 当flex-item宽度和大于flex容器宽度，不管通过哪个属性设置的宽度，flex-item宽度要根据flex-shrink值缩小。
flex-basis: auto;  // 如果未指定宽度，则宽度将根据内容决定。默认值。
flex-basis: 100px; // 固定宽度
flex-basis: 10%;   // 占弹性容器的百分比

// flex-grow, flex-shrink和flex-basis的复合属性
flex: 0 1 100px;

// 控制弹性子元素的顺序
// 如果子元素的order值相同，按照文档里的顺序去排列。如果子元素的order值不同，按照order值从小到大排列
order: 0; // 默认值0

// 允许独立的弹性子元素覆盖弹性容器的默认在侧轴且是单行的对齐方式(align-items)
align-self: flex-start; // 从侧轴开始点位置开始排列。默认值。
align-self: flex-end; 	// 从侧轴结束点位置开始排列
align-self: center;     // 从中间位置开始排列
align-self: stretch;    // 当子元素不设置侧轴方向的宽高属性的时候，会自动去侵占剩余空间
align-self: baseline;   // 子元素会以内容区域去互相对齐
```

### 页面适配

##### 屏幕显示概念

* 像素：https://github.com/jawil/blog/issues/21
* 设备尺寸，分辨率，像素密度
  * 分辨率(单位像素) 1920PX * 1080PX
    * 像素：屏幕上呈现图像的最小单位
  * 设备尺寸 5.2英寸（对角线长度）
  * 像素密度(ppi, 每英寸所拥有的像素数目)
    * ppi = √(横向^2 + 纵向^2) / 屏幕尺寸(inch)
    * 像素密度越大，相当于同尺寸下拥有的像素越多，所以显示效果更细腻，更好，实际的像素物理尺寸更小，就可以显示下更多的像素（色彩块）。
  * 小结：
    * 做适配要关心的是分辨率而不是屏幕尺寸。
    * 在同一个设备上，它的像素个数和像素大小是固定的了，也就是系统的最高分辨率，这是厂商在出厂时就设置好了的，只有不同的设备之间，才有像素大小的区别。像素是没有实际的物理尺寸的，像素这个东西，就像金箍，能变大能变小。系统调节分辨率是使用虚拟色彩块来充当部分像素块，以达到降低分辨率的效果。
    * 像素密度是决定屏幕显示清晰度的。也就是分辨率和尺寸大小共同决定的。

##### 自适应

同一个页面在不同尺寸的屏幕下，页面都能完美呈现。

百分比 

* width：基于父级宽度
* height：基于父级高度
* margin, padding：基于父级宽度
* left：基于父级宽度
* top：基于父级高度

flex 

media 

rem 

vw vh 

##### 响应式

同一个页面在不同尺寸的屏幕下，元素的排列、展示的形式都会不同。

企业站、资讯类等等页面结构简单的网站，适合响应式。

优点：

* 节省成本，只写一套网页就能让多种终端完美适配

缺点：

* 有兼容问题，低版本浏览器不兼容
* 页面体积会变大，移动端访问耗费流量，响应速度变慢
* 代码冗余，开发难度增大

主要方法：

* 设计的支持：隐藏 + 折行 + 自适应空间

* 技术实现

  * rem：通过 html 的字体大小来确定元素大小，使用这个单位进行布局，针对不同大小的屏幕给出不同大小的字号，元素就会跟着缩放。rem 有时换算完是不精准的。

  * viewport：确定要将页面整个界面放到多大，一般都是设置成设备的宽度。

  * media query：媒体查询，根据不同设备的特性来匹配不同的样式，给小屏和大屏分别写一套样式。大屏幕的样式写在上面，优先满足小屏。

    ```css
    @media screen and (min-width:750px){
      section div{
        width: 50%;
      }
    }
    ```

## Css 动画

##### transition 补间动画

两个状态的切换之间的动画。有开头有结尾，中间的过程是补出来的。

给出两点的状态，它会去算中间的过程，不能算所有的属性，比如 dispaly: block; 和 display: none; 是有和没有的区别，它中间的渐变是没法算的，所以只能计算一部分属性。

* 位置 - 平移（left/right/margin/transform）
* 方位 - 旋转（transform）
* 大小 - 缩放（transform）
* 透明度（opacity）
* 其他 - 线性变换（transform）

```css
div {
  /* 要变换的动画属性 */
  transition-property: width; 
  /* 动画的时长 */
  transition-duration: 3s; 
  /* 速度时间曲线，用来指定动画的时间和进度的关系。除了css内置的属性，还可以自己指定贝塞尔曲线，贝塞尔曲线的作用就是让变化平滑的度过 */
  transition-timing-function: ease;  
  /* 延迟时间 */
  transition-delay: 1s; 
  /* 组合写法 */
  /* property duration timing-function delay */
  transition: width 3s ease 1s; 
}
```

transition 可以重复多次，指定多个属性的变换规则。

```css
div {
  transition: width 1s, background 3s; 
  transition: all 1s; /* 该元素所有能够补间动画的属性都加上动画 */
}
```

##### keyframes 动画

动画的部分还是补间动画，区别是它可以有很多个关键帧。

```css
div {
  animation-duration: 3s; /* 动画时间 */
  animation-timing-function: ease-in; /* 动画的速度时间曲线 */
  animation-delay: 1s; /* 动画开始前的延迟时间 */
  animation-iteration-count: 2; /* 动画播放次数 */
  animation-direction: reverse; /* 指定是否应该轮流反向播放动画 */
  animation-fill-mode: both; /* 当动画不播放时，要应用到元素的样式 */
  animation-play-state: paused; /* 指定动画是否正在运行或已暂停 */
  animation-name: run; /* 关键帧动画名称 */
  /* 组合写法 */
 	/* duration timing-function delay iteration-count direction fill-mode play-state name */
	animation: 3s ease-in 1s 2 reverse both paused run; 
}

@keyframes run {
  0% {
		width: 100px;
  }
  100% {
		width: 800px;
  }
}
```

transition 和 animation 组合使用，抛弃 animation 的 timing-function，以编排不同段用不同的曲线。

在这个例子中，在 keyframes 中定义了 transition 属性，以达到各段曲线都不同的效果。

```js
@keyframes mykf {
  from { top: 0; transition:top ease}
  50% { top: 30px; transition:top ease-in }
  75% { top: 10px; transition:top ease-out }
  to { top: 0; transition:top linear}
}
```

##### 逐帧动画

在关键帧动画的基础上可以做逐帧动画，中间是没有补间的，就是没有计算出来的画面。有的只是从第一个跳到第二个的画面。

每一帧都是关键帧，中间没有补间的过程。它属于关键帧动画特殊的用法，适用于无法补间计算的动画。因为每一帧都是一个单独的表现，所以资源会比较大，一般需要很多图片来实现逐帧动画。因为关键帧动画中间默认是有补间过度的，所以使用 animation-timing-function: steps(1); 使它在每个关键帧的时间静止，不要有中间的过度。steps() 是指定关键帧之间要有几个过度画面，不想有补间过度就设置 1。



## Css 预处理器

##### 嵌套 

反应层级和约束范围。

##### 变量

一处定义多处使用。

less

```less
@fontSize: 12px;
@bgColor: red;

div {
	font-size: @fontSize;
  background-color: @bgColor;
}
```

sass

```scss
$fontSize: 12px;
$bgColor: red;

div {
	font-size: $fontSize;
  background-color: $bgColor;
}
```

##### mixin

当有一段代码想要复用的时候，可复用的代码片段。

less 

```less
.block(@fontSize) {
  font-size: @fontSize;
  border: 1px solid #ccc;
  border-radius: 4px;
}
div {
  .block(@fontSize);
}
```

sass

```scss
@mixin block($fontSize) {
	font-size: $fontSize;
  border: 1px solid #ccc;
  border-radius: 4px;
}
div {
  @include block($fontSize);
}
```

##### extend

引用 mixin 的地方更多，mixin 代码体积更大的时候。编译好的 css 会有很多代码的重复。extend 就是为了解决这个问题的。extend 和 mixin 都是在 css 内部完成样式的复用，但最后生成的结果是有一些不一样的，mixin 是直接把代码复制过来，extend 是把选择器提取出来，然后把公共的样式写到一起。

如果不需要参数来控制，或追求编译的结果是比较小的，就可以考虑使用 extend。如果场景比较复杂，或者带条件的情况就需要 mixin 处理。

less

```less
.block {
	font-size: @fontSize;
  border: 1px solid #ccc;
  border-radius: 4px;
}
div:extend(.block) {
  background-color: #333;
}
```

sass

```scss
.block {
	font-size: @fontSize;
  border: 1px solid #ccc;
  border-radius: 4px;
}
div {
  @extend .block
  background-color: #333;
}
```

##### loop

适用于复杂有规律的样式，按照一定的规则生成一系列的 css 代码。

less 

less 中实际是没有循环的，但是一个 mixin 是可以调用自己的，所以可以做到递归来达到跟循环类似的效果，定义一个 mixin，然后给 mixin 一个出口，不管是循环还是递归一定要有一个出口，不然就会变成一个死循环。

```less
.gen-col(@n) when (@n > 0) {
	.gen-col(@n - 1);
  .col-@{n} {
		width: 1000px/12*@n;
  }
}
.gen-col(12);
```

循环适用于网格系统、复杂的动画效果、很多元素动画延迟不一样的、很多元素有微小差异样式的，都可以通过循环的方式处理的。

sass 

mixin 递归的方式：

```scss
@mixin gen-col($n) {
  @if $n > 0 {
    @include gen-col($n - 1);
    .col-#{$n} {
      width: 1000px/12*$n;
    }
  }
}
@include gen-col(12);
```

for 循环：

```scss
@for $i from 1 through 12 {
  .col-#{$i} {
    width: 1000px/12*$i;
  }
}
```

##### import

处理 css 模块化。css 本身的 import 不会做合并或加载的时候复用连接，它只能一个文件一个文件的请求，这样会增加 http 的连接数，造成性能问题。css 预处理器的 import 会在编译的时候将文件编译到一起，产生一整个 css 文件。

有了模块之后，就可以按照 css 结构去组织文件，按需去拆解 css 文件。

预处理器的变量是可以跨文件使用的，只要正确的 import 引入了即可。

less 

```less
@import "./module1";
@import "./module2";
```

sass

```scss
@import "./module1";
@import "./module2";
```

## 浏览器 API

### DOM

document.documentElement 表示的是整个 html。

document.body 和 document.documentElement 是一个意思，在文档没有设置 Doctype 的时候使用。

##### 节点

根据相对位置获取元素：

* parentNode
* childNodes
* firstChild
* lastChild
* nextSibling
* previousSibling

操作 DOM 树的 API，全都是在父元素上操作的：

* appendChild
* insertBefore
* removeChild
* replaceChild

一些高级 API：

* contains 检查一个节点是否包含另一个节点的函数。
* cloneNode 复制一个节点，如果传入参数 true，则会连同子元素做深拷贝。
* isEqualNode 检查两个节点是否完全相同。
* isSameNode 检查两个节点是否是同一个节点，实际上在 JavaScript 中可以用“===”。
* compareDocumentPosition 比较两个节点中关系的函数。

创建 DOM 节点：

* createElement
* createTextNode
* createCDATASection
* createComment
* createProcessingInstruction
* createDocumentFragment
* createDocumentType

查找元素：

* querySelector
* querySelectorAll
* getElementById
* getElementsByName
* getElementsByTagName
* getElementsByClassName

##### Attribute

对 DOM 而言，Attribute 和 Property 是完全不同的含义，只有特性场景下，两者才会互相关联。

首先，我们可以把元素的 Attribute 当作字符串来看待，这样就有以下的 API：

* getAttribute
* setAttribute
* removeAttribute
* hasAttribute

像 property 一样的访问 attribute，可以使用 attributes 对象，比如 document.body.attributes.class = “a” 等效于 document.body.setAttribute(“class”, “a”)。

attribute 和 property 的区别是 property 不能修改和获取节点的自定义属性，attribute 可以。

### CSSOM View 

CSSOM View API 可以视为 DOM API 的扩展，在原本的 Element 接口上，添加了显示相关的功能，可以分成三个部分：窗口部分，滚动部分和布局部分。

##### 窗口 API

* moveTo(x, y), moveBy(x, y) 移动窗口位置
* resizeTo(x, y), resizeBy(x, y) 改变窗口大小
* window.open() 打开窗口

```html
<input type="button" value="打开窗口" onclick="openWindow()" />
<input type="button" value="移动窗口" onclick="moveWindow()" />

<script>
  function openWindow() {
    myWindow = window.open('','_blank','width=200,height=100,left=100,right=100')
  }
  function moveWindow() {''
    myWindow.moveTo(200,100)
    myWindow.resizeTo(300,200)
    myWindow.focus()
  }
</script>
```

##### 滚动 API

###### 视口滚动：

相当于视口是父容器，html 为滚动子元素，html 的宽高超出视口，就会发生滚动。

视口滚动行为由 window 对象上的一组 API 控制，我们可以读取视口的滚动位置和操纵视口滚动。

* scrollX： X 方向上的当前滚动距离，有别名 pageXOffset
* scrollY：Y 方向上的当前滚动距离，有别名 pageYOffset
* scroll(x, y)：使页面滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 {top, left}
* scrollBy(x, y)：使页面滚动特定的距离，支持传入配置型参数 {top, left}

监听视口滚动事件，需要在 document 或 window 对象上绑定事件监听函数：

```js
document.addEventListener("scroll", function(event){
  console.log(event.target) // target是document
})
```

###### 元素滚动：

形成滚动的要素：

* 父容器有固定高度
* 父容器设置 `overflow: scroll; `
* 子元素高度超出父元素高度

下面的所有属性和方法都是设置在滚动的父容器身上的：

* scrollTop：Y 方向上子元素的滚动距离。
* scrollLeft：X 方向上子元素的当前滚动距离。
* scrollWidth：子元素可滚动区域的宽度，没有滚动时就为父容器的宽度。
* scrollHeight：子元素可滚动区域的高度，没有滚动时就为父容器的高度。
* scroll(x, y)：使子元素滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 {top, left}。
* scrollBy(x, y) 使子元素滚动特定的距离，支持传入配置型参数 {top, left}。

可在父容器元素上监听它的滚动事件 scroll：

```js
element.addEventListener("scroll", function(event){
  console.log(event.target) // target是滚动父容器
})
```

##### 布局 API

###### 设备屏幕，浏览器窗口，视口的布局信息：

前端开发工作只需要跟视口打交道，所以主要使用 innerHeight、innerWidth 和 devicePixelRatio 这三个属性。

* window.innerHeight, window.innerWidth：视口大小。
* window.devicePixelRatio：表示物理像素和 CSS 像素单位的倍率关系，Retina 屏这个值是 2，后来也出现了一些 3 倍的 Android 屏。
* window.outerWidth, window.outerHeight：浏览器窗口占据的大小。
* window.screen：设备的屏幕尺寸相关信息。

###### 元素的布局信息（都是只读信息）：

* clientRect 系列

  * element.getClientRects()：返回一个包含元素对应的每一个盒所占据的客户端矩形区域的列表。
  * element.getBoundingClientRect()：返回元素对应的盒的布局信息对象。
    * x, y：顶点坐标，相对于视口。
    * width, height：宽高，包括 content, padding, border。跟 offset 系列的宽高一样。
    * top, right, bottom, left：四个边的坐标，相对于视口。

* offset 系列

  document.documentElement.offsetHeight：html 的宽高

  * element.offsetParent：返回一个最近的包含该元素的定位元素或者最近的 `table,` `td,` `th,` `body`元素
  * element.offsetTop：当前元素相对于其 `offsetParent` 元素的顶部距离
  * element.offsetLeft：当前元素相对于其 `offsetParent` 元素的左部距离
  * element.offsetWidth：盒子的宽度，包括 content, padding, border，不包括 margin 和滚动条的尺寸
  * element.offsetHeight：盒子的高度，包括 content, padding, border，不包括 margin 和滚动条的尺寸

* client 系列

  document.documentElement.clientHeight：视口的宽高

  * element.clientTop：盒子的上边框的宽度
  * element.clientLeft：盒子的左边框的宽度
  * element.clientWidth：盒子的宽度，包括 content, padding 的尺寸，不包括 border, margin 和滚动条的尺寸
  * element.clientHeight：盒子的高度，包括 content, padding 的尺寸，不包括 border, margin 和滚动条的尺寸

##### document load 和 DOMContentLoaded 的区别

load 事件在页面所有资源全部加载完成后（包括 DOM 文档树，css 文件，js 文件，图片资源等）会执行。

DOMContentLoaded 事件在形成 DOM 树后就会触发。

##### new Object() 和 Object.create() 有什么区别

```js
// 1.{}等同于new Object()，原型都是Object.prototype
// 2.Object.create(null)，必须传一个参数，可以是一个对象也可以是null。传入null就是没有原型。传入对象就是指定原型。Object.create()就是创建一个空对象，然后把空对象的原型指定为传入的这个对象上。
  const obj1 = {
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  }
  const obj2 = new Object({
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj3 = new Object(obj1)
  console.log(obj1 === obj3)            // true
  const obj4 = Object.create(null)      // {}，但是没有原型
  const obj5 = new Object()             // {}，有原型
  const obj6 = Object.create({          // {}，原型就是传入的这个对象
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj7 = Object.create(obj1)      // 意思就是说我们通过obj1创建了obj6，通过create方式来创建的。
  console.log(obj6.__proto__ === obj1)  // true
  console.log(obj6 === obj1)            // false
  console.log(obj1 === obj3)            // true 
```

##### 手写字符串 trim 方法，保证浏览器兼容性

```js
String.prototype.trim = function () {
  return this.replace(/(^\s*)|(\s*$)/g, "");
}
```

##### 如何捕获 js 程序中的异常

```js
// 1.手动捕获异常
// 这种方式用的比较常见，觉得哪个地方可能会风险比较高，那就用一个try catch给它包起来，然后有异常就输出
try {
  // todo
} catch (ex) {
  console.error(ex) // 手动捕获catch
} finally {
  // todo
}
// 2.自动捕获异常
// 一种兜底方案，比如说我们想要监听一下前端页面，已经上线了，我们做一个统计监听，我们看一下前端页面有没有什么js错误，一般我们第一种方式就是用上面的方式在该try catch的地方打上try catch，如果catch到我们就发一个统计打点，作为一个记录。第二种方式就是我们不可能每一行都用try catch。这样成本太高。我们只在一个高风险的地方用try catch，其他地方我们用一个window.onerror就可以了。它会自动捕获你程序中的一些问题。
window.onerror = function (message, source, lineNum, colNum, error) {
  // 报错信息 源码 行号 列号 错误栈
  // 第一，对跨域的js，如cdn，会告诉你错误了，但不会有详细的报错信息
  // 第二，对于压缩的js，还要配合sourceMap去反查到为压缩代码的行，列
}
//所以通过这两个方式来集合，你就能监听到页面上绝大部分的错误。
```

##### 获取当前页面 url 参数

```js
// 1.传统方式，查找location.search
function query (name) {
  const search = location.search.substring(1)
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
  const res = search.match(reg)
  if (res == null) {
    return null
  }
  return res[2]
}
// 2.新api，URLSearchParams
function query (name) {
  const search = location.search
  const p = new URLSearchParams(search)
  return p.get(name)
}
```

##### 数组去重

```js
// 1.传统方式，遍历元素挨个比较，去重
function unique (arr) {
  const res = []
  arr.forEach(item => {
    if (res.indexOf(item) < 0) {
      res.push(item)
    }
  })
  return res
}
// 2.使用Set（无序，不能重复）
function unique (arr) {
  const set = new Set(arr)
  return [...set]
}
```

##### 前端性能优化

原则：多使用内存缓存，减少计算，减少网络请求
方向：加载页面要更快，页面渲染要更快，页面操作要更流畅

##### 防抖，节流

```js
// 防抖
function debounce(fn, wait) {
  var timer = null
  return function () {
    var context = this
    var args = arguments
    // 只要timer有就清除它
    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, wait)
  }
}
// 立即执行版
function debounce(func, wait) {
  let timer;
  return function() {
    let context = this
    let args = arguments
    if (timer) {
      clearTimeout(timer)
    }
    let callNow = !timer;
    timer = setTimeout(() => {
      timer = null;
    }, wait)
    if (callNow) func.apply(context, args);
  }
}
// 使用
var fn = function () {
 console.log('boom')
}
document.onclick = debounce(fn, 500)

// 节流
// 定时器版
function throttle(fn, wait) {
  let timer;
  return function() {
    let context = this
    let args = arguments
    // timer没有的时候才执行函数
    if (!timer) {
      timer = setTimeout(() => {
        timer = null
        fn.apply(context, args)
      }, wait)
    }
  }
}
// 时间戳版
function throttle(fn, wait) {
  let previous = 0
  return function() {
    let now = Date.now()
    let context = this
    let args = arguments
    if (now - previous > wait) {
      fn.apply(context, args)
      previous = now
    }
  }
}

// 使用
var fn = function () {
 console.log('boom')
}
document.onclick = throttle(fn, 500)
```

##### vue diff 算法

必要性：lifecycle.js - mountComponent()，组件中可能存在多个 key 的变化，一个组件又只有一个 Watcher ，所以需要知道具体哪里发生了变化，这时就必须要用 diff 算法去比对具体哪里变化。

执行方式：patch.js - patchVnode()，patchVnode 是 diff 发生起始的地方，整体策略：深度优先，同层比较 updateChildren() 递归操作。

diff 算法是虚拟 DOM 技术的必然产物：通过新旧虚拟 DOM 的对比（即diff），将变化的地方更新在真实 DOM 上。diff 高效的对比过程也降低了时间复杂度，提高性能。

Vue 中 diff 执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果 oldVnode 和新的渲染结果 newVnode，此过程称为 patch。

##### vue 模版编译

字符串模版 => 抽象语法树(AST) => 生成 JS 函数。

模板编译的主要目标是将模板 template 转换为渲染函数 render。这个过程是一个字符串模版被转换成 JS 函数。

入口文件 entry-runtime-with-compiler.js 中，如果存在 template 或 el 选项就会执行编译，会执行 compileToFunctions 方法，把模版传进去。通过方法名就可以知道，它可以把字符串模版变成一个函数，它会返回 render 函数。

编译分为三步：解析、优化和生成，src/compiler/index.js。

- 解析 - parse：解析器把模版转换为 AST 对象，抽象语法树，它是对我们将来我们要生成的代码的 JS 对象的描述，将来遍历这棵树，把代码生成。这是底层代码生成器的必要知识。用对象的形式来描述 JS 代码，先把字符串变成对象，这个对象是有格式规定的，能描述将来要生成的代码。解析器内部分了HTML解析器、文本解析器和过滤器解析器。
- 优化 - optimize：在 AST 中标记静态子树，静态子树是界面中永远不变的节点，如两层嵌套以上的纯文本节点。
  - 每次重新渲染，不需要为静态子树创建新节点。
  - 虚拟 DOM 中 patch 时，可以跳过静态子树。
- 代码生成 - generate：把 AST 转换成代码字符串，比如一个字符串形式的函数，然后用 new Function(code) 把字符串函数的代码作为参数传进去就可以得到一个真正的 render 函数。

processIf 用于解析 v-if，genIf 用于生成条件语句相关代码。

processFor 用于解析 v-for 指令，genFor 用于生成相应代码。

v-if，v-for 这些指令只能在编译器阶段处理，如果我们要在 render 函数处理条件或循环只能使用 if 和 for，然后生成VNode。

##### vue 批量异步更新策略

侦听到数据变化，不会把对应的 Watcher 直接更新，而是开启一个队列，存放所有需要变化的组件 Watcher，启动一个微任务 Promise.resolve().then()，在面里遍历队列，一次性的执行所有 Watcher 的更新函数，更新函数把所有的 DOM 更新全部做完之后，浏览器统一的刷新一次，就达到了我们期待的高效方式。

如果一个 key 同时被多次修改，导致 Watcher 被多次触发，只会被推入到队列中一次，避免不必要的计算和 DOM 操作。

异步策略的选择会有优先级，根据当前执行环境的支持情况，会分别使用 Promise.then、MutationObserver、setImmediate、setTimeout，如果使用宏任务做的话，用户体验就不好了，因为它只能到下一个循环才能看到结果了。

##### MVVM 框架三要素

数据响应式：数据变化视图更新。

模版引擎：提供描述视图的模版语法。

渲染：把模版生成真正的 html。

##### let const

let

* let 声明的变量是拥有块级作用域的。
* 用 let 声明的全局变量不能通过 window 的属性去访问。
* var 定义的变量可以重复，let 声明的变量不允许重复定义。
* let 声明的变量不会进行变量提升。

const

* const 具备以上 let 的所有特点
* const 它定义的是常量。既然是常量，也就是说它不能再被修改了。
* const 不允许先声明再赋值，let, var 都可以，就是声明的时候必须做初始化。

##### forEach 实现 break

```js
let arr = [1, 2, 3, 4, 5]
try{
  arr.forEach(item => {
    if (item === 3) {
      throw new Error('出错了')
    } else {
      console.log(item)
    }
  })
} catch(e){
  throw e
}
```

##### Proxy

代理的核心价值是屏蔽原始信息，保证原始信息的安全。

```js
let o = {
  name: 'xiaoming',
  price: 190
}
let d = new Proxy(o, {})
```

* 第一个参数：你要代理谁。

* 第二个参数：代理之后我能干什么。比如劫持构造函数，劫持你的 get, set。但是经常使用的就是读和取。因为我们在写业务的过程中百分之九十九都是在读写数据，对于其他的操作来说基本用不到。

操作传成 {} 就相当于没操作，没操作就等于是透传。

```js
d.revoke() // 撤销代理
```

##### .then() 链式调用的工作原理

* then 传入的函数返回了 promise 实例，那 then 函数返回就是这个 promise 实例；
* then 传入的函数返回的不是 promise 实例，那 then 函数会返回一个全新的 promise 实例并 resolve 这个返回的数据；
* then 传入的函数什么都没返回，那 then 函数也是会返回一个全新的 promise 实例并 resolve undefined。
* then 传入的是非函数，那 then 函数返回的是该 then 前面的那个的 promise 实例。

所以不管怎么样，then() 最终都会返回一个 promise 对象，这样就能保证我们能连续的使用链式调用。

##### Promise.all() & Promise.rase()

```js
// all
const p1 = Promise.resolve(1)
const p2 = Promise.resolve(2)
const p3 = Promise.resolve(3)
Promise.all([p1, p2, p3])
  .then(value => {
    console.log(value) // [1, 2, 3]
  })
// rase
const p1 = () => {
  return new Promise((resolve, reject) => {
    setTimeout(function () {
      resolve(1)
    }, 0)
  })
}
const p2 = () => {
  return new Promise((resolve, reject) => {
    setTimeout(function () {
      resolve(2)
    }, 1000)
  })
}
Promise.race([p1(), p2()])
  .then(value => {
    console.log(value) // 1
  })
```

##### Promise.all 实现

```js
Promise.all = arr => {
  let aResult = [];    // 用于存放每次执行后返回结果
  return new _Promise(function (resolve, reject) {
    let i = 0;
    next();    // 开始逐次执行数组中的函数(重要)
    function next() {
      arr[i].then(function (res) {
        aResult.push(res);    // 存储每次得到的结果
        i++;
        if (i == arr.length) {    // 如果函数数组中的函数都执行完，便resolve
          resolve(aResult);
        } else {
          next();
        }
      })
    }
  })
}
```

##### async/await

用同步的写法来写异步。

* 使用 await，函数必须用 async 标识，这个函数也可以作为一个普通的函数来执行。 
* await 后面必须跟一个 promise 实例，如果不是它会帮你自动处理成一个 promise 对象，await 的返回值就是这个 promise 实例 resolve 或 reject 传出来的结果。

```js
const load = async function () {
  const result1 = await loadImg(src1)
  console.log(result1)
  const result2 = await loadImg(src2)
  console.log(result2)
}
load()
```

async 函数中你返回的不是一个 promise 的时候，它会自动的帮你把返回值变成一个 promise 实例。

```js
async function firstAsync () {
  return 27 // 引擎会自动帮你转成这种效果Promise.resolve(27)
}
```

##### form 的 enctype 属性是声明编码格式，针对 post 的时候主要有两种编码

* url encode 的方式提交文本。
* formdata 是把数据做编码之后提交，这种方式的好处是它可以上传文件。

##### html 语义

语义类标签对开发者更为友好，语义类标签增强了可读性，能够清晰地看出网页的结构，便于团队的开发和维护。

语义类标签也更适合搜索引擎检索（SEO），也可以让搜索引擎爬虫更好地获取到更多有效信息，有效提升网页的搜索量，并且语义类还可以支持读屏软件，根据文章可以自动生成目录等等。

正确使用整体结构类的语义标签，可以让页面对机器更友好。比如，这里一个典型的 body 类似这样：

在 body 下面，有一个 header，header 里面是一个 nav，跟 header 同级的有一个 aside，aside 里面也有一个 nav。接下来是文章的整体，也就是一个一个的 section。section 里面可能还有嵌套，但是我们就不管了，最后是一个 footer，这个 footer 里面可能有 address 这样的内容。

```html
<body>
    <header>
        <nav>
            ……
        </nav>
    </header>
    <aside>
        <nav>
            ……
        </nav>
    </aside>
    <section>……</section>
    <section>……</section>
    <section>……</section>
    <footer>
        <address>……</address>
    </footer>
</body>
```

##### rem  根据根元素的字体大小搞来搞去

```css
html {
  font-size: 62.5%; /* 10÷16=62.5% */
}
@media only screen and (min-width: 481px){
  html {
    font-size: 94%!important; /* 15.04÷16=94% */
  }
}
@media only screen and (min-width: 561px){
  html {
    font-size: 109%!important; /* 17.44÷16=109% */
  }
}
@media only screen and (min-width: 641px){
  html {
    font-size: 125%!important; /* 20÷16=125% */
  }
}
```

##### 禁用手型

```css
div {
	cursor: not-allowed;
}
```

##### 文字超出末尾显示省略号

```css
div {
  width: 200px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
```

##### css 画三角形

![triangle-up](/Users/dxm/tool/images/实战/triangle-up.png)

```css
#triangle-up {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}
```

##### 是否可选择文本

```css
div {
  user-select: none; /* none用户不能选择文本，text用户可以选择文本 */
}
```

##### css reset

https://meyerweb.com/eric/tools/css/reset/

https://yuilibrary.com/yui/docs/cssreset

https://necolas.github.io/normalize.css/

##### height

* height 不会继承，在所有元素都不设置高度的情况下，如果想给某个元素设置 height: 100% 需要从 html 开始，每一层都要设置 height: 100%，才会有效。
* 父级元素的高度会被设置了高度的子元素撑开，高度就为子元素的高度。

##### 字体

指定字体：

```
body {
  font-family: 'PingFang SC', 'Microsoft Yahei', serif;
}
```

自定义字体：

```
@font-face {
  font-family: 'IF';
  src: url('./IndieFlower.ttf');
}
.custom-font {
  font-family: 'IF';
}
```

iconfont: 

既然可以自定义字体，所谓自定义字体原理就是规定每个字长什么样，如果规定每个字是图标的样子，就可以把文字当做图标用了。

##### webpack 和 css

webpack 给 css 提供了相当多的能力和处理方式。

* css-loader 将 css 变成 js
* style-loader 将 js 样式插入 head
* ExtractTextWebpackPlugin 将 css 从 js 中提取出来
* css modules 解决 css 命名冲突的问题
* less-loader sass-loader 等各类预处理器
* postcss-loader postcss 处理

##### 常见的 web 前端攻击方式有哪些，怎么预防

1.XSS 跨站请求攻击

* 一个博客网站，我发表一篇博客，其中嵌入 \<script> 脚本
* 脚本内容：获取 cookie，发送到我的服务器（服务器配合跨域）
* 发布这篇博客，有人查看它，我轻松收割访问者的 cookie

预防：

* 替换特殊字符，如把 < 变为 \&lt;，把 > 变为 \&gt;
* 这样的话 \<script> 就变为 \<script&gt;，直接显示，而不会作为脚本被执行。只有 html 里面有 script 才会作为脚本被执行
* 前端要替换，后端也要替换，都做总不会有错
* 有 xss npm 工具

2.XSRF 跨站请求伪造

* 你正在购物，看中了某个商品，商品 id 是 100
* 付费接口是 xxx.com/pay?id=100，但没有任何验证
* 我是一个攻击者，我看中了一个商品，id 是 200
* 我向你发送一个电子邮件，邮件标题很吸引人
* 但邮件正文隐藏着 \<img src="xxx.com/pay?id=200" />
* 你一查看邮件，就购买了 id 是 200 的商品

因为你现在正在购物，肯定登录了这个网站了，你就会有用户信息了，图片的地址去访问的时候，你的用户信息已经带过去了。

预防：

* 使用 post 接口，用 img 攻击是攻击不通的，因为 img 的 src 只支持 get 请求
* 增加验证，例如密码，短信验证码，指纹等

##### 浏览器兼容

1.DOM 事件处理程序的兼容写法

```js
var eventshiv = {
  // event兼容
  getEvent: function(event) {
    return event ? event : window.event;
  },

  // 添加事件句柄
  addHandler: function(elem, type, listener) {
    if (elem.addEventListener) {
      elem.addEventListener(type, listener, false)
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, listener)
    } else {
      elem['on' + type] = listener
    }
  },

  // 移除事件句柄
  removeHandler: function(elem, type, listener) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, listener, false)
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, listener)
    } else {
      elem['on' + type] = null
    }
  },

  // 取消默认行为
  preventDefault: function(event) {
    if (event.preventDefault) {
      event.preventDefault()
    } else {
      event.returnValue = false
    }
  },

  // 阻止事件冒泡
  stopPropagation: function(event) {
    if (event.stopPropagation) {
      event.stopPropagation()
    } else {
      event.cancelBubble = true
    }
  }
}
```

2.IE9 以下浏览器不能使用 opacity

```css
.class {  
  filter:alpha(opacity=50);  
  -moz-opacity:0.5;  
  opacity: 0.5;  
}
```

3.图片默认有间距

使用 float 为 img 布局。

4.不同浏览器的标签默认的外补丁和内补丁不同

使用 css reset

5.ajax 写法

IE：ActiveXObject
其他：xmlHttpReuest

##### BOM

location

地址的一些信息

```js
// https://coding.imooc.com/lesson/400.html?a=100&b=200#mid=30309
location.href        // https://coding.imooc.com/lesson/400.html#mid=30309
location.protocol    // 'https:'  
location.host        // 'coding.imooc.com'  
location.pathname    // '/lesson/400.html'
location.search      // '?a=100&b=200'
location.hash        // '#mid=30309'
```

history

前进后退等路由信息

```js
history.back()    // 网页后退
history.forward() // 网页前进
```

##### cookie

cookie 本身是用于浏览器端和 server 端通讯的，也就是 http 请求的一部分。

早期没有专门的本地存储，只能用 cookie 来做本地存储。

cookie api：

cookie是个字符串，中间用分号分割，每一部分都是key=value的形式。

```js
document.cookie = 'key=value;path=path;domain=domain;max-age=max-age-in-seconds;expires=date-in-GMTString-format;secure'
```

每次赋值，相同的key会覆盖，不同key会追加：

```js
document.cookie = 'a=100'
console.log(document.cookie) // 'a=100'
document.cookie = 'b=200'
console.log(document.cookie) // 'a=100; b=200'
document.cookie = 'a=300'
console.log(document.cookie) // 'b=200; a=300'
```

简化`document.cookie` 的获取方法

```js
var docCookies = {
  getItem: function (sKey) {
    return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[-.+*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
  },
  setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
    if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
    var sExpires = "";
    if (vEnd) {
      switch (vEnd.constructor) {
        case Number:
          sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
          break;
        case String:
          sExpires = "; expires=" + vEnd;
          break;
        case Date:
          sExpires = "; expires=" + vEnd.toUTCString();
          break;
      }
    }
    document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
    return true;
  },
  removeItem: function (sKey, sPath, sDomain) {
    if (!sKey || !this.hasItem(sKey)) { return false; }
    document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + ( sDomain ? "; domain=" + sDomain : "") + ( sPath ? "; path=" + sPath : "");
    return true;
  },
  hasItem: function (sKey) {
    return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[-.+*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
  },
  keys: /* optional method: you can safely remove it! */ function () {
    var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
    for (var nIdx = 0; nIdx < aKeys.length; nIdx++) { aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); }
    return aKeys;
  }
};

// 使用
docCookies.setItem("test0", "Hello world!");
docCookies.setItem("test1", "Unicode test: \u00E0\u00E8\u00EC\u00F2\u00F9", Infinity);
docCookies.setItem("test2", "Hello world!", new Date(2020, 5, 12));
docCookies.setItem("test3", "Hello world!", new Date(2027, 2, 3), "/blog");
docCookies.setItem("test4", "Hello world!", "Sun, 06 Nov 2022 21:43:15 GMT");
docCookies.setItem("test5", "Hello world!", "Tue, 06 Dec 2022 13:11:07 GMT", "/home");
docCookies.setItem("test6", "Hello world!", 150);
docCookies.setItem("test7", "Hello world!", 245, "/content");
docCookies.setItem("test8", "Hello world!", null, null, "example.com");
docCookies.setItem("test9", "Hello world!", null, null, null, true);
docCookies.setItem("test1;=", "Safe character test;=", Infinity);
 
alert(docCookies.keys().join("\n"));
alert(docCookies.getItem("test1"));
alert(docCookies.getItem("test5"));
docCookies.removeItem("test1");
docCookies.removeItem("test5", "/home");
alert(docCookies.getItem("test1"));
alert(docCookies.getItem("test5"));
alert(docCookies.getItem("unexistingCookie"));
alert(docCookies.getItem());
alert(docCookies.getItem("test1;="));
```

##### 事件

事件来自输入设备，输入设备有三种：

* 键盘
* 鼠标
* 触摸屏

###### 捕获与冒泡

捕获过程是从外向内，冒泡过程是从内向外。

在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。

建议这样使用冒泡和捕获机制：默认使用冒泡模式，当开发组件时，遇到需要父元素控制子元素的行为，可以使用捕获机制。

这是捕获和冒泡发生的完整顺序：

```html
<body>
  <input id="i"/>
</body>

<script>
document.body.addEventListener("mousedown", () => {
  console.log("key1")
}, true)

document.getElementById("i").addEventListener("mousedown", () => {
  console.log("key2")
}, true)

document.body.addEventListener("mousedown", () => {
  console.log("key11")
}, false)

document.getElementById("i").addEventListener("mousedown", () => {
  console.log("key22")
}, false)
  
// key1
// key2
// key22
// key11
  
</script>
```

addEventListener 三个参数：

* 事件名称
* 事件处理函数
* 捕获还是冒泡

事件处理函数不一定是函数，也可以是个 JavaScript 具有 handleEvent 方法的对象：

```js
var o = {
  handleEvent: event => console.log(event)
}
document.body.addEventListener("keydown", o, false);
```

第三个参数不一定是 bool 值，也可以是个对象，它提供了更多选项。

* once：只执行一次。
* passive：承诺此事件监听不会调用 preventDefault，这有助于性能。
* useCapture：是否捕获（否则冒泡）。

###### 事件代理

事件代理是基于事件冒泡做的，在事件冒泡这个机制的基础上去实现事件代理，代理就是因为数量太多或结果比较复杂，不好去挨个都去绑定事件，所以把事件绑到某一个父元素上，在事件里判断是不是我们想要触发事件的那个元素，再去做一些其他的操作。

###### 焦点

浏览器 API 提供了 API 来操作焦点：

其实原本键盘事件不需要捕获过程，但是为了跟 pointer 设备保持一致，也规定了从外向内传播的捕获过程。

```js
document.body.focus()
document.body.blur()
```

###### 事件应用

通用事件监听函数

```js
// 定义
function bindEvent (elem, type, fn) {
  elem.addEventListener(type, fn)
}
// 使用
const btn1 = document.getElementById('btn1')
bindEvent(btn1, 'click', event => {
  console.log(event.target) // 触发事件的目标元素，就是这个btn1这个dom对象
  event.preventDefault() // 阻止浏览器默认行为
  event.stopPropagation() // 阻止事件冒泡
  console.log('clicked')
})
```

适用普通的绑定和事件代理的绑定。

```js
// 定义
function bindEvent (elem, type, selector, fn) {
  if (fn == null) {
    fn = selector
    selector = null
  }
  elem.addEventListener(type, event => {
    const target = event.target
    if (selector) {
      // 代理绑定
      if (target.matched(selector)) {
        fn.call(target, event)
      }
    } else {
      // 普通绑定
      fn.call(target, event)
    }
  })
}

// 使用
const btn1 = document.getElementById('btn1')
const div3 = document.getElementById('div3')
bindEvent(btn1, 'click', function (event) {
  event.preventDefault()
  alert(this.innerHTML)
})
bindEvent(div3, 'click', 'a', function (event) {
  event.preventDefault()
  alert(this.innerHTML)
})
```

##### cookie 和 session

cookie 是在服务端返回数据的时候通过 Set-Cookie 这个 header 设置到浏览器里面。

在网站的开发当中，经常用到的就是使用 cookie 来保存 session，我们经常会做的一个方式就是把用户登录之后的一个 id 或者是 session的一个 key 给它设置到 cookie 里面，然后下一次用户请求过来的时候呢，我们就可以读取这个 cookie 下面的值，然后通过这个 key 去定位这个用户的信息，这就是 session 的概念，只要能够保证定位到这个用户，那么它就是一种 session 的实现方案，我们可以直接把用户的 id 给它写到 cookie 里面去，然后下次请求过来的时候，我们根据这个 id 去搜索用户的信息，但是呢因为用户 id 也算是用户信息的一部分，那么直接保存在客户端，那么相对是不太安全的，那么也有其他的方案就是说我们把这个 id 相关的一些信息给它转化一下，转化成一个对应的唯一key，然后这个用户信息跟这个sessionkey的对应关系就存在服务端的数据库或者缓存里面，然后请求过来的时候我们读取这个 sessionkey 然后再去搜索一下，把这个对应的关系拿出来就可以，这就是 session 的一个概念，它跟 cookie 不是一一对应的，它不一定要用 cookie 来实现，我们可以通过 js 的方式写在 header 里面那也是可以实现的，所以方式有很多种。

##### 跨域

同源策略：

ajax 请求的时候，浏览器要求当前网页和 server 必须同源（安全），同源指的是协议、域名、端口三者一致。在服务端或非浏览器的环境下是没有这个限制的。

加载图片，css，js 可无视同源策略：

同源策略第一个条件就是 ajax 请求，如果不是 ajax 请求，比如说图片，css，js 等文件的加载可无视同源策略，它们的地址都可以跨域，浏览器不会限制。

图片，css，js 可以无视同源策略，都是有一定的功能需求的，浏览器也是为了它们有一定功能做了一些考虑。

```html
<img src="跨域的图片地址" />
<link href="跨域的css地址" />
<script src="跨域的js地址"></script>
```

1.\<img/>

图片可用于统计打点。统计可能是使用第三方统计服务，比如站长之家，百度统计等，这些都是外域的，统计打点无非就是发一个请求，如果用 ajax 发的话就会出现跨域。所以说我们用图片，初始化一个图片，把图片的地址写成第三方统计服务的地址，在地址里面写上我们各种各样需要的参数，通过图片去发这个请求就可以了。

2.\<link/> \<script>

\<link /> \<script> 可以使用 cdn，cdn 一般都是外域。

3.\<script> 可以实现 jsonp

jsonp 是前端实现跨域一个比较常用的方案。

跨域解决方案：

所有的跨域，都必须经过 server 端允许和配合。

如果未经 server 端允许就实现的跨域，说明浏览器有漏洞，是一个危险信号。

1.Jsonp

我们先看一个问题，浏览器随便访问一个网址，服务端返回的一定是一个 html 文件吗。服务端拿到这个网址 url 之后分析，获取这个请求文件的内容，然后把文件内容返回，其实服务端不一定返回一个 html 文件的内容，服务端可以动态拼接任何的数据内容返回，只要符合相应文件的格式要求，同理 script 去访问一个 js 地址，也不一定就返回一个 js 静态文件。

Jsonp 原理

* \<script> 可以绕过跨域限制
* 服务端可以拼接任意动态数据返回
* 所以就可以通过 \<script> 获得跨域的数据，只要服务端愿意返回
* 只能用 GET 请求，并且要求返回 JavaScript。

jsonp 简易 demo

```html
<script>
  window.callback = function (data) {
    // 这是我们跨域接收的信息
    console.log(data)
  }
</script>

<!-- 这个script将返回 callback({x: 100, y: 200}) -->
<script src="https://imooc.com/getData.js?cb=callback&id=123"></script>
```

2.cors

其实不管我们有没有返回 'Access-Control-Allow-Origin' 这个头，浏览器它都会向我们的服务去发送这个请求，浏览器在发送一个请求的时候它并不知道我们这个服务是不是跨域的，所以说它还是会发送请求，并且接收你的返回内容，只不过呢在浏览器接收到它的数据返回的时候，它看到里面没有一个'Access-Control-Allow-Origin'这么一个头并且设置为允许的话，那么它会把这个请求返回的内容给它忽略掉并且在控制台中报跨域的错。

服务端支持的一种解决跨域的方式，是纯服务器端的操作。

cors 其实是一个统称，就是服务器端可以设置 http header，在服务端 response 返回的时候可以设置 header，如下面这些东西。

```js
response.setHeader('Access-Control-Allow-Origin', 'http://localhost:8081') // 允许的域名是什么 
response.setHeader('Access-Control-Allow-Headers', 'X-Requested-With')     // 允许的headers是什么 
response.setHeader('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS') // 允许的methods是什么 
response.setHeader('Access-Control-Allow-Credentials', 'true') // 接收跨域的cookie，是否允许传cookie
```

##### ajax

xhr.readyState 等于 4 的时候才说明 ajax 请求成功了，然后判断 xhr.status 也就是 http 状态码就可以了。比如网络断开的情况下 xhr 不可能等于 4，所以前端 ajax 请求的业务逻辑中根本就不用判断类似断网的这种情况。

简易 ajax 封装：

```js
// 回调函数版
function ajax (url, method, successFn, errorFn, postData) {
  const xhr = new XMLHttpRequest()
  xhr.open(method, url, true)
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        successFn(
          JSON.parse(xhr.responseText) // 返回的信息是字符串
        )
      } else if (xhr.status === 404) {
        errorFn(new Error('404 not found'))
      }
    }
  }
  if (method === 'GET') {
  	xhr.send()
  } else {
    xhr.send(JSON.stringify(postData)) // 发送的数据也要求是字符串
  }
}

const url = '/data/test.json'
const method = 'POST'
const postData = {
  username: 'zhangsan',
  password: 'xxx'
}
ajax(url, method, postData, function(res) {
  console.log(res)
}, function(err) {
  console.log(err)
})
```

```js
// promise版
function ajax (url, method, postData) {
  const p = new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest()
    xhr.open(method, url, true)
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(
            JSON.parse(xhr.responseText)
          )
        } else if (xhr.status === 404) {
          reject(new Error('404 not found'))
        }
      }
    }
    if (method === 'GET') {
      xhr.send()
    } else {
      xhr.send(JSON.stringify(postData)) // 发送的数据也要求是字符串
    }
  })
  return p
}

const url = '/data/test.json'
const method = 'GET'
const postData = {
  username: 'zhangsan',
  password: 'xxx'
}
ajax(url, method, postData)
  .then(res => {
    console.log(res)
  })
  .catch(err => {
    console.log(err)
  })
```

##### 性能优化

让网页加载的更快，渲染的更快，运行的更流畅。

* 让加载更快：减少网络加载耗时。

  * 减少资源体积：压缩代码，js 代码，css 代码，图片都可以压缩。
  * 减少访问次数：合并代码，ssr 服务端渲染（会将首屏页面和内容一起返回，减少一次 ajax 请求页面内容的时间，加速首屏渲染。），缓存
  * 使用 cdn 

* 让渲染更快：减少 cpu 计算量。多使用内存、缓存或其他方法。（空间换时间）

  * css 放在 head 里面

    在dom树生成完成之前就把 css 规则给它加载完，当 dom 树生成完之后直接和所有的 css 整合生成一个渲染树，生成一个 Render Tree，然后一步渲染完成，这样的话就不要再出现重复了。

  * js 放到 body 最下面

    因为 js 执行和 dom 渲染都是使用的渲染进程的主线程。防止一个页面渲染的过程比较长，让用户尽早的看到渲染后的页面，不要让 js 阻碍 dom 渲染。

  * 尽早执行 js

    window.onload：网页全部资源加载完才会执行，包括图片，视频等。

    window.DOMContentLoaded：dom 渲染完即可执行，此时图片，视频可能还没有加载完。

  * 懒加载：

    列表图片懒加载：把图片地址赋值成一个默认的预览图片 src="preview.png"。把真正的图片地址放到 data-realsrc 里，当判断到图片露出屏幕的时候再去把图片真正的地址赋值到图片的 src 上。

    ```html
    <img id="img1" src="preview.png" data-realsrc="abc.png" />
    
    <script type="text/javascript">
      var img1 = document.getElementById('img1')
      img1.src = img1.getAttribute('data-realsrc')
    </script>
    ```

  * 对 dom 查询进行缓存

  * 频繁 dom 操作，合并到一起插入 dom 结构

  * 节流 throttle 防抖 debounce：你要知道节流防抖是怎么回事，节流防抖不是让渲染更快，而是让渲染更加流畅，是体验性的优化。当然归到让渲染更快，渲染优化里面也没问题。

##### 防抖 debounce

* 监听一个输入框，文字变化后触发 change 事件。
* 直接监听 keyup 事件，则会频繁触发 change 事件。
* 防抖：用户在输入结束或暂停的时候，才会触发 change 事件。

防抖简易 demo：

```js
const input1 = document.getElementById('input1')
let timer = null
input1.addEventListener('keyup', function () {
  if (timer) {
    clearTimeout(timer)
  }
  timer = setTimeout(() => {
    // 模拟触发change事件
    console.log(input1.value)
    // 清空定时器
    timer = null
  }, 500)
})
// debounce是对函数的封装，所以它最终返回应该是一个函数
// 函数的封装就是将大部分逻辑封装起来，使使用的时候更加简单，只写业务逻辑就行了。jq zepto等库和插件都是这个原理。
function debounce (fn, delay = 500) {
  // 这个timer是在闭包中的，timer这个数据就被隐藏了，不会被外面轻易拿到
  let timer = null

  return function () {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      // this是为了获取添加事件的dom对象，arguments是为了将事件函数接收到的参数透传给fn
      fn.apply(this, arguments)
      timer = null
    }, delay)
  }
}

// 使用
input1.addEventListener('keyup', debounce(function () {
  console.log(input1.value)
}, 300))
```

##### 节流 throttle

防抖的场景是频繁输入和频繁操作的时候最后的时候才去触发。节流是你在频繁输入频繁操作的时候它会保持一个频率连续触发。

* 比如拖拽一个元素时，要随时拿到这个元素被拖拽的位置。
* 如果直接用 drag 事件，则会频繁触发，很容易导致卡顿。
* 这个时候我们需要节流：无论拖拽的速度多快，都会每隔 100ms 触发一次。

节流简易 demo：

```js
const div1 = document.getElementById('div1')
let timer = null
div1.addEventListener('drag', function (e) {
  if (timer) {
    return 
  }
  timer = setTimeout(() => {
    console.log(e.offsetX, e.offsetY)
    timer = null
  }, 100)
})
// 节流函数封装
function throttle (fn, delay = 100) {
  let timer = null
  return function () {
    if (timer) {
      return
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments)
      timer = null
    }, delay)
  }
}

// 使用
input1.addEventListener('drag', throttle(function (e) {
  console.log(e.offsetX, e.offsetY)
}, 200))
```

##### trim

```js
 String.prototype.trim=function(){
   return this.replace(/(^\s*)|(\s*$)/g, "");
 }
```


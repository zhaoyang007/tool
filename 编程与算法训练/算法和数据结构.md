思考、训练

学习高手代码

自顶向下的编程方式：先写主干逻辑。

升纬，空间换时间



编程能力：语言本身的运用和表达，算法的设计，数据结构的设计。

算法不是空洞的理论和公式，算法是用来解决实际问题的。

问题抽象：把描述很大很全的问题收敛成一个非常小的点去做这件事情，用代码去实际的写出来实现它。

弄好算法的必要条件：

* 要先把所有的基础 API 搞清楚
* 搞清楚他的需求是要干什么

思路：怎么设计算法

* 算法的本质是寻找规律并实现
* 如何找规律：规律就是输入和输出之间的关系，先找到简单的形式，然后按照这个形式寻找突破点。去实现。把所有的关系都列出来，基本就找到规律了。
* 实现：实现是程序的本质算法（条件，循环，递归...就是算法运算的过程）+ 数据结构的结合体



程序：让机器按照你设定的流程去运行。能控制程序运行流程的就是条件，循环，递归...等。

用数学归纳法找重复性。用计算机思维去找，不要人肉递归。

程序改变代码运行的流程。

数据结构用来保存你的数据和你的调度。

在输入输出之间找规律找关联。

问题抽象：将场景的问题分析出来，找出关键点和规律，然后实现它。

数学建模：将场景用数据结构表示出来。

动态输入：举出多种输入情况去验证你的思路。

边界问题。



匹配一个字符串的子串，用正则处理比较好。



时间复杂度：运行的次数。

空间复杂度：占用的内存。



##### 递归

递归：找到规律，分步拆解。

递归就是范围从大到小，每一部分的处理过程是相同的，输入输出是相同的，处理次数未知，再加上边界条件。

确定好输入输出，边界条件后，然后想好一次的处理过程，然后递归下去就可以了，不用把全部的都想出来。

普通递归：只要最后的一个结果。

要上一级返回的结果的递归：要每一级累计的结果，输入和输出不能是同一个东西。从前往后遍历计算累加结果。

深度优先：先递归，再做事。先处理下级内容。是向内一层一层的钻进。知道最后一个层级的结果，拿到它再一层一层的把上面的结果都算出来，最终算到最大的那个数，就是答案了。所以是从后往前遍历。输入是 n，输出是结果所要的东西。

广度优先：先做事，再递归。先处理同级内容。

递归的时机可以在边界的条件判断去找。

代码落地

分步拆解复杂问题

##### 编程技巧

一维数组的坐标变换。

1.维护 i j 两个指针来做各种事情。

双指针交换：一个循环指针，一个始终记录下一个想要的节点要放的位置的指针。这样就可以在不增加新内存的情况下，通过 index 方式，把所有想要的节点放在应该的位置。

```js
// 移动零
function moveZero(arr) {
  // j记录下一个要填入的非零元素在什么地方。
  let j = 0;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] !== 0) {
    	arr[j] = arr[i];
      if (i !== j) {
				arr[i] = 0;
      }
      j++;
    }
  }
  return arr;
}
```

2.双循环 O(n^2)

3.左右边界 i j 向中间收敛，左右夹逼 O(n)

##### 思路

1.暴力

2.基本情况

3.在列举基本情况的基础上，找 最近 重复子问题。因为程序除了简单的情况使用 if else，其他就是用 for while 和递归 不断的重复。所有复杂问题最终都要变成这几个语句来给计算机去处理。所以我们就往这个方向去做和思考。如果能用重复的东西解决的问题，说明这个问题本身就是可重复的，所以就是找它的重复性。重复的时候可以分出很多 if else 分支，就会让递归的程序越来越复杂，复杂性就慢慢出来了。

先按照自己觉得对的思路，一步步的开始做，开始不要想太多实现不了的

遇到想象不出来的抽象，要具体描述出问题，思路就清晰了。

栈：具有最近相关性用栈解决，外层和外层配对，内层可以和内层配对。 

现实和工程中都有很多这种从外向内或从内向外逐渐扩散的特性。

先来后到就用队列。

所有东西都不是发明创造的，都是对现实中已有的逻辑进行抽象，然后用计算机的语言来进行表达。

比较复杂的算法最后都会归结到找最近的重复性。因为你只能写 if else, for loop, 递归这几个简单的语言。要么就是客观就这么复杂要写很长的程序，要不然就是程序很短的话，那肯定是有重复性，然后用一个递归或者一个 for loop 就可以解决了。

##### 数据结构

堆栈：运算受限的线性表。（线性是和二叉树相对的，数据是相邻的。二叉树是分叉的，每个元素之间不是相邻的。）

队列：运算受限的线性表。

链表：链表只会暴露一个头指针，元素是不能直接访问到的，需要通过头指针不断的访问 next 对象，才能拿到具体的元素，

1. 如何手动的创建一个链表的数据结构
2. 如何对链表进行排序
3. 如何检测链表是否是闭环的（环形链表）

二叉树：

1. 实现一个二叉树的数据结构
2. 围绕二叉树做一些操作：遍历，插入，验证

树的遍历基本上是基于递归的，因为树的结构本身导致了它没法有效的进行循环。做法是对它的左右节点再调用相同的遍历函数。

哈希表：

Map, Set, Object



##### 一维数组运用技巧

1. 百分号取余换行

##### 技巧

1. 判断的时候是与的关系初始化就是 ture，或的关系初始化就是 false，加的关系初始化是 0，乘的关系初始化是 1。
2. 全搜索，剪枝搜索。

##### 异步编程

1. 业务逻辑和时序逻辑分开
2. Promise 要求写一个 promise 函数，把异步相关的变成 promise，

##### 寻路问题（搜索算法）

1. 深度优先是先找下级，广度优先是先找同级。
2. 深度优先搜索（栈），广度优先搜索（队列）唯一的区别就是使用的数据结构。
3. 广搜是可以找到最优路径的，深搜不行。
4. 所有的搜索算法唯一的区别就是数据结构。
5. 所有递归的问题都可以用深度优先所有的 stack 的形式去写。

##### 正则

匹配字符串的子串用正则做比较好，一个字母、单词、空格都能提取出来。


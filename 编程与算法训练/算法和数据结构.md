##### 算法学习方法

算法存在客观的复杂度。

反复的思考、练习。

算法只是基础，不要抗拒记忆。

学习最终就是大脑建立稳定的神经回路。

时间间隔分开的过遍数。

过程痛苦是正在成长。

学习高手代码（leetcode）。

##### 学习方法（‘Outliers’一万小时训练法）

1. 切碎知识点（分清知识体系脉络，形成知识网）
2. 刻意练习，基础动作分解训练，反复练习（基本功），练习弱项
3. 反馈（看好代码，别人给你指点，实战）

##### 切题步骤

1. 正确理解题目的需求
2. 想所有可能的解法，分析不同解法的时空复杂度，找出最优的一种解法
3. 写代码
4. 例举测试样例，测试程序正确性。

##### 无毒神掌

1. 5-10 分钟读题 + 思考

   没思路直接看解法，多解法，比较解法优劣。

   背诵、默写好的解法（因为只要先把它记住了之后，100% 都可以理解的，只是要反复很多遍之后）。

2. 马上自己写 --> leetcode 提交，有 bug 就反复 debug，修改，直到通过。多个解法都写一遍。关注时空复杂度。看力扣好的题解。再看力扣国际站。

3. 过一天后做一遍前一天做过的题目。对不太熟悉的解法，做专项训练。

4. 过了一周，回来练习相同题目。对不太熟悉的解法，做专项训练。

5. 面试前一周再把之前的题目做一遍。

##### 最终达到的效果

* 常见的高频题马上就知道它常见的一些办法和每个办法的时间空间复杂度
* 它最简洁的代码实现形式在脑子里马上知道。

##### 指法和小操作

* fn + delete 删除光标右边
* command +left/right 光标切换到行头/行尾
* option + left/right/delete 光标按单词切分
* shift + command + left/right 选中整行
* ide 使用技巧，top tips

##### 自顶向下的编程方式

关键的主干大层次的逻辑代码写在上面，其他的私有函数和细节的逻辑函数写在下面。先森林在枝干再叶子。先不考虑细节怎么实现，把主干逻辑写出来。

##### 时间复杂度

前面的常数系数是不用考虑的。时间复杂度就是根据 n 的不同情况会运行多少次

* O(1)：常数复杂度
* O(log n)：对数复杂度
* O(n)：线性时间复杂度
* O(n^2)：平方
* O(n^3)：立方
* O(2^n)：指数
* O(n!)：阶乘

递归可以画出它的状态树来看它的时间复杂度。

主定理：计算所有递归的时间复杂度

* 排好序的一维数组进行二分查找：O(log n)
* 二叉树遍历：O(n)
* 排好序的二维矩阵中进行二分查找：O(n)
* 归并排序：O(nlog n)，所有排序最优的就是在这个时间复杂度

##### 空间复杂度

* 程序里开了数组，那数组的长度就是你的空间复杂度
* 如果有递归，那递归的深度就是你的空间复杂度。

##### 数据结构

* 一维数据结构
  * 基础
    * 数组
    * 链表
  * 高级
    * 栈
    * 队列
    * 双端队列
    * 集合 set (hash)
    * 映射 map object (hash)
* 二维数据结构：都是从一维数据结构泛化而来的
  * 基础
    * 树
    * 图
  * 高级：在树的基础上加了约束条件
    * 二叉搜索树（红黑树，AVL）
    * 堆
    * 并查集
    * 字典树
* 特殊数据结构：运用于工程中特定的情景
  * 位运算
  * 布隆过滤器
  * LRU 缓存

##### 算法

前三点是所有算法和数据结构的基石。任何高级的算法和数据结构到最后都会转换成这三点。高级复杂算法的根本就是找到它的重复单元，基于这个重复单元就可以泛化成高级的数据结构。

* if else, switch   --->  branch
* for while loop  --->  Iteration
* 递归 recursion（函数自己调用自己）
* 搜索
  * 深度优先搜索 DFS
  * 广度优先搜索 BFS
  * 启发式搜索 A*
* 动态规划
* 二分查找：对有序的数组很快的找到你要的节点
* 贪心算法
* 排序算法
* 数学和几何上的操作。

##### 解题思路

1.暴力

2.基本情况

3.泛化：

用递推，数学归纳法找重复性。用计算机的思维去思考怎么解决问题，不要人肉递归，不要用人脑的思维去想。

找重复性。在列举基本情况的基础上，找 最近 重复子问题。因为程序除了简单的情况使用 if else，其他就是用 for while 和递归 不断的重复。因为计算机不是人脑，它能想到的只有这些简单的解决方式，它就是简单的重复式的机器，你就把它想成一个不断重复在那里干事情的东西就好了，所有复杂问题最终都要变成这几个语句来给计算机去处理。所以我们就往这个方向去做和思考。要让计算机用重复的东西解决你的问题，如果能用重复的东西解决的问题，说明这个问题本身就是可重复的，所以就是找它的重复性。重复的时候可以分出很多 if else 分支，就会让递归的程序越来越复杂，复杂性就慢慢出来了。

比较复杂的算法最后都会归结到找最近的重复性。因为你只能写 if else, for loop, 递归这几个简单的语言。要么就是客观就这么复杂要写很长的程序，要不然就是程序很短的话，那肯定是有重复性，然后用一个递归或者一个 for loop 就可以解决了。

4.思考先想简单的办法，再想高大上的办法。

5.寻找边界条件遵循的原则：互斥且全量。

##### 数组、链表、跳表的基本实现和特性

* 数组

  底层硬件实现有一个叫内存管理器的东西，每当申请数组的话，计算机实际上是在内存中开辟了一段连续的地址，每一个地址可以直接通过内存管理器访问，访问的时间复杂度是 O(1) 的。插入是 O(n)，每当插入一个元素，它后面的元素都要向后挪一个位置，这个过程会涉及到很多元素的复制操作，把要插入的位置让出来，然后把元素插入。删除也是 O(n)，把要删除的元素清除掉，然后把后面的元素都向前移动，再把最后一个元素设置为空。

  * prepend O(1)
  * append O(1)
  * lookup O(1)
  * insert O(n)
  * delete O(n)

* 链表

  元素定义好之后，有 value 和 next，next 指向下一个元素，串在一起就变成了一个类似于数组的结构，每个元素一般用 class 来定义，叫 node。

  如果只有一个 next 指针的话叫单链表，有一个向前的指针有一个向后的指针就是双向链表，头指针一般用 head 来表示，尾指针用 tail 来表示，最后一个元素的 next 指向空，tail 的 next 指回到 head 就叫循环链表。

  链表可以弥补数组的缺点，在一些修改，添加，删除操作比较频繁的情况下，数组并不好用。

  插入删除元素都是 O(1)，增加和删除任何节点都没有引起整个链表的群移操作，也不需要复制元素，挪动多个元素到新的位置。访问元素必须从头节点开始一步一步往后找，是 O(n) 的。这也是它的问题所在

  * prepend O(1)
  * append O(1)
  * lookup O(n)
  * insert O(1)
  * delete O(1)

  从数组和链表可以看到，并没有完美的一种数据结构，如果有的话就不再需要 array 或 linked list 这两个数据结构并存了，就直接用那个牛逼的数据结构就可以了。所以各种数据结构各有优劣，看你使用的场景是什么地方。

* 跳表

  利用升维思想。

  只能用于链表元素有序的情况下。

  跳表对标的是平衡二叉树和二分查找，是一种插入，删除，搜索都是 O(log n) 的数据结构。空间复杂度 O(n)。

  它的优势是原理简单，容易实现，方便扩展，效率更高。因此在一些热门项目里用来替代平衡树，如 Redis，LevelDB 等。

##### 数组实战题目

1.[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)（7次）2021.06.07（8次）2021.06.15（9次）2021.07.05

```js
/*
* 思路：1.loop O(n^2)，遇零删除，在数组最后添加 0
*      2.开新内存 O(n)，非零的放前面 i，零放后面 j
*      3.双指针index操作 O(n)，一维数组两个下标换来换去。维护 i j 两个指针来做各种事情。
*			   双指针交换：一个循环指针，一个始终记录下一个想要的节点要放的位置的指针。这样就可以在不增加新内存的情况下，通过 index 方          *			   式，把所有想要的节点放在应该的位置。
*/
// 1
function moveZeroes(nums) {
  let count = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === 0) {
      nums.splice(i, 1);
      i--;
      count++;
    }
  }
  for (i = 0; i < count; i++) {
    nums.push(0);
  }
  return nums;
};
// 2
function moveZeroes(nums) {
  let res1 = [];
  let res2 = [];
  nums.forEach(item => {
    if (item === 0) {
      res1.push(item);
    } else {
      res2.push(item);
    }
  });
  return res2.concat(res1);
};
// 3
function moveZeroes(nums) {
  // j记录的要被替换的0的位置。
  let j = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
    	nums[j] = nums[i];
      if (i !== j) {
				nums[i] = 0;
      }
      j++;
    }
  }
  return nums;
};
function moveZeroes(nums) {
  let j = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      let c = nums[j];
      nums[j] = nums[i];
      if (c === 0) {
        nums[i] = 0;
      }
      j++;
    }
  }
  return nums;
};
function moveZeroes(nums) {
  let j = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      let c = nums[j];
      nums[j] = nums[i];
      nums[i] = c;
      j++;
    }
  }
  return nums;
};
```

2.[11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)（7次）2021.06.07（8次）2021.06.15（9次）2021.07.12

```js
/*
*	思路：1.枚举，双循环 O(n^2)：左柱子x，右柱子y，(x-y)*height。
*      2.左右夹逼 O(n)：左右边界 i j 向中间收敛，最后在中间汇合，只有一层循环 
*/
// 1
function maxArea(height) {
  let max = 0;
  for (let i = 0; i < height.length - 1; i++) {
    for (let j = i + 1; j < height.length; j++) {
      let minHeight = Math.min(height[i], height[j]);
      let area = minHeight * (j - i);
      max = Math.max(max, area);
    }
  }
  return max;
}
// 2
function maxArea(height) {
  let max = 0;
  for (let i = 0, j = height.length - 1; i < j; ) {
    // 谁高度小谁往里面挪，来找那个更高的棒子。
    let minHeight = height[i] < height[j] ? height[i++] : height[j--];
    let area = minHeight * (j - i + 1);
    max = Math.max(max, area);
  }
  return max;
}
```

3.[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)（7次）2021.06.08（8次）2021.06.16（9次）2021.07.12

```js
/* f(n) = f(n - 1) + f(n - 2) 斐波那契数列
* 思路：1.暴力递归 O(2^n)
*      2.记忆化递归 O(n)
*      3.动态规划 O(n)：保证计算到 n 就行了。
*/
// 1
function climbStairs(n) {
  if (n <= 2) return n;
  return climbStairs(n - 1) + climbStairs(n - 2);
}
// 2
function climbStairs(n) {
  const map = new Map();
  function recursion(n) {
    if (n <= 2) return n;
    if (map.has(n)) return map.get(n);
    const value = recursion(n - 1) + recursion(n - 2);
    map.set(n, value);
    return value; 
  }
  return recursion(n);
}
// 3
function climbStairs(n) {
  if (n <= 2) return n;
	let arr = [];
  arr[1] = 1;
  arr[2] = 2;
  for (let i = 3; i <= n; i++) {
    arr[i] = arr[i - 1] + arr[i - 2];
  }
  return arr[n];
}
function climbStairs(n) {
  if (n <= 2) return n;
  let a = 1, b = 2, r = 0;
  for (let i = 0; i < n - 2; i++) {
		r = a + b;
    a = b;
    b = r;
  }
  return r;
}
```

4.[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)（7次）2021.06.10（8次）2021.06.18（9次）2021.07.12

```js
/*
* 思路：1.暴力枚举 O(n^2)：两层循环
*      2.哈希表 O(n)：枚举 a，看 target-a 是否也在数组里面。
*/
// 1
function twoSum(nums, target) {
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
  return [];
}
// 2 
function twoSum(nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) {
      return [map.get(target - nums[i]), i];
    }
    map.set(nums[i], i);
  }
  return [];
}
```

5.[15. 三数之和](https://leetcode-cn.com/problems/3sum/)（7次）2021.06.10（8次）2021.06.20（9次）2021.06.23

```js
/*
* 思路：1.暴力 O(n^3)：三重循环
*      2.哈希 O(n^2)：两重循环 + hash 哈希一个数，然后让剩余的数都互相碰一遍。
*.     3.夹逼 O(n^2)：排序后，双指针左右夹逼
*/
// 1
function threeSum(nums) {
  if (nums == null || nums.length <= 2) return [];
  let a = [];
  let set = new Set();
  for (let i = 0; i < nums.length - 2; i++) {
    for (let j = i + 1; j < nums.length - 1; j++) {
      for (let k = j + 1; k < nums.length; k++) {
        let sum = nums[i] + nums[j] + nums[k];
        if (sum === 0) {
          let tmp = [nums[i], nums[j], nums[k]];
          tmp.sort();
          if (!set.has(tmp.join())) {
            a.push([nums[i], nums[j], nums[k]]);
            set.add(tmp.join());
          }
        }
      }
    }
  }
  return a;
}
// 2 技巧 hash，先存 map
function threeSum(nums) {
  if (nums == null || nums.length <= 2) return [];
  let a = [];
  let mapData = new Map();
  let setData = new Set();
  for (let i = 0; i < nums.length - 2; i++) {
    mapData.set(nums[i], nums[i]);
    for (let j = i + 2; j < nums.length; j++) {
      let sum = nums[i + 1] + nums[j];
      if (mapData.has(-sum)) {
        let tmp = [mapData.get(-sum), nums[i + 1], nums[j]].sort();
        if (!setData.has(tmp.join())) {
          a.push(tmp);
          setData.add(tmp.join());
        }
      }
    }
  }
  return a;
}
// 2 技巧 hash，后存 map，天然避免当前map的数重复计算
function threeSum(nums) {
  if (nums == null || nums.length <= 2) return [];
  let a = [];
  let map = new Map();
  let set = new Set();
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      let sum = nums[i] + nums[j];
      if (map.has(-sum)) {
        let tmp = [nums[map.get(-sum)], nums[i], nums[j]].sort();
        if (!set.has(tmp.join())) {
          a.push(tmp);
          set.add(tmp.join());
        }
      }
    }
    map.set(nums[i], i);
  }
  return a;
}
// 2 两次循环 hash，注意不要和当前哈希表中的数重复
function threeSum(nums) {
  if (nums == null || nums.length <= 2) return [];
  let a = [];
  let mapData = new Map();
  let setData = new Set();
  for (let i = 0; i < nums.length - 2; i++) {
    mapData.set(nums[i], i);
  }
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      let sum = nums[i] + nums[j];
      if (mapData.has(-sum) && mapData.get(-sum) !== i  && mapData.get(-sum) !== j) {
        let tmp = [nums[mapData.get(-sum)], nums[i], nums[j]].sort();
        if (!setData.has(tmp.join())) {
          a.push(tmp);
          setData.add(tmp.join());
        }
      }
    }
  }
  return a;
}
// 3
function threeSum(nums) {
  if (nums == null || nums.length <= 2) return [];
  nums.sort((a, b) => a - b);
  let a = [];
  for (let k = 0; k < nums.length - 2; k++) {
    if (nums[k] > 0) break;
    if (k > 0 && nums[k] === nums[k - 1]) continue;
    let i = k + 1, j = nums.length - 1;
    while(i < j) {
    	let sum = nums[k] + nums[i] + nums[j];
      if (sum < 0) {
      	while(i < j && nums[i] === nums[++i]);
      } else if (sum > 0) {
      	while(i < j && nums[j] === nums[--j]);   
      } else {
        a.push([nums[k], nums[i], nums[j]]);
        while(i < j && nums[i] === nums[++i]);   
        while(i < j && nums[j] === nums[--j]);   
      }
    }
  }
  return a;
}
```

6.[26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

7.[189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

8.[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

9.[66. 加一](https://leetcode-cn.com/problems/plus-one/)

##### 链表实战题目

所有链表的题目的解法都非常固定，主要就是熟能生巧，没有很多算法的东西，关键就是要熟悉怎么把链表的 next 和 prev 指针换来换去。

js 声明链表数据结构（7次）2021.06.16（8次）2021.06.24（9次）2021.07.20

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}
class LinkedList {
	constructor(arr) {
    let head = new Node(arr.shift());
    let next = head;
    for (let i of data) {
      next.next = new Node(i);
      next = next.next;
    }
    return head;
  }
}
```

1.[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

2.[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

3.[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)（7次）2021.06.16（8次）2021.06.24（9次）2021.07.20

```js
/*
* 思路：1.暴力 时间O(n) 空间O(n)：遍历链表，hash/set 
*      2.快慢指针 时间O(n) 空间O(1)
*/
// 1
function hasCycle(head) {
  if (head == null || head.next == null) return false;
  let map = new Map();
  let next = head;
  while (next != null) {
    if (map.has(next)) {
      return true;
    }
    map.set(next, 1);
    next = next.next;
  }
  return false;
}
// 2
function hasCycle(head) {
  if (head == null || head.next == null) return false;
  let slow = head;
  let fast = head.next;
  while(fast != null && fast.next != null) {
  	if (fast === slow || fast.next === slow) {
    	return true;
   	}
    slow = slow.next;
    fast = fast.next.next;
 	}
  return false;
}
```

4.[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

5.[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

6.[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

##### 栈和队列的基本实现和特性

* 栈 stack：先入后出的容器结构。

* 队列 queue：排队，先入先出

* 双端队列 deque：实战中使用双端队列的比较多，双端队列就是 queue 和 stack 的结合体。头和尾都可以进行元素的出和入的队列。

  栈、队列、双端队列添加、删除都是 O(1)，查询为 O(n)。因为它是无序的，你要查任何一个元素的话，就必须把这个数据结构遍历一遍。

* 优先队列 priority queue：

  插入操作 O(1)，取出操作 O(log n) 按照元素的优先级取出

  底层具体实现的数据结构较为多样和复杂：例如 heap、bst、treap

##### 栈、队列实战题目

如果一个东西具有最近相关性的话就会用栈解决，外层和外层配对，内层可以和内层配对。 现实和工程中都有很多这种从外向内或从内向外逐渐扩散的特性。

先来后到、公平性、排队就用队列。

所有东西都不是发明创造的，都是对现实中已有的逻辑进行抽象，然后用计算机的语言来进行表达。

1.[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)（7次）2021.06.17（8次）2021.06.25（9次）2021.07.20

```js
/*
* 思路：1.暴力 O(n^2)：不断replace匹配括号 -> ''
*      2.栈 O(n)：所有括号问题都类似，用栈解决就行了。像洋葱一样的结构。如果是左括号就压到栈里面去，如果是右括号就和栈顶元素匹配看 *				能不能匹配上，匹配上就把栈顶元素移出栈，不然就是不合法，一直这么操作下去。直到整个栈为空就说明完全匹配了。
*/
// 1
function isValid(s) {
  if (s.length % 2 === 1) return false;
  let l = s.length / 2;
  for(let i = 0; i < l; i++){
    s = s.replace('()', '').replace('[]', '').replace('{}', '');
  }
  return !s.length;
}
// 2
function isValid(s) {
  if (s.length % 2 === 1) return false;
  const map = new Map([
    [')', '('],
    [']', '['],
    ['}', '{']
  ]);
  const stack = [];
  for (let i of s){
    if (map.has(i)) {
      if (!stack.length || stack.pop() !== map.get(i)) {
        return false;
      }
    } else {
      stack.push(i);
    }
  };
  return !stack.length;
}
```

2.[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)（7次）2021.06.18（8次）2021.06.25

```js
/*
* 思路：1.栈：两个栈，一个维护出入关系，一个维护最小值的栈。
*        很多时候，用两个栈或两个队列会解决一些特殊性的数据结构的问题，比如只用栈来实现队列或者只用队列来实现栈。
*/
// 1 同步
class MinStack {
  constructor() {
    this.x_stack = [];
    this.min_stack = [Infinity];
  }
  push(x) {
    this.x_stack.push(x);
    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));
  }
  pop() {
    this.x_stack.pop();
    this.min_stack.pop();
  }
  top() {
    return this.x_stack[this.x_stack.length - 1];
  }
  getMin() {
    return this.min_stack[this.min_stack.length - 1];
  }
}
// 1 不同步
class MinStack {
  constructor() {
    this.x_stack = [];
    this.min_stack = [];
  }
  push(x) {
    this.x_stack.push(x);
    if (!this.min_stack.length || x <= this.min_stack[this.min_stack.length - 1]) {
    	this.min_stack.push(x);
    }
  }
  pop() {
    if (this.x_stack.pop() === this.min_stack[this.min_stack.length - 1]) {
      this.min_stack.pop();
    }
  }
  top() {
    return this.x_stack[this.x_stack.length - 1];
  }
  getMin() {
    return this.min_stack[this.min_stack.length - 1];
  }
}
```

3.[84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)（7次）2021.06.30（8次）2021.07.09

```js
/*
* 思路：1.暴力 O(n^3)：
* 		 2.扩散 O(n^2)：遍历，找到当前柱子的前面和后面第一个比他小的柱子，算出它能组成的最大的面积。
*        (i和j不断的往左右两边扩散，或者i和j往中间推进最后相遇，以及i和j写两层嵌套的循环枚举所有可能的i和j的情况。像这些代码一定要*        写的滚瓜烂熟。)
*      3.栈 O(n)：维护一个递增栈，当前元素的前一个元素就是它的左边界，如果大于栈顶元素继续入栈，如果发现比他小的可以确定它的右边  
*        界了，这时就弹栈计算面积。最后清空栈，计算栈中剩余元素的面积。
*/
// 1
function largestRectangleArea(heights) {
  let max = 0;
  // 这样的两重遍历是自己和自己会相遇一次，这样会保证所有的单根面积都计算到。两两相遇是计算组合面积。因为是计算面积，所以并不是两两比较两个数相遇一次就可以的。
  for (let i = 0; i < heights.length; i++) {
    for (let j = i; j < heights.length; j++) {
      let area = (j - i + 1) * Math.min.apply(null, heights.slice(i, j + 1));
      max = Math.max(max, area);
    }
  }
  return max;
}
// 1
function largestRectangleArea(heights) {
  let max = 0;
  for (let i = 0; i < heights.length; i++) {
    let minHeight = heights[i];
    for (let j = i; j < heights.length; j++) {
      minHeight = Math.min(minHeight, heights[j]);
      let area = (j - i + 1) * minHeight;
      max = Math.max(max, area);
    }
  }
  return max;
}
// 2
function largestRectangleArea(heights) {
  let max = 0;
  for (let i = 0; i < heights.length; i++) {
    let j = i;
    let k = i;
    for (; j >= 0; j--) {
      if (heights[j] < heights[i]) break;
    }
    for (; k < heights.length; k++) {
      if (heights[k] < heights[i]) break;
    }
    let area = (k - j - 1) * heights[i];
    max = Math.max(max, area);
  }
  return max;
}
// 2
function largestRectangleArea(heights) {
  let max = 0;
  for (let i = 0; i < heights.length; i++) {
    let j = i;
    let k = i;
    while (j >= 0 && heights[j] >= heights[i]) j--;
    while (k < heights.length && heights[k] >= heights[i]) k++;
    let area = (k - j - 1) * heights[i];
    max = Math.max(max, area);
  }
  return max;
}
// 3 计算弹出来的柱子的左右边界
function largestRectangleArea(heights) {
	let max = 0;
  let stack = [-1];
  heights.push(0);
  for (let i = 0; i < heights.length; i++) {
    while (stack.length > 1 && heights[i] < heights[stack[stack.length - 1]]) {
      let index = stack.pop();
      let area = (i - stack[stack.length - 1] - 1) * heights[index];
      max = Math.max(max, area);
    }
    stack.push(i);
  }
  return max;
}
// 3 计算弹出来的柱子的左右边界
function largestRectangleArea(heights) {
	let max = 0;
  let stack = [-1];
  for (let i = 0; i < heights.length; i++) {
    while (stack.length > 1 && heights[i] < heights[stack[stack.length - 1]]) {
      let index = stack.pop();
      let area = (i - stack[stack.length - 1] - 1) * heights[index];
      max = Math.max(max, area);
    }
    stack.push(i);
  }
  for (let i = 1; i < stack.length; i++) {
    let area = heights[stack[i]] * (stack[stack.length - 1] - stack[i - 1]);
    max = Math.max(max, area);
  }
  return max;
}
// 3 两次循环分别找出每根柱子的左右边界
function largestRectangleArea(heights) {
  let max = 0;
	let left = [];
  let right = [];
  let stack = [];
  for (let i = 0; i < heights.length; i++) {
		while (stack.length && heights[i] <= heights[stack[stack.length - 1]]) {
    	stack.pop();
    }
    left[i] = !stack.length ? -1 : stack[stack.length - 1];
    stack.push(i);
  }
  stack = [];
  for (let i = heights.length - 1; i >= 0; i--) {
		while (stack.length && heights[i] <= heights[stack[stack.length - 1]]) {
    	stack.pop();
    }
    right[i] = !stack.length ? heights.length : stack[stack.length - 1];
    stack.push(i);
  }
  for (let i = 0; i < heights.length; i++) {
    let area = heights[i] * (right[i] - left[i] - 1);
    max = Math.max(max, area);
  }
  return max;
}
// 3 一次循环找出每根柱子的左右边界
function largestRectangleArea(heights) {
  let max = 0;
	let left = [];
  let right = new Array(heights.length).fill(heights.length);
  let stack = [];
  for (let i = 0; i < heights.length; i++) {
		while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {
    	right[stack.pop()] = i;
    }
    left[i] = !stack.length ? -1 : stack[stack.length - 1];
    stack.push(i);
  }
  for (let i = 0; i < heights.length; i++) {
    let area = heights[i] * (right[i] - left[i] - 1);
    max = Math.max(max, area);
  }
  return max;
}
```

4.[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)（7次）2021.06.25（8次）2021.07.03

```js
/*
* 思路：1.暴力 O(n*k)
*      2.双端单调队列 deque O(n)：单调递减队列，保持队首元素是最大值。
*.       所有滑动窗口的题目就想到用队列处理就行了。
*/
// 1
function maxSlidingWindow(nums, k) {
  let a = [];
	for (let i = 0; i < nums.length - k + 1; i++) {
    let max = nums[i];
    for (let j = i; j < i + k; j++) {
      max = Math.max(max, nums[j])
    }
    a.push(max);
  }
  return a;
}
// 2 
function maxSlidingWindow(nums, k) {
  let a = [];
  let q = [];
  for (let i = 0; i < k; i++) {
    while (q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop();
    }
    q.push(i);
  }
  a.push(nums[q[0]]);
  for (let i = k; i < nums.length; i++) {
    while (q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop();
    }
    q.push(i);
    while (q[0] < i - k + 1) {
      q.shift();
    }
    a.push(nums[q[0]]);
  }
  return a;
}
// 2
function maxSlidingWindow(nums, k) {
  let a = [];
  let q = [];
  for (let i = 0; i < nums.length; i++) {
    while (q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop();
    }
    q.push(i);
    while (q[0] < i - k + 1) {
      q.shift();
    }
    if (i >= k - 1) a.push(nums[q[0]]);
  }
  return a;
}
```

5.[641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/)

6.[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

##### 哈希表、映射、集合的实现与特性

现实中用的最多的除了数组链表之外，就是 map 和 set 了。他们底层结构基本都是使用哈希表来实现的，有的会用二叉树来实现。

哈希表（hash table）： 

也叫散列表，是根据关键码值（key value）来直接访问的数据结构。

底层实现：key -> 哈希函数 -> index -> arr[index] = value

它通过把关键码值映射到表中的一个位置来访问记录，以加快查询的速度。

这个映射函数叫散列函数也叫哈希函数。存放记录的数组叫做哈希表。

查询添加删除的时间复杂度都是 O(1) 的。有一种最坏的情况就是哈希函数选的非常不好或者哈希表的整个 size 太小了，就导致经常会发生冲突，这样它就退化成一个链表了，这时时间复杂度就退化成 O(n) 了。空间复杂度是 O(n)。

在工程中，我们经常在用的就不再是哈希表了，而是在哈希表基础上抽象出来的，使用的比较多的就是 map 和 set。map 就是键值对，key 是不重复的，值可以重复。set 就是不重复的元素的集合，没有键值对，就是单个的元素。

##### 哈希表实战题目

1.[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)（7次）2021.06.30（8次）2021.07.09

```js
/*
* 思路：1.暴力 O(nlogn)：按照字符的顺序 sort 后比较 string 是否相等
*      2.hash O(n)：统计每个字符的频次，如果每个字符出现的频次一样那就是字母异位词。
*/
// 1
function isAnagram(s, t) {
  if (s.length !== t.length) return false;
  return Array.from(s).sort().join() === Array.from(t).sort().join();
}
// 2
function isAnagram(s, t) {
  if (s.length !== t.length) return false;
  let map = new Map();
  for (let i of s) {
    let value = map.has(i) ? map.get(i) + 1 : 1;
    map.set(i, value);
  }
  for (let i of t) {
    if (map.has(i)) {
      map.set(i, map.get(i) - 1);
      if (map.get(i) < 0) return false;
    } else {
      return false;
    }
  }
  return true;
}
// 2 自制 hash
function isAnagram(s, t) {
  if (s.length !== t.length) return false;
  let table = new Array(26).fill(0);
  for (let i of s) {
    table[i.charCodeAt() - 'a'.charCodeAt()]++;
  }
  for (let i of t) {
    table[i.charCodeAt() - 'a'.charCodeAt()]--;
    if (table[i.charCodeAt() - 'a'.charCodeAt()] < 0) return false;
  }
  return true;
}
```

2.[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)（7次）2021.06.30（8次）2021.07.09

```js
/*
* 思路：1.排序 + hash O(n*klogk)：排序后当作key，hash归类。  
*      2.自制hash + hash O(n*k)：自制 hash 后的数组当作key，hash归类。
*/
// 1
function groupAnagrams(strs) {
  let map = new Map();
  for (let str of strs) {
    let key = [...str].sort().join();
    let value = map.has(key) ? map.get(key) : [];
    value.push(str);
    map.set(key, value);
  }
  return [...map.values()];
}
// 2
function groupAnagrams(strs) {
  let map = {};
  for (let str of strs) {
    let table = new Array(26).fill(0);
    for (let c of str) {
      table[c.charCodeAt() - 'a'.charCodeAt()]++;
    }
    map[table] ? map[table].push(str) : map[table] = [str];
  }
  return Object.values(map);
}
// 2
function groupAnagrams(strs) {
 	let map = new Map();
  for (let str of strs) {
    let table = new Array(26).fill(0);
    for (let c of str) {
      table[c.charCodeAt() - 'a'.charCodeAt()]++;
    }
    let value = map.has(table.join()) ? map.get(table.join()) : [];
    value.push(str);
    map.set(table.join(), value);
  }
  return Array.from(map.values());
}
```

3.[18. 四数之和](https://leetcode-cn.com/problems/4sum/)（7次）2021.07.03（8次）2021.07.12

```js
/*
* 思路：1.hash O(n^3) 
*/
// 1
function fourSum(nums, target) {
  let a = [];
  let map = new Map();
  let set = new Set();
  for (let i = 0; i < nums.length - 2; i++) {
    for (let j = i + 1; j < nums.length - 1; j++) {
      for (let k = j + 1; k < nums.length; k++) {
        let sum = nums[i] + nums[j] + nums[k];
        if (map.has(target - sum)) {
          let key = [target - sum, nums[i], nums[j], nums[k]].sort();
          if (!set.has(key.join())) {
            a.push(key);
            set.add(key.join());
          }
        }
      }
    }
    map.set(nums[i], nums[i]);
  }
  return a;
}
```

##### 树、二叉树、二叉搜索树的实现和特性

树：有一个根节点，左子树，右子树，左儿子，右儿子，父节点，兄弟节点，不同的层。从一个节点指向多个节点。

现实中用的最多的就是二叉树，儿子节点只有两个，左儿子和右儿子。

树和图最关键的差别就是有没有环，树里如果有环的话就是图。

链表就是特殊化的树。树就是特殊化的图。

js 根据一维数组声明完全二叉树数据结构（7次）2021.07.08（8次）2021.07.16

```js
class Node {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}
class Tree {
  constructor(data) {
    // 存储所有节点
    let nodeList = [];
    for (let i = 0; i < data.length; i++) {
      let node = new Node(data[i]);
      nodeList.push(node);
      if (i > 0) {
        // 计算当前节点属于哪一层
        let n = Math.floor(Math.sqrt(i + 1));
        // 当前层起始点
        let q = Math.pow(2, n) - 1;
        // 上一层起始点
        let p = Math.pow(2, n - 1) - 1;
        // 找到当前节点的父节点
        let parent = nodeList[p + Math.floor((i - q) / 2)];
        // 将当前节点和上一层的父节点做关联
        if (parent.left) {
          parent.right = node;
        } else {
          parent.left = node;
        }
      }
    }
    let root = nodeList.shift();
    nodeList.length = 0;
    return root;
  }
}
class Tree {
  constructor(data) {
    let nodeList = [];
    for (let i = 0; i < data.length; i++) {
      let node = new Node(data[i]);
      nodeList.push(node);
      if (i > 0) {
        // 找到当前节点的父节点
        let parent = nodeList[Math.floor((i - 1) / 2)];
        // 将当前节点和父节点做关联
        if (parent.left) {
          parent.right = node;
        } else {
          parent.left = node;
        }
      }
    }
    let root = nodeList.shift();
    nodeList.length = 0;
    return root;
  }
}
```

为什么会出来树这么一个结构，因为人类生活在一个三维的世界里面，所有人类很多的工程实践就是在二维的基础上去解决的，而树就是人经常会碰到的一种情况。 例如斐波那契数组求解的时候，暴力递归它扩散出去的节点就是一个树状的节点，叫做它递归的状态树，就是一个树形结构。还有棋类游戏，走了一步之后就会棋盘就会扩散出不同的状态，棋盘的状态也是一个树形结构，每走一步，棋盘就会往下扩散出不同的状态，形成第二层，第三层，第四层的树的节点，到最后的叶子节点就是这个棋盘的某一个终极形态，这时不能再下了，其中某一方赢输或和棋的状态。这是状态树的空间，同时还有一个博弈的空间（决策树的空间），在这个空间里找它的最优解，它们共同决定了这个棋的复杂度。 星际争霸打游戏的时候也是一个树状的结构往外扩散，对手可以动的东西太多了，以至于它们分散出去之后就越来越复杂。

二叉树遍历：

基本的无序的树想查找一个元素就必须要遍历，就是把所有的节点都走一遍，其他的数据结构就是循环一遍一直到没有，树的话会有左子树右子树，那就类似的递归去把它反复的求证。树的遍历基本上是基于递归的，因为树的结构本身导致了它没法有效的进行循环，而写递归调用相对比较简单，做法是对它的左右节点再调用相同的遍历函数。所以树的各种操作不要怕递归，要拥抱递归。

前中后序遍历，因为要查根节点的值，同时还要访问左子树和右子树，总共需要三句语言，这三句语言的顺序就变成了不同的遍历方式。

* 前序：根-左-右
* 中序：左-根-右
* 后序：左-右-根

![树的遍历](树的遍历.jpg)

二叉搜索树：

如果一个普通的树要查找里面的节点，就必须把它的树给遍历一遍，那就是 O(n) 的算法复杂度。那它跟链表就没有太大的区别了，就没有太大意义。所以一般我们会把树的结构变得更加的有序，这样你查找和维护起来就会更加的有效。

二叉搜索树：又叫二叉搜索排序树，也称有序二叉树或排序二叉树，它是一棵空树或者具有下列性质的二叉树。

* 左子树上的所有节点的值都小于它的根节点的值
* 右子树上的所有节点的值都大于它的根节点的值
* 以此类推，左右子树也分别如此满足这两个条件为二叉搜索树。（这就是重复性）

二叉搜索树的中序遍历是升序排列的。

二叉搜索树常见操作：

查询插入和删除都是 O(log n) 的，相当于加速了。

创建就是从一个空树开始把所有的节点不断的调用插入操作依次的插入到这个二叉搜索树里面去即可。

如果删除的是叶子节点，查询到直接删掉即可，如果删除的是某个根节点，删除这个节点之后，要拉一个它的下面的节点来填充它的位置来使整棵树依然成立，要拿和这个节点最接近的节点，紧邻着这个节点但刚刚小于它的节点或紧邻着这个节点但刚刚大于它的节点，也就分别是左子树最右(大)边的节点和右子树最左(小)边的节点。一般是选后者替换上去即可。

有一种特殊的情况就是这个树退化成了一根棍子，这就变成了一个链表了，它的复杂度就都退化成 O(n) 了。要想加速就要把它配平变成平衡二叉树。

##### 树、二叉树、二叉搜索树实战题目

树的面试题的解法一般都是递归。

1.[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)（7次）2021.07.08（8次）2021.07.16

```js
/*
* 思路：1.递归 O(n)：关注递归每层做的事和递归的行走路径。
*      2.基于栈的迭代遍历 O(n)：手动维护一个栈，因为递归每次调用一个函数，就相当于让系统帮你创建一个栈，把要调用的函数和它相应的参
*        数依次压入栈中。
*      3.莫里斯遍历：建立一个索引树
*      4.颜色标记法
*/
// 1
function inorderTraversal(root) {
  let res = [];
  function inorder(root) {
    if (root) {
      inorder(root.left);
      res.push(root.val);
      inorder(root.right);
    }
  }
  inorder(root);
  return res;
}
// 2
function inorderTraversal(root) {
  let res = [];
  let stack = [];
  while (root || stack.length) {
    while (root) {
      stack.push(root);
      root = root.left;
    }
    root = stack.pop();
    res.push(root.val);
    root = root.right;
  }
  return res;
}
// 3
// 4
```

2.[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

3.[590. N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

4.[589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

5.[429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

##### 堆、二叉堆的实现和特性

堆：可以迅速的找到一堆数中的最大者或最小者的数据结构。

将根节点最大的堆叫大顶堆，将根节点最小的堆叫小顶堆。堆是比较抽象的数据结构，根据实现形式常见的堆有二叉堆、斐波那契堆（基于多叉树实现的）等。

二叉堆是堆的一种常见且简单的实现，但并不是最优的实现。工程中直接调优先队列就行了。

二叉堆：通过完全二叉树来实现。

二叉堆（大顶）特性：

1. 是一棵完全二叉树。
2. 树中任意节点的值总是大于等于其子节点的值。

二叉堆常见操作 API 和实现细节（假设是大顶堆）：

由于它是一棵完全二叉树，所以就不需要再用链表的结构，就是一个树的节点，然后它有左儿子右儿子这种指针的形式了。我们直接就可以用一维数组来实现。

根元素放在索引为 0 的位置，索引为 i 的节点的左儿子的索引就是 2 * i + 1，右儿子的索引是 2 * i + 2，索引为 i 的父节点的索引是 floor((i - 1) / 2)。

取最大值 find-max O(1)：直接把根节点返回即可。

插入操作 insert(create) O(logn) ：

1. 新元素一律先插入到堆的尾部
2. 依次向上调整整个堆的结构（一直到根即可），HeapifyUp，每次和它的父节点比，大于的话就交换。调整的最坏的情况就是树的深度，就是 log2^n 的。

删除堆顶操作 delete-max O(logn)：

1. 将堆尾元素替换到顶部（即堆顶被替代删除掉）
2. 依次从根部向下调整整个堆的结构（一直到堆尾即可），HeapifyDown，每次比较它的左右儿子，跟更大的儿子交换。调整的最坏的情况就是树的深度，就是 log2^n 的。

js 声明二叉堆数据结构（7次）2021.07.14（8次）2021.07.22

```js
class BinaryHeap {  
  constructor(compare) {    
    this.data = [];    
    this.compare = compare;
  }  
  insert(value) {    
    this.insertAt(this.data.length, value);  
  }  
  insertAt(i, value) {
    this.data[i] = value;
    // 对比当前节点与其父节点，如果当前节点更大就交换它们 
    while (i > 0 && this.compare(value, this.data[Math.floor((i - 1) / 2)]) < 0) {
      this.data[i] = this.data[Math.floor((i - 1) / 2)];
      this.data[Math.floor((i - 1) / 2)] = value;
      i = Math.floor((i - 1) / 2);
    }
  }
  delete(i) {    
    if (this.data.length === 0) return;    
    let value = this.data[i];     
    // fix heap    
    while (i < this.data.length) {      
      let left = i * 2 + 1;      
      let right = i * 2 + 2;      
      // 没有左子节点      
      if (left >= this.data.length) break;      
      // 没有右子节点      
      if (right >= this.data.length) {        
        this.data[i] = this.data[left];        
        i = left;        
        break;      
      }      
      // 左右子节点都有，比较左右子节点的大小，更大的补到父节点      
      if (this.compare(this.data[left], this.data[right]) < 0) {        
        this.data[i] = this.data[left];        
        i = left;      
      } else {        
        this.data[i] = this.data[right];        
        i = right;      
      }    
    }    
    // 查看最后的空位是不是最后的叶子节点    
    if (i < this.data.length - 1) {      
      this.insertAt(i, this.data.pop());    
    } else {      
      this.data.pop();    
    }    
    return value;  
  }
  printHeap() {       
    console.log(this.data);  
  }
}
let maxHeap = new BinaryHeap((a, b) => b - a);
let minHeap = new BinaryHeap((a, b) => a - b);
```

##### 堆和二叉堆实战题目

1.[剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)（7次）2021.07.21（8次）2021.07.28

```js
/*
* 思路：1.sort O(nlogn)
*      2.heap O(nlogk)：把 arr 放到 heap 里面去，然后从 heap 里取出 k 个就行了。
*      3.快排
*/
// 1
function getLeastNumbers(nums, k) {
  nums.sort((a, b) => a - b);
  return nums.slice(0, k);
}
// 2
function getLeastNumbers(nums, k) {
  let a = [];
  for (let i of nums) {
    minHeap.insert(i);
  }
  for (let i = 0; i < k; i++) {
    a[i] = minHeap.delete(0);
  }
  return a;
}
// 3
```

2.[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

```js
/*
* 思路：1.堆：比双端队列多了一个logk的时间复杂度，因为它要插入进来调整
*/
// 1
```

3.[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)（7次）2021.07.22（8次）2021.07.29

```js
/*
* 思路：1.sort：统计元素出现的频次，sort 排序 value，再取出前 k 个 value 对应的 k。
* 	   2.堆：统计元素出现的频次，将 value 放入堆中排序，再取出前 k 个 value 对应的 k。
*/
// 1
function topKFrequent(nums, k) {
	let a = [];
  let map = new Map();
  for (let i of nums) {
    let value = map.has(i) ? map.get(i) + 1 : 1;
    map.set(i, value);
  }
  let arr = [...map.values()].sort((a, b) => b - a);
  for (let i = 0; i < k; i++) {
    let value = arr.shift();
    for (let [k, v] of map) {
      if (value === v) {
        a.push(k);
        map.delete(k);
        break;
      }
    }
  }
  return a;
}
// 2
function topKFrequent(nums, k) {
  let a = [];
  let map = new Map();
  for (let i of nums) {
    let value = map.has(i) ? map.get(i) + 1 : 1;
    map.set(i, value);
  }
  for (let [k, v] of map) {
    maxHeap.insert(v);
  }
  for (let i = 0; i < k; i++) {
    let value = maxHeap.delete(0);
    for (let [k, v] of map) {
      if (value === v) {
        a.push(k);
        map.delete(k);
        break;
      }
    }
  }
  return a;
}
```

3.[剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

##### 范型递归、树的递归的实现、特性以及思维要点

递归就是要捋清代码的执行顺序。

递归本质上类似于循环，通过循环体调用自己来进行循环。

计算机的汇编没有所谓的循环，它用的就是不断的反复跳到之前的一段指令不断的去执行，这就是所谓的递归。循环编译出来的汇编代码和递归是有异曲同工之处的，所以递归和循环没有明显的边界。

一层一层的不断的向下递归，再一层一层的回来。每进到一层递归相当于是一个新的世界，每层的环境是不受影响的。每次下去或回来的时候，他自身或某个状态会发生改变在不同层带来带去。

递归代码模版（7次）2021.07.24（8次）2021.07.31

```js
function recursion(level, params) {   
  // recursion terminator 递归终止条件
  if(level > MAX_LEVEL){     
    process_result     
    return    
  }   
  // process current level 处理当前层逻辑
  process(level, params)   
  // drill down 下探到下一层
  recursion(level + 1, params)   
  // clean current level status if needed 清理当前层
}
```

递归思维要点：

1. 不要人肉进行递归，刚开始可以画递归状态树，后期就不要了，直接看函数本身开始写即可，不然永远没法有效的掌握或熟练的使用递归。
2. 找到最近最简的方法，将其拆解成可重复解决的问题（找最近重复子问题）（找最近重复性）。逻辑比较多，比较复杂的程序，但却可以用几行语句解决，就是因为这个复杂的逻辑本身有所谓的可重复性。假设没有任何重复性的话，说明它的复杂度是客观存在的，有多少复杂的逻辑，就要写多少复杂的代码，比如从 n = 1, n = 2 一直到 n = n 每一个都写出来，代码是几千行几万行这样。
3. 数学归纳法思维，从最简的 1, 2 开始向后递推出 n 成立的形式。先把当 n=1, n=2 的最基础的条件是什么想明白，然后再解决 n 成立的话怎么推到 n + 1。

##### 范型递归、树的递归实战题目

1.计算 n!（7次）2021.07.23（8次）2021.07.30

```js
/*
* 思路：1.递归
*/
// 1
function factorial(n) {
  function recursion(n) {
    if (n === 0) return 1;
    return n * recursion(n - 1);
  }
  return recursion(n);
}
```

2.[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

3.[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)（7次）2021.07.23（8次）2021.07.30

```js
/*
* 思路：1.深度优先搜索
*      2.广度优先搜索
*/
// 生成全部括号组合
function generateParenthesis(n) {
  let a = [];
  function generate(level, n, s) {
    // 递归终止条件
    if (level > 2 * n) {
      a.push(s);
      return;
    }
    // 处理当前层
    // 下探下一层
    generate(level + 1, n, s + '(');
    generate(level + 1, n, s + ')');
  }
  generate(1, n, '');
  return a;
}
// 1
function generateParenthesis(n) {
  let a = [];
  function generate(left, right, n, s) {
    // 终止条件
    if (left === n && right === n) {
      a.push(s);
      return;
    }
    // 处理当前层
    // 下探下一层
    if (left < n) generate(left + 1, right, n, s + '(');
    if (left > right) generate(left, right + 1, n, s + ')');
    // 清理当前层
  }
  generate(0, 0, n, '');
  return a;
}
// 2
```

4.[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)（7次）2021.07.25（8次）2021.08.02

```js
/*
* 思路：1.递归 O(n)
*      2.中序遍历是递增的 O(n)
*/
// 1
function isValidBST(root) {
	function recursion(root, lower, upper) {
    if (root == null) return true;
    if (root.val <= lower || root.val >= upper) return false;
    return recursion(root.left, lower, root.val) && recursion(root.right, root.val, upper); 
  }
  return recursion(root, -Infinity, Infinity);
}
// 2
function isValidBST(root) {
  let flag = true;
  let pre = -Infinity;
  function inorder(root) {
    if (root) {
      inorder(root.left);
      if (root.val <= pre) flag = false;
      pre = root.val;
      inorder(root.right);
    }
  }
  inorder(root);
  return flag;
}
// 2
function isValidBST(root) {
  let stack = [];
  let pre = -Infinity;
  while (root || stack.length) {
    while (root) {
      stack.push(root);
      root = root.left;
    }
    root = stack.pop();
    if (root.val <= pre) return false;
    pre = root.val;
    root = root.right;
  }
  return true;
}
```

5.[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)（7次）2021.07.25（8次）2021.08.02

```js
/*
* 思路：1.递归（深搜）：找重复性，深度就是左子树或右子树的深度+1 
*      2.广搜
*/
// 1
function maxDepth(root) {
  function recursion(root) {
    if (root == null) return 0;
    let leftDepth = maxDepth(root.left);
    let rightDepth = maxDepth(root.right);
    return Math.max(leftDepth, rightDepth) + 1;
  }
  return recursion(root);
}
// 2
function maxDepth(root) {
	if (root == null) return 0;
  let count = 0;
  let q = [root];
  while (q.length) {
    let n = q.length;
    while (n > 0) {
      let node = q.shift();
      if (node.left != null) q.push(node.left);
      if (node.right != null) q.push(node.right);
      n--;
    }
    count++;
  }
  return count;
}
```

6.[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

7.[全排列](https://leetcode-cn.com/problems/permutations/)

8.[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/description/) 

9.[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)

10.[二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

11.[从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)

12.[组合](https://leetcode-cn.com/problems/combinations/)

13.[全排列 II ](https://leetcode-cn.com/problems/permutations-ii/)

##### 分治、回溯的实现和特性

分治和回溯本质上就是递归，是递归其中的一个细分类，一种特殊的递归或较为复杂的递归。

分治：

找重复性，重复性有最近重复性（根据重复性怎么构造以及分解就有分治、回溯或其他各种办法，本质上就是递归，更本质的就是找它的重复性）或最优重复性（动态规划）。

分治在递归的状态树中对一个问题它要化解成好几个子问题，基本很多递归都是需要分治的，因为一个大问题之所以为大问题，肯定是有很多细的子问题组成。

不管是递归，分治，回溯或者其他的办法，最后本质上就是找重复性，以及分解问题和最后组合每个子问题的结果。

Problem -> Sub-Problem -> Sub-Solution -> Solution

分治代码模版

```js
function divide_conquer(problem, params) {  
  // 递归终止条件：相当于递归的层级到了最后层级的叶子节点，没有问题要解决了。
  if (problem == null) {    
    process_result    
    return  
  }   
  // 处理当前层，看把大问题如何分解成子问题。这点比较重要，主要看经验。
  subproblems = split_problem(problem, data)  
  // 下探到下一层
  subresult1 = divide_conquer(subproblem[0], p1)  
  subresult2 = divide_conquer(subproblem[1], p1)  
  subresult3 = divide_conquer(subproblem[2], p1)  
  // 组合子结果返回
  result = process_result(subresult1, subresult2, subresult3)  
  // 清理当前层状态
}
```

回溯：

不断的在每一层去试，看这个方法行不行，最典型的应用是八皇后和数独。把全部情况列举出来，看行不行，把不行的过滤掉，或只保留行的，回溯的过程中尽早的判定当前的结果是不行的，就越能节省执行次数。如生成括号问题。

##### 分治、回溯实战题目

1.[50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)（7次）2021.07.28（8次）2021.08.04

```js
/*
* 思路：1.暴力枚举累乘 O(n)
*			 2.傻递归 O(n) 调用栈栈溢出
*      3.分治递归 O(logn)
*/
// 1
function myPow(x, n) {
  if (n < 0) {
    x = 1 / x;
    n = -n;
  }
  let res = 1;
  for (let i = 0; i < n; i++) {
    res = res * x;
  }
  return res;
}
// 2
function myPow(x, n) {
  if (n < 0) {
    x = 1 / x;
    n = -n;
  }
  function pow(x, n) {
    if (n === 0) return 1;
    return x * pow(x, n - 1);
  }
  return pow(x, n);
}
// 3
function myPow(x, n) {
  if (n < 0) {
    x = 1 / x;
    n = -n;
  }
  function pow(x, n) {
    if (n === 0) return 1;
    let sub = pow(x, Math.floor(n / 2));
    return n % 2 === 0 ? sub * sub : sub * sub * x;
  }
  return pow(x, n);
}
```

2.[78. 子集](https://leetcode-cn.com/problems/subsets/)（7次）2021.07.29（8次）2021.08.05

```js
/*
* 思路：1.递归 O(2^n)
*      2.迭代 O(2^n)
*/
// 1
function subsets(nums) {
  let a = [];
  function recursion(nums, list, index) {
    if (index === nums.length) {
      a.push(list);
      return;
    }
    recursion(nums, JSON.parse(JSON.stringify(list)), index + 1);
    list.push(nums[index]);
    recursion(nums, JSON.parse(JSON.stringify(list)), index + 1);
  }
  recursion(nums, [], 0);
  return a;	
}
function subsets(nums) {
  let a = [];
  function recursion(nums, list, index) {
    if (index === nums.length) {
      a.push(list.slice());
      return;
    }
    recursion(nums, list, index + 1);
    list.push(nums[index]);
    recursion(nums, list, index + 1);
    list.pop();
  }
  recursion(nums, [], 0);
  return a;
}
// 2
function subsets(nums) {
  let a = [[]];
  for (let num of nums) {
    let res = [];
    for (let sub of a) {
      res.push(sub.concat(num));
    }
    a = a.concat(res);
  }
  return a;
}
```

3.[169. 多数元素](https://leetcode-cn.com/problems/majority-element/)（7次）2021.07.30（8次）2021.08.06

```js
/*
* 思路：1.hash O(n)
*      2.排序 O(nlogn)
*      3.分治 O(nlogn)
*/
// 1
function majorityElement(nums) {
  let map = new Map();
  for (let i of nums) {
    let value = map.has(i) ? map.get(i) + 1 : 1;
    map.set(i, value);
  }
  for (let [k, v] of map) {
    if (v > nums.length / 2) return k;
  }
}	
function majorityElement(nums) {
	let map = new Map();
  for (let i of nums) {
    let value = map.has(i) ? map.get(i) + 1 : 1;
    map.set(i, value);
    if (map.get(i) > nums.length / 2) return i;
  }
}
// 2
function majorityElement(nums) {
	nums.sort((a, b) => a - b);
  return nums[Math.floor(nums.length / 2)];
}
// 3
```

4.[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)（7次）2021.07.30（8次）2021.08.06

```js
/*
* 思路：1.分治递归
*      2.队列，广度优先
*/
// 1 括号生成递归方式
function letterCombinations(digits) {
  if (digits === '') return [];
  let a = [];
  let map = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];
  let b = [];
  for (let i of digits) {
    b.push(map[i]);
  }
  function recursion(arr, s, index) {
    if (index === digits.length) {
      a.push(s);
      return;
    }
    for (let i of arr[index]) {
      recursion(arr, s + i, index + 1);
    }
  }
  recursion(b, '', 0); 
  return a;
}
// 1
function letterCombinations(digits) {
  if (digits === '') return [];
  let map = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];
  if (digits.length === 1) return map[digits].split('');
  let b = [];
  for (let i of digits) {
    b.push(map[i]);
  }
  function recursion(arr) {
    if (arr.length === 1) {
      return arr[0];
    }
    let a1 = arr.shift();
    let a2 = arr.shift();
    let res = [];
    for (let i of a1) {
      for (let j of a2) {
        res.push(i + j);
      }
    }
    arr.unshift(res);
    return recursion(arr);
  }
  return recursion(b);
}
```

5.[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

```js
/*
* 思路：1.回溯：反复试不同的情况，最后把可以的放到结果里，不行的再重新试。
*/
// 1
```

##### 深度优先搜索和广度优先搜索的实现和特性

每个节点访问一次且仅访问一次，对于节点的访问顺序不同就可以分为深度优先搜索和广度优先搜索。

优先级优先搜索，更加适用于现实中的业务场景，称为启发式搜索。

深度优先搜索代码模版（7次）2021.08.11（8次）2021.08.18

```js
// 二叉树
let visited = new Set();
function dfs(root) {  
  if (visited.has(root)) return;
  visited.add(root);
  dfs(root.left);
  dfs(root.right);
}
// 多叉树
let visited = new Set();
function dfs(root) {  
  if (visited.has(root)) return;
  visited.add(root);
  for (let next_node of root.children) {
    dfs(next_node);
  }
}
// 非递归写法：手动维护一个栈
// https://shimo.im/docs/UdY2UUKtliYXmk8t/read
function dfs(root) {
  if (root == null) return;
  let visited = new Set();
  let stack = [root];
  while (stack.length) {
		let node = stack.pop();
    if (visited.has(node)) continue;
    visited.add(node);
    for (let i = node.children.length - 1; i >= 0; i--) {
      stack.push(node.children[i]);
    }
  }
}
```

广度优先搜索代码模版（7次）2021.08.11（8次）2021.08.18

```js
// 使用队列
function bfs(root) {    
  if (root == null) return [];
  let a = [];
  let q = [root];
  while (q.length > 0) {    
    let res = [];
    let n = q.length;    
    for (let i = 0; i < n; i++) {      
      let node = q.shift();  
      res.push(node.val);      
      if (node.left) q.push(node.left);     
      if (node.right) q.push(node.right);    
    }    
    a.push(res);
  }  
  return a;
}
```

##### 深度优先搜索和广度优先搜索实战题目

1.[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)（7次）2021.08.05（8次）2021.08.12

```js
/*
* 思路：1.bfs O(n)
*      2.dfs O(n)：访问的时候记录当前节点是在哪一层，把它加在它相应的层即可。
*/
// 1
function levelOrder(root) {
  if (root == null) return [];
  let a = [];
  let q = [root];
  while (q.length) {
    let res = [];
    let length = q.length;
    while (length > 0) {
	  	let node = q.shift();
      res.push(node.val);
      if (node.left) q.push(node.left);
      if (node.right) q.push(node.right);
    	length--; 
    }
    a.push(res);
  }
  return a;
}
// 2
function levelOrder(root) {
  let a = [];
  function dfs(root, index) {
    if (root == null) return;
    a[index] ? a[index].push(root.val) : a[index] = [root.val];
    dfs(root.left, index + 1);
    dfs(root.right, index + 1);
  }
  dfs(root, 0);
  return a;
}
```

2.[433. 最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)

```js
/*
* 思路：1.bfs
*      2.双向 bfs
*/
// 1
```

3.[515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)（7次）2021.08.06（8次）2021.08.13

```js
/*
* 思路：1.bfs O(n)
*      2.dfs O(n)
*/
// 1
function largestValues(root) {
  if (root == null) return [];
  let a = [];
  let q = [root];
  while (q.length) {
    let max = -Infinity;
    let n = q.length;
    for (let i = 0; i < n; i++) {
      let node = q.shift();
      max = Math.max(max, node.val);
      if (node.left) q.push(node.left);
      if (node.right) q.push(node.right);
    }
    a.push(max);
  }
  return a;
}
// 2
function largestValues(root) {
  let a = [];
  function recursion(root, index) {
    if (root == null) return;
    a[index] = a[index] == null ? root.val : Math.max(a[index], root.val);
    recursion(root.left, index + 1);
    recursion(root.right, index + 1);
  }
  recursion(root, 0);
  return a;
}
```

4.[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)（7次）2021.08.09（8次）2021.08.16

```js
/*
* 思路：1.dfs：嵌套循环每一个元素，遇到1岛屿数量加1，然后递归把所有和这个1相邻的1全部变成0，直到循环结束。
*      2.bfs
*      3.并查集
*/
// 1
function numIslands(grid) {
  let count = 0;
  let n = grid.length;
  if (n === 0) return 0;
  let m = grid[0].length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (grid[i][j] === '1') {
        count++;
        dfsMarking(grid, i, j);
      }
    }
  }
  function dfsMarking(grid, i, j) {
    if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] !== '1') return;
    grid[i][j] = '0';
    dfsMarking(grid, i - 1, j);
    dfsMarking(grid, i + 1, j);
    dfsMarking(grid, i, j - 1);
    dfsMarking(grid, i, j + 1);
  }
  return count;
}
```

5.[127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

6.[126. 单词接龙 II](https://leetcode-cn.com/problems/word-ladder-ii/)

7.[529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

##### 贪心算法的实现和特性

贪心：当下做出局部最优的选择。问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解，这种子问题最优解称为最优子结构。对每个子问题的解决方案都要做出选择，且不能回退。

贪心比较高效，得到的结果比较接近最优解，所以有些时候会用作一个辅助算法。比如最小生成树。

回溯：能够回退。

动态规划：带有最优判断的回溯。会保存以前的运算结果，并根据之前的结果对当前进行选择，有回退功能，重新选择。

##### 贪心算法实战题目

1.[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

2.[860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

3.[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)（7次）2021.08.14（8次）2021.08.21

```js
/*
* 思路：1.贪心 O(n)
*      2.动态规划
*/
// 1
function maxProfit(prices) {
  let money = 0;
  for (let i = 0; i < prices.length - 1; i++) {
    if (prices[i] < prices[i + 1]) money += prices[i + 1] - prices[i];
  }
  return money;
}
```

4.[455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

5.[874. 模拟行走机器人](https://leetcode-cn.com/problems/walking-robot-simulation/)

6.[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

7.[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

##### 二分查找的实现和特性

二分查找前提条件：

1. 目标函数单调性
2. 存在上下界
3. 能够通过索引访问

二分查找代码模版（7次）2021.08.13（8次）2021.08.20

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  while (left <= right) {  
    let mid = (left + right) >> 1;
    if (arr[mid] === target) { 
      return mid;
    }  else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return -1;
}
```

##### 二分查找实战题目

1.[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)（7次）2021.08.14（8次）2021.08.21

```js
/*
* 思路：1.二分查找
*      2.牛顿迭代法
*/
// 1
function mySqrt(x) {
  let left = 0;
  let right = x;
  while (left <= right) {
    let mid = (left + right) >> 1;
    if (mid * mid === x) {
      return mid;
    } else if (mid * mid < x) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return right;
}
// 2
function mySqrt(x) {
    let r = x;
    while (r * r > x) {
        r = (r + x / r) / 2 | 0;
    }
    return r;
}
```

2.[367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)（7次）2021.08.14（8次）2021.08.21

```js
/*
* 思路：1.二分查找
*/
// 1
function isPerfectSquare(num) {
    let left = 0;
    let right = num;
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (mid * mid === num) {
            return true;
        } else if (mid * mid < num) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return false;
}
```

3.[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)（7次）2021.08.15（8次）2021.08.22

```js
/*
* 思路：1.暴力枚举 O(n)
*      2.二分查找 O(logn)
*/
// 1
function search(nums, target) {
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === target) return i;
    }
    return -1;
}
// 2
function search(nums, target) {
	let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    let mid = (left + right) >> 1;
    if (nums[mid] === target) return mid;
    if (nums[left] <= nums[mid]) {
      if (target >= nums[left] && target <= nums[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    } else {
      if (target >= nums[mid] && target <= nums[right]) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
  }
  return -1;
}
```

4.[74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

5.[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

##### 动态规划（动态递推）的实现和特性

所有贪心的问题一定都可以转为动态规划来解决，因为动态规划是从全局把所有可能的候选项都经过对比选出它的最优解，所以动态规划肯定是贪心的超集。

分治 回溯 递归 动态规划。他们并没有本质上的非常大的不一样，很多时候就是一些小的细节的问题。

他们的本质都是将一个复杂的问题分解成子问题，同时寻找他的重复性。

找到最近最简方法，将其拆解成可重复解决的问题。

动态规划关键点：

1. 最优子结构 opt[n] = best_of(opt[n - 1], opt[n - 2], ...)，累加或求最大值最小值，中途淘汰次优解。
2. 存储中间状态：opt[i]
3. 递归公式（状态转移方程）

##### 动态规划实战题目

最优子结构：可递推，找第 i 和第 i - 1 之的能够包含所有情况并且最优的关系。

```js
dp[i] 0...i
dp[i - 1] 0...i-1 + nums[i]
```

1.[剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)（7次）2021.08.17（8次）2021.08.25

```js
/*
* f(n) = f(n - 1) + f(n - 2)
* 思路：1.傻递归（自顶向下） O(2*n)
*      2.记忆化递归（自顶向下） O(n)
*      3.动态规划循环递推（自底向上）O(n)
*/
// 1
function fib(n) {
  if (n <= 1) return n;
  return (fib(n - 1) + fib(n - 2)) % 1000000007;
}
// 2
function fib(n) {
	let a = [];
  function recursion(n) {
    if (n <= 1) return n;
    if (a[n] != null) return a[n];
    a[n] = (recursion(n - 1) + recursion(n - 2)) % 1000000007;
    return a[n];
  }
  return recursion(n);
}
// 3
function fib(n) {
	let a = [];
  a[0] = 0;
  a[1] = 1;
  for (let i = 2; i <= n; i++) {
    a[i] = (a[i - 1] + a[i - 2]) % 1000000007;
  }
  return a[n];
}
// 3
function fib(n) {
	if (n <= 1) return n;
  let a = 0;
  let b = 1;
  let r;
  for (let i = 2; i <= n; i++) {
    r = (a + b) % 1000000007;
    a = b;
    b = r;
  }
  return r;
}
```

3.[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)（7次）2021.08.19（8次）2021.08.26

```js
/*
* 路径计数：1.二维数组动态递归 2.取舍最优子结构
* 1.递归最后才知道确定的值，动态规划就是从确定的值开始递推累加。其实计算方向是一样的，只是执行的过程不一样2.dp要清楚累加的方向不要弄反。
* 思路：1.递归（自顶向下）
*      2.记忆化递归（自顶向下）
*      3.动态规划循环递推（自底向上）
*/
// 1
function uniquePathsWithObstacles(obstacleGrid) {
  let n = obstacleGrid.length;
  let m = obstacleGrid[0].length;
  function recursion(i, j) {
    if (obstacleGrid[i][j] === 1) return 0;
    if (i === n - 1 && j === m - 1) return 1;
    let value = 0;
    if (i === n - 1){
      value = recursion(i, j + 1);
    } else if (j === m - 1) {
			value = recursion(i + 1, j);
    } else {
	    value = recursion(i + 1, j) + recursion(i, j + 1);
    }
    return value;
  }
  return recursion(0, 0);
}
// 2
function uniquePathsWithObstacles(obstacleGrid) {
  let n = obstacleGrid.length;
  let m = obstacleGrid[0].length;
  let a = [];
  function recursion(i, j) {
    if (obstacleGrid[i][j] === 1) return 0;
    if (i === n - 1 && j === m - 1) return 1;
    if (a[i] == null) a[i] = [];
    if (a[i][j] != null) return a[i][j];
    let value = 0;
    if (i === n - 1){
      value = recursion(i, j + 1);
    } else if (j === m - 1) {
			value = recursion(i + 1, j);
    } else {
	    value = recursion(i + 1, j) + recursion(i, j + 1);
    }
    a[i][j] = value;
    return value;
  }
  return recursion(0, 0);
}
// 3
function uniquePathsWithObstacles(obstacleGrid) {
	let a = [];
  let n = obstacleGrid.length;
  let m = obstacleGrid[0].length;
  for (let i = n - 1; i >= 0; i--) {
    a[i] = [];
    for (let j = m - 1; j >= 0; j--) {
      if (obstacleGrid[i][j] === 0) {
        if (i === n - 1 && j === m - 1) {
          a[i][j] = 1;
        } else if (i === n - 1) {
          a[i][j] = a[i][j + 1];
        } else if (j === m - 1) {
          a[i][j] = a[i + 1][j];
        } else {
          a[i][j] = a[i + 1][j] + a[i][j + 1];
        }
      } else {
        a[i][j] = 0;
      }
    }
  }
  return a[0][0];
}
// 3
function uniquePathsWithObstacles(obstacleGrid) {
	let a = [];
  let n = obstacleGrid.length;
  let m = obstacleGrid[0].length;
  for (let i = 0; i < n; i++) {
    a[i] = [];
    for (let j = 0; j < m; j++) {
      if (obstacleGrid[i][j] === 0) {
        if (i === 0 && j === 0) {
          a[i][j] = 1;
        } else if (i === 0) {
          a[i][j] = a[i][j - 1];
        } else if (j === 0) {
          a[i][j] = a[i - 1][j];
        } else {
          a[i][j] = a[i - 1][j] + a[i][j - 1];
        }
      } else {
        a[i][j] = 0;
      }
    }
  }
  return a[n - 1][m - 1];
}
```

3.[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```js
/*
* 字符串进行变化的 dp，把它扩展成二维数组来定义状态。两个字符串变换的问题，最后就要做成一个二维数组，行列分别是两个字符串。
* 思路：1.暴力递归生成一个字符串的所有子序列，看子序列在另一个字符串中是否存在 O(2*n)
*      2.动态规划循环递推（自底向上）O(n)
*/
```

4.[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

5.[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

6.[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)（7次）2021.08.20（8次）2021.08.27

```js
/*
* 思路：1.暴力递归 O(2^n)
*      2.记忆化递归 O(m * n)
*      3.动态规划
*        a.重复性
*        b.定义状态数组
*        c.DP方程（前两步合体）
*/
// 1
function minimumTotal(triangle) {
  let n = triangle.length;
	function recursion(i, j) {
    if (i === n - 1) return triangle[i][j];
		return Math.min(recursion(i + 1, j), recursion(i + 1, j + 1)) + triangle[i][j];
  }
  return recursion(0, 0);
}
// 2
function minimumTotal(triangle) {
  let n = triangle.length;
  let a = [];
	function recursion(i, j) {
    if (i === n - 1) return triangle[i][j];
    if (a[i] == null) a[i] = [];
    if (a[i][j] != null) return a[i][j];
    a[i][j] = Math.min(recursion(i + 1, j), recursion(i + 1, j + 1)) + triangle[i][j];
		return a[i][j];
  }
  return recursion(0, 0);
}
// 3
function minimumTotal(triangle) {
	for (let i = triangle.length - 2; i >= 0; i--) {
    for (let j = 0; j < triangle[i].length; j++) {
      triangle[i][j] += Math.min(triangle[i + 1][j], triangle[i + 1][j + 1]);
    }
  }
  return triangle[0][0];
}
```

7.[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)（7次）2021.08.22（8次）2021.08.29

```js
/*
* 思路：1.暴力枚举 O(n^2)
*      2.分治递归 O(nlogn)
*      3.动态规划 O(n)
*/
// 1
function maxSubArray(nums) {
  let max = -Infinity;
  for (let i = 0; i < nums.length; i++) {
    let subMax = nums[i];
    let sum = nums[i];
    for (let j = i + 1; j < nums.length; j++) {
      sum += nums[j];
      subMax = Math.max(subMax, sum);
    }
    max = Math.max(max, subMax);
  }
  return max;
}
// 1
function maxSubArray(nums) {
  let max = -Infinity;
  for (let i = 0; i < nums.length; i ++) {
    let sum = nums[i];
     max = Math.max(max, nums[i]);
    for (let j = i + 1; j < nums.length; j++) {
      sum += nums[j];
      max = Math.max(max, sum);
    }
  }
  return max;
}
// 2
function maxSubArray(nums) {
  let a = [];
  function recursion(index) {
    if (index === 0) {
      a.push(nums[0]);
      return nums[0];
    }
    let max = Math.max(nums[index], recursion(index - 1) + nums[index]);
    a.push(max);
    return max;
  }
  recursion(nums.length - 1);
  return Math.max.apply(null, a);
}
// 2
function maxSubArray(nums) {
  let a = [];
  function recursion(index) {
    if (index === nums.length - 1) {
      a.push(nums[nums.length - 1]);
      return nums[nums.length - 1];
    }
    let max = Math.max(nums[index], recursion(index + 1) + nums[index]);
    a.push(max);
    return max;
  }
  recursion(0);
  return Math.max.apply(null, a);
}
// 3
function maxSubArray(nums) {
  let a = nums;
  for (let i = 1; i < nums.length; i++) {
    a[i] = Math.max(nums[i], nums[i] + a[i - 1]);
  }
  return Math.max.apply(null, a);
}
// 3
function maxSubArray(nums) {
  for (let i = nums.length - 2; i >= 0; i--) {
    nums[i] = Math.max(nums[i], nums[i + 1] + nums[i]);
  }
  return Math.max.apply(null, nums);
}
```

8.[152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

9.[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```js
/*
* 思路：1.递归
*      2.bfs
*      3.贪心
*      4.动态规划
*/
```

10.[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```js
/*
* 思路：1.动态规划
*/
```

11.[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

12.[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

13.[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

14.[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

15.[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

16.[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

17.[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

18.[股票问题系列通解](https://leetcode-cn.com/circle/article/qiAgHn/)

19.[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

20.[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

21.[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

22.[980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)

23.[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

24.[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

25.[221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

26.[621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

27.[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

28.[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

29.[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

30.[363. 矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

31.[403. 青蛙过河](https://leetcode-cn.com/problems/frog-jump/)

32.[410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)

33.[552. 学生出勤记录 II](https://leetcode-cn.com/problems/student-attendance-record-ii/)

34.[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

35.[312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

##### 排序算法的实现和特性

[ 9 种经典排序算法可视化动画](https://www.bilibili.com/video/av25136272)

[ 6 分钟看完 15 种排序算法动画展示](https://www.bilibili.com/video/av63851336)

1.比较类排序：

系统排序函数中可以传进去一个叫 comparator 的比较器，也就是说它比较的元素不一定非得是数字类型，它可以是任何结构体或对象，你只要给它传一个可以比较两个 object 之间前后关系的话，它都可以帮你排出来。

像这种通过比较来决定元素间的相对次序，时间复杂度不能突破 nlogn，因此也称为非线性时间比较类排序，我们大部分用到的排序都是这种比较类排序。

2.非比较类排序：

不用通过比较来决定元素间的相对次序， 一般是对于整型的元素，对于字符串或对象的排序就无能为力了，同时要额外的内存空间。可以用线性时间完成，因此也称为线性时间非比较类排序。 

3.排序算法分类：[十大经典排序算法](https://www.cnblogs.com/onepixel/p/7674659.html)

* 排序算法
  * 比较类排序
    * 交换排序
      * 冒泡排序
      * 快速排序
    * 插入排序
      * 简单插入排序
      * 希尔排序
    * 选择排序
      * 简单选择排序
      * 堆排序
    * 归并排序
      * 二路归并排序
      * 多路归并排序
  * 非比较类排序（放在一个数组里面统计每个数出现的次序）
    * 计数排序
    * 桶排序
    * 基数排序

4.排序算法复杂度分析：

<img src="排序算法复杂度分析.png" alt="排序算法复杂度分析"  />

5.初级排序 O(n^2)

选择排序（7次）2021.08.28

每次找最小值，放到待排序数组最前面。

内层循环找出最小值的下标跟外层循环 i 交换。

```js
function selectionSort(nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[j] < nums[minIndex]) {
        minIndex = j;
      }
    }
    if (minIndex !== i) {
      let c = nums[i];
      nums[i] = nums[minIndex];
      nums[minIndex] = c;
    }
  }
  return nums;
}
```

插入排序（7次）2021.08.28

从前到后构建有序序列， 在已排序序列从后向前扫描，将待排序数据插入到相应位置。

```js
// 1
function insertionSort(nums) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i; j > 0; j--) {
      if (nums[j] < nums[j - 1]) {
        let c = nums[j - 1];
        nums[j - 1] = nums[j];
        nums[j] = c;
      }
    }
  }
  return nums;
}
// 2
function insertionSort(nums) {
  for (let i = 0; i < nums.length; i++) {
    let preIndex = i - 1;
    let temp = nums[i];
    while (preIndex >= 0 && nums[preIndex] > temp) {
      nums[preIndex + 1] = nums[preIndex];
      preIndex--;
    }
    nums[preIndex + 1] = temp;
  }
  return nums;
}
```

冒泡排序（7次）2021.08.28

嵌套循环，内层循环每次把最大的元素放到最后面。

```js
function bubbleSort(nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = 0; j < nums.length - i - 1; j++) {
      if (nums[j] > nums[j + 1]) {
        let c = nums[j];
        nums[j] = nums[j + 1];
        nums[j + 1] = c;
      }
    }
  }
  return nums;
}
```

6.高级排序 O(nlogn)

快速排序（7次）2021.08.29

[快速排序代码示例](https://shimo.im/docs/TX9bDbSC7C0CR5XO)

快排是高级程序标准排序库里用的最多的。

在数组中取一个标杆 pivot，将小于 pivot 的元素放到 pivot 左侧，大于 pivot 的放到右侧，这样就会达到左侧的所有元素都小于右侧的所有元素，然后依次对左侧和右侧的子数组进行快排，也就是递归调用。这样整个数组就会达到有序的状态了。

```js
// 1
function quickSort(nums) {
  if (nums.length < 2) return nums;
  let tmp = nums[0];
  let left = [];
  let right = [];
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] < tmp) {
      left.push(nums[i]);
    } else {
      right.push(nums[i]);
    }
  }
  return quickSort(left).concat(tmp, quickSort(right));
}
// 2
function quickSort(nums) {
  function recursion(nums, left, right) {
    if (right <= left) return;
    let index = partition(nums, left, right);
    recursion(nums, left, index - 1);
    recursion(nums, index + 1, right);
  }
  recursion(nums, 0, nums.length - 1);
  function partition(nums, left, right) {
    let pivot = left, counter = left + 1;
    for (let i = left; i <= right; i++) {
      if (nums[i] < nums[pivot]) {
        [nums[counter], nums[i]] = [nums[i], nums[counter]];
        counter++;
      }
    }
    [nums[pivot], nums[counter - 1]] = [nums[counter - 1], nums[pivot]];
    return counter - 1;
  }
  return nums;
}
```

归并排序（7次）2021.08.30

[归并排序代码示例](https://shimo.im/docs/sDXxjjiKf3gLVVAU)

原理可以认为是快排的逆向操作。先分治再排序，快排是先排序再分治。

先把数组一分为二，对两个子序列分别做归并排序，将两个排序好的子序列合并成最终的排序序列。

```js
function mergeSort(nums) {
  function recursion(nums, left, right) {
    if (right <= left) return;
    let mid = (left + right) >> 1;
    recursion(nums, left, mid);
    recursion(nums, mid + 1, right);
    merge(nums, left, mid, right);
  }
  recursion(nums, 0, nums.length - 1);
  function merge(nums, left, mid, right) {
    let temp = [];
    let i = left, j = mid + 1, k = 0;
    while (i <= mid && j <= right) {
      temp[k++] = nums[i] <= nums[j] ? nums[i++] : nums[j++];
    }
    while (i <= mid) temp[k++] = nums[i++];
    while (j <= right) temp[k++] = nums[j++];
    for (let p = 0; p < temp.length; p++) {
      nums[left + p] = temp[p];
    } 
  }
  return nums;
}
```

堆排序（7次）2021.08.31

[堆排序代码示例](https://shimo.im/docs/M2xfacKvwzAykhz6)

堆的插入和删除都是 O(logn) 的，取最大/小值是 O(1) 的。

1. 数组元素依次建立小顶堆。
2. 依次取堆顶元素，并删除。

```js
// 1
function heapSort(nums) {
  let a = [];
  let minHeap = new BinaryHeap((a, b) => a - b);
  for (let i = 0; i < nums.length; i++) {
    minHeap.insert(nums[i]);
  }
  for (let i = 0; i < nums.length; i++) {
		a[i] = minHeap.delete(0);
  }
  return a;
}
// 2
function heapSort(nums) {
  let len = nums.length;
  // 建堆
  for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
    heapify(nums, len, i);
  }
  // 排序
  for (let i = len - 1; i >= 0; i--) {
    [nums[0], nums[i]] = [nums[i], nums[0]];
    heapify(nums, i, 0);
  }
  // 从i开始向下维护堆
  function heapify(nums, len, i) {
    let left = 2 * i + 1;
    let right = 2 * i + 2;
    let largest = i;
    if (left < len && nums[left] > nums[largest]) {
      largest = left;
    }
    if (right < len && nums[right] > nums[largest]) {
      largest = right;
    }
    if (largest !== i) {
      [nums[i], nums[largest]] = [nums[largest], nums[i]];
      heapify(nums, len, largest);
    }
  }
  return nums;
}
```

##### 排序算法实战题目

1.[1122. 数组的相对排序](https://leetcode-cn.com/problems/relative-sort-array/)

2.[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

3.[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)（7次）2021.08.31

```js
/*
* 思路：1.排序，扫描 O(nlogn)
*/
// 1
function merge(intervals) {
	intervals.sort((a, b) => a[0] - b[0]);
  for (let i = 0; i < intervals.length - 1; i++) {
		if (intervals[i][1] >= intervals[i + 1][0]) {
      intervals.splice(i, 2, [intervals[i][0], Math.max(intervals[i][1], intervals[i + 1][1])]);
      i--;
    }
  }
  return intervals;
}
```

4.[493. 翻转对](https://leetcode-cn.com/problems/reverse-pairs/)

5.[151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

6.[205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

##### 高级动态规划

dp 顺推模版

```js
function DP() {
  // dp状态的定义，二维情况
	dp = [][];
  // 有几维就写几层嵌套循环
  for (let i = 0; i < n; i++) {
		for (let j = 0; i < m; j++) {
      // 从之前的dp的状态推到最新的dp[i][j]的状态
      // fib/求一个最小值/累加/累减/有一层小的循环从之前的k个状态里面找出它的最值放到这
			dp[i][j] = _Function([dp[i][j]...]);
    }
  }
  // 最终结果
  return dp[n][m];
}
```

##### 高级动态规划实战题目

1.[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)（考虑各种变形怎么做）

2.[746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

3.[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

4.[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

5.[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

6.[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

7.[85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

8.[115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

9.[818. 赛车](https://leetcode-cn.com/problems/race-car/)

##### 字符串算法的实现和特性

##### 字符串算法实战题目

1.[709. 转换成小写字母](https://leetcode-cn.com/problems/to-lower-case/)

2.[58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)

3.[771. 宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/)

4.[387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

5.[8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

[ Atoi 代码示例](https://shimo.im/docs/5kykuLmt7a4DdjSP)

6.[14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

7.[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

8.[541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

9.[151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

10.[557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

11.[917. 仅仅反转字母](https://leetcode-cn.com/problems/reverse-only-letters/)

12.[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

13.[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

14.[438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

15.[125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

16.[680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

17.[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

18.[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

19.[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

20.[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

21.[10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

题解：[ https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/](https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/)

22.[44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)

23.[115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

##### 字符串匹配算法

- [Boyer-Moore 算法](https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)
- [ Sunday 算法](https://blog.csdn.net/u012505432/article/details/52210975)
- [字符串匹配暴力法代码示例](https://shimo.im/docs/8G0aJqNL86wWrPUE)
- [ Rabin-Karp 代码示例](https://shimo.im/docs/1wnsM7eaZ6Ab9j9M)
- [ KMP 字符串匹配算法视频](https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171)
- [字符串匹配的 KMP 算法](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)



##### todo：

##### 高级搜索

1. 朴素搜索

2. 优化方式：不重复（记忆化 fibonacci）、剪枝（生成括号问题）

3. 搜索方向：

   dfs

   bfs

   双向搜索、启发式搜索

##### 剪枝的实现和特性

##### 剪枝实战题目

1.[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

2.[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

3.[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

4.[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

```js
/*
* 思路：1.
*/
```

5.[37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

```js
/*
* 思路：1.
*/
```

##### 双向 bfs 的实现和特性

从两头分别做 bfs 扩散，当扩散的两层节点有重合的时候，就是最短路径。

##### 双向 bfs 实战题目

1.[127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

```js
/*
* 思路：1.bfs
*      2.dfs
*      3.双向 bfs
*/
```

2.[433. 最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)

##### 启发式搜索的实现和特性

智能搜索，基于 bfs，把 q 换成优先队列。

[ A* 代码模板](https://shimo.im/docs/8CzMlrcvbWwFXA8r)

##### 启发式搜索实战题目

1.[1091. 二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

2.[773. 滑动谜题](https://leetcode-cn.com/problems/sliding-puzzle/)

3.[37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

##### 字典树的实现和特性

[ Tire 树代码模板](https://shimo.im/docs/DP53Y6rOwN8MTCQH)

##### 字典树实战题目

1.[208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

2.[212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)

##### 并查集的实现和特性

[并查集代码模板](https://shimo.im/docs/VtcxL0kyp04OBHak)

##### 并查集实战题目

1.[剑指 Offer II 116. 朋友圈](https://leetcode-cn.com/problems/bLyHh0/)

2.[547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

3.[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

4.[130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

##### 高级树、AVL树和红黑树的实现和特性

二叉搜索树查询的时间复杂度是取决于树的深度的，所有使二叉搜索树平衡就能保证它的查询效率。

平衡二叉树：保证左右子树节点平衡，如：AVL、红黑树、二三树、B+ 树都是平衡二叉树。

AVL 适合查询操作比较多的，红黑树适合插入删除操作比较多的。

AVL 树：

1. 平衡因子：左子树的高度减去右子树的高度。平衡因子在 -1 0 1 之间，就是一棵完全平衡二叉树。每个节点上都要存一个平衡因子。
2. 通过旋转操作来进行平衡（四种）：左旋，右旋，左右旋，右左旋。
3. 不足：节点需要存储额外信息，且调整次数频繁。

红黑树：

红黑树是一种近似平衡的二叉搜索树，它能够确保任何一个节点的左右子树的高度差小于两倍。红黑树是满足下面条件的二叉搜索树。

1. 每个节点要么是红色，要么是黑色。
2. 根节点是黑色。
3. 每个叶子节点是黑色。且叶子节点都是空节点。
4. 不能有相邻接的两个红色节点。
5. 从任何一个节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。

##### 位运算实现和特性

位运算符和含义：

左移 <<、右移 >>：新位置补零，移出的位置消失。

或 |：两个二进制数进行操作

与 &：

取反 ~：

异或（相同为零不同为一）^：

<img src="位运算.jpg" alt="位运算" style="zoom:50%;" />

位运算的应用：

```js
// 判断奇偶
x % 2 === 1    (x & 1) == 1
x % 2 === 0    (x & 1) == 0
// 取中间值
Math.floor((left + right) / 2)     (left + right) >> 1
// 清零最低位的1
x = x & (x - 1)
// 得到最低位的1
x & -x
// 等于0
x & ~x
```

##### 位运算实战题目

1.[191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

2.[231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)

3.[190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

4.[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

5.[52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)

[ N 皇后位运算代码示例](https://shimo.im/docs/YzWa5ZZrZPYWahK2)

6.[338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

##### 布隆过滤器和LRU缓存的实现和特性

布隆过滤器：

由一个很长的二进制向量和一系列随机映射函数构成。可以用来检索一个元素是否在一个集合中。

优点是空间效率和查询时间都远远高于一般算法。

缺点是有一定的误识别率和删除困难。

[布隆过滤器代码示例](https://shimo.im/docs/UITYMj1eK88JCJTH)

LRU缓存：

[ LRU Cache 代码示例](https://shimo.im/docs/CoyPAyXooGcDuLQo)

##### 布隆过滤器和LRU缓存实战题目

1.[146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

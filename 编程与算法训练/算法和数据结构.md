##### 算法学习方法

算法存在客观的复杂度。

反复的思考、练习。

算法只是基础，不要抗拒记忆。

学习最终就是大脑建立稳定的神经回路。

时间间隔分开的过遍数。

过程痛苦是正在成长。

学习高手代码（leetcode）。

##### 学习方法（‘Outliers’一万小时训练法）

1. 切碎知识点（分清知识体系脉络，形成知识网）
2. 刻意练习，基础动作分解训练，反复练习（基本功），练习弱项
3. 反馈（看好代码，别人给你指点，实战）

##### 切题步骤

1. 正确理解题目的需求
2. 想所有可能的解法，分析不同解法的时空复杂度，找出最优的一种解法
3. 写代码
4. 例举测试样例，测试程序正确性。

##### 无毒神掌

1. 5-10 分钟读题 + 思考

   没思路直接看解法，多解法，比较解法优劣。

   背诵、默写好的解法：先把它记住了之后，100% 都可以理解的，只是要反复很多遍之后。

2. 马上自己写 --> leetcode 提交，有 bug 就反复 debug，修改，直到通过。多个解法都写一遍。关注时空复杂度。看力扣好的题解。再看力扣国际站。

3. 过一天后做一遍前一天做过的题目。对不太熟悉的解法，做专项训练。

4. 过了一周，回来练习相同题目。对不太熟悉的解法，做专项训练。

5. 面试前一周再把之前的题目做一遍。

##### 最终达到的效果

* 常见的高频题马上就知道它常见的一些办法和每个办法的时间空间复杂度
* 它最简洁的代码实现形式在脑子里马上知道。

##### 指法和小操作

* fn + delete 删除光标右边
* command +left/right 光标切换到行头/行尾
* option + left/right/delete 光标按单词切分
* shift + command + left/right 选中整行
* ide 使用技巧，top tips

##### 自顶向下的编程方式

关键的主干大层次的逻辑代码写在上面，其他的私有函数和细节的逻辑函数写在下面。先森林在枝干再叶子。先不考虑细节怎么实现，把主干逻辑写出来。

##### 时间复杂度

前面的常数系数是不用考虑的。时间复杂度就是根据 n 的不同情况会运行多少次

* O(1)：常数复杂度
* O(log n)：对数复杂度
* O(n)：线性时间复杂度
* O(n^2)：平方
* O(n^3)：立方
* O(2^n)：指数
* O(n!)：阶乘

递归可以画出它的状态树来看它的时间复杂度。

主定理：计算所有递归的时间复杂度

* 排好序的一维数组进行二分查找：O(log n)
* 二叉树遍历：O(n)
* 排好序的二维矩阵中进行二分查找：O(n)
* 归并排序：O(nlog n)，所有排序最优的就是在这个时间复杂度

##### 空间复杂度

* 程序里开了数组，那数组的长度就是你的空间复杂度
* 如果有递归，那递归的深度就是你的空间复杂度。

##### 数据结构

* 一维数据结构
  * 基础
    * 数组
    * 链表
  * 高级
    * 栈
    * 队列
    * 双端队列
    * 集合 set
    * 映射 map (hash)
* 二维数据结构：都是从一维数据结构泛化而来的
  * 基础
    * 树
    * 图
  * 高级：在树的基础上加了很多的特殊判断和约定条件
    * 二叉搜索树（红黑树，AVL）
    * 堆
    * 并查集
    * 字典树
* 特殊数据结构：运用于工程中特定的情景
  * 位运算
  * 布隆过滤器
  * LRU 缓存

##### 算法

前三点是所有算法和数据结构的基石。任何高级的算法和数据结构到最后都会转换成这三点。高级复杂算法的根本就是找到它的重复单元，基于这个重复单元就可以泛化成高级的数据结构。

* if else, switch   --->  branch
* for while loop  --->  Iteration
* 递归 recursion（函数自己调用自己）
* 搜索
  * 深度优先搜索 DFS
  * 广度优先搜索 BFS
  * 启发式搜索 A*
* 动态规划
* 二分查找：对有序的数组很快的找到你要的节点
* 贪心算法
* 排序算法
* 数学和几何上的操作。

##### 解题思路

1.暴力

2.基本情况

3.泛化：

用递推，数学归纳法找重复性。用计算机的思维去思考怎么解决问题，不要人肉递归，不要用人脑的思维去想。

找重复性。在列举基本情况的基础上，找 最近 重复子问题。因为程序除了简单的情况使用 if else，其他就是用 for while 和递归 不断的重复。因为计算机不是人脑，它能想到的只有这些简单的解决方式，它就是简单的重复式的机器，你就把它想成一个不断重复在那里干事情的东西就好了，所有复杂问题最终都要变成这几个语句来给计算机去处理。所以我们就往这个方向去做和思考。要让计算机用重复的东西解决你的问题，如果能用重复的东西解决的问题，说明这个问题本身就是可重复的，所以就是找它的重复性。重复的时候可以分出很多 if else 分支，就会让递归的程序越来越复杂，复杂性就慢慢出来了。

思考先想简单的办法，再想高大上的办法。

栈：具有最近相关性用栈解决，外层和外层配对，内层可以和内层配对。 

现实和工程中都有很多这种从外向内或从内向外逐渐扩散的特性。

先来后到就用队列。

所有东西都不是发明创造的，都是对现实中已有的逻辑进行抽象，然后用计算机的语言来进行表达。

比较复杂的算法最后都会归结到找最近的重复性。因为你只能写 if else, for loop, 递归这几个简单的语言。要么就是客观就这么复杂要写很长的程序，要不然就是程序很短的话，那肯定是有重复性，然后用一个递归或者一个 for loop 就可以解决了。

##### 数组、链表、跳表的基本实现和特性

* 数组

  底层硬件实现有一个叫内存管理器的东西，每当申请数组的话，计算机实际上是在内存中开辟了一段连续的地址，每一个地址可以直接通过内存管理器访问，访问的时间复杂度是 O(1) 的。插入是 O(n)，删除也是 O(n)

  * prepend O(1)
  * append O(1)
  * lookup O(1)
  * insert O(n)
  * delete O(n)

* 链表

  元素定义好之后，有 value 和 next，next 指向下一个元素，串在一起就变成了一个类似于数组的结构，每个元素一般用 class 来定义，叫 node。

  如果只有一个 next 指针的话叫单链表，有一个向前的指针有一个向后的指针就是双向链表，头指针一般用 head 来表示，尾指针用 tail 来表示，最后一个元素的 next 指向空，tail 的 next 指回到 head 就叫循环链表。

  链表可以弥补数组的缺点，在一些修改，添加，删除操作比较频繁的情况下，数组并不好用。

  插入删除元素都是 O(1)，增加和删除任何节点都没有引起整个链表的群移操作，也不需要复制元素。访问元素必须从头节点开始一步一步往后找，是 O(n) 的。这也是它的问题所在

  * prepend O(1)
  * append O(1)
  * lookup O(n)
  * insert O(1)
  * delete O(1)

  从数组和链表可以看到，并没有完美的一种数据结构，如果有的话就不再需要 array 或 linked list 这两个数据结构并存了，就直接用那个牛逼的数据结构就可以了。所以各种数据结构各有优劣，看你使用的场景是什么地方。

* 跳表

  利用升维思想。

  只能用于链表元素有序的情况下。

  跳表对标的是平衡二叉树和二分查找，是一种插入，删除，搜索都是 O(log n) 的数据结构。空间复杂度 O(n)。

  它的优势是原理简单，容易实现，方便扩展，效率更高。因此在一些热门项目里用来替代平衡树，如 Redis，LevelDB 等。

##### 数组实战题目

1.[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)（6次）

```js
/*
* 思路：1.loop，遇零删除，在数组最后添加 0
*      2.开新数组，非零的放前面 i，零放后面 j
*      3.双指针index操作，一维数组两个下标换来换去。维护 i j 两个指针来做各种事情。
*			   双指针交换：一个循环指针，一个始终记录下一个想要的节点要放的位置的指针。这样就可以在不增加新内存的情况下，通过 index 方          *			   式，把所有想要的节点放在应该的位置。
*/
// 1
function moveZeroes(nums) {
  let count = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === 0) {
      nums.splice(i, 1);
      i--;
      count++;
    }
  }
  for (i = 0; i < count; i++) {
    nums.push(0);
  }
  return nums;
};
// 2
function moveZeroes(nums) {
  let res1 = [];
  let res2 = [];
  nums.forEach(item => {
    if (item === 0) {
      res1.push(item);
    } else {
      res2.push(item);
    }
  });
  return res2.concat(res1);
};
// 3
function moveZeroes(nums) {
  // j记录的是下一个要填入的非零元素的位置。
  let j = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
    	nums[j] = nums[i];
      if (i !== j) {
				nums[i] = 0;
      }
      j++;
    }
  }
  return nums;
};
function moveZeroes(nums) {
  let j = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      let c = nums[j];
      nums[j] = nums[i];
      if (c === 0) {
        nums[i] = 0;
      }
      j++;
    }
  }
  return nums;
};
function moveZeroes(nums) {
  let j = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      let c = nums[j];
      nums[j] = nums[i];
      nums[i] = c;
      j++;
    }
  }
  return nums;
};
```

2.[11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)（6次）

```js
/*
*	思路：1.枚举，双循环 O(n^2)：左柱子x，右柱子y，(x-y)*height。
*      2.左右夹逼 O(n)：左右边界 i j 向中间收敛，最后在中间汇合，只有一层循环 
*/
// 1
function maxArea(arr) {
  let max = 0;
	for (let i = 0; i < arr.length - 1; i++) {
		for (let j = i + 1; j < arr.length; j++) {
			let area = (j - i) * Math.min(arr[i], arr[j]);
      max = Math.max(max, area);
   	}
  }
  return max;
}
// 2
function maxArea(arr) {
  let max = 0;
	for (let i = 0, j = arr.length - 1; i < j; ) {
    // 谁高度小谁往里面挪，来找那个更高的棒子。
    let minHeight = arr[i] < arr[j] ? arr[i++] : arr[j--];
    let area = (j - i + 1) * minHeight;
    max = Math.max(max, area);
  }
  return max;
}
```

3.[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)（5次）

```js
/* f(n) = f(n - 1) + f(n - 2) 斐波那契数列
* 思路：1.暴力递归 O(2^n)
*      2.记忆化递归 O(n)
*      3.动态规划 O(n)：保证计算到 n 就行了。
*/
// 1
function climbStairs(n) {
  if (n <= 2) return n;
  return climbStairs(n - 1) + climbStairs(n - 2);
}
// 2
let mapData = new Map();
function climbStairs(n) {
  if (n <= 2) return n;
  if (mapData.has(n)) return mapData.get(n);
  let res = climbStairs(n - 1) + climbStairs(n - 2); 
  mapData.set(n, res);
  return res;
}
// 3
function climbStairs(n) {
  if (n <= 2) return n;
	let arr = [];
  arr[1] = 1;
  arr[2] = 2;
  for (let i = 3; i <= n; i++) {
    arr[i] = arr[i - 1] + arr[i - 2];
  }
  return arr[n];
}
function climbStairs(n) {
  if (n <= 2) return n;
  let a = 1, b = 2, res = 0;
  for (let i = 0; i < n - 2; i++) {
		res = a + b;
    a = b;
    b = res;
  }
  return res;
}
```

4.[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)（3次）

```js
/*
* 思路：1.暴力枚举 O(n^2)：两层循环
*      2.哈希表 O(n)
*/
// 1
function twoSum(nums, target) {
  let a = [];
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        a[0] = i;
        a[1] = j;
      }
    }
  }
  return a;
}
// 2 
function twoSum(nums, target) {
  let mapData = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (mapData.has(target - nums[i])) {
        return [mapData.get(target - nums[i]), i];
    }
    mapData.set(nums[i], i);
  }
  return [];
}
```

5.[15. 三数之和](https://leetcode-cn.com/problems/3sum/)（3次）

```js
/*
* 思路：1.暴力 O(n^3)：三重循环
*      2.哈希 O(n^2)：两重循环 + hash
*.     3.夹逼 O(n^2)：排序后，双指针左右夹逼
*/
// 1
function threeSum(nums) {
  if (nums == null || nums.length <= 2) return [];
  let a = [];
  let mapData = new Map();
  for (let i = 0; i < nums.length - 2; i++) {
		for (let j = i + 1; j < nums.length - 1; j++) {
      for (let k = j + 1; k < nums.length; k++) {
				if (nums[i] + nums[j] + nums[k] === 0) {
          let tmp = [nums[i], nums[j], nums[k]];
          tmp.sort();
          if (!mapData.has(tmp.join())) {
          	a.push([nums[i], nums[j], nums[k]]);
            mapData.set(tmp.join(), [nums[i], nums[j], nums[k]]);
         	}
        }
      }
    }
  }
  return a;
}
// 2 1.技巧 hash 2.两次循环 hash
// 3
function threeSum(nums) {
  if (nums == null || nums.length <= 2) return [];
  nums.sort((a, b) => a - b);
  let a = [];
  for (let k = 0; k < nums.length - 2; k++) {
    if (nums[k] > 0) break;
    if (k > 0 && nums[k] === nums[k - 1]) continue;
    let i = k + 1, j = nums.length - 1;
    while(i < j) {
    	let sum = nums[k] + nums[i] + nums[j];
      if (sum < 0) {
      	while(i < j && nums[i] === nums[++i]);
      } else if (sum > 0) {
      	while(i < j && nums[j] === nums[--j]);   
      } else {
        a.push([nums[k], nums[i], nums[j]]);
        while(i < j && nums[i] === nums[++i]);   
        while(i < j && nums[j] === nums[--j]);   
      }
    }
  }
  return a;
}
```

##### 链表实战题目

所有链表的题目的解法都非常固定，主要就死熟能生巧，没有很多算法的东西，关键就是要熟悉怎么把链表的 next 和 prev 指针换来换去。

1.[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

2.[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

3.[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```js
/*
* 思路：1.暴力：遍历链表，hash/set
*      2.快慢指针
*/
// 1
```

4.[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

5.[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

##### 作业

简单：

1.[26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

2.[189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

3.[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

4.[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

5.[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

6.[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

7.[66. 加一](https://leetcode-cn.com/problems/plus-one/)

中等：

1.[641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/)

困难：

1.[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)











##### 技巧

匹配一个字符串的子串，用正则处理比较好。

一维数组运用技巧，百分号取余换行。

判断的时候是与的关系初始化就是 ture，或的关系初始化就是 false，加的关系初始化是 0，乘的关系初始化是 1。

匹配字符串的子串用正则做比较好，一个字母、单词、空格都能提取出来。

树的遍历基本上是基于递归的，因为树的结构本身导致了它没法有效的进行循环。做法是对它的左右节点再调用相同的遍历函数。

##### 递归

递归：找到规律，分步拆解。

递归就是范围从大到小，每一部分的处理过程是相同的，输入输出是相同的，处理次数未知，再加上边界条件。

深度优先：先递归，再做事。先处理下级内容。是向内一层一层的钻进。知道最后一个层级的结果，拿到它再一层一层的把上面的结果都算出来，最终算到最大的那个数，就是答案了。所以是从后往前遍历。输入是 n，输出是结果所要的东西。

广度优先：先做事，再递归。先处理同级内容。

##### 寻路问题（搜索算法）

1. 深度优先是先找下级，广度优先是先找同级。
2. 深度优先搜索（栈），广度优先搜索（队列）唯一的区别就是使用的数据结构。
3. 广搜是可以找到最优路径的，深搜不行。
4. 所有的搜索算法唯一的区别就是数据结构。
5. 所有递归的问题都可以用深度优先所有的 stack 的形式去写。

##### 算法学习方法

算法存在客观的复杂度。

反复的思考、练习。

算法只是基础，不要抗拒记忆。

学习最终就是大脑建立稳定的神经回路。

时间间隔分开的过遍数。

过程痛苦是正在成长。

学习高手代码（leetcode）。

##### 学习方法（‘Outliers’一万小时训练法）

1. 切碎知识点（分清知识体系脉络，形成知识网）
2. 刻意练习，基础动作分解训练，反复练习（基本功），练习弱项
3. 反馈（看好代码，别人给你指点，实战）

##### 切题步骤

1. 正确理解题目的需求
2. 想所有可能的解法，分析不同解法的时空复杂度，找出最优的一种解法
3. 写代码
4. 例举测试样例，测试程序正确性。

##### 无毒神掌

1. 5-10 分钟读题 + 思考

   没思路直接看解法，多解法，比较解法优劣。

   背诵、默写好的解法：先把它记住了之后，100% 都可以理解的，只是要反复很多遍之后。

2. 马上自己写 --> leetcode 提交，有 bug 就反复 debug，修改，直到通过。多个解法都写一遍。关注时空复杂度。看力扣好的题解。再看力扣国际站。

3. 过一天后做一遍前一天做过的题目。对不太熟悉的解法，做专项训练。

4. 过了一周，回来练习相同题目。对不太熟悉的解法，做专项训练。

5. 面试前一周再把之前的题目做一遍。

##### 最终达到的效果

* 常见的高频题马上就知道它常见的一些办法和每个办法的时间空间复杂度
* 它最简洁的代码实现形式在脑子里马上知道。

##### 指法和小操作

* fn + delete 删除光标右边
* command +left/right 光标切换到行头/行尾
* option + left/right/delete 光标按单词切分
* shift + command + left/right 选中整行
* ide 使用技巧，top tips

##### 自顶向下的编程方式

关键的主干大层次的逻辑代码写在上面，其他的私有函数和细节的逻辑函数写在下面。先森林在枝干再叶子。先不考虑细节怎么实现，把主干逻辑写出来。

##### 时间复杂度

前面的常数系数是不用考虑的。时间复杂度就是根据 n 的不同情况会运行多少次

* O(1)：常数复杂度
* O(log n)：对数复杂度
* O(n)：线性时间复杂度
* O(n^2)：平方
* O(n^3)：立方
* O(2^n)：指数
* O(n!)：阶乘

递归可以画出它的状态树来看它的时间复杂度。

主定理：计算所有递归的时间复杂度

* 排好序的一维数组进行二分查找：O(log n)
* 二叉树遍历：O(n)
* 排好序的二维矩阵中进行二分查找：O(n)
* 归并排序：O(nlog n)，所有排序最优的就是在这个时间复杂度

##### 空间复杂度

* 程序里开了数组，那数组的长度就是你的空间复杂度
* 如果有递归，那递归的深度就是你的空间复杂度。

##### 数据结构

* 一维数据结构
  * 基础
    * 数组
    * 链表
  * 高级
    * 栈
    * 队列
    * 双端队列
    * 集合 set
    * 映射 map (hash)
* 二维数据结构：都是从一维数据结构泛化而来的
  * 基础
    * 树
    * 图
  * 高级：在树的基础上加了很多的特殊判断和约定条件
    * 二叉搜索树（红黑树，AVL）
    * 堆
    * 并查集
    * 字典树
* 特殊数据结构：运用于工程中特定的情景
  * 位运算
  * 布隆过滤器
  * LRU 缓存

##### 算法

前三点是所有算法和数据结构的基石。任何高级的算法和数据结构到最后都会转换成这三点。高级复杂算法的根本就是找到它的重复单元，基于这个重复单元就可以泛化成高级的数据结构。

* if else, switch   --->  branch
* for while loop  --->  Iteration
* 递归 recursion（函数自己调用自己）
* 搜索
  * 深度优先搜索 DFS
  * 广度优先搜索 BFS
  * 启发式搜索 A*
* 动态规划
* 二分查找：对有序的数组很快的找到你要的节点
* 贪心算法
* 排序算法
* 数学和几何上的操作。

##### 解题思路

1.暴力

2.基本情况

3.泛化：

用递推，数学归纳法找重复性。用计算机的思维去思考怎么解决问题，不要人肉递归，不要用人脑的思维去想。

找重复性。在列举基本情况的基础上，找 最近 重复子问题。因为程序除了简单的情况使用 if else，其他就是用 for while 和递归 不断的重复。因为计算机不是人脑，它能想到的只有这些简单的解决方式，它就是简单的重复式的机器，你就把它想成一个不断重复在那里干事情的东西就好了，所有复杂问题最终都要变成这几个语句来给计算机去处理。所以我们就往这个方向去做和思考。要让计算机用重复的东西解决你的问题，如果能用重复的东西解决的问题，说明这个问题本身就是可重复的，所以就是找它的重复性。重复的时候可以分出很多 if else 分支，就会让递归的程序越来越复杂，复杂性就慢慢出来了。

比较复杂的算法最后都会归结到找最近的重复性。因为你只能写 if else, for loop, 递归这几个简单的语言。要么就是客观就这么复杂要写很长的程序，要不然就是程序很短的话，那肯定是有重复性，然后用一个递归或者一个 for loop 就可以解决了。

4.思考先想简单的办法，再想高大上的办法。

##### 数组、链表、跳表的基本实现和特性

* 数组

  底层硬件实现有一个叫内存管理器的东西，每当申请数组的话，计算机实际上是在内存中开辟了一段连续的地址，每一个地址可以直接通过内存管理器访问，访问的时间复杂度是 O(1) 的。插入是 O(n)，每当插入一个元素，它后面的元素都要向后挪一个位置，这个过程会涉及到很多元素的复制操作，把要插入的位置让出来，然后把元素插入。删除也是 O(n)，把要删除的元素清除掉，然后把后面的元素都向前移动，再把最后一个元素设置为空。

  * prepend O(1)
  * append O(1)
  * lookup O(1)
  * insert O(n)
  * delete O(n)

* 链表

  元素定义好之后，有 value 和 next，next 指向下一个元素，串在一起就变成了一个类似于数组的结构，每个元素一般用 class 来定义，叫 node。

  如果只有一个 next 指针的话叫单链表，有一个向前的指针有一个向后的指针就是双向链表，头指针一般用 head 来表示，尾指针用 tail 来表示，最后一个元素的 next 指向空，tail 的 next 指回到 head 就叫循环链表。

  链表可以弥补数组的缺点，在一些修改，添加，删除操作比较频繁的情况下，数组并不好用。

  插入删除元素都是 O(1)，增加和删除任何节点都没有引起整个链表的群移操作，也不需要复制元素，挪动多个元素到新的位置。访问元素必须从头节点开始一步一步往后找，是 O(n) 的。这也是它的问题所在

  * prepend O(1)
  * append O(1)
  * lookup O(n)
  * insert O(1)
  * delete O(1)

  从数组和链表可以看到，并没有完美的一种数据结构，如果有的话就不再需要 array 或 linked list 这两个数据结构并存了，就直接用那个牛逼的数据结构就可以了。所以各种数据结构各有优劣，看你使用的场景是什么地方。

* 跳表

  利用升维思想。

  只能用于链表元素有序的情况下。

  跳表对标的是平衡二叉树和二分查找，是一种插入，删除，搜索都是 O(log n) 的数据结构。空间复杂度 O(n)。

  它的优势是原理简单，容易实现，方便扩展，效率更高。因此在一些热门项目里用来替代平衡树，如 Redis，LevelDB 等。

##### 数组实战题目

1.[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)（7次）2021.06.07

```js
/*
* 思路：1.loop，遇零删除，在数组最后添加 0
*      2.开新内存，非零的放前面 i，零放后面 j
*      3.双指针index操作，一维数组两个下标换来换去。维护 i j 两个指针来做各种事情。
*			   双指针交换：一个循环指针，一个始终记录下一个想要的节点要放的位置的指针。这样就可以在不增加新内存的情况下，通过 index 方          *			   式，把所有想要的节点放在应该的位置。
*/
// 1
function moveZeroes(nums) {
  let count = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === 0) {
      nums.splice(i, 1);
      i--;
      count++;
    }
  }
  for (i = 0; i < count; i++) {
    nums.push(0);
  }
  return nums;
};
// 2
function moveZeroes(nums) {
  let res1 = [];
  let res2 = [];
  nums.forEach(item => {
    if (item === 0) {
      res1.push(item);
    } else {
      res2.push(item);
    }
  });
  return res2.concat(res1);
};
// 3
function moveZeroes(nums) {
  // j记录的是下一个要填入的非零元素的位置。
  let j = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
    	nums[j] = nums[i];
      if (i !== j) {
				nums[i] = 0;
      }
      j++;
    }
  }
  return nums;
};
function moveZeroes(nums) {
  let j = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      let c = nums[j];
      nums[j] = nums[i];
      if (c === 0) {
        nums[i] = 0;
      }
      j++;
    }
  }
  return nums;
};
function moveZeroes(nums) {
  let j = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      let c = nums[j];
      nums[j] = nums[i];
      nums[i] = c;
      j++;
    }
  }
  return nums;
};
```

2.[11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)（7次）2021.06.07

```js
/*
*	思路：1.枚举，双循环 O(n^2)：左柱子x，右柱子y，(x-y)*height。
*      2.左右夹逼 O(n)：左右边界 i j 向中间收敛，最后在中间汇合，只有一层循环 
*/
// 1
function maxArea(arr) {
  let max = 0;
	for (let i = 0; i < arr.length - 1; i++) {
		for (let j = i + 1; j < arr.length; j++) {
			let area = (j - i) * Math.min(arr[i], arr[j]);
      max = Math.max(max, area);
   	}
  }
  return max;
}
// 2
function maxArea(arr) {
  let max = 0;
	for (let i = 0, j = arr.length - 1; i < j; ) {
    // 谁高度小谁往里面挪，来找那个更高的棒子。
    let minHeight = arr[i] < arr[j] ? arr[i++] : arr[j--];
    let area = (j - i + 1) * minHeight;
    max = Math.max(max, area);
  }
  return max;
}
```

3.[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)（7次）2021.06.08

```js
/* f(n) = f(n - 1) + f(n - 2) 斐波那契数列
* 思路：1.暴力递归 O(2^n)
*      2.记忆化递归 O(n)
*      3.动态规划 O(n)：保证计算到 n 就行了。
*/
// 1
function climbStairs(n) {
  if (n <= 2) return n;
  return climbStairs(n - 1) + climbStairs(n - 2);
}
// 2
let mapData = new Map();
function climbStairs(n) {
  if (n <= 2) return n;
  if (mapData.has(n)) return mapData.get(n);
  let res = climbStairs(n - 1) + climbStairs(n - 2); 
  mapData.set(n, res);
  return res;
}
// 3
function climbStairs(n) {
  if (n <= 2) return n;
	let arr = [];
  arr[1] = 1;
  arr[2] = 2;
  for (let i = 3; i <= n; i++) {
    arr[i] = arr[i - 1] + arr[i - 2];
  }
  return arr[n];
}
function climbStairs(n) {
  if (n <= 2) return n;
  let a = 1, b = 2, r = 0;
  for (let i = 0; i < n - 2; i++) {
		r = a + b;
    a = b;
    b = r;
  }
  return r;
}
```

4.[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)（7次）2021.06.10

```js
/*
* 思路：1.暴力枚举 O(n^2)：两层循环
*      2.哈希表 O(n)：枚举 a，看 target-a 是否也在数组里面。
*/
// 1
function twoSum(nums, target) {
  let a = [];
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        a[0] = i;
        a[1] = j;
      }
    }
  }
  return a;
}
// 2 
function twoSum(nums, target) {
  let mapData = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (mapData.has(target - nums[i])) {
        return [mapData.get(target - nums[i]), i];
    }
    mapData.set(nums[i], i);
  }
  return [];
}
```

5.[15. 三数之和](https://leetcode-cn.com/problems/3sum/)（7次）2021.06.10

```js
/*
* 思路：1.暴力 O(n^3)：三重循环
*      2.哈希 O(n^2)：两重循环 + hash
*.     3.夹逼 O(n^2)：排序后，双指针左右夹逼
*/
// 1
function threeSum(nums) {
  if (nums == null || nums.length <= 2) return [];
  let a = [];
  let mapData = new Map();
  for (let i = 0; i < nums.length - 2; i++) {
		for (let j = i + 1; j < nums.length - 1; j++) {
      for (let k = j + 1; k < nums.length; k++) {
				if (nums[i] + nums[j] + nums[k] === 0) {
          let tmp = [nums[i], nums[j], nums[k]];
          tmp.sort();
          if (!mapData.has(tmp.join())) {
          	a.push([nums[i], nums[j], nums[k]]);
            mapData.set(tmp.join(), [nums[i], nums[j], nums[k]]);
         	}
        }
      }
    }
  }
  return a;
}
// 2 1.技巧 hash 2.两次循环 hash
// 3
function threeSum(nums) {
  if (nums == null || nums.length <= 2) return [];
  nums.sort((a, b) => a - b);
  let a = [];
  for (let k = 0; k < nums.length - 2; k++) {
    if (nums[k] > 0) break;
    if (k > 0 && nums[k] === nums[k - 1]) continue;
    let i = k + 1, j = nums.length - 1;
    while(i < j) {
    	let sum = nums[k] + nums[i] + nums[j];
      if (sum < 0) {
      	while(i < j && nums[i] === nums[++i]);
      } else if (sum > 0) {
      	while(i < j && nums[j] === nums[--j]);   
      } else {
        a.push([nums[k], nums[i], nums[j]]);
        while(i < j && nums[i] === nums[++i]);   
        while(i < j && nums[j] === nums[--j]);   
      }
    }
  }
  return a;
}
```

##### 链表实战题目

所有链表的题目的解法都非常固定，主要就是熟能生巧，没有很多算法的东西，关键就是要熟悉怎么把链表的 next 和 prev 指针换来换去。

```js
// js 声明链表数据结构（5次）
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}
class LinkedList {
	constructor(arr) {
    let head = new Node(arr.shift());
    let next = head;
    arr.forEach(item => {
      next.next = new Node(item);
      next = next.next;
    });
    return head;
  }
}
```

1.[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

2.[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

3.[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)（5次）

```js
/*
* 思路：1.暴力 时间O(n) 空间O(n)：遍历链表，hash/set 
*      2.快慢指针 时间O(n) 空间O(1)
*/
// 1
function hasCycle(head) {
  if(head == null || head.next == null) return false;
  let mapData = new Map();
  let next = head;
  while(next != null) {
    if (mapData.has(next)) {
    	return true;
    }
		mapData.set(next, 1);
    next = next.next;
  }
  return false;
}
// 2
function hasCycle(head) {
  if(head == null || head.next == null) return false;
  let slow = head;
  let fast = head.next;
  while(fast != null && fast.next != null) {
  	if (fast === slow || fast.next === slow) {
    	return true;
   	}
    slow = slow.next;
    fast = fast.next.next;
 	}
  return false;
}
```

4.[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

5.[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

##### 栈和队列的基本实现和特性

* 栈 stack：先入后出的容器结构。

* 队列 queue：排队，先入先出

* 双端队列 deque：实战中使用双端队列的比较多，双端队列就是 queue 和 stack 的结合体。头和尾都可以进行元素的出和入的队列。

  栈、队列、双端队列添加、删除都是 O(1)，查询为 O(n)。因为它是无序的，你要查任何一个元素的话，就必须把这个数据结构遍历一遍。

* 优先队列 priority queue：

  插入操作 O(1)，取出操作 O(log n) 按照元素的优先级取出

  底层具体实现的数据结构较为多样和复杂：例如 heap、bst、treap

##### 栈、队列实战题目

如果一个东西具有最近相关性的话就会用栈解决，外层和外层配对，内层可以和内层配对。 现实和工程中都有很多这种从外向内或从内向外逐渐扩散的特性。

先来后到、公平性、排队就用队列。

所有东西都不是发明创造的，都是对现实中已有的逻辑进行抽象，然后用计算机的语言来进行表达。

1.[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)（4次）

```js
/*
* 思路：1.暴力 O(n^2)：不断replace匹配括号 -> ''
*      2.栈 O(n)：所有括号问题都类似，用栈解决就行了。像洋葱一样的结构。如果是左括号就压到栈里面去，如果是右括号就和栈顶元素匹配看 *				能不能匹配上，匹配上就把展顶元素移出栈，不然就是不合法，一直这么操作下去。直到整个栈为空就说明完全匹配了。
*/
// 1
function isValid(s) {
  if (s.length % 2 === 1) return false;
  let l = s.length / 2;
  for(let i = 0; i < l; i++){
    s = s.replace('()', '').replace('{}', '').replace('[]', '');
  }
  return !s.length;
}
// 2
function isValid(s) {
  if (s.length % 2 === 1) return false;
  let mapData = new Map([
    [')', '('],
    [']', '['],
    ['}', '{']
  ]);
  let stack = [];
  for (let i of s){
    if (mapData.has(i)) {
      if (!stack.length || stack.pop() !== mapData.get(i)) {
        return false;
      }
    } else {
      stack.push(i);
    }
  };
  return !stack.length;
}
```

2.[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)（3次）

```js
/*
* 思路：1.栈：两个栈，一个维护出入关系，一个维护最小值的栈。
*        很多时候，用两个栈或两个队列会解决一些特殊性的数据结构的问题，比如只用栈来实现队列或者只用队列来实现栈。
*/
// 1 同步
class MinStack {
  constructor() {
    this.x_stack = [];
    this.min_stack = [Infinity];
  }
  push(x) {
    this.x_stack.push(x);
    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));
  }
  pop() {
    if (this.x_stack.length) {
      this.x_stack.pop();
      this.min_stack.pop();
    }
  }
  top() {
    return this.x_stack[this.x_stack.length - 1];
  }
  getMin() {
    return this.min_stack[this.min_stack.length - 1];
  }
}
// 1 不同步
class MinStack {
  constructor() {
    this.x_stack = [];
    this.min_stack = [];
  }
  push(x) {
    this.x_stack.push(x);
    if (!this.min_stack.length || x <= this.min_stack[this.min_stack.length - 1]) {
    	this.min_stack.push(x);
    }
  }
  pop() {
    if (this.x_stack.length) {
      if (this.x_stack.pop() === this.min_stack[this.min_stack.length - 1]) {
        this.min_stack.pop();
      }
    }
  }
  top() {
    return this.x_stack[this.x_stack.length - 1];
  }
  getMin() {
    return this.min_stack[this.min_stack.length - 1];
  }
}
```

3.[84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

```js
/*
* 思路：1.暴力 O(n^3)：
* 		 2.暴力2 O(n^2)：遍历，找到当前柱子的前面和后面第一个比他小的柱子，算出它能组成的最大的面积。
*        i和j不断的往左右两边扩散，或者i和j往中间推进最后相遇，以及i和j写两层嵌套的循环枚举所有可能的i和j的情况。像这些代码一定要写*				 的滚瓜烂熟。
*      3.栈 O(n)：创建一个有序的栈，当前元素的前一个元素就是它的左边界，如果大于栈顶元素继续入栈，如果发现比他小的可以确定它的右边  *.       界了，这时就弹栈计算面积。最后清空栈，计算栈中剩余元素的面积。
*/
```

4.[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

```js
/*
* 思路：1.暴力 O(n*k)
*      2.双端队列 deque O(n)：所有滑动窗口的题目就想到用队列处理就行了。
*/
// 1
function maxSlidingWindow(nums, k) {
  let a = [];
	for (let i = 0; i < nums.length - k + 1; i++) {
    let max = nums[i];
    for (let j = i; j < i + k; j++) {
      if (nums[j] > max) {
				max = nums[j];
      }
    }
    a.push(max);
  }
  return a;
}
// 
```

##### 作业

简单：

1.[26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

2.[189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

3.[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

4.[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

5.[66. 加一](https://leetcode-cn.com/problems/plus-one/)

中等：

1.[641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/)

困难：

1.[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

##### 哈希表、映射、集合的实现与特性

现实中用的最多的除了数组链表之外，就是 map 和 set 了。他们底层结构基本都是使用哈希表来实现的，有的会用二叉树来实现。

哈希表（hash table）： 

也叫散列表，是根据关键码值（key value）来直接访问的数据结构。

底层实现：key -> 哈希函数 -> index -> arr[index] = value

它通过把关键码值映射到表中的一个位置来访问记录，以加快查询的速度。

这个映射函数叫散列函数也叫哈希函数。存放记录的数组叫做哈希表。

查询添加删除的时间复杂度都是 O(1) 的。有一种最坏的情况就是哈希函数选的非常不好或者哈希表的整个 size 太小了，就导致经常会发生冲突，这样它就退化成一个链表了，这时时间复杂度就退化成 O(n) 了。空间复杂度是 O(n)。

在工程中，我们经常在用的就不再是哈希表了，而是在哈希表基础上抽象出来的，使用的比较多的就是 map 和 set。map 就是键值对，key 是不重复的，值可以重复。set 就是不重复的元素的集合，没有键值对，就是单个的元素。

##### 哈希表实战题目

1.[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

```js
/*
* 思路：1.暴力 O(nlogn)：按照字符的顺序 sort 后比较 string 是否相等
*      2.hash map O(n)：统计每个字符的频次，如果每个字符出现的频次一样那就是字母异位词。
*/
```

2.[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)



##### 技巧

匹配一个字符串的子串，用正则处理比较好。

一维数组运用技巧，百分号取余换行。

判断的时候是与的关系初始化就是 ture，或的关系初始化就是 false，加的关系初始化是 0，乘的关系初始化是 1。

匹配字符串的子串用正则做比较好，一个字母、单词、空格都能提取出来。

树的遍历基本上是基于递归的，因为树的结构本身导致了它没法有效的进行循环。做法是对它的左右节点再调用相同的遍历函数。

##### 递归

递归：找到规律，分步拆解。

递归就是范围从大到小，每一部分的处理过程是相同的，输入输出是相同的，处理次数未知，再加上边界条件。

深度优先：先递归，再做事。先处理下级内容。是向内一层一层的钻进。知道最后一个层级的结果，拿到它再一层一层的把上面的结果都算出来，最终算到最大的那个数，就是答案了。所以是从后往前遍历。输入是 n，输出是结果所要的东西。

广度优先：先做事，再递归。先处理同级内容。

##### 寻路问题（搜索算法）

1. 深度优先是先找下级，广度优先是先找同级。
2. 深度优先搜索（栈），广度优先搜索（队列）唯一的区别就是使用的数据结构。
3. 广搜是可以找到最优路径的，深搜不行。
4. 所有的搜索算法唯一的区别就是数据结构。
5. 所有递归的问题都可以用深度优先所有的 stack 的形式去写。
